(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signed.
  Module conversions.
    Module Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
          fn try_from(from: Uint<BITS, LIMBS>) -> Result<Self, Self::Error> {
              let value = Self(from);
              match value.sign() {
                  Sign::Positive => Ok(value),
                  Sign::Negative => Err(BigIntConversionError),
              }
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ from ] =>
          ltac:(M.monadic
            (let from := M.alloc (| from |) in
            M.read (|
              let~ value :
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] :=
                M.alloc (|
                  Value.StructTuple "alloy_primitives::signed::int::Signed" [ M.read (| from |) ]
                |) in
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.path "alloy_primitives::signed::sign::Sign",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "sign",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, value |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::signed::sign::Sign::Positive"
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::result::Result::Ok" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::signed::sign::Sign::Negative"
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [
                            Value.StructTuple
                              "alloy_primitives::signed::errors::BigIntConversionError"
                              []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_ruint_Uint_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [].
      
      (*     type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
          fn try_from(value: Signed<BITS, LIMBS>) -> Result<Self, Self::Error> {
              match value.sign() {
                  Sign::Positive => Ok(value.0),
                  Sign::Negative => Err(BigIntConversionError),
              }
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.path "alloy_primitives::signed::sign::Sign",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "sign",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, value |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::signed::sign::Sign::Positive"
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            M.read (|
                              M.SubPointer.get_struct_tuple_field (|
                                value,
                                "alloy_primitives::signed::int::Signed",
                                0
                              |)
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::signed::sign::Sign::Negative"
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [
                            Value.StructTuple
                              "alloy_primitives::signed::errors::BigIntConversionError"
                              []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_ruint_Uint_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_ref__str_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Error = ParseSignedError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::ParseSignedError".
      
      (*
          fn try_from(value: &str) -> Result<Self, Self::Error> {
              Self::from_str(value)
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "alloy_primitives::signed::errors::ParseSignedError"
                ],
              M.get_trait_method (|
                "core::str::traits::FromStr",
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                [],
                [],
                "from_str",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_ref__str_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_ref__alloc_string_String_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Error = ParseSignedError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::ParseSignedError".
      
      (*
          fn try_from(value: &String) -> Result<Self, Self::Error> {
              value.parse()
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "alloy_primitives::signed::errors::ParseSignedError"
                ],
              M.get_associated_function (|
                Ty.path "str",
                "parse",
                [],
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.path "alloc::string::String",
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value |) |) |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_ref__alloc_string_String_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloc_string_String_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Error = ParseSignedError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::ParseSignedError".
      
      (*
          fn try_from(value: String) -> Result<Self, Self::Error> {
              value.parse()
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "alloy_primitives::signed::errors::ParseSignedError"
                ],
              M.get_associated_function (|
                Ty.path "str",
                "parse",
                [],
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.path "alloc::string::String",
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, value |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloc_string_String_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_str_traits_FromStr_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Err = ParseSignedError; *)
      Definition _Err (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::ParseSignedError".
      
      (*
          fn from_str(s: &str) -> Result<Self, Self::Err> {
              let (sign, s) = match s.as_bytes().first() {
                  Some(b'+') => (Sign::Positive, &s[1..]),
                  Some(b'-') => (Sign::Negative, &s[1..]),
                  _ => (Sign::Positive, s),
              };
              let abs = Uint::<BITS, LIMBS>::from_str(s)?;
              Self::checked_from_sign_and_abs(sign, abs).ok_or(ParseSignedError::IntegerOverflow)
          }
      *)
      Definition from_str
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    None,
                    M.match_operator (|
                      Some
                        (Ty.tuple
                          [
                            Ty.path "alloy_primitives::signed::sign::Sign";
                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ]
                          ]),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                            "first",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 43
                              |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  Value.StructTuple
                                    "alloy_primitives::signed::sign::Sign::Positive"
                                    [];
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.path "str",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeFrom")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| s |) |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::RangeFrom"
                                            [ ("start", Value.Integer IntegerKind.Usize 1) ]
                                        ]
                                      |)
                                    |)
                                  |)
                                ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let _ :=
                              is_constant_or_break_match (|
                                M.read (| γ0_0 |),
                                Value.Integer IntegerKind.U8 45
                              |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  Value.StructTuple
                                    "alloy_primitives::signed::sign::Sign::Negative"
                                    [];
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                        M.get_trait_method (|
                                          "core::ops::index::Index",
                                          Ty.path "str",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeFrom")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| s |) |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::RangeFrom"
                                            [ ("start", Value.Integer IntegerKind.Usize 1) ]
                                        ]
                                      |)
                                    |)
                                  |)
                                ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.Tuple
                                [
                                  Value.StructTuple
                                    "alloy_primitives::signed::sign::Sign::Positive"
                                    [];
                                  M.read (| s |)
                                ]
                            |)))
                      ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let sign := M.copy (| γ0_0 |) in
                          let s := M.copy (| γ0_1 |) in
                          let~ abs : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                            M.copy (|
                              M.match_operator (|
                                Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::ops::control_flow::ControlFlow")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "ruint::string::ParseError"
                                          ];
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::try_trait::Try",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                          Ty.path "ruint::string::ParseError"
                                        ],
                                      [],
                                      [],
                                      "branch",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                            Ty.path "ruint::string::ParseError"
                                          ],
                                        M.get_trait_method (|
                                          "core::str::traits::FromStr",
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          [],
                                          [],
                                          "from_str",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| s |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Break",
                                          0
                                        |) in
                                      let residual := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloy_primitives::signed::int::Signed")
                                                      [ BITS; LIMBS ]
                                                      [];
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::ParseSignedError"
                                                  ],
                                                M.get_trait_method (|
                                                  "core::ops::try_trait::FromResidual",
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloy_primitives::signed::int::Signed")
                                                        [ BITS; LIMBS ]
                                                        [];
                                                      Ty.path
                                                        "alloy_primitives::signed::errors::ParseSignedError"
                                                    ],
                                                  [],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.path "core::convert::Infallible";
                                                        Ty.path "ruint::string::ParseError"
                                                      ]
                                                  ],
                                                  "from_residual",
                                                  [],
                                                  []
                                                |),
                                                [ M.read (| residual |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::ops::control_flow::ControlFlow::Continue",
                                          0
                                        |) in
                                      let val := M.copy (| γ0_0 |) in
                                      val))
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [];
                                  Ty.path "alloy_primitives::signed::errors::ParseSignedError"
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                "ok_or",
                                [],
                                [ Ty.path "alloy_primitives::signed::errors::ParseSignedError" ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "checked_from_sign_and_abs",
                                    [],
                                    []
                                  |),
                                  [ M.read (| sign |); M.read (| abs |) ]
                                |);
                                Value.StructTuple
                                  "alloy_primitives::signed::errors::ParseSignedError::IntegerOverflow"
                                  []
                              ]
                            |)
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::str::traits::FromStr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Err", InstanceField.Ty (_Err BITS LIMBS));
            ("from_str", InstanceField.Method (from_str BITS LIMBS))
          ].
    End Impl_core_str_traits_FromStr_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i128.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i128".
      
      (*     type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
          fn try_from(value: Signed<BITS, LIMBS>) -> Result<Self, Self::Error> {
              if value.bits() > 128 {
                  return Err(BigIntConversionError);
              }
      
              if value.is_positive() {
                  Ok(u128::try_from(value.0).unwrap() as Self)
              } else {
                  let u = twos_complement(value.0);
                  let u = u128::try_from(u).unwrap() as Self;
                  Ok((!u).wrapping_add(1))
              }
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "bits",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, value |) ]
                                      |);
                                      Value.Integer IntegerKind.U32 128
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Err"
                                      [
                                        Value.StructTuple
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                          []
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "i128";
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ]),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "is_positive",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, value |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                M.cast
                                  (Ty.path "i128")
                                  (M.call_closure (|
                                    Ty.path "u128",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "u128";
                                          Ty.apply
                                            (Ty.path "ruint::from::FromUintError")
                                            []
                                            [ Ty.path "u128" ]
                                        ],
                                      "unwrap",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "u128";
                                            Ty.apply
                                              (Ty.path "ruint::from::FromUintError")
                                              []
                                              [ Ty.path "u128" ]
                                          ],
                                        M.get_trait_method (|
                                          "core::convert::TryFrom",
                                          Ty.path "u128",
                                          [],
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                          "try_from",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              value,
                                              "alloy_primitives::signed::int::Signed",
                                              0
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |))
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let~ u : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                M.get_function (|
                                  "alloy_primitives::signed::utils::twos_complement",
                                  [ BITS; LIMBS ],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_tuple_field (|
                                      value,
                                      "alloy_primitives::signed::int::Signed",
                                      0
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ u : Ty.path "i128" :=
                            M.alloc (|
                              M.cast
                                (Ty.path "i128")
                                (M.call_closure (|
                                  Ty.path "u128",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "u128";
                                        Ty.apply
                                          (Ty.path "ruint::from::FromUintError")
                                          []
                                          [ Ty.path "u128" ]
                                      ],
                                    "unwrap",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "u128";
                                          Ty.apply
                                            (Ty.path "ruint::from::FromUintError")
                                            []
                                            [ Ty.path "u128" ]
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.path "u128",
                                        [],
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| u |) ]
                                    |)
                                  ]
                                |))
                            |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                M.call_closure (|
                                  Ty.path "i128",
                                  M.get_associated_function (|
                                    Ty.path "i128",
                                    "wrapping_add",
                                    [],
                                    []
                                  |),
                                  [ UnOp.not (| M.read (| u |) |); Value.Integer IntegerKind.I128 1
                                  ]
                                |)
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i128.
    
    Module Impl_core_convert_TryFrom_i128_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
          fn try_from(value: i128) -> Result<Self, Self::Error> {
              let u = value as u128;
              if value >= 0 {
                  return Self::try_from(u);
              }
      
              // This is a bit messy :(
              let tc = (!u).wrapping_add(1);
              let stc = Uint::<128, 2>::saturating_from(tc);
              let (num, overflow) = Uint::<BITS, LIMBS>::overflowing_from_limbs_slice(stc.as_limbs());
              if overflow {
                  return Err(BigIntConversionError);
              }
              Ok(Self(twos_complement(num)))
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ u : Ty.path "u128" :=
                    M.alloc (| M.cast (Ty.path "u128") (M.read (| value |)) |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [ M.read (| value |); Value.Integer IntegerKind.I128 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [];
                                          Ty.path
                                            "alloy_primitives::signed::errors::BigIntConversionError"
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [ Ty.path "u128" ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| u |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ tc : Ty.path "u128" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u128",
                        M.get_associated_function (| Ty.path "u128", "wrapping_add", [], [] |),
                        [ UnOp.not (| M.read (| u |) |); Value.Integer IntegerKind.U128 1 ]
                      |)
                    |) in
                  let~ stc :
                      Ty.apply
                        (Ty.path "ruint::Uint")
                        [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                        [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "ruint::Uint")
                          [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2 ]
                          [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "ruint::Uint")
                            [ Value.Integer IntegerKind.Usize 128; Value.Integer IntegerKind.Usize 2
                            ]
                            [],
                          "saturating_from",
                          [],
                          [ Ty.path "u128" ]
                        |),
                        [ M.read (| tc |) ]
                      |)
                    |) in
                  M.match_operator (|
                    None,
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "overflowing_from_limbs_slice",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.path "u64" ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "ruint::Uint")
                                    [
                                      Value.Integer IntegerKind.Usize 128;
                                      Value.Integer IntegerKind.Usize 2
                                    ]
                                    [],
                                  "as_limbs",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, stc |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let num := M.copy (| γ0_0 |) in
                          let overflow := M.copy (| γ0_1 |) in
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.use overflow in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::result::Result::Err"
                                              [
                                                Value.StructTuple
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                                  []
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::result::Result::Ok"
                              [
                                Value.StructTuple
                                  "alloy_primitives::signed::int::Signed"
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_function (|
                                        "alloy_primitives::signed::utils::twos_complement",
                                        [ BITS; LIMBS ],
                                        []
                                      |),
                                      [ M.read (| num |) ]
                                    |)
                                  ]
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_i128_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u128.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u128".
      
      (*     type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
          fn try_from(value: Signed<BITS, LIMBS>) -> Result<Self, Self::Error> {
              if value.is_negative() {
                  return Err(BigIntConversionError);
              }
      
              let saturated = Uint::<BITS, LIMBS>::saturating_from(Self::MAX);
      
              // if the value is greater than the saturated value, return an error
              if value > Signed(saturated) {
                  return Err(BigIntConversionError);
              }
      
              value.into_raw().try_into().map_err(|_| BigIntConversionError)
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "is_negative",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, value |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Err"
                                      [
                                        Value.StructTuple
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                          []
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ saturated : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "saturating_from",
                          [],
                          [ Ty.path "u128" ]
                        |),
                        [
                          M.read (|
                            get_associated_constant (| Ty.path "u128", "MAX", Ty.path "u128" |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialOrd",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "gt",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, value |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.StructTuple
                                            "alloy_primitives::signed::int::Signed"
                                            [ M.read (| saturated |) ]
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Err"
                                      [
                                        Value.StructTuple
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                          []
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "u128";
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "u128";
                            Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u128" ]
                          ],
                        "map_err",
                        [],
                        [
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "ruint::from::FromUintError")
                                    []
                                    [ Ty.path "u128" ]
                                ]
                            ]
                            (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.path "u128";
                              Ty.apply (Ty.path "ruint::from::FromUintError") [] [ Ty.path "u128" ]
                            ],
                          M.get_trait_method (|
                            "core::convert::TryInto",
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            [],
                            [ Ty.path "u128" ],
                            "try_into",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "into_raw",
                                [],
                                []
                              |),
                              [ M.read (| value |) ]
                            |)
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Some
                                      (Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "ruint::from::FromUintError")
                                                []
                                                [ Ty.path "u128" ]
                                            ]
                                        ]
                                        (Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError")),
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (Value.StructTuple
                                            "alloy_primitives::signed::errors::BigIntConversionError"
                                            []))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u128.
    
    Module Impl_core_convert_TryFrom_u128_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
          fn try_from(value: u128) -> Result<Self, Self::Error> {
              let saturated = Uint::<BITS, LIMBS>::saturating_from(value);
      
              if value != saturated.to::<u128>() {
                  return Err(BigIntConversionError);
              }
      
              Self::try_from(saturated)
          }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ saturated : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "saturating_from",
                          [],
                          [ Ty.path "u128" ]
                        |),
                        [ M.read (| value |) ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ne,
                                    [
                                      M.read (| value |);
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          "to",
                                          [],
                                          [ Ty.path "u128" ]
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, saturated |) ]
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Err"
                                      [
                                        Value.StructTuple
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                          []
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ],
                      M.get_trait_method (|
                        "core::convert::TryFrom",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                        "try_from",
                        [],
                        []
                      |),
                      [ M.read (| saturated |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_u128_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_u8
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.U8 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "u8")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_u8 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_u8" (low_u8 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_u8.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_u8
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "u8"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u8";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "u8",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_u8 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_u8" (as_u8 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_u8.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_i8
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.I8 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "i8")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_i8 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_i8" (low_i8 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_i8.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_i8
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "i8"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i8";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "i8",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_i8 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_i8" (as_i8 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_i8.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_u16
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.U16 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "u16")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_u16 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_u16" (low_u16 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_u16.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_u16
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "u16"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u16";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "u16",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_u16 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_u16" (as_u16 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_u16.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_i16
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.I16 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "i16")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_i16 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_i16" (low_i16 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_i16.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_i16
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "i16"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i16";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "i16",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_i16 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_i16" (as_i16 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_i16.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_u32
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.U32 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "u32")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_u32 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_u32" (low_u32 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_u32.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_u32
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "u32"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u32";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "u32",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_u32 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_u32" (as_u32 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_u32.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_i32
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.I32 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "i32")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_i32 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_i32" (low_i32 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_i32.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_i32
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "i32"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i32";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "i32",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_i32 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_i32" (as_i32 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_i32.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_u64
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.U64 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.use
                    (M.SubPointer.get_array_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "as_limbs",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "alloy_primitives::signed::int::Signed",
                                0
                              |)
                            |)
                          ]
                        |)
                      |),
                      Value.Integer IntegerKind.Usize 0
                    |))
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_u64 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_u64" (low_u64 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_u64.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_u64
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "u64"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u64";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "u64",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_u64 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_u64" (as_u64 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_u64.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_i64
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.I64 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "i64")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_i64 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_i64" (low_i64 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_i64.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_i64
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "i64"; Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i64";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "i64",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_i64 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_i64" (as_i64 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_i64.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_usize
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.Usize 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "usize")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_usize :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_usize" (low_usize BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_usize.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_usize
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.path "usize";
                    Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "usize";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "usize",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_usize :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_usize" (as_usize BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_usize.
      
      (*
              pub const fn $low(&self) -> $t {
                  if BITS == 0 {
                      return 0
                  }
      
                  self.0.as_limbs()[0] as $t
              }
      *)
      Definition low_isize
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.Isize 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        M.SubPointer.get_array_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                "as_limbs",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_tuple_field (|
                                    M.deref (| M.read (| self |) |),
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |)
                              ]
                            |)
                          |),
                          Value.Integer IntegerKind.Usize 0
                        |)
                      |))
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_low_isize :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "low_isize" (low_isize BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque low_isize.
      
      (*
              pub fn $as(&self) -> $t {
                  <$t as TryFrom<Self>>::try_from( *self).unwrap()
              }
      *)
      Definition as_isize
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.path "isize";
                    Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "isize";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    Ty.path "isize",
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_from",
                    [],
                    []
                  |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_isize :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "as_isize" (as_isize BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque as_isize.
    End Impl_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $u) -> Result<Self, Self::Error> {
                          let u = Uint::<BITS, LIMBS>::try_from(value).map_err(|_| BigIntConversionError)?;
                          Signed::checked_from_sign_and_abs(Sign::Positive, u).ok_or(BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ u : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ];
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  "map_err",
                                  [],
                                  [
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError";
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::from::ToUintError")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ]
                                      ]
                                      (Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [ Ty.path "u8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Some
                                                (Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::from::ToUintError")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [ BITS; LIMBS ]
                                                              []
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError")),
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (Value.StructTuple
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                      []))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [];
                                            Ty.path
                                              "alloy_primitives::signed::errors::BigIntConversionError"
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [];
                                              Ty.path
                                                "alloy_primitives::signed::errors::BigIntConversionError"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          ],
                        "ok_or",
                        [],
                        [ Ty.path "alloy_primitives::signed::errors::BigIntConversionError" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "checked_from_sign_and_abs",
                            [],
                            []
                          |),
                          [
                            Value.StructTuple "alloy_primitives::signed::sign::Sign::Positive" [];
                            M.read (| u |)
                          ]
                        |);
                        Value.StructTuple
                          "alloy_primitives::signed::errors::BigIntConversionError"
                          []
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $i) -> Result<Self, Self::Error> {
                          let uint: $u = value as $u;
      
                          if value.is_positive() {
                              return Self::try_from(uint);
                          }
      
                          let abs = (!uint).wrapping_add(1);
                          let tc = twos_complement(Uint::<BITS, LIMBS>::from(abs));
                          Ok(Self(tc))
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ uint : Ty.path "u8" :=
                    M.alloc (| M.cast (Ty.path "u8") (M.read (| value |)) |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "i8",
                                      "is_positive",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [];
                                          Ty.path
                                            "alloy_primitives::signed::errors::BigIntConversionError"
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [ Ty.path "u8" ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| uint |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ abs : Ty.path "u8" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (| Ty.path "u8", "wrapping_add", [], [] |),
                        [ UnOp.not (| M.read (| uint |) |); Value.Integer IntegerKind.U8 1 ]
                      |)
                    |) in
                  let~ tc : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_function (|
                          "alloy_primitives::signed::utils::twos_complement",
                          [ BITS; LIMBS ],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "from",
                              [],
                              [ Ty.path "u8" ]
                            |),
                            [ M.read (| abs |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ M.read (| tc |) ]
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u8.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u8".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$u, Self::Error> {
                          u128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u8";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "u128",
                        [],
                        [ Ty.path "u8" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "u128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "u128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "u128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "u8";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "u8";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u8.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i8.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i8".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$i, Self::Error> {
                          i128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i8";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "i128",
                        [],
                        [ Ty.path "i8" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "i128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "i128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "i128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "i8";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "i8";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i8.
    
    Module Impl_core_convert_TryFrom_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $u) -> Result<Self, Self::Error> {
                          let u = Uint::<BITS, LIMBS>::try_from(value).map_err(|_| BigIntConversionError)?;
                          Signed::checked_from_sign_and_abs(Sign::Positive, u).ok_or(BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ u : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ];
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  "map_err",
                                  [],
                                  [
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError";
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::from::ToUintError")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ]
                                      ]
                                      (Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [ Ty.path "u16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Some
                                                (Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::from::ToUintError")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [ BITS; LIMBS ]
                                                              []
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError")),
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (Value.StructTuple
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                      []))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [];
                                            Ty.path
                                              "alloy_primitives::signed::errors::BigIntConversionError"
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [];
                                              Ty.path
                                                "alloy_primitives::signed::errors::BigIntConversionError"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          ],
                        "ok_or",
                        [],
                        [ Ty.path "alloy_primitives::signed::errors::BigIntConversionError" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "checked_from_sign_and_abs",
                            [],
                            []
                          |),
                          [
                            Value.StructTuple "alloy_primitives::signed::sign::Sign::Positive" [];
                            M.read (| u |)
                          ]
                        |);
                        Value.StructTuple
                          "alloy_primitives::signed::errors::BigIntConversionError"
                          []
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $i) -> Result<Self, Self::Error> {
                          let uint: $u = value as $u;
      
                          if value.is_positive() {
                              return Self::try_from(uint);
                          }
      
                          let abs = (!uint).wrapping_add(1);
                          let tc = twos_complement(Uint::<BITS, LIMBS>::from(abs));
                          Ok(Self(tc))
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ uint : Ty.path "u16" :=
                    M.alloc (| M.cast (Ty.path "u16") (M.read (| value |)) |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "i16",
                                      "is_positive",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [];
                                          Ty.path
                                            "alloy_primitives::signed::errors::BigIntConversionError"
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [ Ty.path "u16" ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| uint |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ abs : Ty.path "u16" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u16",
                        M.get_associated_function (| Ty.path "u16", "wrapping_add", [], [] |),
                        [ UnOp.not (| M.read (| uint |) |); Value.Integer IntegerKind.U16 1 ]
                      |)
                    |) in
                  let~ tc : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_function (|
                          "alloy_primitives::signed::utils::twos_complement",
                          [ BITS; LIMBS ],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "from",
                              [],
                              [ Ty.path "u16" ]
                            |),
                            [ M.read (| abs |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ M.read (| tc |) ]
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u16.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u16".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$u, Self::Error> {
                          u128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u16";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "u128",
                        [],
                        [ Ty.path "u16" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "u128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "u128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "u128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "u16";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "u16";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u16.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i16.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i16".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$i, Self::Error> {
                          i128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i16";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "i128",
                        [],
                        [ Ty.path "i16" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "i128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "i128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "i128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "i16";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "i16";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i16.
    
    Module Impl_core_convert_TryFrom_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $u) -> Result<Self, Self::Error> {
                          let u = Uint::<BITS, LIMBS>::try_from(value).map_err(|_| BigIntConversionError)?;
                          Signed::checked_from_sign_and_abs(Sign::Positive, u).ok_or(BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ u : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ];
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  "map_err",
                                  [],
                                  [
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError";
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::from::ToUintError")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ]
                                      ]
                                      (Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Some
                                                (Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::from::ToUintError")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [ BITS; LIMBS ]
                                                              []
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError")),
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (Value.StructTuple
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                      []))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [];
                                            Ty.path
                                              "alloy_primitives::signed::errors::BigIntConversionError"
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [];
                                              Ty.path
                                                "alloy_primitives::signed::errors::BigIntConversionError"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          ],
                        "ok_or",
                        [],
                        [ Ty.path "alloy_primitives::signed::errors::BigIntConversionError" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "checked_from_sign_and_abs",
                            [],
                            []
                          |),
                          [
                            Value.StructTuple "alloy_primitives::signed::sign::Sign::Positive" [];
                            M.read (| u |)
                          ]
                        |);
                        Value.StructTuple
                          "alloy_primitives::signed::errors::BigIntConversionError"
                          []
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $i) -> Result<Self, Self::Error> {
                          let uint: $u = value as $u;
      
                          if value.is_positive() {
                              return Self::try_from(uint);
                          }
      
                          let abs = (!uint).wrapping_add(1);
                          let tc = twos_complement(Uint::<BITS, LIMBS>::from(abs));
                          Ok(Self(tc))
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ uint : Ty.path "u32" :=
                    M.alloc (| M.cast (Ty.path "u32") (M.read (| value |)) |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "i32",
                                      "is_positive",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [];
                                          Ty.path
                                            "alloy_primitives::signed::errors::BigIntConversionError"
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [ Ty.path "u32" ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| uint |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ abs : Ty.path "u32" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u32",
                        M.get_associated_function (| Ty.path "u32", "wrapping_add", [], [] |),
                        [ UnOp.not (| M.read (| uint |) |); Value.Integer IntegerKind.U32 1 ]
                      |)
                    |) in
                  let~ tc : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_function (|
                          "alloy_primitives::signed::utils::twos_complement",
                          [ BITS; LIMBS ],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "from",
                              [],
                              [ Ty.path "u32" ]
                            |),
                            [ M.read (| abs |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ M.read (| tc |) ]
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u32.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u32".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$u, Self::Error> {
                          u128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u32";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "u128",
                        [],
                        [ Ty.path "u32" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "u128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "u128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "u128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "u32";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "u32";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u32.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i32.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i32".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$i, Self::Error> {
                          i128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i32";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "i128",
                        [],
                        [ Ty.path "i32" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "i128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "i128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "i128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "i32";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "i32";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i32.
    
    Module Impl_core_convert_TryFrom_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $u) -> Result<Self, Self::Error> {
                          let u = Uint::<BITS, LIMBS>::try_from(value).map_err(|_| BigIntConversionError)?;
                          Signed::checked_from_sign_and_abs(Sign::Positive, u).ok_or(BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ u : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ];
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  "map_err",
                                  [],
                                  [
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError";
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::from::ToUintError")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ]
                                      ]
                                      (Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Some
                                                (Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::from::ToUintError")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [ BITS; LIMBS ]
                                                              []
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError")),
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (Value.StructTuple
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                      []))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [];
                                            Ty.path
                                              "alloy_primitives::signed::errors::BigIntConversionError"
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [];
                                              Ty.path
                                                "alloy_primitives::signed::errors::BigIntConversionError"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          ],
                        "ok_or",
                        [],
                        [ Ty.path "alloy_primitives::signed::errors::BigIntConversionError" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "checked_from_sign_and_abs",
                            [],
                            []
                          |),
                          [
                            Value.StructTuple "alloy_primitives::signed::sign::Sign::Positive" [];
                            M.read (| u |)
                          ]
                        |);
                        Value.StructTuple
                          "alloy_primitives::signed::errors::BigIntConversionError"
                          []
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $i) -> Result<Self, Self::Error> {
                          let uint: $u = value as $u;
      
                          if value.is_positive() {
                              return Self::try_from(uint);
                          }
      
                          let abs = (!uint).wrapping_add(1);
                          let tc = twos_complement(Uint::<BITS, LIMBS>::from(abs));
                          Ok(Self(tc))
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ uint : Ty.path "u64" :=
                    M.alloc (| M.cast (Ty.path "u64") (M.read (| value |)) |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "i64",
                                      "is_positive",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [];
                                          Ty.path
                                            "alloy_primitives::signed::errors::BigIntConversionError"
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [ Ty.path "u64" ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| uint |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ abs : Ty.path "u64" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_associated_function (| Ty.path "u64", "wrapping_add", [], [] |),
                        [ UnOp.not (| M.read (| uint |) |); Value.Integer IntegerKind.U64 1 ]
                      |)
                    |) in
                  let~ tc : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_function (|
                          "alloy_primitives::signed::utils::twos_complement",
                          [ BITS; LIMBS ],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "from",
                              [],
                              [ Ty.path "u64" ]
                            |),
                            [ M.read (| abs |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ M.read (| tc |) ]
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u64.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "u64".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$u, Self::Error> {
                          u128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "u64";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "u128",
                        [],
                        [ Ty.path "u64" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "u128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "u128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "u128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "u64";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "u64";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_u64.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i64.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "i64".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$i, Self::Error> {
                          i128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "i64";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "i128",
                        [],
                        [ Ty.path "i64" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "i128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "i128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "i128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "i64";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "i64";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_i64.
    
    Module Impl_core_convert_TryFrom_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $u) -> Result<Self, Self::Error> {
                          let u = Uint::<BITS, LIMBS>::try_from(value).map_err(|_| BigIntConversionError)?;
                          Signed::checked_from_sign_and_abs(Sign::Positive, u).ok_or(BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ u : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ];
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                  Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                      Ty.apply
                                        (Ty.path "ruint::from::ToUintError")
                                        []
                                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                    ],
                                  "map_err",
                                  [],
                                  [
                                    Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError";
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path "ruint::from::ToUintError")
                                              []
                                              [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                                              ]
                                          ]
                                      ]
                                      (Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [];
                                        Ty.apply
                                          (Ty.path "ruint::from::ToUintError")
                                          []
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ]
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Some
                                                (Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "ruint::from::ToUintError")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "ruint::Uint")
                                                              [ BITS; LIMBS ]
                                                              []
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError")),
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (Value.StructTuple
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                      []))
                                              ]
                                            |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end))
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [];
                                            Ty.path
                                              "alloy_primitives::signed::errors::BigIntConversionError"
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [];
                                              Ty.path
                                                "alloy_primitives::signed::errors::BigIntConversionError"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          ],
                        "ok_or",
                        [],
                        [ Ty.path "alloy_primitives::signed::errors::BigIntConversionError" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "checked_from_sign_and_abs",
                            [],
                            []
                          |),
                          [
                            Value.StructTuple "alloy_primitives::signed::sign::Sign::Positive" [];
                            M.read (| u |)
                          ]
                        |);
                        Value.StructTuple
                          "alloy_primitives::signed::errors::BigIntConversionError"
                          []
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: $i) -> Result<Self, Self::Error> {
                          let uint: $u = value as $u;
      
                          if value.is_positive() {
                              return Self::try_from(uint);
                          }
      
                          let abs = (!uint).wrapping_add(1);
                          let tc = twos_complement(Uint::<BITS, LIMBS>::from(abs));
                          Ok(Self(tc))
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ uint : Ty.path "usize" :=
                    M.alloc (| M.cast (Ty.path "usize") (M.read (| value |)) |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "isize",
                                      "is_positive",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [];
                                          Ty.path
                                            "alloy_primitives::signed::errors::BigIntConversionError"
                                        ],
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [ Ty.path "usize" ],
                                        "try_from",
                                        [],
                                        []
                                      |),
                                      [ M.read (| uint |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ abs : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (| Ty.path "usize", "wrapping_add", [], [] |),
                        [ UnOp.not (| M.read (| uint |) |); Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |) in
                  let~ tc : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_function (|
                          "alloy_primitives::signed::utils::twos_complement",
                          [ BITS; LIMBS ],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              "from",
                              [],
                              [ Ty.path "usize" ]
                            |),
                            [ M.read (| abs |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ M.read (| tc |) ]
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_usize.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "usize".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$u, Self::Error> {
                          u128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "usize";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "u128",
                        [],
                        [ Ty.path "usize" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "u128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "u128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "u128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "usize";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "usize";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_usize.
    
    Module Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_isize.
      Definition Self (BITS LIMBS : Value.t) : Ty.t := Ty.path "isize".
      
      (*                 type Error = BigIntConversionError; *)
      Definition _Error (BITS LIMBS : Value.t) : Ty.t :=
        Ty.path "alloy_primitives::signed::errors::BigIntConversionError".
      
      (*
                      fn try_from(value: Signed<BITS, LIMBS>) -> Result<$i, Self::Error> {
                          i128::try_from(value)?.try_into().map_err(|_| BigIntConversionError)
                      }
      *)
      Definition try_from
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "isize";
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError" ],
                    "map_err",
                    [],
                    [
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError";
                      Ty.function
                        [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                        (Ty.path "alloy_primitives::signed::errors::BigIntConversionError")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError" ],
                      M.get_trait_method (|
                        "core::convert::TryInto",
                        Ty.path "i128",
                        [],
                        [ Ty.path "isize" ],
                        "try_into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Some (Ty.path "i128"),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "i128";
                                      Ty.path
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "i128";
                                        Ty.path
                                          "alloy_primitives::signed::errors::BigIntConversionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| value |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "isize";
                                                Ty.path
                                                  "alloy_primitives::signed::errors::BigIntConversionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "isize";
                                                  Ty.path
                                                    "alloy_primitives::signed::errors::BigIntConversionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "alloy_primitives::signed::errors::BigIntConversionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Some
                                  (Ty.function
                                    [ Ty.tuple [ Ty.path "core::num::error::TryFromIntError" ] ]
                                    (Ty.path
                                      "alloy_primitives::signed::errors::BigIntConversionError")),
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (Value.StructTuple
                                        "alloy_primitives::signed::errors::BigIntConversionError"
                                        []))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Error", InstanceField.Ty (_Error BITS LIMBS));
            ("try_from", InstanceField.Method (try_from BITS LIMBS))
          ].
    End Impl_core_convert_TryFrom_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_isize.
  End conversions.
End signed.
