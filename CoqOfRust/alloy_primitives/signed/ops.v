(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signed.
  Module ops.
    Module Impl_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          pub fn abs(self) -> Self {
              handle_overflow(self.overflowing_abs())
          }
      *)
      Definition abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_abs",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "abs" (abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
          pub fn overflowing_abs(self) -> (Self, bool) {
              if BITS == 0 {
                  return (self, false);
              }
              if self == Self::MIN {
                  (self, true)
              } else {
                  (Self(self.unsigned_abs()), false)
              }
          }
      *)
      Definition overflowing_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.Tuple [ M.read (| self |); Value.Bool false ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    Some
                      (Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "bool"
                        ]),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, self |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            Value.Tuple
                              [
                                Value.StructTuple
                                  "alloy_primitives::signed::int::Signed"
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "unsigned_abs",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ];
                                Value.Bool false
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_abs" (overflowing_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_abs.
      
      (*
          pub fn checked_abs(self) -> Option<Self> {
              match self.overflowing_abs() {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_abs",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_abs" (checked_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_abs.
      
      (*
          pub fn saturating_abs(self) -> Self {
              match self.overflowing_abs() {
                  (value, false) => value,
                  _ => Self::MAX,
              }
          }
      *)
      Definition saturating_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_abs",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      value));
                  fun γ =>
                    ltac:(M.monadic
                      (get_associated_constant (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "MAX",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_abs" (saturating_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_abs.
      
      (*
          pub fn wrapping_abs(self) -> Self {
              self.overflowing_abs().0
          }
      *)
      Definition wrapping_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_abs",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_abs" (wrapping_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_abs.
      
      (*
          pub fn unsigned_abs(self) -> Uint<BITS, LIMBS> {
              self.into_sign_and_abs().1
          }
      *)
      Definition unsigned_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.path "alloy_primitives::signed::sign::Sign";
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "into_sign_and_abs",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |),
                1
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_unsigned_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "unsigned_abs" (unsigned_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque unsigned_abs.
      
      (*
          pub fn overflowing_neg(self) -> (Self, bool) {
              if BITS == 0 {
                  return (self, false);
              }
              if self == Self::MIN {
                  (self, true)
              } else {
                  (Self(twos_complement(self.0)), false)
              }
          }
      *)
      Definition overflowing_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.Tuple [ M.read (| self |); Value.Bool false ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    Some
                      (Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "bool"
                        ]),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, self |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            Value.Tuple
                              [
                                Value.StructTuple
                                  "alloy_primitives::signed::int::Signed"
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_function (|
                                        "alloy_primitives::signed::utils::twos_complement",
                                        [ BITS; LIMBS ],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            self,
                                            "alloy_primitives::signed::int::Signed",
                                            0
                                          |)
                                        |)
                                      ]
                                    |)
                                  ];
                                Value.Bool false
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_neg" (overflowing_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_neg.
      
      (*
          pub fn checked_neg(self) -> Option<Self> {
              match self.overflowing_neg() {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_neg",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_neg" (checked_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_neg.
      
      (*
          pub fn saturating_neg(self) -> Self {
              match self.overflowing_neg() {
                  (value, false) => value,
                  _ => Self::MAX,
              }
          }
      *)
      Definition saturating_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_neg",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      value));
                  fun γ =>
                    ltac:(M.monadic
                      (get_associated_constant (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "MAX",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_neg" (saturating_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_neg.
      
      (*
          pub fn wrapping_neg(self) -> Self {
              self.overflowing_neg().0
          }
      *)
      Definition wrapping_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_neg",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_neg" (wrapping_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_neg.
      
      (*
          pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
              let (unsigned, _) = self.0.overflowing_add(rhs.0);
              let result = Self(unsigned);
      
              // NOTE: Overflow is determined by checking the sign of the operands and
              //   the result.
              let overflow = matches!(
                  (self.sign(), rhs.sign(), result.sign()),
                  (Sign::Positive, Sign::Positive, Sign::Negative)
                      | (Sign::Negative, Sign::Negative, Sign::Positive)
              );
      
              (result, overflow)
          }
      *)
      Definition overflowing_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "overflowing_add",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          self,
                          "alloy_primitives::signed::int::Signed",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::signed::int::Signed",
                          0
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let unsigned := M.copy (| γ0_0 |) in
                      let~ result :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        M.alloc (|
                          Value.StructTuple
                            "alloy_primitives::signed::int::Signed"
                            [ M.read (| unsigned |) ]
                        |) in
                      let~ overflow : Ty.path "bool" :=
                        M.copy (|
                          M.match_operator (|
                            Some (Ty.path "bool"),
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                  |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.find_or_pattern (|
                                    γ,
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_0,
                                              "alloy_primitives::signed::sign::Sign::Positive"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_1,
                                              "alloy_primitives::signed::sign::Sign::Positive"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_2,
                                              "alloy_primitives::signed::sign::Sign::Negative"
                                            |) in
                                          Value.Tuple []));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_0,
                                              "alloy_primitives::signed::sign::Sign::Negative"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_1,
                                              "alloy_primitives::signed::sign::Sign::Negative"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_2,
                                              "alloy_primitives::signed::sign::Sign::Positive"
                                            |) in
                                          Value.Tuple []))
                                    ],
                                    fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [ M.read (| result |); M.read (| overflow |) ] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_add" (overflowing_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_add.
      
      (*
          pub const fn checked_add(self, rhs: Self) -> Option<Self> {
              match self.overflowing_add(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_add",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_add" (checked_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_add.
      
      (*
          pub const fn saturating_add(self, rhs: Self) -> Self {
              let (result, overflow) = self.overflowing_add(rhs);
              if overflow {
                  match result.sign() {
                      Sign::Positive => Self::MIN,
                      Sign::Negative => Self::MAX,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_add",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use overflow in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.match_operator (|
                                Some
                                  (Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Positive"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Negative"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)))
                                ]
                              |)));
                          fun γ => ltac:(M.monadic result)
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_add" (saturating_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_add.
      
      (*
          pub const fn wrapping_add(self, rhs: Self) -> Self {
              self.overflowing_add(rhs).0
          }
      *)
      Definition wrapping_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_add",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_add" (wrapping_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_add.
      
      (*
          pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
              // NOTE: We can't just compute the `self + (-rhs)` because `-rhs` does
              //   not always exist, specifically this would be a problem in case
              //   `rhs == Self::MIN`
      
              let (unsigned, _) = self.0.overflowing_sub(rhs.0);
              let result = Self(unsigned);
      
              // NOTE: Overflow is determined by checking the sign of the operands and
              //   the result.
              let overflow = matches!(
                  (self.sign(), rhs.sign(), result.sign()),
                  (Sign::Positive, Sign::Negative, Sign::Negative)
                      | (Sign::Negative, Sign::Positive, Sign::Positive)
              );
      
              (result, overflow)
          }
      *)
      Definition overflowing_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "overflowing_sub",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          self,
                          "alloy_primitives::signed::int::Signed",
                          0
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          rhs,
                          "alloy_primitives::signed::int::Signed",
                          0
                        |)
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let unsigned := M.copy (| γ0_0 |) in
                      let~ result :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        M.alloc (|
                          Value.StructTuple
                            "alloy_primitives::signed::int::Signed"
                            [ M.read (| unsigned |) ]
                        |) in
                      let~ overflow : Ty.path "bool" :=
                        M.copy (|
                          M.match_operator (|
                            Some (Ty.path "bool"),
                            M.alloc (|
                              Value.Tuple
                                [
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                  |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.find_or_pattern (|
                                    γ,
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_0,
                                              "alloy_primitives::signed::sign::Sign::Positive"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_1,
                                              "alloy_primitives::signed::sign::Sign::Negative"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_2,
                                              "alloy_primitives::signed::sign::Sign::Negative"
                                            |) in
                                          Value.Tuple []));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_0,
                                              "alloy_primitives::signed::sign::Sign::Negative"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_1,
                                              "alloy_primitives::signed::sign::Sign::Positive"
                                            |) in
                                          let _ :=
                                            M.is_struct_tuple (|
                                              γ0_2,
                                              "alloy_primitives::signed::sign::Sign::Positive"
                                            |) in
                                          Value.Tuple []))
                                    ],
                                    fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                                        | _ => M.impossible "wrong number of arguments"
                                        end)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [ M.read (| result |); M.read (| overflow |) ] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_sub" (overflowing_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_sub.
      
      (*
          pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
              match self.overflowing_sub(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_sub",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_sub" (checked_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_sub.
      
      (*
          pub const fn saturating_sub(self, rhs: Self) -> Self {
              let (result, overflow) = self.overflowing_sub(rhs);
              if overflow {
                  match result.sign() {
                      Sign::Positive => Self::MIN,
                      Sign::Negative => Self::MAX,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_sub",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use overflow in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.match_operator (|
                                Some
                                  (Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "sign",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Positive"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Negative"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)))
                                ]
                              |)));
                          fun γ => ltac:(M.monadic result)
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_sub" (saturating_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_sub.
      
      (*
          pub const fn wrapping_sub(self, rhs: Self) -> Self {
              self.overflowing_sub(rhs).0
          }
      *)
      Definition wrapping_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_sub",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_sub" (wrapping_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_sub.
      
      (*
          pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
              if self.is_zero() || rhs.is_zero() {
                  return (Self::ZERO, false);
              }
              let sign = self.sign() * rhs.sign();
              let (unsigned, overflow_mul) = self.unsigned_abs().overflowing_mul(rhs.unsigned_abs());
              let (result, overflow_conv) = Self::overflowing_from_sign_and_abs(sign, unsigned);
      
              (result, overflow_mul || overflow_conv)
          }
      *)
      Definition overflowing_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "is_zero",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "is_zero",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.Tuple
                                      [
                                        M.read (|
                                          get_associated_constant (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            "ZERO",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          |)
                                        |);
                                        Value.Bool false
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ sign : Ty.path "alloy_primitives::signed::sign::Sign" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "alloy_primitives::signed::sign::Sign",
                        M.get_trait_method (|
                          "core::ops::arith::Mul",
                          Ty.path "alloy_primitives::signed::sign::Sign",
                          [],
                          [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                          "mul",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.path "alloy_primitives::signed::sign::Sign",
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              "sign",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, self |) ]
                          |);
                          M.call_closure (|
                            Ty.path "alloy_primitives::signed::sign::Sign",
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              "sign",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    None,
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "overflowing_mul",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              "unsigned_abs",
                              [],
                              []
                            |),
                            [ M.read (| self |) ]
                          |);
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              "unsigned_abs",
                              [],
                              []
                            |),
                            [ M.read (| rhs |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let unsigned := M.copy (| γ0_0 |) in
                          let overflow_mul := M.copy (| γ0_1 |) in
                          M.match_operator (|
                            None,
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [];
                                    Ty.path "bool"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "overflowing_from_sign_and_abs",
                                  [],
                                  []
                                |),
                                [ M.read (| sign |); M.read (| unsigned |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let result := M.copy (| γ0_0 |) in
                                  let overflow_conv := M.copy (| γ0_1 |) in
                                  M.alloc (|
                                    Value.Tuple
                                      [
                                        M.read (| result |);
                                        LogicalOp.or (|
                                          M.read (| overflow_mul |),
                                          ltac:(M.monadic (M.read (| overflow_conv |)))
                                        |)
                                      ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_mul" (overflowing_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_mul.
      
      (*
          pub fn checked_mul(self, rhs: Self) -> Option<Self> {
              match self.overflowing_mul(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_mul",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_mul" (checked_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_mul.
      
      (*
          pub fn saturating_mul(self, rhs: Self) -> Self {
              let (result, overflow) = self.overflowing_mul(rhs);
              if overflow {
                  match self.sign() * rhs.sign() {
                      Sign::Positive => Self::MAX,
                      Sign::Negative => Self::MIN,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_mul",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use overflow in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.match_operator (|
                                Some
                                  (Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      Ty.path "alloy_primitives::signed::sign::Sign",
                                      [],
                                      [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "alloy_primitives::signed::sign::Sign",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "sign",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "alloy_primitives::signed::sign::Sign",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "sign",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Positive"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Negative"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)))
                                ]
                              |)));
                          fun γ => ltac:(M.monadic result)
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_mul" (saturating_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_mul.
      
      (*
          pub fn wrapping_mul(self, rhs: Self) -> Self {
              self.overflowing_mul(rhs).0
          }
      *)
      Definition wrapping_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_mul",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_mul" (wrapping_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_mul.
      
      (*
          pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {
              assert!(!rhs.is_zero(), "attempt to divide by zero");
              let sign = self.sign() * rhs.sign();
              // Note, signed division can't overflow!
              let unsigned = self.unsigned_abs() / rhs.unsigned_abs();
              let (result, overflow_conv) = Self::overflowing_from_sign_and_abs(sign, unsigned);
      
              (result, overflow_conv && !result.is_zero())
          }
      *)
      Definition overflowing_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "is_zero",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                  |)
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array [ mk_str (| "attempt to divide by zero" |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ sign : Ty.path "alloy_primitives::signed::sign::Sign" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "alloy_primitives::signed::sign::Sign",
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.path "alloy_primitives::signed::sign::Sign",
                      [],
                      [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.path "alloy_primitives::signed::sign::Sign",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "sign",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, self |) ]
                      |);
                      M.call_closure (|
                        Ty.path "alloy_primitives::signed::sign::Sign",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "sign",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                      |)
                    ]
                  |)
                |) in
              let~ unsigned : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                      "div",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "unsigned_abs",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "unsigned_abs",
                          [],
                          []
                        |),
                        [ M.read (| rhs |) ]
                      |)
                    ]
                  |)
                |) in
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_from_sign_and_abs",
                      [],
                      []
                    |),
                    [ M.read (| sign |); M.read (| unsigned |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow_conv := M.copy (| γ0_1 |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| result |);
                            LogicalOp.and (|
                              M.read (| overflow_conv |),
                              ltac:(M.monadic
                                (UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "is_zero",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                  |)
                                |)))
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_div" (overflowing_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_div.
      
      (*
          pub fn checked_div(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.overflowing_div(rhs).0)
              }
          }
      *)
      Definition checked_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "is_zero",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                              |),
                              ltac:(M.monadic
                                (LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, self |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MIN",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, rhs |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            "MINUS_ONE",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          |)
                                        |)
                                      ]
                                    |)))
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.SubPointer.get_tuple_field (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [];
                                        Ty.path "bool"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "overflowing_div",
                                      [],
                                      []
                                    |),
                                    [ M.read (| self |); M.read (| rhs |) ]
                                  |)
                                |),
                                0
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_div" (checked_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_div.
      
      (*
          pub fn saturating_div(self, rhs: Self) -> Self {
              match self.overflowing_div(rhs) {
                  (value, false) => value,
                  // MIN / -1 is the only possible saturating overflow
                  _ => Self::MAX,
              }
          }
      *)
      Definition saturating_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_div",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      value));
                  fun γ =>
                    ltac:(M.monadic
                      (get_associated_constant (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "MAX",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_div" (saturating_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_div.
      
      (*
          pub fn wrapping_div(self, rhs: Self) -> Self {
              self.overflowing_div(rhs).0
          }
      *)
      Definition wrapping_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_div",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_div" (wrapping_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_div.
      
      (*
          pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
              if self == Self::MIN && rhs == Self::MINUS_ONE {
                  (Self::ZERO, true)
              } else {
                  let div_res = self / rhs;
                  (self - div_res * rhs, false)
              }
          }
      *)
      Definition overflowing_rem
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, self |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    get_associated_constant (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "MIN",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    |)
                                  |)
                                ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, rhs |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MINUS_ONE",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (|
                              get_associated_constant (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "ZERO",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  []
                              |)
                            |);
                            Value.Bool true
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ div_res :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            M.get_trait_method (|
                              "core::ops::arith::Div",
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  []
                              ],
                              "div",
                              [],
                              []
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_trait_method (|
                                "core::ops::arith::Sub",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []
                                ],
                                "sub",
                                [],
                                []
                              |),
                              [
                                M.read (| self |);
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "mul",
                                    [],
                                    []
                                  |),
                                  [ M.read (| div_res |); M.read (| rhs |) ]
                                |)
                              ]
                            |);
                            Value.Bool false
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_rem :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_rem" (overflowing_rem BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_rem.
      
      (*
          pub fn checked_rem(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.overflowing_rem(rhs).0)
              }
          }
      *)
      Definition checked_rem
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "is_zero",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                              |),
                              ltac:(M.monadic
                                (LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, self |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MIN",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, rhs |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            "MINUS_ONE",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          |)
                                        |)
                                      ]
                                    |)))
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.SubPointer.get_tuple_field (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [];
                                        Ty.path "bool"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "overflowing_rem",
                                      [],
                                      []
                                    |),
                                    [ M.read (| self |); M.read (| rhs |) ]
                                  |)
                                |),
                                0
                              |)
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_rem :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_rem" (checked_rem BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_rem.
      
      (*
          pub fn wrapping_rem(self, rhs: Self) -> Self {
              self.overflowing_rem(rhs).0
          }
      *)
      Definition wrapping_rem
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_rem",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_rem :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_rem" (wrapping_rem BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_rem.
      
      (*
          pub fn div_euclid(self, rhs: Self) -> Self {
              let q = self / rhs;
              if (self % rhs).is_negative() {
                  if rhs.is_positive() {
                      q - Self::ONE
                  } else {
                      q + Self::ONE
                  }
              } else {
                  q
              }
          }
      *)
      Definition div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ q :
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |) in
              M.match_operator (|
                Some
                  (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "is_negative",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      M.get_trait_method (|
                                        "core::ops::arith::Rem",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        ],
                                        "rem",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |); M.read (| rhs |) ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "is_positive",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Sub",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (| q |);
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "ONE",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (| q |);
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "ONE",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)
                              |)))
                        ]
                      |)));
                  fun γ => ltac:(M.monadic q)
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "div_euclid" (div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque div_euclid.
      
      (*
          pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
              if self == Self::MIN && rhs == Self::MINUS_ONE {
                  (self, true)
              } else {
                  (self.div_euclid(rhs), false)
              }
          }
      *)
      Definition overflowing_div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, self |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    get_associated_constant (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "MIN",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    |)
                                  |)
                                ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, rhs |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MINUS_ONE",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.Tuple [ M.read (| self |); Value.Bool true ] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "div_euclid",
                                [],
                                []
                              |),
                              [ M.read (| self |); M.read (| rhs |) ]
                            |);
                            Value.Bool false
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "overflowing_div_euclid"
          (overflowing_div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_div_euclid.
      
      (*
          pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.div_euclid(rhs))
              }
          }
      *)
      Definition checked_div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "is_zero",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                              |),
                              ltac:(M.monadic
                                (LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, self |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MIN",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, rhs |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            "MINUS_ONE",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          |)
                                        |)
                                      ]
                                    |)))
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "div_euclid",
                                [],
                                []
                              |),
                              [ M.read (| self |); M.read (| rhs |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "checked_div_euclid"
          (checked_div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_div_euclid.
      
      (*
          pub fn wrapping_div_euclid(self, rhs: Self) -> Self {
              self.overflowing_div_euclid(rhs).0
          }
      *)
      Definition wrapping_div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_div_euclid",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "wrapping_div_euclid"
          (wrapping_div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_div_euclid.
      
      (*
          pub fn rem_euclid(self, rhs: Self) -> Self {
              let r = self % rhs;
              if r < Self::ZERO {
                  if rhs < Self::ZERO {
                      r - rhs
                  } else {
                      r + rhs
                  }
              } else {
                  r
              }
          }
      *)
      Definition rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ r :
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |) in
              M.match_operator (|
                Some
                  (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []
                                ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, r |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_associated_constant (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "ZERO",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialOrd",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        ],
                                        "lt",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, rhs |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            "ZERO",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Sub",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "sub",
                                    [],
                                    []
                                  |),
                                  [ M.read (| r |); M.read (| rhs |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [ M.read (| r |); M.read (| rhs |) ]
                                |)
                              |)))
                        ]
                      |)));
                  fun γ => ltac:(M.monadic r)
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "rem_euclid" (rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque rem_euclid.
      
      (*
          pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
              if self == Self::MIN && rhs == Self::MINUS_ONE {
                  (Self::ZERO, true)
              } else {
                  (self.rem_euclid(rhs), false)
              }
          }
      *)
      Definition overflowing_rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, self |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    get_associated_constant (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "MIN",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    |)
                                  |)
                                ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, rhs |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MINUS_ONE",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (|
                              get_associated_constant (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "ZERO",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  []
                              |)
                            |);
                            Value.Bool true
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "rem_euclid",
                                [],
                                []
                              |),
                              [ M.read (| self |); M.read (| rhs |) ]
                            |);
                            Value.Bool false
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "overflowing_rem_euclid"
          (overflowing_rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_rem_euclid.
      
      (*
          pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {
              self.overflowing_rem_euclid(rhs).0
          }
      *)
      Definition wrapping_rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_rem_euclid",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "wrapping_rem_euclid"
          (wrapping_rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_rem_euclid.
      
      (*
          pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.rem_euclid(rhs))
              }
          }
      *)
      Definition checked_rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "is_zero",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                              |),
                              ltac:(M.monadic
                                (LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, self |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MIN",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, rhs |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            "MINUS_ONE",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          |)
                                        |)
                                      ]
                                    |)))
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "rem_euclid",
                                [],
                                []
                              |),
                              [ M.read (| self |); M.read (| rhs |) ]
                            |)
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "checked_rem_euclid"
          (checked_rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_rem_euclid.
      
      (*
          pub(crate) const fn pow_sign(self, exp: Uint<BITS, LIMBS>) -> Sign {
              let is_exp_odd = BITS != 0 && exp.as_limbs()[0] % 2 == 1;
              if is_exp_odd && self.is_negative() {
                  Sign::Negative
              } else {
                  Sign::Positive
              }
          }
      *)
      Definition pow_sign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            M.read (|
              let~ is_exp_odd : Ty.path "bool" :=
                M.alloc (|
                  LogicalOp.and (|
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.ne,
                      [ BITS; Value.Integer IntegerKind.Usize 0 ]
                    |),
                    ltac:(M.monadic
                      (M.call_closure (|
                        Ty.path "bool",
                        BinOp.eq,
                        [
                          M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.rem,
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        "as_limbs",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, exp |) ]
                                    |)
                                  |),
                                  Value.Integer IntegerKind.Usize 0
                                |)
                              |);
                              Value.Integer IntegerKind.U64 2
                            ]
                          |);
                          Value.Integer IntegerKind.U64 1
                        ]
                      |)))
                  |)
                |) in
              M.match_operator (|
                Some (Ty.path "alloy_primitives::signed::sign::Sign"),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              M.read (| is_exp_odd |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "is_negative",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple "alloy_primitives::signed::sign::Sign::Negative" []
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple "alloy_primitives::signed::sign::Sign::Positive" []
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow_sign :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "pow_sign" (pow_sign BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque pow_sign.
      
      (*
          pub fn exp10(n: usize) -> Self {
              Uint::<BITS, LIMBS>::from(10).pow(Uint::from(n)).try_into().expect("overflow")
          }
      *)
      Definition exp10
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "expect",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryInto",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_into",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "pow",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "from",
                            [],
                            [ Ty.path "i32" ]
                          |),
                          [ Value.Integer IntegerKind.I32 10 ]
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "from",
                            [],
                            [ Ty.path "usize" ]
                          |),
                          [ M.read (| n |) ]
                        |)
                      ]
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "overflow" |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_exp10 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "exp10" (exp10 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque exp10.
      
      (*
          pub fn pow(self, exp: Uint<BITS, LIMBS>) -> Self {
              handle_overflow(self.overflowing_pow(exp))
          }
      *)
      Definition pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_pow",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "pow" (pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque pow.
      
      (*
          pub fn overflowing_pow(self, exp: Uint<BITS, LIMBS>) -> (Self, bool) {
              if BITS == 0 {
                  return (Self::ZERO, false);
              }
      
              let sign = self.pow_sign(exp);
      
              let (unsigned, overflow_pow) = self.unsigned_abs().overflowing_pow(exp);
              let (result, overflow_conv) = Self::overflowing_from_sign_and_abs(sign, unsigned);
      
              (result, overflow_pow || overflow_conv)
          }
      *)
      Definition overflowing_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.Tuple
                                      [
                                        M.read (|
                                          get_associated_constant (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            "ZERO",
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          |)
                                        |);
                                        Value.Bool false
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ sign : Ty.path "alloy_primitives::signed::sign::Sign" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "alloy_primitives::signed::sign::Sign",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "pow_sign",
                          [],
                          []
                        |),
                        [ M.read (| self |); M.read (| exp |) ]
                      |)
                    |) in
                  M.match_operator (|
                    None,
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "overflowing_pow",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              "unsigned_abs",
                              [],
                              []
                            |),
                            [ M.read (| self |) ]
                          |);
                          M.read (| exp |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let unsigned := M.copy (| γ0_0 |) in
                          let overflow_pow := M.copy (| γ0_1 |) in
                          M.match_operator (|
                            None,
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [];
                                    Ty.path "bool"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "overflowing_from_sign_and_abs",
                                  [],
                                  []
                                |),
                                [ M.read (| sign |); M.read (| unsigned |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let result := M.copy (| γ0_0 |) in
                                  let overflow_conv := M.copy (| γ0_1 |) in
                                  M.alloc (|
                                    Value.Tuple
                                      [
                                        M.read (| result |);
                                        LogicalOp.or (|
                                          M.read (| overflow_pow |),
                                          ltac:(M.monadic (M.read (| overflow_conv |)))
                                        |)
                                      ]
                                  |)))
                            ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_pow" (overflowing_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_pow.
      
      (*
          pub fn checked_pow(self, exp: Uint<BITS, LIMBS>) -> Option<Self> {
              let (result, overflow) = self.overflowing_pow(exp);
              if overflow {
                  None
              } else {
                  Some(result)
              }
          }
      *)
      Definition checked_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_pow",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| exp |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use overflow in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| result |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_pow" (checked_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_pow.
      
      (*
          pub fn saturating_pow(self, exp: Uint<BITS, LIMBS>) -> Self {
              let (result, overflow) = self.overflowing_pow(exp);
              if overflow {
                  match self.pow_sign(exp) {
                      Sign::Positive => Self::MAX,
                      Sign::Negative => Self::MIN,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_pow",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| exp |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let result := M.copy (| γ0_0 |) in
                      let overflow := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use overflow in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.match_operator (|
                                Some
                                  (Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []),
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "pow_sign",
                                      [],
                                      []
                                    |),
                                    [ M.read (| self |); M.read (| exp |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Positive"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "alloy_primitives::signed::sign::Sign::Negative"
                                        |) in
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)))
                                ]
                              |)));
                          fun γ => ltac:(M.monadic result)
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_pow" (saturating_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_pow.
      
      (*
          pub fn wrapping_pow(self, exp: Uint<BITS, LIMBS>) -> Self {
              self.overflowing_pow(exp).0
          }
      *)
      Definition wrapping_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let exp := M.alloc (| exp |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_pow",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| exp |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_pow" (wrapping_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_pow.
      
      (*
          pub fn overflowing_shl(self, rhs: usize) -> (Self, bool) {
              if rhs >= 256 {
                  (Self::ZERO, true)
              } else {
                  (Self(self.0 << rhs), false)
              }
          }
      *)
      Definition overflowing_shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| rhs |); Value.Integer IntegerKind.Usize 256 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (|
                              get_associated_constant (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "ZERO",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  []
                              |)
                            |);
                            Value.Bool true
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.StructTuple
                              "alloy_primitives::signed::int::Signed"
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  M.get_trait_method (|
                                    "core::ops::bit::Shl",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "usize" ],
                                    "shl",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_tuple_field (|
                                        self,
                                        "alloy_primitives::signed::int::Signed",
                                        0
                                      |)
                                    |);
                                    M.read (| rhs |)
                                  ]
                                |)
                              ];
                            Value.Bool false
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_shl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_shl" (overflowing_shl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_shl.
      
      (*
          pub fn checked_shl(self, rhs: usize) -> Option<Self> {
              match self.overflowing_shl(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_shl",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_shl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_shl" (checked_shl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_shl.
      
      (*
          pub fn wrapping_shl(self, rhs: usize) -> Self {
              self.overflowing_shl(rhs).0
          }
      *)
      Definition wrapping_shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_shl",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_shl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_shl" (wrapping_shl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_shl.
      
      (*
          pub fn overflowing_shr(self, rhs: usize) -> (Self, bool) {
              if rhs >= 256 {
                  (Self::ZERO, true)
              } else {
                  (Self(self.0 >> rhs), false)
              }
          }
      *)
      Definition overflowing_shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| rhs |); Value.Integer IntegerKind.Usize 256 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (|
                              get_associated_constant (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "ZERO",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  []
                              |)
                            |);
                            Value.Bool true
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.StructTuple
                              "alloy_primitives::signed::int::Signed"
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  M.get_trait_method (|
                                    "core::ops::bit::Shr",
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    [],
                                    [ Ty.path "usize" ],
                                    "shr",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_tuple_field (|
                                        self,
                                        "alloy_primitives::signed::int::Signed",
                                        0
                                      |)
                                    |);
                                    M.read (| rhs |)
                                  ]
                                |)
                              ];
                            Value.Bool false
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_shr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_shr" (overflowing_shr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_shr.
      
      (*
          pub fn checked_shr(self, rhs: usize) -> Option<Self> {
              match self.overflowing_shr(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_shr",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value := M.copy (| γ0_0 |) in
                      let _ :=
                        is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| value |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_shr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_shr" (checked_shr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_shr.
      
      (*
          pub fn wrapping_shr(self, rhs: usize) -> Self {
              self.overflowing_shr(rhs).0
          }
      *)
      Definition wrapping_shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_shr",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_shr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_shr" (wrapping_shr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_shr.
      
      (*
          pub fn asr(self, rhs: usize) -> Self {
              // Avoid shifting if we are going to know the result regardless of the value.
              if rhs == 0 || BITS == 0 {
                  return self;
              }
      
              if rhs >= BITS - 1 {
                  match self.sign() {
                      Sign::Positive => return Self::ZERO,
                      Sign::Negative => return Self::MINUS_ONE,
                  }
              }
      
              match self.sign() {
                  // Perform the shift.
                  Sign::Positive => self.wrapping_shr(rhs),
                  Sign::Negative => {
                      // We need to do: `for 0..shift { self >> 1 | 2^255 }`
                      // We can avoid the loop by doing: `self >> shift | ~(2^(255 - shift) - 1)`
                      // where '~' represents ones complement
                      let two: Uint<BITS, LIMBS> = Uint::from(2);
                      let bitwise_or = Self::from_raw(
                          !(two.pow(Uint::<BITS, LIMBS>::from(BITS - rhs))
                              - Uint::<BITS, LIMBS>::from(1)),
                      );
                      (self.wrapping_shr(rhs)) | bitwise_or
                  }
              }
          }
      *)
      Definition asr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| rhs |); Value.Integer IntegerKind.Usize 0 ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [
                                      M.read (| rhs |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.sub,
                                        [ BITS; Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Positive"
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.read (|
                                              get_associated_constant (|
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                                  [ BITS; LIMBS ]
                                                  [],
                                                "ZERO",
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                                  [ BITS; LIMBS ]
                                                  []
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Negative"
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.read (|
                                              get_associated_constant (|
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                                  [ BITS; LIMBS ]
                                                  [],
                                                "MINUS_ONE",
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                                  [ BITS; LIMBS ]
                                                  []
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "alloy_primitives::signed::int::Signed")
                        [ BITS; LIMBS ]
                        []),
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "alloy_primitives::signed::sign::Sign",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "sign",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, self |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "alloy_primitives::signed::sign::Sign::Positive"
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "wrapping_shr",
                                [],
                                []
                              |),
                              [ M.read (| self |); M.read (| rhs |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_struct_tuple (|
                              γ,
                              "alloy_primitives::signed::sign::Sign::Negative"
                            |) in
                          let~ two : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  "from",
                                  [],
                                  [ Ty.path "i32" ]
                                |),
                                [ Value.Integer IntegerKind.I32 2 ]
                              |)
                            |) in
                          let~ bitwise_or :
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "from_raw",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    M.get_trait_method (|
                                      "core::ops::bit::Not",
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      [],
                                      [],
                                      "not",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        M.get_trait_method (|
                                          "core::ops::arith::Sub",
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          [],
                                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                          "sub",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              "pow",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (| two |);
                                              M.call_closure (|
                                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "from",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.sub,
                                                    [ BITS; M.read (| rhs |) ]
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              "from",
                                              [],
                                              [ Ty.path "i32" ]
                                            |),
                                            [ Value.Integer IntegerKind.I32 1 ]
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_trait_method (|
                                "core::ops::bit::BitOr",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []
                                ],
                                "bitor",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "wrapping_shr",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| rhs |) ]
                                |);
                                M.read (| bitwise_or |)
                              ]
                            |)
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_asr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "asr" (asr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque asr.
      
      (*
          pub fn asl(self, rhs: usize) -> Option<Self> {
              if rhs == 0 || BITS == 0 {
                  Some(self)
              } else {
                  let result = self.wrapping_shl(rhs);
                  if result.sign() != self.sign() {
                      // Overflow occurred
                      None
                  } else {
                      Some(result)
                  }
              }
          }
      *)
      Definition asl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [ M.read (| rhs |); Value.Integer IntegerKind.Usize 0 ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| self |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let~ result :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              "wrapping_shl",
                              [],
                              []
                            |),
                            [ M.read (| self |); M.read (| rhs |) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some
                          (Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.path "alloy_primitives::signed::sign::Sign",
                                        [],
                                        [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                                        "ne",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "alloy_primitives::signed::sign::Sign",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                                  [ BITS; LIMBS ]
                                                  [],
                                                "sign",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "alloy_primitives::signed::sign::Sign",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                                  [ BITS; LIMBS ]
                                                  [],
                                                "sign",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (| Value.StructTuple "core::option::Option::None" [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| result |) ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_asl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "asl" (asl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque asl.
      
      (*
          pub fn twos_complement(self) -> Uint<BITS, LIMBS> {
              let abs = self.into_raw();
              match self.sign() {
                  Sign::Positive => abs,
                  Sign::Negative => twos_complement(abs),
              }
          }
      *)
      Definition twos_complement
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ abs : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "into_raw",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              M.match_operator (|
                Some (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []),
                M.alloc (|
                  M.call_closure (|
                    Ty.path "alloy_primitives::signed::sign::Sign",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "sign",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::signed::sign::Sign::Positive"
                        |) in
                      abs));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "alloy_primitives::signed::sign::Sign::Negative"
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_function (|
                            "alloy_primitives::signed::utils::twos_complement",
                            [ BITS; LIMBS ],
                            []
                          |),
                          [ M.read (| abs |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_twos_complement :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "twos_complement" (twos_complement BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque twos_complement.
    End Impl_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i8" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i8" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u8" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u8" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i16" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i16" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u16" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u16" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i32" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i32" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u32" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u32" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i64" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "i64" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u64" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "u64" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "isize" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "isize" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.read (| M.use rhs |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "usize" ],
                        "shl",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.read (| M.use rhs |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ Ty.path "usize" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.StructTuple
              "core::option::Option::Some"
              [
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp BITS LIMBS)) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_cmp_Ord_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn cmp(&self, other: &Self) -> cmp::Ordering {
              // TODO(nlordell): Once subtraction is implemented:
              // self.saturating_sub( *other).signum64().partial_cmp(&0)
      
              use cmp::Ordering::*;
              use Sign::*;
      
              match (self.into_sign_and_abs(), other.into_sign_and_abs()) {
                  ((Positive, _), (Negative, _)) => Greater,
                  ((Negative, _), (Positive, _)) => Less,
                  ((Positive, this), (Positive, other)) => this.cmp(&other),
                  ((Negative, this), (Negative, other)) => other.cmp(&this),
              }
          }
      *)
      Definition cmp
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "core::cmp::Ordering"),
                M.alloc (|
                  Value.Tuple
                    [
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.path "alloy_primitives::signed::sign::Sign";
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "into_sign_and_abs",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.path "alloy_primitives::signed::sign::Sign";
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "into_sign_and_abs",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Positive"
                        |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Negative"
                        |) in
                      M.alloc (| Value.StructTuple "core::cmp::Ordering::Greater" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Negative"
                        |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Positive"
                        |) in
                      M.alloc (| Value.StructTuple "core::cmp::Ordering::Less" [] |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Positive"
                        |) in
                      let this := M.copy (| γ1_1 |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Positive"
                        |) in
                      let other := M.copy (| γ1_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::cmp::Ordering",
                          M.get_trait_method (|
                            "core::cmp::Ord",
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            [],
                            [],
                            "cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, this |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, other |) |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Negative"
                        |) in
                      let this := M.copy (| γ1_1 |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                      let _ :=
                        M.is_struct_tuple (|
                          γ1_0,
                          "alloy_primitives::signed::sign::Sign::Negative"
                        |) in
                      let other := M.copy (| γ1_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::cmp::Ordering",
                          M.get_trait_method (|
                            "core::cmp::Ord",
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            [],
                            [],
                            "cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, other |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, this |) |)
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self BITS LIMBS)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp BITS LIMBS)) ].
    End Impl_core_cmp_Ord_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Add_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn add(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_add(rhs.into()))
          }
      *)
      Definition add
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_add",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("add", InstanceField.Method (add BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Add_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_AddAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn add_assign(&mut self, rhs: T) {
              *self = *self + rhs;
          }
      *)
      Definition add_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ T ],
                        "add",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_AddAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Sub_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn sub(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_sub(rhs.into()))
          }
      *)
      Definition sub
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_sub",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("sub", InstanceField.Method (sub BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Sub_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_SubAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn sub_assign(&mut self, rhs: T) {
              *self = *self - rhs;
          }
      *)
      Definition sub_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ T ],
                        "sub",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_SubAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Mul_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn mul(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_mul(rhs.into()))
          }
      *)
      Definition mul
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_mul",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("mul", InstanceField.Method (mul BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Mul_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_MulAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn mul_assign(&mut self, rhs: T) {
              *self = *self * rhs;
          }
      *)
      Definition mul_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ T ],
                        "mul",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_MulAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Div_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn div(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_div(rhs.into()))
          }
      *)
      Definition div
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_div",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("div", InstanceField.Method (div BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Div_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_DivAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn div_assign(&mut self, rhs: T) {
              *self = *self / rhs;
          }
      *)
      Definition div_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::arith::Div",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ T ],
                        "div",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("div_assign", InstanceField.Method (div_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_DivAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Rem_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn rem(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_rem(rhs.into()))
          }
      *)
      Definition rem
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_rem",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("rem", InstanceField.Method (rem BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Rem_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_RemAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn rem_assign(&mut self, rhs: T) {
              *self = *self % rhs;
          }
      *)
      Definition rem_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [ T ],
                        "rem",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("rem_assign", InstanceField.Method (rem_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_RemAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_iter_traits_accum_Sum_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn sum<I: Iterator<Item = T>>(iter: I) -> Self {
              iter.fold(Self::ZERO, |acc, x| acc + x)
          }
      *)
      Definition sum
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "fold",
                [],
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          T
                        ]
                    ]
                    (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [])
                ]
              |),
              [
                M.read (| iter |);
                M.read (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [];
                                      T
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc := M.copy (| γ |) in
                                  M.match_operator (|
                                    Some
                                      (Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [];
                                              T
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [])),
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| γ |) in
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [],
                                              [],
                                              [ T ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| acc |); M.read (| x |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Sum"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("sum", InstanceField.Method (sum BITS LIMBS T)) ].
    End Impl_core_iter_traits_accum_Sum_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_iter_traits_accum_Product_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn product<I: Iterator<Item = T>>(iter: I) -> Self {
              iter.fold(Self::ONE, |acc, x| acc * x)
          }
      *)
      Definition product
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "fold",
                [],
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          T
                        ]
                    ]
                    (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [])
                ]
              |),
              [
                M.read (| iter |);
                M.read (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "ONE",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [];
                                      T
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [])),
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc := M.copy (| γ |) in
                                  M.match_operator (|
                                    Some
                                      (Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [];
                                              T
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [])),
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| γ |) in
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [],
                                              [],
                                              [ T ],
                                              "mul",
                                              [],
                                              []
                                            |),
                                            [ M.read (| acc |); M.read (| x |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Product"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("product", InstanceField.Method (product BITS LIMBS T)) ].
    End Impl_core_iter_traits_accum_Product_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitAnd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitand(self, rhs: Self) -> Self::Output {
              Self(self.0 & rhs.0)
          }
      *)
      Definition bitand
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAnd",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitand",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("bitand", InstanceField.Method (bitand BITS LIMBS))
          ].
    End Impl_core_ops_bit_BitAnd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitAndAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitand_assign(&mut self, rhs: Self) {
              *self = *self & rhs;
          }
      *)
      Definition bitand_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("bitand_assign", InstanceField.Method (bitand_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_BitAndAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitOr_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitor(self, rhs: Self) -> Self::Output {
              Self(self.0 | rhs.0)
          }
      *)
      Definition bitor
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOr",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("bitor", InstanceField.Method (bitor BITS LIMBS))
          ].
    End Impl_core_ops_bit_BitOr_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitOrAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitor_assign(&mut self, rhs: Self) {
              *self = *self | rhs;
          }
      *)
      Definition bitor_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::BitOr",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "bitor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("bitor_assign", InstanceField.Method (bitor_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_BitOrAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitXor_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitxor(self, rhs: Self) -> Self::Output {
              Self(self.0 ^ rhs.0)
          }
      *)
      Definition bitxor
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXor",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitxor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("bitxor", InstanceField.Method (bitxor BITS LIMBS))
          ].
    End Impl_core_ops_bit_BitXor_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitXorAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitxor_assign(&mut self, rhs: Self) {
              *self = *self ^ rhs;
          }
      *)
      Definition bitxor_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let rhs := M.alloc (| rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::ops::bit::BitXor",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "bitxor",
                        [],
                        []
                      |),
                      [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("bitxor_assign", InstanceField.Method (bitxor_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_BitXorAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Neg_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn neg(self) -> Self::Output {
              handle_overflow(self.overflowing_neg())
          }
      *)
      Definition neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_neg",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("neg", InstanceField.Method (neg BITS LIMBS))
          ].
    End Impl_core_ops_arith_Neg_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Not_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn not(self) -> Self::Output {
              Self(!self.0)
          }
      *)
      Definition not
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::Not",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [],
                    "not",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("not", InstanceField.Method (not BITS LIMBS))
          ].
    End Impl_core_ops_bit_Not_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
  End ops.
End signed.
