(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signed.
  Module ops.
    Module Impl_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          pub fn abs(self) -> Self {
              handle_overflow(self.overflowing_abs())
          }
      *)
      Definition abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_abs",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "abs" (abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque abs.
      
      (*
          pub fn overflowing_abs(self) -> (Self, bool) {
              if BITS == 0 {
                  return (self, false);
              }
              if self == Self::MIN {
                  (self, true)
              } else {
                  (Self(self.unsigned_abs()), false)
              }
          }
      *)
      Definition overflowing_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.catch_return
              (Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ M.read (| self |); Value.Bool false ] |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.match_operator (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "bool"
                        ],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, self |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MIN",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            Value.Tuple [ M.read (| self |); Value.Bool true ]));
                        fun γ =>
                          ltac:(M.monadic
                            (Value.Tuple
                              [
                                Value.StructTuple
                                  "alloy_primitives::signed::int::Signed"
                                  [ BITS; LIMBS ]
                                  []
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "unsigned_abs",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ];
                                Value.Bool false
                              ]))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_abs" (overflowing_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_abs.
      
      (*
          pub fn checked_abs(self) -> Option<Self> {
              match self.overflowing_abs() {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_abs",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| value |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_abs" (checked_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_abs.
      
      (*
          pub fn saturating_abs(self) -> Self {
              match self.overflowing_abs() {
                  (value, false) => value,
                  _ => Self::MAX,
              }
          }
      *)
      Definition saturating_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_abs",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    M.read (| value |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      get_associated_constant (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "MAX",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_abs" (saturating_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_abs.
      
      (*
          pub fn wrapping_abs(self) -> Self {
              self.overflowing_abs().0
          }
      *)
      Definition wrapping_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_abs",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_abs" (wrapping_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_abs.
      
      (*
          pub fn unsigned_abs(self) -> Uint<BITS, LIMBS> {
              self.into_sign_and_abs().1
          }
      *)
      Definition unsigned_abs
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.path "alloy_primitives::signed::sign::Sign";
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.path "alloy_primitives::signed::sign::Sign";
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "into_sign_and_abs",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                  |)
                |),
                1
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_unsigned_abs :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "unsigned_abs" (unsigned_abs BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque unsigned_abs.
      
      (*
          pub fn overflowing_neg(self) -> (Self, bool) {
              if BITS == 0 {
                  return (self, false);
              }
              if self == Self::MIN {
                  (self, true)
              } else {
                  (Self(twos_complement(self.0)), false)
              }
          }
      *)
      Definition overflowing_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.catch_return
              (Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.Tuple [ M.read (| self |); Value.Bool false ] |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.match_operator (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "bool"
                        ],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, self |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MIN",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            Value.Tuple [ M.read (| self |); Value.Bool true ]));
                        fun γ =>
                          ltac:(M.monadic
                            (Value.Tuple
                              [
                                Value.StructTuple
                                  "alloy_primitives::signed::int::Signed"
                                  [ BITS; LIMBS ]
                                  []
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_function (|
                                        "alloy_primitives::signed::utils::twos_complement",
                                        [ BITS; LIMBS ],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_tuple_field (|
                                            self,
                                            "alloy_primitives::signed::int::Signed",
                                            0
                                          |)
                                        |)
                                      ]
                                    |)
                                  ];
                                Value.Bool false
                              ]))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_neg" (overflowing_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_neg.
      
      (*
          pub fn checked_neg(self) -> Option<Self> {
              match self.overflowing_neg() {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_neg",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| value |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_neg" (checked_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_neg.
      
      (*
          pub fn saturating_neg(self) -> Self {
              match self.overflowing_neg() {
                  (value, false) => value,
                  _ => Self::MAX,
              }
          }
      *)
      Definition saturating_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_neg",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    M.read (| value |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      get_associated_constant (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "MAX",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_neg" (saturating_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_neg.
      
      (*
          pub fn wrapping_neg(self) -> Self {
              self.overflowing_neg().0
          }
      *)
      Definition wrapping_neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_neg",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_neg :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_neg" (wrapping_neg BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_neg.
      
      (*
          pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {
              let (unsigned, _) = self.0.overflowing_add(rhs.0);
              let result = Self(unsigned);
      
              // NOTE: Overflow is determined by checking the sign of the operands and
              //   the result.
              let overflow = matches!(
                  (self.sign(), rhs.sign(), result.sign()),
                  (Sign::Positive, Sign::Positive, Sign::Negative)
                      | (Sign::Negative, Sign::Negative, Sign::Positive)
              );
      
              (result, overflow)
          }
      *)
      Definition overflowing_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              M.alloc (|
                Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "overflowing_add",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let unsigned :=
                      M.copy (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], γ0_0 |) in
                    M.read (|
                      let~ result :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ BITS; LIMBS ]
                          []
                          [ M.read (| unsigned |) ] in
                      let~ overflow : Ty.path "bool" :=
                        M.match_operator (|
                          Ty.path "bool",
                          M.alloc (|
                            Ty.tuple
                              [
                                Ty.path "alloy_primitives::signed::sign::Sign";
                                Ty.path "alloy_primitives::signed::sign::Sign";
                                Ty.path "alloy_primitives::signed::sign::Sign"
                              ],
                            Value.Tuple
                              [
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |);
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                |);
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.find_or_pattern (Ty.tuple []) (|
                                  γ,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_0,
                                            "alloy_primitives::signed::sign::Sign::Positive"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_1,
                                            "alloy_primitives::signed::sign::Sign::Positive"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_2,
                                            "alloy_primitives::signed::sign::Sign::Negative"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_0,
                                            "alloy_primitives::signed::sign::Sign::Negative"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_1,
                                            "alloy_primitives::signed::sign::Sign::Negative"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_2,
                                            "alloy_primitives::signed::sign::Sign::Positive"
                                          |) in
                                        Value.Tuple []))
                                  ],
                                  fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [] => ltac:(M.monadic (Value.Bool true))
                                      | _ => M.impossible "wrong number of arguments"
                                      end)
                                |)));
                            fun γ => ltac:(M.monadic (Value.Bool false))
                          ]
                        |) in
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [];
                            Ty.path "bool"
                          ],
                        Value.Tuple [ M.read (| result |); M.read (| overflow |) ]
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_add" (overflowing_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_add.
      
      (*
          pub const fn checked_add(self, rhs: Self) -> Option<Self> {
              match self.overflowing_add(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_add",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| value |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_add" (checked_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_add.
      
      (*
          pub const fn saturating_add(self, rhs: Self) -> Self {
              let (result, overflow) = self.overflowing_add(rhs);
              if overflow {
                  match result.sign() {
                      Sign::Positive => Self::MIN,
                      Sign::Negative => Self::MAX,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_add",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let overflow := M.copy (| Ty.path "bool", γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use overflow in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.alloc (|
                                Ty.path "alloy_primitives::signed::sign::Sign",
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Positive"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Negative"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.read (| result |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_add" (saturating_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_add.
      
      (*
          pub const fn wrapping_add(self, rhs: Self) -> Self {
              self.overflowing_add(rhs).0
          }
      *)
      Definition wrapping_add
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_add",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_add :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_add" (wrapping_add BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_add.
      
      (*
          pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {
              // NOTE: We can't just compute the `self + (-rhs)` because `-rhs` does
              //   not always exist, specifically this would be a problem in case
              //   `rhs == Self::MIN`
      
              let (unsigned, _) = self.0.overflowing_sub(rhs.0);
              let result = Self(unsigned);
      
              // NOTE: Overflow is determined by checking the sign of the operands and
              //   the result.
              let overflow = matches!(
                  (self.sign(), rhs.sign(), result.sign()),
                  (Sign::Positive, Sign::Negative, Sign::Negative)
                      | (Sign::Negative, Sign::Positive, Sign::Positive)
              );
      
              (result, overflow)
          }
      *)
      Definition overflowing_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              M.alloc (|
                Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                M.call_closure (|
                  Ty.tuple [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    "overflowing_sub",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let unsigned :=
                      M.copy (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], γ0_0 |) in
                    M.read (|
                      let~ result :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ BITS; LIMBS ]
                          []
                          [ M.read (| unsigned |) ] in
                      let~ overflow : Ty.path "bool" :=
                        M.match_operator (|
                          Ty.path "bool",
                          M.alloc (|
                            Ty.tuple
                              [
                                Ty.path "alloy_primitives::signed::sign::Sign";
                                Ty.path "alloy_primitives::signed::sign::Sign";
                                Ty.path "alloy_primitives::signed::sign::Sign"
                              ],
                            Value.Tuple
                              [
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |);
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                |);
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.find_or_pattern (Ty.tuple []) (|
                                  γ,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_0,
                                            "alloy_primitives::signed::sign::Sign::Positive"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_1,
                                            "alloy_primitives::signed::sign::Sign::Negative"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_2,
                                            "alloy_primitives::signed::sign::Sign::Negative"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_0,
                                            "alloy_primitives::signed::sign::Sign::Negative"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_1,
                                            "alloy_primitives::signed::sign::Sign::Positive"
                                          |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ0_2,
                                            "alloy_primitives::signed::sign::Sign::Positive"
                                          |) in
                                        Value.Tuple []))
                                  ],
                                  fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [] => ltac:(M.monadic (Value.Bool true))
                                      | _ => M.impossible "wrong number of arguments"
                                      end)
                                |)));
                            fun γ => ltac:(M.monadic (Value.Bool false))
                          ]
                        |) in
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [];
                            Ty.path "bool"
                          ],
                        Value.Tuple [ M.read (| result |); M.read (| overflow |) ]
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_sub" (overflowing_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_sub.
      
      (*
          pub const fn checked_sub(self, rhs: Self) -> Option<Self> {
              match self.overflowing_sub(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_sub",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| value |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_sub" (checked_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_sub.
      
      (*
          pub const fn saturating_sub(self, rhs: Self) -> Self {
              let (result, overflow) = self.overflowing_sub(rhs);
              if overflow {
                  match result.sign() {
                      Sign::Positive => Self::MIN,
                      Sign::Negative => Self::MAX,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_sub",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let overflow := M.copy (| Ty.path "bool", γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use overflow in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.alloc (|
                                Ty.path "alloy_primitives::signed::sign::Sign",
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Positive"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Negative"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.read (| result |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_sub" (saturating_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_sub.
      
      (*
          pub const fn wrapping_sub(self, rhs: Self) -> Self {
              self.overflowing_sub(rhs).0
          }
      *)
      Definition wrapping_sub
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_sub",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_sub :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_sub" (wrapping_sub BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_sub.
      
      (*
          pub fn overflowing_mul(self, rhs: Self) -> (Self, bool) {
              if self.is_zero() || rhs.is_zero() {
                  return (Self::ZERO, false);
              }
              let sign = self.sign() * rhs.sign();
              let (unsigned, overflow_mul) = self.unsigned_abs().overflowing_mul(rhs.unsigned_abs());
              let (result, overflow_conv) = Self::overflowing_from_sign_and_abs(sign, unsigned);
      
              (result, overflow_mul || overflow_conv)
          }
      *)
      Definition overflowing_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.catch_return
              (Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "is_zero",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "is_zero",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.Tuple
                                    [
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "ZERO",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |);
                                      Value.Bool false
                                    ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  let~ sign : Ty.path "alloy_primitives::signed::sign::Sign" :=
                    M.call_closure (|
                      Ty.path "alloy_primitives::signed::sign::Sign",
                      M.get_trait_method (|
                        "core::ops::arith::Mul",
                        Ty.path "alloy_primitives::signed::sign::Sign",
                        [],
                        [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                        "mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "alloy_primitives::signed::sign::Sign",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "sign",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, self |) ]
                        |);
                        M.call_closure (|
                          Ty.path "alloy_primitives::signed::sign::Sign",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "sign",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                        |)
                      ]
                    |) in
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.match_operator (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "bool"
                        ],
                      M.alloc (|
                        Ty.tuple
                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                        M.call_closure (|
                          Ty.tuple
                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "overflowing_mul",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "unsigned_abs",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |);
                            M.call_closure (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "unsigned_abs",
                                [],
                                []
                              |),
                              [ M.read (| rhs |) ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let unsigned :=
                              M.copy (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                γ0_0
                              |) in
                            let overflow_mul := M.copy (| Ty.path "bool", γ0_1 |) in
                            M.match_operator (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [];
                                  Ty.path "bool"
                                ],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [];
                                    Ty.path "bool"
                                  ],
                                M.call_closure (|
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [];
                                      Ty.path "bool"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "overflowing_from_sign_and_abs",
                                    [],
                                    []
                                  |),
                                  [ M.read (| sign |); M.read (| unsigned |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let result :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        γ0_0
                                      |) in
                                    let overflow_conv := M.copy (| Ty.path "bool", γ0_1 |) in
                                    Value.Tuple
                                      [
                                        M.read (| result |);
                                        LogicalOp.or (|
                                          M.read (| overflow_mul |),
                                          ltac:(M.monadic (M.read (| overflow_conv |)))
                                        |)
                                      ]))
                              ]
                            |)))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_mul" (overflowing_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_mul.
      
      (*
          pub fn checked_mul(self, rhs: Self) -> Option<Self> {
              match self.overflowing_mul(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_mul",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| value |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_mul" (checked_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_mul.
      
      (*
          pub fn saturating_mul(self, rhs: Self) -> Self {
              let (result, overflow) = self.overflowing_mul(rhs);
              if overflow {
                  match self.sign() * rhs.sign() {
                      Sign::Positive => Self::MAX,
                      Sign::Negative => Self::MIN,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_mul",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let overflow := M.copy (| Ty.path "bool", γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use overflow in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.alloc (|
                                Ty.path "alloy_primitives::signed::sign::Sign",
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    Ty.path "alloy_primitives::signed::sign::Sign",
                                    [],
                                    [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                                    "mul",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "alloy_primitives::signed::sign::Sign",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "sign",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "alloy_primitives::signed::sign::Sign",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "sign",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Positive"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Negative"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.read (| result |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_mul" (saturating_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_mul.
      
      (*
          pub fn wrapping_mul(self, rhs: Self) -> Self {
              self.overflowing_mul(rhs).0
          }
      *)
      Definition wrapping_mul
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_mul",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_mul :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_mul" (wrapping_mul BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_mul.
      
      (*
          pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {
              assert!(!rhs.is_zero(), "attempt to divide by zero");
              let sign = self.sign() * rhs.sign();
              // Note, signed division can't overflow!
              let unsigned = self.unsigned_abs() / rhs.unsigned_abs();
              let (result, overflow_conv) = Self::overflowing_from_sign_and_abs(sign, unsigned);
      
              (result, overflow_conv && !result.is_zero())
          }
      *)
      Definition overflowing_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              UnOp.not (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "is_zero",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                  |)
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [ Value.Integer IntegerKind.Usize 1 ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 1 ]
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                          Value.Array [ mk_str (| "attempt to divide by zero" |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              let~ sign : Ty.path "alloy_primitives::signed::sign::Sign" :=
                M.call_closure (|
                  Ty.path "alloy_primitives::signed::sign::Sign",
                  M.get_trait_method (|
                    "core::ops::arith::Mul",
                    Ty.path "alloy_primitives::signed::sign::Sign",
                    [],
                    [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                    "mul",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "alloy_primitives::signed::sign::Sign",
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "sign",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, self |) ]
                    |);
                    M.call_closure (|
                      Ty.path "alloy_primitives::signed::sign::Sign",
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "sign",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                    |)
                  ]
                |) in
              let~ unsigned : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::arith::Div",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "div",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "unsigned_abs",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "unsigned_abs",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |) in
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.match_operator (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "bool"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "overflowing_from_sign_and_abs",
                        [],
                        []
                      |),
                      [ M.read (| sign |); M.read (| unsigned |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let result :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            γ0_0
                          |) in
                        let overflow_conv := M.copy (| Ty.path "bool", γ0_1 |) in
                        Value.Tuple
                          [
                            M.read (| result |);
                            LogicalOp.and (|
                              M.read (| overflow_conv |),
                              ltac:(M.monadic
                                (UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "is_zero",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                  |)
                                |)))
                            |)
                          ]))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_div" (overflowing_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_div.
      
      (*
          pub fn checked_div(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.overflowing_div(rhs).0)
              }
          }
      *)
      Definition checked_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.or (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "is_zero",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, self |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, rhs |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MINUS_ONE",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |)))
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [
                        M.read (|
                          M.SubPointer.get_tuple_field (|
                            M.alloc (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [];
                                  Ty.path "bool"
                                ],
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [];
                                    Ty.path "bool"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "overflowing_div",
                                  [],
                                  []
                                |),
                                [ M.read (| self |); M.read (| rhs |) ]
                              |)
                            |),
                            0
                          |)
                        |)
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_div" (checked_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_div.
      
      (*
          pub fn saturating_div(self, rhs: Self) -> Self {
              match self.overflowing_div(rhs) {
                  (value, false) => value,
                  // MIN / -1 is the only possible saturating overflow
                  _ => Self::MAX,
              }
          }
      *)
      Definition saturating_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_div",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    M.read (| value |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      get_associated_constant (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "MAX",
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_div" (saturating_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_div.
      
      (*
          pub fn wrapping_div(self, rhs: Self) -> Self {
              self.overflowing_div(rhs).0
          }
      *)
      Definition wrapping_div
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_div",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_div :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_div" (wrapping_div BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_div.
      
      (*
          pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {
              if self == Self::MIN && rhs == Self::MINUS_ONE {
                  (Self::ZERO, true)
              } else {
                  let div_res = self / rhs;
                  (self - div_res * rhs, false)
              }
          }
      *)
      Definition overflowing_rem
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.and (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []
                                ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, self |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_associated_constant (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "MIN",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  |)
                                |)
                              ]
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, rhs |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    get_associated_constant (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "MINUS_ONE",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    |)
                                  |)
                                ]
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.Tuple
                      [
                        M.read (|
                          get_associated_constant (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "ZERO",
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          |)
                        |);
                        Value.Bool true
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      let~ div_res :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.get_trait_method (|
                            "core::ops::arith::Div",
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ],
                            "div",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |) in
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [];
                            Ty.path "bool"
                          ],
                        Value.Tuple
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_trait_method (|
                                "core::ops::arith::Sub",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []
                                ],
                                "sub",
                                [],
                                []
                              |),
                              [
                                M.read (| self |);
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Mul",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "mul",
                                    [],
                                    []
                                  |),
                                  [ M.read (| div_res |); M.read (| rhs |) ]
                                |)
                              ]
                            |);
                            Value.Bool false
                          ]
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_rem :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_rem" (overflowing_rem BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_rem.
      
      (*
          pub fn checked_rem(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.overflowing_rem(rhs).0)
              }
          }
      *)
      Definition checked_rem
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.or (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "is_zero",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, self |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, rhs |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MINUS_ONE",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |)))
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [
                        M.read (|
                          M.SubPointer.get_tuple_field (|
                            M.alloc (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [];
                                  Ty.path "bool"
                                ],
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [];
                                    Ty.path "bool"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "overflowing_rem",
                                  [],
                                  []
                                |),
                                [ M.read (| self |); M.read (| rhs |) ]
                              |)
                            |),
                            0
                          |)
                        |)
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_rem :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_rem" (checked_rem BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_rem.
      
      (*
          pub fn wrapping_rem(self, rhs: Self) -> Self {
              self.overflowing_rem(rhs).0
          }
      *)
      Definition wrapping_rem
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_rem",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_rem :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_rem" (wrapping_rem BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_rem.
      
      (*
          pub fn div_euclid(self, rhs: Self) -> Self {
              let q = self / rhs;
              if (self % rhs).is_negative() {
                  if rhs.is_positive() {
                      q - Self::ONE
                  } else {
                      q + Self::ONE
                  }
              } else {
                  q
              }
          }
      *)
      Definition div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              let~ q :
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] :=
                M.call_closure (|
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::arith::Div",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "div",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                M.match_operator (|
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  "is_negative",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        M.get_trait_method (|
                                          "core::ops::arith::Rem",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          ],
                                          "rem",
                                          [],
                                          []
                                        |),
                                        [ M.read (| self |); M.read (| rhs |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "is_positive",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Sub",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (| q |);
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "ONE",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (| q |);
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "ONE",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.read (| q |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "div_euclid" (div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque div_euclid.
      
      (*
          pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {
              if self == Self::MIN && rhs == Self::MINUS_ONE {
                  (self, true)
              } else {
                  (self.div_euclid(rhs), false)
              }
          }
      *)
      Definition overflowing_div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.and (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []
                                ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, self |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_associated_constant (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "MIN",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  |)
                                |)
                              ]
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, rhs |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    get_associated_constant (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "MINUS_ONE",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    |)
                                  |)
                                ]
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.Tuple [ M.read (| self |); Value.Bool true ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.Tuple
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "div_euclid",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |);
                        Value.Bool false
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "overflowing_div_euclid"
          (overflowing_div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_div_euclid.
      
      (*
          pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.div_euclid(rhs))
              }
          }
      *)
      Definition checked_div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.or (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "is_zero",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, self |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, rhs |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MINUS_ONE",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |)))
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "div_euclid",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "checked_div_euclid"
          (checked_div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_div_euclid.
      
      (*
          pub fn wrapping_div_euclid(self, rhs: Self) -> Self {
              self.overflowing_div_euclid(rhs).0
          }
      *)
      Definition wrapping_div_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_div_euclid",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_div_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "wrapping_div_euclid"
          (wrapping_div_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_div_euclid.
      
      (*
          pub fn rem_euclid(self, rhs: Self) -> Self {
              let r = self % rhs;
              if r < Self::ZERO {
                  if rhs < Self::ZERO {
                      r - rhs
                  } else {
                      r + rhs
                  }
              } else {
                  r
              }
          }
      *)
      Definition rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              let~ r :
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] :=
                M.call_closure (|
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::arith::Rem",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "rem",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                M.match_operator (|
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                  "lt",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, r |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    get_associated_constant (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "ZERO",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              []
                                          ],
                                          "lt",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (| Pointer.Kind.Ref, rhs |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            get_associated_constant (|
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [],
                                              "ZERO",
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                []
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Sub",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "sub",
                                    [],
                                    []
                                  |),
                                  [ M.read (| r |); M.read (| rhs |) ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::arith::Add",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [ M.read (| r |); M.read (| rhs |) ]
                                |)))
                          ]
                        |)));
                    fun γ => ltac:(M.monadic (M.read (| r |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "rem_euclid" (rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque rem_euclid.
      
      (*
          pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {
              if self == Self::MIN && rhs == Self::MINUS_ONE {
                  (Self::ZERO, true)
              } else {
                  (self.rem_euclid(rhs), false)
              }
          }
      *)
      Definition overflowing_rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.and (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    []
                                ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, self |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_associated_constant (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "MIN",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  |)
                                |)
                              ]
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, rhs |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    get_associated_constant (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "MINUS_ONE",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    |)
                                  |)
                                ]
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.Tuple
                      [
                        M.read (|
                          get_associated_constant (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "ZERO",
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          |)
                        |);
                        Value.Bool true
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.Tuple
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "rem_euclid",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |);
                        Value.Bool false
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "overflowing_rem_euclid"
          (overflowing_rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_rem_euclid.
      
      (*
          pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {
              self.overflowing_rem_euclid(rhs).0
          }
      *)
      Definition wrapping_rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_rem_euclid",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "wrapping_rem_euclid"
          (wrapping_rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_rem_euclid.
      
      (*
          pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {
              if rhs.is_zero() || (self == Self::MIN && rhs == Self::MINUS_ONE) {
                  None
              } else {
                  Some(self.rem_euclid(rhs))
              }
          }
      *)
      Definition checked_rem_euclid
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.or (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "is_zero",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
                            |),
                            ltac:(M.monadic
                              (LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, self |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, rhs |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "MINUS_ONE",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |)
                                    ]
                                  |)))
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "rem_euclid",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |)
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_rem_euclid :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C
          (Self BITS LIMBS)
          "checked_rem_euclid"
          (checked_rem_euclid BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_rem_euclid.
      
      (*
          pub(crate) const fn pow_sign(self, exp: Uint<BITS, LIMBS>) -> Sign {
              let is_exp_odd = BITS != 0 && exp.as_limbs()[0] % 2 == 1;
              if is_exp_odd && self.is_negative() {
                  Sign::Negative
              } else {
                  Sign::Positive
              }
          }
      *)
      Definition pow_sign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let exp := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], exp |) in
            M.read (|
              let~ is_exp_odd : Ty.path "bool" :=
                LogicalOp.and (|
                  M.call_closure (|
                    Ty.path "bool",
                    BinOp.ne,
                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      BinOp.eq,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.rem,
                          [
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      "as_limbs",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, exp |) ]
                                  |)
                                |),
                                Value.Integer IntegerKind.Usize 0
                              |)
                            |);
                            Value.Integer IntegerKind.U64 2
                          ]
                        |);
                        Value.Integer IntegerKind.U64 1
                      ]
                    |)))
                |) in
              M.alloc (|
                Ty.path "alloy_primitives::signed::sign::Sign",
                M.match_operator (|
                  Ty.path "alloy_primitives::signed::sign::Sign",
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              LogicalOp.and (|
                                M.read (| is_exp_odd |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      "is_negative",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        Value.StructTuple
                          "alloy_primitives::signed::sign::Sign::Negative"
                          []
                          []
                          []));
                    fun γ =>
                      ltac:(M.monadic
                        (Value.StructTuple
                          "alloy_primitives::signed::sign::Sign::Positive"
                          []
                          []
                          []))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow_sign :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "pow_sign" (pow_sign BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque pow_sign.
      
      (*
          pub fn exp10(n: usize) -> Self {
              Uint::<BITS, LIMBS>::from(10).pow(Uint::from(n)).try_into().expect("overflow")
          }
      *)
      Definition exp10
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| Ty.path "usize", n |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                  ],
                "expect",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "alloy_primitives::signed::errors::BigIntConversionError"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryInto",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                    ],
                    "try_into",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "pow",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "from",
                            [],
                            [ Ty.path "i32" ]
                          |),
                          [ Value.Integer IntegerKind.I32 10 ]
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "from",
                            [],
                            [ Ty.path "usize" ]
                          |),
                          [ M.read (| n |) ]
                        |)
                      ]
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "overflow" |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_exp10 :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "exp10" (exp10 BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque exp10.
      
      (*
          pub fn pow(self, exp: Uint<BITS, LIMBS>) -> Self {
              handle_overflow(self.overflowing_pow(exp))
          }
      *)
      Definition pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let exp := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], exp |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_pow",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "pow" (pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque pow.
      
      (*
          pub fn overflowing_pow(self, exp: Uint<BITS, LIMBS>) -> (Self, bool) {
              if BITS == 0 {
                  return (Self::ZERO, false);
              }
      
              let sign = self.pow_sign(exp);
      
              let (unsigned, overflow_pow) = self.unsigned_abs().overflowing_pow(exp);
              let (result, overflow_conv) = Self::overflowing_from_sign_and_abs(sign, unsigned);
      
              (result, overflow_pow || overflow_conv)
          }
      *)
      Definition overflowing_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let exp := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], exp |) in
            M.catch_return
              (Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.Tuple
                                    [
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            [],
                                          "ZERO",
                                          Ty.apply
                                            (Ty.path "alloy_primitives::signed::int::Signed")
                                            [ BITS; LIMBS ]
                                            []
                                        |)
                                      |);
                                      Value.Bool false
                                    ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  let~ sign : Ty.path "alloy_primitives::signed::sign::Sign" :=
                    M.call_closure (|
                      Ty.path "alloy_primitives::signed::sign::Sign",
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "pow_sign",
                        [],
                        []
                      |),
                      [ M.read (| self |); M.read (| exp |) ]
                    |) in
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.match_operator (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [];
                          Ty.path "bool"
                        ],
                      M.alloc (|
                        Ty.tuple
                          [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                        M.call_closure (|
                          Ty.tuple
                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "overflowing_pow",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "unsigned_abs",
                                [],
                                []
                              |),
                              [ M.read (| self |) ]
                            |);
                            M.read (| exp |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let unsigned :=
                              M.copy (|
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                γ0_0
                              |) in
                            let overflow_pow := M.copy (| Ty.path "bool", γ0_1 |) in
                            M.match_operator (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [];
                                  Ty.path "bool"
                                ],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [];
                                    Ty.path "bool"
                                  ],
                                M.call_closure (|
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [];
                                      Ty.path "bool"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "overflowing_from_sign_and_abs",
                                    [],
                                    []
                                  |),
                                  [ M.read (| sign |); M.read (| unsigned |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let result :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        γ0_0
                                      |) in
                                    let overflow_conv := M.copy (| Ty.path "bool", γ0_1 |) in
                                    Value.Tuple
                                      [
                                        M.read (| result |);
                                        LogicalOp.or (|
                                          M.read (| overflow_pow |),
                                          ltac:(M.monadic (M.read (| overflow_conv |)))
                                        |)
                                      ]))
                              ]
                            |)))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_pow" (overflowing_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_pow.
      
      (*
          pub fn checked_pow(self, exp: Uint<BITS, LIMBS>) -> Option<Self> {
              let (result, overflow) = self.overflowing_pow(exp);
              if overflow {
                  None
              } else {
                  Some(result)
              }
          }
      *)
      Definition checked_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let exp := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], exp |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_pow",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let overflow := M.copy (| Ty.path "bool", γ0_1 |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use overflow in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            Value.StructTuple
                              "core::option::Option::None"
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  []
                              ]
                              []));
                        fun γ =>
                          ltac:(M.monadic
                            (Value.StructTuple
                              "core::option::Option::Some"
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  []
                              ]
                              [ M.read (| result |) ]))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_pow" (checked_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_pow.
      
      (*
          pub fn saturating_pow(self, exp: Uint<BITS, LIMBS>) -> Self {
              let (result, overflow) = self.overflowing_pow(exp);
              if overflow {
                  match self.pow_sign(exp) {
                      Sign::Positive => Self::MAX,
                      Sign::Negative => Self::MIN,
                  }
              } else {
                  result
              }
          }
      *)
      Definition saturating_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let exp := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], exp |) in
            M.match_operator (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_pow",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| exp |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let result :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let overflow := M.copy (| Ty.path "bool", γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use overflow in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.alloc (|
                                Ty.path "alloy_primitives::signed::sign::Sign",
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "pow_sign",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| exp |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Positive"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MAX",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Negative"
                                      |) in
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "MIN",
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          []
                                      |)
                                    |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.read (| result |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_saturating_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "saturating_pow" (saturating_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque saturating_pow.
      
      (*
          pub fn wrapping_pow(self, exp: Uint<BITS, LIMBS>) -> Self {
              self.overflowing_pow(exp).0
          }
      *)
      Definition wrapping_pow
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; exp ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let exp := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], exp |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_pow",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| exp |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_pow :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_pow" (wrapping_pow BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_pow.
      
      (*
          pub fn overflowing_shl(self, rhs: usize) -> (Self, bool) {
              if rhs >= 256 {
                  (Self::ZERO, true)
              } else {
                  (Self(self.0 << rhs), false)
              }
          }
      *)
      Definition overflowing_shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.ge,
                            [ M.read (| rhs |); Value.Integer IntegerKind.Usize 256 ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.Tuple
                      [
                        M.read (|
                          get_associated_constant (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "ZERO",
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          |)
                        |);
                        Value.Bool true
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.Tuple
                      [
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ BITS; LIMBS ]
                          []
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              M.get_trait_method (|
                                "core::ops::bit::Shl",
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                [],
                                [ Ty.path "usize" ],
                                "shl",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_tuple_field (|
                                    self,
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |);
                                M.read (| rhs |)
                              ]
                            |)
                          ];
                        Value.Bool false
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_shl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_shl" (overflowing_shl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_shl.
      
      (*
          pub fn checked_shl(self, rhs: usize) -> Option<Self> {
              match self.overflowing_shl(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_shl",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| value |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_shl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_shl" (checked_shl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_shl.
      
      (*
          pub fn wrapping_shl(self, rhs: usize) -> Self {
              self.overflowing_shl(rhs).0
          }
      *)
      Definition wrapping_shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_shl",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_shl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_shl" (wrapping_shl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_shl.
      
      (*
          pub fn overflowing_shr(self, rhs: usize) -> (Self, bool) {
              if rhs >= 256 {
                  (Self::ZERO, true)
              } else {
                  (Self(self.0 >> rhs), false)
              }
          }
      *)
      Definition overflowing_shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.ge,
                            [ M.read (| rhs |); Value.Integer IntegerKind.Usize 256 ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.Tuple
                      [
                        M.read (|
                          get_associated_constant (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "ZERO",
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          |)
                        |);
                        Value.Bool true
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.Tuple
                      [
                        Value.StructTuple
                          "alloy_primitives::signed::int::Signed"
                          [ BITS; LIMBS ]
                          []
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                              M.get_trait_method (|
                                "core::ops::bit::Shr",
                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                [],
                                [ Ty.path "usize" ],
                                "shr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_tuple_field (|
                                    self,
                                    "alloy_primitives::signed::int::Signed",
                                    0
                                  |)
                                |);
                                M.read (| rhs |)
                              ]
                            |)
                          ];
                        Value.Bool false
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_overflowing_shr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "overflowing_shr" (overflowing_shr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque overflowing_shr.
      
      (*
          pub fn checked_shr(self, rhs: usize) -> Option<Self> {
              match self.overflowing_shr(rhs) {
                  (value, false) => Some(value),
                  _ => None,
              }
          }
      *)
      Definition checked_shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                    Ty.path "bool"
                  ],
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_shr",
                    [],
                    []
                  |),
                  [ M.read (| self |); M.read (| rhs |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let value :=
                      M.copy (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        γ0_0
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ0_1 |), Value.Bool false |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| value |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "core::option::Option::None"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_checked_shr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "checked_shr" (checked_shr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque checked_shr.
      
      (*
          pub fn wrapping_shr(self, rhs: usize) -> Self {
              self.overflowing_shr(rhs).0
          }
      *)
      Definition wrapping_shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.read (|
              M.SubPointer.get_tuple_field (|
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [];
                        Ty.path "bool"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      "overflowing_shr",
                      [],
                      []
                    |),
                    [ M.read (| self |); M.read (| rhs |) ]
                  |)
                |),
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_wrapping_shr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "wrapping_shr" (wrapping_shr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque wrapping_shr.
      
      (*
          pub fn asr(self, rhs: usize) -> Self {
              // Avoid shifting if we are going to know the result regardless of the value.
              if rhs == 0 || BITS == 0 {
                  return self;
              }
      
              if rhs >= BITS - 1 {
                  match self.sign() {
                      Sign::Positive => return Self::ZERO,
                      Sign::Negative => return Self::MINUS_ONE,
                  }
              }
      
              match self.sign() {
                  // Perform the shift.
                  Sign::Positive => self.wrapping_shr(rhs),
                  Sign::Negative => {
                      // We need to do: `for 0..shift { self >> 1 | 2^255 }`
                      // We can avoid the loop by doing: `self >> shift | ~(2^(255 - shift) - 1)`
                      // where '~' represents ones complement
                      let two: Uint<BITS, LIMBS> = Uint::from(2);
                      let bitwise_or = Self::from_raw(
                          !(two.pow(Uint::<BITS, LIMBS>::from(BITS - rhs))
                              - Uint::<BITS, LIMBS>::from(1)),
                      );
                      (self.wrapping_shr(rhs)) | bitwise_or
                  }
              }
          }
      *)
      Definition asr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.catch_return
              (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| rhs |); Value.Integer IntegerKind.Usize 0 ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [
                                      M.read (| rhs |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.sub,
                                        [ BITS; Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.path "alloy_primitives::signed::sign::Sign",
                                M.call_closure (|
                                  Ty.path "alloy_primitives::signed::sign::Sign",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "sign",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Positive"
                                      |) in
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [],
                                              "ZERO",
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                []
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (|
                                        γ,
                                        "alloy_primitives::signed::sign::Sign::Negative"
                                      |) in
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [],
                                              "MINUS_ONE",
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                []
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.match_operator (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.alloc (|
                        Ty.path "alloy_primitives::signed::sign::Sign",
                        M.call_closure (|
                          Ty.path "alloy_primitives::signed::sign::Sign",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "sign",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, self |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "alloy_primitives::signed::sign::Sign::Positive"
                              |) in
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "wrapping_shr",
                                [],
                                []
                              |),
                              [ M.read (| self |); M.read (| rhs |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "alloy_primitives::signed::sign::Sign::Negative"
                              |) in
                            M.read (|
                              let~ two : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                                M.call_closure (|
                                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                    "from",
                                    [],
                                    [ Ty.path "i32" ]
                                  |),
                                  [ Value.Integer IntegerKind.I32 2 ]
                                |) in
                              let~ bitwise_or :
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [] :=
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    "from_raw",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                      M.get_trait_method (|
                                        "core::ops::bit::Not",
                                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                        [],
                                        [],
                                        "not",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                          M.get_trait_method (|
                                            "core::ops::arith::Sub",
                                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                            [],
                                            [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                                            "sub",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                                "pow",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (| two |);
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "ruint::Uint")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "ruint::Uint")
                                                      [ BITS; LIMBS ]
                                                      [],
                                                    "from",
                                                    [],
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.sub,
                                                      [ BITS; M.read (| rhs |) ]
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |);
                                            M.call_closure (|
                                              Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                                                "from",
                                                [],
                                                [ Ty.path "i32" ]
                                              |),
                                              [ Value.Integer IntegerKind.I32 1 ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |) in
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_trait_method (|
                                    "core::ops::bit::BitOr",
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        []
                                    ],
                                    "bitor",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloy_primitives::signed::int::Signed")
                                          [ BITS; LIMBS ]
                                          [],
                                        "wrapping_shr",
                                        [],
                                        []
                                      |),
                                      [ M.read (| self |); M.read (| rhs |) ]
                                    |);
                                    M.read (| bitwise_or |)
                                  ]
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_asr :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "asr" (asr BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque asr.
      
      (*
          pub fn asl(self, rhs: usize) -> Option<Self> {
              if rhs == 0 || BITS == 0 {
                  Some(self)
              } else {
                  let result = self.wrapping_shl(rhs);
                  if result.sign() != self.sign() {
                      // Overflow occurred
                      None
                  } else {
                      Some(result)
                  }
              }
          }
      *)
      Definition asl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          LogicalOp.or (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.eq,
                              [ M.read (| rhs |); Value.Integer IntegerKind.Usize 0 ]
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [ BITS; Value.Integer IntegerKind.Usize 0 ]
                              |)))
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ]
                      [ M.read (| self |) ]));
                fun γ =>
                  ltac:(M.monadic
                    (M.read (|
                      let~ result :
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [] :=
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "wrapping_shl",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| rhs |) ]
                        |) in
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              []
                          ],
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                []
                            ],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.path "alloy_primitives::signed::sign::Sign",
                                          [],
                                          [ Ty.path "alloy_primitives::signed::sign::Sign" ],
                                          "ne",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Ty.path "alloy_primitives::signed::sign::Sign",
                                              M.call_closure (|
                                                Ty.path "alloy_primitives::signed::sign::Sign",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloy_primitives::signed::int::Signed")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "sign",
                                                  [],
                                                  []
                                                |),
                                                [ M.borrow (| Pointer.Kind.Ref, result |) ]
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Ty.path "alloy_primitives::signed::sign::Sign",
                                              M.call_closure (|
                                                Ty.path "alloy_primitives::signed::sign::Sign",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "alloy_primitives::signed::int::Signed")
                                                    [ BITS; LIMBS ]
                                                    [],
                                                  "sign",
                                                  [],
                                                  []
                                                |),
                                                [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                Value.StructTuple
                                  "core::option::Option::None"
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ]
                                  []));
                            fun γ =>
                              ltac:(M.monadic
                                (Value.StructTuple
                                  "core::option::Option::Some"
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      []
                                  ]
                                  [ M.read (| result |) ]))
                          ]
                        |)
                      |)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_asl :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "asl" (asl BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque asl.
      
      (*
          pub fn twos_complement(self) -> Uint<BITS, LIMBS> {
              let abs = self.into_raw();
              match self.sign() {
                  Sign::Positive => abs,
                  Sign::Negative => twos_complement(abs),
              }
          }
      *)
      Definition twos_complement
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.read (|
              let~ abs : Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] :=
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "into_raw",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                M.match_operator (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.alloc (|
                    Ty.path "alloy_primitives::signed::sign::Sign",
                    M.call_closure (|
                      Ty.path "alloy_primitives::signed::sign::Sign",
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "sign",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, self |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "alloy_primitives::signed::sign::Sign::Positive"
                          |) in
                        M.read (| abs |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "alloy_primitives::signed::sign::Sign::Negative"
                          |) in
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_function (|
                            "alloy_primitives::signed::utils::twos_complement",
                            [ BITS; LIMBS ],
                            []
                          |),
                          [ M.read (| abs |) ]
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_twos_complement :
        forall (BITS LIMBS : Value.t),
        M.IsAssociatedFunction.C (Self BITS LIMBS) "twos_complement" (twos_complement BITS LIMBS).
      Admitted.
      Global Typeclasses Opaque twos_complement.
    End Impl_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i8", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i8", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i8" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i8", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i8", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i8" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u8", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u8", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u8" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u8", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u8", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u8" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u8_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i16", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i16", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i16" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i16", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i16", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i16" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u16", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u16", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u16" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u16", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u16", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u16" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u16_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i32", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i32", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i32" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i32", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i32", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i32" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u32", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u32", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u32" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u32", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u32", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u32" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u32_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i64", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i64", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i64" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i64", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "i64", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "i64" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_i64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u64", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u64", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u64" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u64", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "u64", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "u64" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_u64_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "isize", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "isize", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "isize" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "isize", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.cast (Ty.path "usize") (M.read (| rhs |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "isize", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "isize" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_isize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shl_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl(self, rhs: $t) -> Self::Output {
                          self.wrapping_shl(rhs as usize)
                      }
      *)
      Definition shl
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shl",
                [],
                []
              |),
              [ M.read (| self |); M.read (| M.use rhs |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shl", InstanceField.Method (shl BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shl_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShlAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shl_assign(&mut self, rhs: $t) {
                          *self = *self << rhs;
                      }
      *)
      Definition shl_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shl",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "usize" ],
                      "shl",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShlAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shl_assign", InstanceField.Method (shl_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShlAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Shr_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*                 type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr(self, rhs: $t) -> Self::Output {
                          self.wrapping_shr(rhs as usize)
                      }
      *)
      Definition shr
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                "wrapping_shr",
                [],
                []
              |),
              [ M.read (| self |); M.read (| M.use rhs |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Shr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("shr", InstanceField.Method (shr BITS LIMBS))
          ].
    End Impl_core_ops_bit_Shr_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_ShrAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
                      fn shr_assign(&mut self, rhs: $t) {
                          *self = *self >> rhs;
                      }
      *)
      Definition shr_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| Ty.path "usize", rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ Ty.path "usize" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::ShrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self BITS LIMBS)
          (* Instance *) [ ("shr_assign", InstanceField.Method (shr_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_ShrAssign_usize_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_cmp_PartialOrd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
              Some(self.cmp(other))
          }
      *)
      Definition partial_cmp
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                other
              |) in
            Value.StructTuple
              "core::option::Option::Some"
              []
              [ Ty.path "core::cmp::Ordering" ]
              [
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::cmp::PartialOrd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp BITS LIMBS)) ].
    End Impl_core_cmp_PartialOrd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_cmp_Ord_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn cmp(&self, other: &Self) -> cmp::Ordering {
              // TODO(nlordell): Once subtraction is implemented:
              // self.saturating_sub( *other).signum64().partial_cmp(&0)
      
              use cmp::Ordering::*;
              use Sign::*;
      
              match (self.into_sign_and_abs(), other.into_sign_and_abs()) {
                  ((Positive, _), (Negative, _)) => Greater,
                  ((Negative, _), (Positive, _)) => Less,
                  ((Positive, this), (Positive, other)) => this.cmp(&other),
                  ((Negative, this), (Negative, other)) => other.cmp(&this),
              }
          }
      *)
      Definition cmp
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                other
              |) in
            M.match_operator (|
              Ty.path "core::cmp::Ordering",
              M.alloc (|
                Ty.tuple
                  [
                    Ty.tuple
                      [
                        Ty.path "alloy_primitives::signed::sign::Sign";
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                      ];
                    Ty.tuple
                      [
                        Ty.path "alloy_primitives::signed::sign::Sign";
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                      ]
                  ],
                Value.Tuple
                  [
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.path "alloy_primitives::signed::sign::Sign";
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "into_sign_and_abs",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |);
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.path "alloy_primitives::signed::sign::Sign";
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "into_sign_and_abs",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                    |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Positive"
                      |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Negative"
                      |) in
                    Value.StructTuple "core::cmp::Ordering::Greater" [] [] []));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Negative"
                      |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Positive"
                      |) in
                    Value.StructTuple "core::cmp::Ordering::Less" [] [] []));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Positive"
                      |) in
                    let this :=
                      M.copy (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], γ1_1 |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Positive"
                      |) in
                    let other :=
                      M.copy (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], γ1_1 |) in
                    M.call_closure (|
                      Ty.path "core::cmp::Ordering",
                      M.get_trait_method (|
                        "core::cmp::Ord",
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        [],
                        [],
                        "cmp",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, this |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, other |) |)
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Negative"
                      |) in
                    let this :=
                      M.copy (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], γ1_1 |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_1, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_1, 1 |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ1_0,
                        "alloy_primitives::signed::sign::Sign::Negative"
                      |) in
                    let other :=
                      M.copy (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], γ1_1 |) in
                    M.call_closure (|
                      Ty.path "core::cmp::Ordering",
                      M.get_trait_method (|
                        "core::cmp::Ord",
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        [],
                        [],
                        "cmp",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, other |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, this |) |)
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::cmp::Ord"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self BITS LIMBS)
          (* Instance *) [ ("cmp", InstanceField.Method (cmp BITS LIMBS)) ].
    End Impl_core_cmp_Ord_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Add_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn add(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_add(rhs.into()))
          }
      *)
      Definition add
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_add",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("add", InstanceField.Method (add BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Add_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_AddAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn add_assign(&mut self, rhs: T) {
              *self = *self + rhs;
          }
      *)
      Definition add_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ T ],
                      "add",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::AddAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("add_assign", InstanceField.Method (add_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_AddAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Sub_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn sub(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_sub(rhs.into()))
          }
      *)
      Definition sub
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_sub",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("sub", InstanceField.Method (sub BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Sub_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_SubAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn sub_assign(&mut self, rhs: T) {
              *self = *self - rhs;
          }
      *)
      Definition sub_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ T ],
                      "sub",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::SubAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("sub_assign", InstanceField.Method (sub_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_SubAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Mul_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn mul(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_mul(rhs.into()))
          }
      *)
      Definition mul
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_mul",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Mul"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("mul", InstanceField.Method (mul BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Mul_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_MulAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn mul_assign(&mut self, rhs: T) {
              *self = *self * rhs;
          }
      *)
      Definition mul_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ T ],
                      "mul",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::MulAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("mul_assign", InstanceField.Method (mul_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_MulAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Div_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn div(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_div(rhs.into()))
          }
      *)
      Definition div
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_div",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Div"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("div", InstanceField.Method (div BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Div_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_DivAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn div_assign(&mut self, rhs: T) {
              *self = *self / rhs;
          }
      *)
      Definition div_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ T ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::DivAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("div_assign", InstanceField.Method (div_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_DivAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Rem_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn rem(self, rhs: T) -> Self::Output {
              handle_overflow(self.overflowing_rem(rhs.into()))
          }
      *)
      Definition rem
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_rem",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      M.get_trait_method (|
                        "core::convert::Into",
                        T,
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            []
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| rhs |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::Rem"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS T));
            ("rem", InstanceField.Method (rem BITS LIMBS T))
          ].
    End Impl_core_ops_arith_Rem_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_RemAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn rem_assign(&mut self, rhs: T) {
              *self = *self % rhs;
          }
      *)
      Definition rem_assign
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs := M.alloc (| T, rhs |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::arith::Rem",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [ T ],
                      "rem",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::ops::arith::RemAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("rem_assign", InstanceField.Method (rem_assign BITS LIMBS T)) ].
    End Impl_core_ops_arith_RemAssign_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_iter_traits_accum_Sum_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn sum<I: Iterator<Item = T>>(iter: I) -> Self {
              iter.fold(Self::ZERO, |acc, x| acc + x)
          }
      *)
      Definition sum
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "fold",
                [],
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.function
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      T
                    ]
                    (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [])
                ]
              |),
              [
                M.read (| iter |);
                M.read (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "ZERO",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            M.alloc (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              α0
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc :=
                                    M.copy (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      γ
                                    |) in
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    M.alloc (| T, α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| T, γ |) in
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [],
                                              [],
                                              [ T ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| acc |); M.read (| x |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Sum"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("sum", InstanceField.Method (sum BITS LIMBS T)) ].
    End Impl_core_iter_traits_accum_Sum_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_iter_traits_accum_Product_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn product<I: Iterator<Item = T>>(iter: I) -> Self {
              iter.fold(Self::ONE, |acc, x| acc * x)
          }
      *)
      Definition product
          (BITS LIMBS : Value.t)
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS T in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| I, iter |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "fold",
                [],
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.function
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      T
                    ]
                    (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [])
                ]
              |),
              [
                M.read (| iter |);
                M.read (|
                  get_associated_constant (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "ONE",
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []
                  |)
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            M.alloc (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              α0
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let acc :=
                                    M.copy (|
                                      Ty.apply
                                        (Ty.path "alloy_primitives::signed::int::Signed")
                                        [ BITS; LIMBS ]
                                        [],
                                      γ
                                    |) in
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    M.alloc (| T, α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let x := M.copy (| T, γ |) in
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloy_primitives::signed::int::Signed")
                                              [ BITS; LIMBS ]
                                              [],
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "alloy_primitives::signed::int::Signed")
                                                [ BITS; LIMBS ]
                                                [],
                                              [],
                                              [ T ],
                                              "mul",
                                              [],
                                              []
                                            |),
                                            [ M.read (| acc |); M.read (| x |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t) (T : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::accum::Product"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BITS LIMBS T)
          (* Instance *) [ ("product", InstanceField.Method (product BITS LIMBS T)) ].
    End Impl_core_iter_traits_accum_Product_where_core_convert_Into_T_alloy_primitives_signed_int_Signed_BITS_LIMBS_T_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitAnd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitand(self, rhs: Self) -> Self::Output {
              Self(self.0 & rhs.0)
          }
      *)
      Definition bitand
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [ BITS; LIMBS ]
              []
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAnd",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitand",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitAnd"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("bitand", InstanceField.Method (bitand BITS LIMBS))
          ].
    End Impl_core_ops_bit_BitAnd_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitAndAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitand_assign(&mut self, rhs: Self) {
              *self = *self & rhs;
          }
      *)
      Definition bitand_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ],
                      "bitand",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitAndAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("bitand_assign", InstanceField.Method (bitand_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_BitAndAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitOr_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitor(self, rhs: Self) -> Self::Output {
              Self(self.0 | rhs.0)
          }
      *)
      Definition bitor
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [ BITS; LIMBS ]
              []
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::BitOr",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitOr"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("bitor", InstanceField.Method (bitor BITS LIMBS))
          ].
    End Impl_core_ops_bit_BitOr_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitOrAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitor_assign(&mut self, rhs: Self) {
              *self = *self | rhs;
          }
      *)
      Definition bitor_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::BitOr",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ],
                      "bitor",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitOrAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("bitor_assign", InstanceField.Method (bitor_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_BitOrAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitXor_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitxor(self, rhs: Self) -> Self::Output {
              Self(self.0 ^ rhs.0)
          }
      *)
      Definition bitxor
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [ BITS; LIMBS ]
              []
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::BitXor",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [] ],
                    "bitxor",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        rhs,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitXor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("bitxor", InstanceField.Method (bitxor BITS LIMBS))
          ].
    End Impl_core_ops_bit_BitXor_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_BitXorAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn bitxor_assign(&mut self, rhs: Self) {
              *self = *self ^ rhs;
          }
      *)
      Definition bitxor_assign
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self; rhs ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
                self
              |) in
            let rhs :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                rhs
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    M.get_trait_method (|
                      "core::ops::bit::BitXor",
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          []
                      ],
                      "bitxor",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::BitXorAssign"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ]
          (Self BITS LIMBS)
          (* Instance *) [ ("bitxor_assign", InstanceField.Method (bitxor_assign BITS LIMBS)) ].
    End Impl_core_ops_bit_BitXorAssign_alloy_primitives_signed_int_Signed_BITS_LIMBS_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_arith_Neg_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn neg(self) -> Self::Output {
              handle_overflow(self.overflowing_neg())
          }
      *)
      Definition neg
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              M.get_function (|
                "alloy_primitives::signed::utils::handle_overflow",
                [ BITS; LIMBS ],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                      Ty.path "bool"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                    "overflowing_neg",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::arith::Neg"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("neg", InstanceField.Method (neg BITS LIMBS))
          ].
    End Impl_core_ops_arith_Neg_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
    
    Module Impl_core_ops_bit_Not_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
      Definition Self (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*     type Output = Self; *)
      Definition _Output (BITS LIMBS : Value.t) : Ty.t :=
        Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [].
      
      (*
          fn not(self) -> Self::Output {
              Self(!self.0)
          }
      *)
      Definition not
          (BITS LIMBS : Value.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self BITS LIMBS in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                self
              |) in
            Value.StructTuple
              "alloy_primitives::signed::int::Signed"
              [ BITS; LIMBS ]
              []
              [
                M.call_closure (|
                  Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                  M.get_trait_method (|
                    "core::ops::bit::Not",
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    [],
                    [],
                    "not",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "alloy_primitives::signed::int::Signed",
                        0
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (BITS LIMBS : Value.t),
        M.IsTraitInstance
          "core::ops::bit::Not"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self BITS LIMBS)
          (* Instance *)
          [
            ("Output", InstanceField.Ty (_Output BITS LIMBS));
            ("not", InstanceField.Method (not BITS LIMBS))
          ].
    End Impl_core_ops_bit_Not_for_alloy_primitives_signed_int_Signed_BITS_LIMBS.
  End ops.
End signed.
