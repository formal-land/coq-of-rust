(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signed.
  Module utils.
    (*
    pub(super) fn handle_overflow<const BITS: usize, const LIMBS: usize>(
        (result, overflow): (Signed<BITS, LIMBS>, bool),
    ) -> Signed<BITS, LIMBS> {
        debug_assert!(!overflow, "overflow");
        result
    }
    *)
    Definition handle_overflow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [ β0 ] =>
        ltac:(M.monadic
          (let β0 :=
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [];
                  Ty.path "bool"
                ],
              β0
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let result :=
                    M.copy (|
                      Ty.path
                        "Type for variables in patterns in function parameters is not handled",
                      γ0_0
                    |) in
                  let overflow :=
                    M.copy (|
                      Ty.path
                        "Type for variables in patterns in function parameters is not handled",
                      γ0_1
                    |) in
                  M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                Ty.path "bool",
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  UnOp.not,
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      UnOp.not,
                                                      [ M.read (| overflow |) ]
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.never_to_any (|
                                            M.call_closure (|
                                              Ty.path "never",
                                              M.get_function (|
                                                "core::panicking::panic_fmt",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::Arguments",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_const",
                                                    [ Value.Integer IntegerKind.Usize 1 ],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 1 ]
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [ Ty.path "str" ]
                                                              ],
                                                            Value.Array [ mk_str (| "overflow" |) ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    result
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_handle_overflow :
      M.IsFunction.C "alloy_primitives::signed::utils::handle_overflow" handle_overflow.
    Admitted.
    Global Typeclasses Opaque handle_overflow.
    
    (*
    pub(super) fn twos_complement<const BITS: usize, const LIMBS: usize>(
        u: Uint<BITS, LIMBS>,
    ) -> Uint<BITS, LIMBS> {
        if BITS == 0 {
            return u;
        }
        (!u).overflowing_add(Uint::<BITS, LIMBS>::from(1)).0
    }
    *)
    Definition twos_complement (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [], u |) in
          M.catch_return (Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (| M.read (| M.return_ (| M.read (| u |) |) |) |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.SubPointer.get_tuple_field (|
                  M.alloc (|
                    Ty.tuple
                      [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                    M.call_closure (|
                      Ty.tuple
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "overflowing_add",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_trait_method (|
                            "core::ops::bit::Not",
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            [],
                            [],
                            "not",
                            [],
                            []
                          |),
                          [ M.read (| u |) ]
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "from",
                            [],
                            [ Ty.path "i32" ]
                          |),
                          [ Value.Integer IntegerKind.I32 1 ]
                        |)
                      ]
                    |)
                  |),
                  0
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_twos_complement :
      M.IsFunction.C "alloy_primitives::signed::utils::twos_complement" twos_complement.
    Admitted.
    Global Typeclasses Opaque twos_complement.
    
    (*
    pub(super) const fn const_eq<const BITS: usize, const LIMBS: usize>(
        left: &Signed<BITS, LIMBS>,
        right: &Signed<BITS, LIMBS>,
    ) -> bool {
        if BITS == 0 {
            return true;
        }
    
        let mut i = 0;
        let llimbs = left.0.as_limbs();
        let rlimbs = right.0.as_limbs();
        while i < LIMBS {
            if llimbs[i] != rlimbs[i] {
                return false;
            }
            i += 1;
        }
        true
    }
    *)
    Definition const_eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [ _ as left; _ as right ] =>
        ltac:(M.monadic
          (let left :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              left
            |) in
          let right :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [] ],
              right
            |) in
          M.catch_return (Ty.path "bool") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ BITS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (| M.read (| M.return_ (| Value.Bool true |) |) |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ i : Ty.path "usize" := Value.Integer IntegerKind.Usize 0 in
                let~ llimbs :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "as_limbs",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| left |) |),
                          "alloy_primitives::signed::int::Signed",
                          0
                        |)
                      |)
                    ]
                  |) in
                let~ rlimbs :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "as_limbs",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| right |) |),
                          "alloy_primitives::signed::int::Signed",
                          0
                        |)
                      |)
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.alloc (|
                          Ty.tuple [],
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [ M.read (| i |); LIMBS ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.ne,
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_array_field (|
                                                            M.deref (| M.read (| llimbs |) |),
                                                            M.read (| i |)
                                                          |)
                                                        |);
                                                        M.read (|
                                                          M.SubPointer.get_array_field (|
                                                            M.deref (| M.read (| rlimbs |) |),
                                                            M.read (| i |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.never_to_any (|
                                                M.read (| M.return_ (| Value.Bool false |) |)
                                              |)));
                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      let β := i in
                                      M.write (|
                                        β,
                                        M.call_closure (|
                                          Ty.path "usize",
                                          BinOp.Wrap.add,
                                          [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                        |)
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)))
                    |)
                  |) in
                M.alloc (| Ty.path "bool", Value.Bool true |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_const_eq :
      M.IsFunction.C "alloy_primitives::signed::utils::const_eq" const_eq.
    Admitted.
    Global Typeclasses Opaque const_eq.
    
    (*
    pub(super) const fn max<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        if LIMBS == 0 {
            return zero();
        }
    
        let mut limbs = [u64::MAX; LIMBS];
        limbs[LIMBS - 1] &= Signed::<BITS, LIMBS>::MASK; // unset all high bits
        limbs[LIMBS - 1] &= !Signed::<BITS, LIMBS>::SIGN_BIT; // unset the sign bit
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.catch_return
            (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ LIMBS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_function (|
                                    "alloy_primitives::signed::utils::zero",
                                    [ BITS; LIMBS ],
                                    []
                                  |),
                                  []
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                  lib.repeat (|
                    M.read (| get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |) |),
                    LIMBS
                  |) in
                let~ _ : Ty.tuple [] :=
                  let β :=
                    M.SubPointer.get_array_field (|
                      limbs,
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ LIMBS; Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [
                        M.read (| β |);
                        M.read (|
                          get_associated_constant (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "MASK",
                            Ty.path "u64"
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  let β :=
                    M.SubPointer.get_array_field (|
                      limbs,
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ LIMBS; Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [
                        M.read (| β |);
                        M.call_closure (|
                          Ty.path "u64",
                          UnOp.not,
                          [
                            M.read (|
                              get_associated_constant (|
                                Ty.apply
                                  (Ty.path "alloy_primitives::signed::int::Signed")
                                  [ BITS; LIMBS ]
                                  [],
                                "SIGN_BIT",
                                Ty.path "u64"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                  Value.StructTuple
                    "alloy_primitives::signed::int::Signed"
                    [ BITS; LIMBS ]
                    []
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "from_limbs",
                          [],
                          []
                        |),
                        [ M.read (| limbs |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_max :
      M.IsFunction.C "alloy_primitives::signed::utils::max" max.
    Admitted.
    Global Typeclasses Opaque max.
    
    (*
    pub(super) const fn min<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        if LIMBS == 0 {
            return zero();
        }
    
        let mut limbs = [0; LIMBS];
        limbs[LIMBS - 1] = Signed::<BITS, LIMBS>::SIGN_BIT;
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.catch_return
            (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ LIMBS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_function (|
                                    "alloy_primitives::signed::utils::zero",
                                    [ BITS; LIMBS ],
                                    []
                                  |),
                                  []
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                  lib.repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) in
                let~ _ : Ty.tuple [] :=
                  M.write (|
                    M.SubPointer.get_array_field (|
                      limbs,
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ LIMBS; Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |),
                    M.read (|
                      get_associated_constant (|
                        Ty.apply
                          (Ty.path "alloy_primitives::signed::int::Signed")
                          [ BITS; LIMBS ]
                          [],
                        "SIGN_BIT",
                        Ty.path "u64"
                      |)
                    |)
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                  Value.StructTuple
                    "alloy_primitives::signed::int::Signed"
                    [ BITS; LIMBS ]
                    []
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "from_limbs",
                          [],
                          []
                        |),
                        [ M.read (| limbs |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_min :
      M.IsFunction.C "alloy_primitives::signed::utils::min" min.
    Admitted.
    Global Typeclasses Opaque min.
    
    (*
    pub(super) const fn zero<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        let limbs = [0; LIMBS];
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
              lib.repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) in
            M.alloc (|
              Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
              Value.StructTuple
                "alloy_primitives::signed::int::Signed"
                [ BITS; LIMBS ]
                []
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "from_limbs",
                      [],
                      []
                    |),
                    [ M.read (| limbs |) ]
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_zero :
      M.IsFunction.C "alloy_primitives::signed::utils::zero" zero.
    Admitted.
    Global Typeclasses Opaque zero.
    
    (*
    pub(super) const fn one<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        if LIMBS == 0 {
            return zero();
        }
    
        let mut limbs = [0; LIMBS];
        limbs[0] = 1;
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition one (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.catch_return
            (Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ LIMBS; Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloy_primitives::signed::int::Signed")
                                    [ BITS; LIMBS ]
                                    [],
                                  M.get_function (|
                                    "alloy_primitives::signed::utils::zero",
                                    [ BITS; LIMBS ],
                                    []
                                  |),
                                  []
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                  lib.repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) in
                let~ _ : Ty.tuple [] :=
                  M.write (|
                    M.SubPointer.get_array_field (| limbs, Value.Integer IntegerKind.Usize 0 |),
                    Value.Integer IntegerKind.U64 1
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "alloy_primitives::signed::int::Signed") [ BITS; LIMBS ] [],
                  Value.StructTuple
                    "alloy_primitives::signed::int::Signed"
                    [ BITS; LIMBS ]
                    []
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "from_limbs",
                          [],
                          []
                        |),
                        [ M.read (| limbs |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_one :
      M.IsFunction.C "alloy_primitives::signed::utils::one" one.
    Admitted.
    Global Typeclasses Opaque one.
    
    (*
    pub(super) const fn sign_bit(bits: usize) -> u64 {
        if bits == 0 {
            return 0;
        }
        let bits = bits % 64;
        if bits == 0 {
            1 << 63
        } else {
            1 << (bits - 1)
        }
    }
    *)
    Definition sign_bit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bits ] =>
        ltac:(M.monadic
          (let bits := M.alloc (| Ty.path "usize", bits |) in
          M.catch_return (Ty.path "u64") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| bits |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.read (| M.return_ (| Value.Integer IntegerKind.U64 0 |) |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ bits : Ty.path "usize" :=
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.rem,
                    [ M.read (| bits |); Value.Integer IntegerKind.Usize 64 ]
                  |) in
                M.alloc (|
                  Ty.path "u64",
                  M.match_operator (|
                    Ty.path "u64",
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| bits |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.shl,
                            [ Value.Integer IntegerKind.U64 1; Value.Integer IntegerKind.I32 63 ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.shl,
                            [
                              Value.Integer IntegerKind.U64 1;
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.sub,
                                [ M.read (| bits |); Value.Integer IntegerKind.Usize 1 ]
                              |)
                            ]
                          |)))
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_sign_bit :
      M.IsFunction.C "alloy_primitives::signed::utils::sign_bit" sign_bit.
    Admitted.
    Global Typeclasses Opaque sign_bit.
  End utils.
End signed.
