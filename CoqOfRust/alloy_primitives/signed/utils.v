(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module signed.
  Module utils.
    (*
    pub(super) fn handle_overflow<const BITS: usize, const LIMBS: usize>(
        (result, overflow): (Signed<BITS, LIMBS>, bool),
    ) -> Signed<BITS, LIMBS> {
        debug_assert!(!overflow, "overflow");
        result
    }
    *)
    Definition handle_overflow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (|
            None,
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let result := M.copy (| γ0_0 |) in
                  let overflow := M.copy (| γ0_1 |) in
                  M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Value.Bool true |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (| UnOp.not (| M.read (| overflow |) |) |)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.call_closure (|
                                              Ty.path "never",
                                              M.get_function (|
                                                "core::panicking::panic_fmt",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::Arguments",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_const",
                                                    [ Value.Integer IntegerKind.Usize 1 ],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Value.Array [ mk_str (| "overflow" |) ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    result
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_handle_overflow :
      M.IsFunction.C "alloy_primitives::signed::utils::handle_overflow" handle_overflow.
    Admitted.
    Global Typeclasses Opaque handle_overflow.
    
    (*
    pub(super) fn twos_complement<const BITS: usize, const LIMBS: usize>(
        u: Uint<BITS, LIMBS>,
    ) -> Uint<BITS, LIMBS> {
        if BITS == 0 {
            return u;
        }
        (!u).overflowing_add(Uint::<BITS, LIMBS>::from(1)).0
    }
    *)
    Definition twos_complement (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| BITS, Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| M.read (| u |) |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.SubPointer.get_tuple_field (|
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple
                        [ Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] []; Ty.path "bool" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "overflowing_add",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_trait_method (|
                            "core::ops::bit::Not",
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            [],
                            [],
                            "not",
                            [],
                            []
                          |),
                          [ M.read (| u |) ]
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                            "from",
                            [],
                            [ Ty.path "i32" ]
                          |),
                          [ Value.Integer IntegerKind.I32 1 ]
                        |)
                      ]
                    |)
                  |),
                  0
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_twos_complement :
      M.IsFunction.C "alloy_primitives::signed::utils::twos_complement" twos_complement.
    Admitted.
    Global Typeclasses Opaque twos_complement.
    
    (*
    pub(super) const fn const_eq<const BITS: usize, const LIMBS: usize>(
        left: &Signed<BITS, LIMBS>,
        right: &Signed<BITS, LIMBS>,
    ) -> bool {
        if BITS == 0 {
            return true;
        }
    
        let mut i = 0;
        let llimbs = left.0.as_limbs();
        let rlimbs = right.0.as_limbs();
        while i < LIMBS {
            if llimbs[i] != rlimbs[i] {
                return false;
            }
            i += 1;
        }
        true
    }
    *)
    Definition const_eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [ _ as left; _ as right ] =>
        ltac:(M.monadic
          (let left := M.alloc (| left |) in
          let right := M.alloc (| right |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| BITS, Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Bool true |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ i : Ty.path "usize" := M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                let~ llimbs :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "as_limbs",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| left |) |),
                            "alloy_primitives::signed::int::Signed",
                            0
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ rlimbs :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        "as_limbs",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| right |) |),
                            "alloy_primitives::signed::int::Signed",
                            0
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.match_operator (|
                        Some (Ty.tuple []),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use (M.alloc (| BinOp.lt (| M.read (| i |), LIMBS |) |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Some (Ty.tuple []),
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.ne (|
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| llimbs |) |),
                                                    M.read (| i |)
                                                  |)
                                                |),
                                                M.read (|
                                                  M.SubPointer.get_array_field (|
                                                    M.deref (| M.read (| rlimbs |) |),
                                                    M.read (| i |)
                                                  |)
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| Value.Bool false |) |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.alloc (|
                                  let β := i in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.add (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.alloc (| Value.Bool true |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_const_eq :
      M.IsFunction.C "alloy_primitives::signed::utils::const_eq" const_eq.
    Admitted.
    Global Typeclasses Opaque const_eq.
    
    (*
    pub(super) const fn max<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        if LIMBS == 0 {
            return zero();
        }
    
        let mut limbs = [u64::MAX; LIMBS];
        limbs[LIMBS - 1] &= Signed::<BITS, LIMBS>::MASK; // unset all high bits
        limbs[LIMBS - 1] &= !Signed::<BITS, LIMBS>::SIGN_BIT; // unset the sign bit
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| LIMBS, Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    M.get_function (|
                                      "alloy_primitives::signed::utils::zero",
                                      [ BITS; LIMBS ],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                  M.alloc (|
                    repeat (|
                      M.read (|
                        get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |)
                      |),
                      LIMBS
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    let β :=
                      M.SubPointer.get_array_field (|
                        limbs,
                        BinOp.Wrap.sub (| LIMBS, Value.Integer IntegerKind.Usize 1 |)
                      |) in
                    M.write (|
                      β,
                      BinOp.bit_and
                        (M.read (| β |))
                        (M.read (|
                          get_associated_constant (|
                            Ty.apply
                              (Ty.path "alloy_primitives::signed::int::Signed")
                              [ BITS; LIMBS ]
                              [],
                            "MASK",
                            Ty.path "u64"
                          |)
                        |))
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    let β :=
                      M.SubPointer.get_array_field (|
                        limbs,
                        BinOp.Wrap.sub (| LIMBS, Value.Integer IntegerKind.Usize 1 |)
                      |) in
                    M.write (|
                      β,
                      BinOp.bit_and
                        (M.read (| β |))
                        (UnOp.not (|
                          M.read (|
                            get_associated_constant (|
                              Ty.apply
                                (Ty.path "alloy_primitives::signed::int::Signed")
                                [ BITS; LIMBS ]
                                [],
                              "SIGN_BIT",
                              Ty.path "u64"
                            |)
                          |)
                        |))
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "alloy_primitives::signed::int::Signed"
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "from_limbs",
                          [],
                          []
                        |),
                        [ M.read (| limbs |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_max :
      M.IsFunction.C "alloy_primitives::signed::utils::max" max.
    Admitted.
    Global Typeclasses Opaque max.
    
    (*
    pub(super) const fn min<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        if LIMBS == 0 {
            return zero();
        }
    
        let mut limbs = [0; LIMBS];
        limbs[LIMBS - 1] = Signed::<BITS, LIMBS>::SIGN_BIT;
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| LIMBS, Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    M.get_function (|
                                      "alloy_primitives::signed::utils::zero",
                                      [ BITS; LIMBS ],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                  M.alloc (| repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_array_field (|
                        limbs,
                        BinOp.Wrap.sub (| LIMBS, Value.Integer IntegerKind.Usize 1 |)
                      |),
                      M.read (|
                        get_associated_constant (|
                          Ty.apply
                            (Ty.path "alloy_primitives::signed::int::Signed")
                            [ BITS; LIMBS ]
                            [],
                          "SIGN_BIT",
                          Ty.path "u64"
                        |)
                      |)
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "alloy_primitives::signed::int::Signed"
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "from_limbs",
                          [],
                          []
                        |),
                        [ M.read (| limbs |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_min :
      M.IsFunction.C "alloy_primitives::signed::utils::min" min.
    Admitted.
    Global Typeclasses Opaque min.
    
    (*
    pub(super) const fn zero<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        let limbs = [0; LIMBS];
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.read (|
            let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
              M.alloc (| repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) |) in
            M.alloc (|
              Value.StructTuple
                "alloy_primitives::signed::int::Signed"
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                      "from_limbs",
                      [],
                      []
                    |),
                    [ M.read (| limbs |) ]
                  |)
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_zero :
      M.IsFunction.C "alloy_primitives::signed::utils::zero" zero.
    Admitted.
    Global Typeclasses Opaque zero.
    
    (*
    pub(super) const fn one<const BITS: usize, const LIMBS: usize>() -> Signed<BITS, LIMBS> {
        if LIMBS == 0 {
            return zero();
        }
    
        let mut limbs = [0; LIMBS];
        limbs[0] = 1;
        Signed(Uint::from_limbs(limbs))
    }
    *)
    Definition one (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ BITS; LIMBS ], [], [] =>
        ltac:(M.monadic
          (M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| LIMBS, Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloy_primitives::signed::int::Signed")
                                      [ BITS; LIMBS ]
                                      [],
                                    M.get_function (|
                                      "alloy_primitives::signed::utils::zero",
                                      [ BITS; LIMBS ],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ limbs : Ty.apply (Ty.path "array") [ LIMBS ] [ Ty.path "u64" ] :=
                  M.alloc (| repeat (| Value.Integer IntegerKind.U64 0, LIMBS |) |) in
                let~ _ : Ty.tuple [] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_array_field (| limbs, Value.Integer IntegerKind.Usize 0 |),
                      Value.Integer IntegerKind.U64 1
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "alloy_primitives::signed::int::Signed"
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "ruint::Uint") [ BITS; LIMBS ] [],
                          "from_limbs",
                          [],
                          []
                        |),
                        [ M.read (| limbs |) ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_one :
      M.IsFunction.C "alloy_primitives::signed::utils::one" one.
    Admitted.
    Global Typeclasses Opaque one.
    
    (*
    pub(super) const fn sign_bit(bits: usize) -> u64 {
        if bits == 0 {
            return 0;
        }
        let bits = bits % 64;
        if bits == 0 {
            1 << 63
        } else {
            1 << (bits - 1)
        }
    }
    *)
    Definition sign_bit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bits ] =>
        ltac:(M.monadic
          (let bits := M.alloc (| bits |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Some (Ty.tuple []),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.eq (| M.read (| bits |), Value.Integer IntegerKind.Usize 0 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (| M.return_ (| Value.Integer IntegerKind.U64 0 |) |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ bits : Ty.path "usize" :=
                  M.alloc (|
                    BinOp.Wrap.rem (| M.read (| bits |), Value.Integer IntegerKind.Usize 64 |)
                  |) in
                M.match_operator (|
                  Some (Ty.path "u64"),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.eq (| M.read (| bits |), Value.Integer IntegerKind.Usize 0 |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            Value.Integer IntegerKind.U64 1,
                            Value.Integer IntegerKind.I32 63
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.shl (|
                            Value.Integer IntegerKind.U64 1,
                            BinOp.Wrap.sub (|
                              M.read (| bits |),
                              Value.Integer IntegerKind.Usize 1
                            |)
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_sign_bit :
      M.IsFunction.C "alloy_primitives::signed::utils::sign_bit" sign_bit.
    Admitted.
    Global Typeclasses Opaque sign_bit.
  End utils.
End signed.
