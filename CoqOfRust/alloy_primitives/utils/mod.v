(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module utils.
  Definition value_WEI_IN_ETHER (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.apply
            (Ty.path "ruint::Uint")
            [ Value.Integer IntegerKind.Usize 256; Value.Integer IntegerKind.Usize 4 ]
            [],
          M.get_associated_function (|
            Ty.path "alloy_primitives::utils::units::Unit",
            "wei_const",
            [],
            []
          |),
          [
            M.read (|
              get_associated_constant (|
                Ty.path "alloy_primitives::utils::units::Unit",
                "ETHER",
                Ty.path "alloy_primitives::utils::units::Unit"
              |)
            |)
          ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_WEI_IN_ETHER :
    M.IsFunction.C "alloy_primitives::utils::WEI_IN_ETHER" value_WEI_IN_ETHER.
  Admitted.
  Global Typeclasses Opaque value_WEI_IN_ETHER.
  
  Axiom Units :
    (Ty.path "alloy_primitives::utils::Units") = (Ty.path "alloy_primitives::utils::units::Unit").
  
  Definition value_EIP191_PREFIX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| mk_str (| "Ethereum Signed Message:
" |) |))).
  
  Global Instance Instance_IsConstant_value_EIP191_PREFIX :
    M.IsFunction.C "alloy_primitives::utils::EIP191_PREFIX" value_EIP191_PREFIX.
  Admitted.
  Global Typeclasses Opaque value_EIP191_PREFIX.
  
  (*
  pub fn box_try_new<T>(value: T) -> Result<Box<T>, TryReserveError> {
      let mut boxed = box_try_new_uninit::<T>()?;
      unsafe {
          boxed.as_mut_ptr().write(value);
          let ptr = Box::into_raw(boxed);
          Ok(Box::from_raw(ptr.cast()))
      }
  }
  *)
  Definition box_try_new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ value ] =>
      ltac:(M.monadic
        (let value := M.alloc (| value |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ boxed :
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Some
                      (Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ]),
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ops::control_flow::ControlFlow")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.path "core::convert::Infallible";
                                Ty.path "alloc::collections::TryReserveError"
                              ];
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ];
                              Ty.path "alloc::collections::TryReserveError"
                            ],
                          [],
                          [],
                          "branch",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ];
                                Ty.path "alloc::collections::TryReserveError"
                              ],
                            M.get_function (|
                              "alloy_primitives::utils::box_try_new_uninit",
                              [],
                              [ T ]
                            |),
                            []
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [ T; Ty.path "alloc::alloc::Global" ];
                                        Ty.path "alloc::collections::TryReserveError"
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [ T; Ty.path "alloc::alloc::Global" ];
                                          Ty.path "alloc::collections::TryReserveError"
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "alloc::collections::TryReserveError"
                                          ]
                                      ],
                                      "from_residual",
                                      [],
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      "write",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ T ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                          "as_mut_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| boxed |) |) |) ]
                      |);
                      M.read (| value |)
                    ]
                  |)
                |) in
              let~ ptr :
                  Ty.apply
                    (Ty.path "*mut")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "*mut")
                      []
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "into_raw",
                      [],
                      []
                    |),
                    [ M.read (| boxed |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        "from_raw",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ T ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ]
                              ],
                            "cast",
                            [],
                            [ T ]
                          |),
                          [ M.read (| ptr |) ]
                        |)
                      ]
                    |)
                  ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_box_try_new :
    M.IsFunction.C "alloy_primitives::utils::box_try_new" box_try_new.
  Admitted.
  Global Typeclasses Opaque box_try_new.
  
  (*
  pub fn box_try_new_uninit<T>() -> Result<Box<MaybeUninit<T>>, TryReserveError> {
      let mut vec = Vec::<MaybeUninit<T>>::new();
  
      // Reserve enough space for one `MaybeUninit<T>`.
      vec.try_reserve_exact(1)?;
  
      // `try_reserve_exact`'s docs note that the allocator might allocate more than requested anyway.
      // Make sure we got exactly 1 element.
      vec.shrink_to(1);
  
      let mut vec = ManuallyDrop::new(vec);
  
      // SAFETY: `vec` is exactly one element long and has not been deallocated.
      Ok(unsafe { Box::from_raw(vec.as_mut_ptr()) })
  }
  *)
  Definition box_try_new_uninit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ vec :
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                      Ty.path "alloc::alloc::Global"
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ops::control_flow::ControlFlow")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "alloc::collections::TryReserveError"
                            ];
                          Ty.tuple []
                        ],
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                        [],
                        [],
                        "branch",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "try_reserve_exact",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, vec |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ];
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.path "alloc::collections::TryReserveError"
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.path "alloc::collections::TryReserveError"
                                      ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "alloc::collections::TryReserveError"
                                        ]
                                    ],
                                    "from_residual",
                                    [],
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "shrink_to",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, vec |); Value.Integer IntegerKind.Usize 1 ]
                  |)
                |) in
              let~ vec :
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ],
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| vec |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [
                          Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "from_raw",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "as_mut_ptr",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ T ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ T ];
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ],
                                    [],
                                    [],
                                    "deref_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.MutRef, vec |) ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_box_try_new_uninit :
    M.IsFunction.C "alloy_primitives::utils::box_try_new_uninit" box_try_new_uninit.
  Admitted.
  Global Typeclasses Opaque box_try_new_uninit.
  
  (*
  pub fn try_collect_vec<I: Iterator<Item = T>, T>(iter: I) -> Result<Vec<T>, TryReserveError> {
      let mut vec = Vec::new();
      if let Some(size_hint) = iter.size_hint().1 {
          vec.try_reserve(size_hint.max(4))?;
      }
      vec.extend(iter);
      Ok(vec)
  }
  *)
  Definition try_collect_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ _ as I; T ], [ iter ] =>
      ltac:(M.monadic
        (let iter := M.alloc (| iter |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ vec :
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.SubPointer.get_tuple_field (|
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.path "usize";
                                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  I,
                                  [],
                                  [],
                                  "size_hint",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, iter |) ]
                              |)
                            |),
                            1
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let size_hint := M.copy (| γ0_0 |) in
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            Some (Ty.tuple []),
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "alloc::collections::TryReserveError"
                                      ];
                                    Ty.tuple []
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ T; Ty.path "alloc::alloc::Global" ],
                                      "try_reserve",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.MutRef, vec |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "core::cmp::Ord",
                                          Ty.path "usize",
                                          [],
                                          [],
                                          "max",
                                          [],
                                          []
                                        |),
                                        [ M.read (| size_hint |); Value.Integer IntegerKind.Usize 4
                                        ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [ T; Ty.path "alloc::alloc::Global" ];
                                                Ty.path "alloc::collections::TryReserveError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ T; Ty.path "alloc::alloc::Global" ];
                                                  Ty.path "alloc::collections::TryReserveError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "alloc::collections::TryReserveError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::iter::traits::collect::Extend",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ T ],
                      "extend",
                      [],
                      [ I ]
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, vec |); M.read (| iter |) ]
                  |)
                |) in
              M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| vec |) ] |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_try_collect_vec :
    M.IsFunction.C "alloy_primitives::utils::try_collect_vec" try_collect_vec.
  Admitted.
  Global Typeclasses Opaque try_collect_vec.
  
  (*
  pub fn vec_try_with_capacity<T>(capacity: usize) -> Result<Vec<T>, TryReserveError> {
      let mut vec = Vec::new();
      vec.try_reserve(capacity).map(|()| vec)
  }
  *)
  Definition vec_try_with_capacity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ capacity ] =>
      ltac:(M.monadic
        (let capacity := M.alloc (| capacity |) in
        M.read (|
          let~ vec :
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  "new",
                  [],
                  []
                |),
                []
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ];
                  Ty.path "alloc::collections::TryReserveError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                "map",
                [],
                [
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ];
                  Ty.function
                    [ Ty.tuple [ Ty.tuple [] ] ]
                    (Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    "try_reserve",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, vec |); M.read (| capacity |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Some
                              (Ty.function
                                [ Ty.tuple [ Ty.tuple [] ] ]
                                (Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ])),
                            M.alloc (| α0 |),
                            [ fun γ => ltac:(M.monadic (M.read (| vec |))) ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_vec_try_with_capacity :
    M.IsFunction.C "alloy_primitives::utils::vec_try_with_capacity" vec_try_with_capacity.
  Admitted.
  Global Typeclasses Opaque vec_try_with_capacity.
  
  (*
  pub fn vec_try_from_elem<T: Clone>(elem: T, n: usize) -> Result<Vec<T>, TryReserveError> {
      let mut vec = Vec::new();
      vec.try_reserve(n)?;
      vec.resize(n, elem);
      Ok(vec)
  }
  *)
  Definition vec_try_from_elem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ elem; n ] =>
      ltac:(M.monadic
        (let elem := M.alloc (| elem |) in
        let n := M.alloc (| n |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let~ vec :
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ops::control_flow::ControlFlow")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "alloc::collections::TryReserveError"
                            ];
                          Ty.tuple []
                        ],
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                        [],
                        [],
                        "branch",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "alloc::collections::TryReserveError" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ],
                            "try_reserve",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, vec |); M.read (| n |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ T; Ty.path "alloc::alloc::Global" ];
                                      Ty.path "alloc::collections::TryReserveError"
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ T; Ty.path "alloc::alloc::Global" ];
                                        Ty.path "alloc::collections::TryReserveError"
                                      ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "alloc::collections::TryReserveError"
                                        ]
                                    ],
                                    "from_residual",
                                    [],
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      "resize",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, vec |); M.read (| n |); M.read (| elem |) ]
                  |)
                |) in
              M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| vec |) ] |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_vec_try_from_elem :
    M.IsFunction.C "alloy_primitives::utils::vec_try_from_elem" vec_try_from_elem.
  Admitted.
  Global Typeclasses Opaque vec_try_from_elem.
  
  (*
  pub fn eip191_hash_message<T: AsRef<[u8]>>(message: T) -> B256 {
      keccak256(eip191_message(message))
  }
  *)
  Definition eip191_hash_message (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ message ] =>
      ltac:(M.monadic
        (let message := M.alloc (| message |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 32 ]
            [],
          M.get_function (|
            "alloy_primitives::utils::keccak256",
            [],
            [
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
              M.get_function (| "alloy_primitives::utils::eip191_message", [], [ T ] |),
              [ M.read (| message |) ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_eip191_hash_message :
    M.IsFunction.C "alloy_primitives::utils::eip191_hash_message" eip191_hash_message.
  Admitted.
  Global Typeclasses Opaque eip191_hash_message.
  
  (*
  pub fn eip191_message<T: AsRef<[u8]>>(message: T) -> Vec<u8> {
      fn eip191_message(message: &[u8]) -> Vec<u8> {
          let len = message.len();
          let mut len_string_buffer = itoa::Buffer::new();
          let len_string = len_string_buffer.format(len);
  
          let mut eth_message = Vec::with_capacity(EIP191_PREFIX.len() + len_string.len() + len);
          eth_message.extend_from_slice(EIP191_PREFIX.as_bytes());
          eth_message.extend_from_slice(len_string.as_bytes());
          eth_message.extend_from_slice(message);
          eth_message
      }
  
      eip191_message(message.as_ref())
  }
  *)
  Definition eip191_message (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ message ] =>
      ltac:(M.monadic
        (let message := M.alloc (| message |) in
        M.call_closure (|
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
          M.get_function (| "alloy_primitives::utils::eip191_message.eip191_message", [], [] |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::convert::AsRef",
                    T,
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "as_ref",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, message |) ]
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_eip191_message :
    M.IsFunction.C "alloy_primitives::utils::eip191_message" eip191_message.
  Admitted.
  Global Typeclasses Opaque eip191_message.
  
  Module eip191_message.
    (*
        fn eip191_message(message: &[u8]) -> Vec<u8> {
            let len = message.len();
            let mut len_string_buffer = itoa::Buffer::new();
            let len_string = len_string_buffer.format(len);
    
            let mut eth_message = Vec::with_capacity(EIP191_PREFIX.len() + len_string.len() + len);
            eth_message.extend_from_slice(EIP191_PREFIX.as_bytes());
            eth_message.extend_from_slice(len_string.as_bytes());
            eth_message.extend_from_slice(message);
            eth_message
        }
    *)
    Definition eip191_message (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ message ] =>
        ltac:(M.monadic
          (let message := M.alloc (| message |) in
          M.read (|
            let~ len : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| message |) |) |) ]
                |)
              |) in
            let~ len_string_buffer : Ty.path "itoa::Buffer" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "itoa::Buffer",
                  M.get_associated_function (| Ty.path "itoa::Buffer", "new", [], [] |),
                  []
                |)
              |) in
            let~ len_string : Ty.apply (Ty.path "&") [] [ Ty.path "str" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                  M.get_associated_function (|
                    Ty.path "itoa::Buffer",
                    "format",
                    [],
                    [ Ty.path "usize" ]
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, len_string_buffer |); M.read (| len |) ]
                |)
              |) in
            let~ eth_message :
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "with_capacity",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (| Ty.path "str", "len", [], [] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.read (|
                                      get_constant (|
                                        "alloy_primitives::utils::EIP191_PREFIX",
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (| Ty.path "str", "len", [], [] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| len_string |) |)
                                |)
                              ]
                            |)
                          ]
                        |);
                        M.read (| len |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "extend_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, eth_message |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  get_constant (|
                                    "alloy_primitives::utils::EIP191_PREFIX",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "extend_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, eth_message |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| len_string |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "extend_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, eth_message |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| message |) |) |)
                  ]
                |)
              |) in
            eth_message
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_eip191_message :
      M.IsFunction.C "alloy_primitives::utils::eip191_message::eip191_message" eip191_message.
    Admitted.
    Global Typeclasses Opaque eip191_message.
  End eip191_message.
  
  (*
  pub fn keccak256<T: AsRef<[u8]>>(bytes: T) -> B256 {
      fn keccak256(bytes: &[u8]) -> B256 {
          let mut output = MaybeUninit::<B256>::uninit();
  
          cfg_if! {
              if #[cfg(all(feature = "native-keccak", not(any(feature = "sha3-keccak", feature = "tiny-keccak", miri))))] {
                  #[link(wasm_import_module = "vm_hooks")]
                  extern "C" {
                      /// When targeting VMs with native keccak hooks, the `native-keccak` feature
                      /// can be enabled to import and use the host environment's implementation
                      /// of [`keccak256`] in place of [`sha3`] or [`tiny_keccak`]. This is overridden
                      /// when the `sha3-keccak` or `tiny-keccak` feature is enabled.
                      ///
                      /// # Safety
                      ///
                      /// The VM accepts the preimage by pointer and length, and writes the
                      /// 32-byte hash.
                      /// - `bytes` must point to an input buffer at least `len` long.
                      /// - `output` must point to a buffer that is at least 32-bytes long.
                      ///
                      /// [`keccak256`]: https://en.wikipedia.org/wiki/SHA-3
                      /// [`sha3`]: https://docs.rs/sha3/latest/sha3/
                      /// [`tiny_keccak`]: https://docs.rs/tiny-keccak/latest/tiny_keccak/
                      fn native_keccak256(bytes: *const u8, len: usize, output: *mut u8);
                  }
  
                  // SAFETY: The output is 32-bytes, and the input comes from a slice.
                  unsafe { native_keccak256(bytes.as_ptr(), bytes.len(), output.as_mut_ptr().cast::<u8>()) };
              } else {
                  let mut hasher = Keccak256::new();
                  hasher.update(bytes);
                  // SAFETY: Never reads from `output`.
                  unsafe { hasher.finalize_into_raw(output.as_mut_ptr().cast()) };
              }
          }
  
          // SAFETY: Initialized above.
          unsafe { output.assume_init() }
      }
  
      keccak256(bytes.as_ref())
  }
  *)
  Definition keccak256 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ bytes ] =>
      ltac:(M.monadic
        (let bytes := M.alloc (| bytes |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
            [ Value.Integer IntegerKind.Usize 32 ]
            [],
          M.get_function (| "alloy_primitives::utils::keccak256.keccak256", [], [] |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  M.get_trait_method (|
                    "core::convert::AsRef",
                    T,
                    [],
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    "as_ref",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_keccak256 :
    M.IsFunction.C "alloy_primitives::utils::keccak256" keccak256.
  Admitted.
  Global Typeclasses Opaque keccak256.
  
  Module keccak256.
    (*
        fn keccak256(bytes: &[u8]) -> B256 {
            let mut output = MaybeUninit::<B256>::uninit();
    
            cfg_if! {
                if #[cfg(all(feature = "native-keccak", not(any(feature = "sha3-keccak", feature = "tiny-keccak", miri))))] {
                    #[link(wasm_import_module = "vm_hooks")]
                    extern "C" {
                        /// When targeting VMs with native keccak hooks, the `native-keccak` feature
                        /// can be enabled to import and use the host environment's implementation
                        /// of [`keccak256`] in place of [`sha3`] or [`tiny_keccak`]. This is overridden
                        /// when the `sha3-keccak` or `tiny-keccak` feature is enabled.
                        ///
                        /// # Safety
                        ///
                        /// The VM accepts the preimage by pointer and length, and writes the
                        /// 32-byte hash.
                        /// - `bytes` must point to an input buffer at least `len` long.
                        /// - `output` must point to a buffer that is at least 32-bytes long.
                        ///
                        /// [`keccak256`]: https://en.wikipedia.org/wiki/SHA-3
                        /// [`sha3`]: https://docs.rs/sha3/latest/sha3/
                        /// [`tiny_keccak`]: https://docs.rs/tiny-keccak/latest/tiny_keccak/
                        fn native_keccak256(bytes: *const u8, len: usize, output: *mut u8);
                    }
    
                    // SAFETY: The output is 32-bytes, and the input comes from a slice.
                    unsafe { native_keccak256(bytes.as_ptr(), bytes.len(), output.as_mut_ptr().cast::<u8>()) };
                } else {
                    let mut hasher = Keccak256::new();
                    hasher.update(bytes);
                    // SAFETY: Never reads from `output`.
                    unsafe { hasher.finalize_into_raw(output.as_mut_ptr().cast()) };
                }
            }
    
            // SAFETY: Initialized above.
            unsafe { output.assume_init() }
        }
    *)
    Definition keccak256 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.read (|
            let~ output :
                Ty.apply
                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      []
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          []
                      ],
                    "uninit",
                    [],
                    []
                  |),
                  []
                |)
              |) in
            let~ hasher : Ty.path "alloy_primitives::utils::Keccak256" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "alloy_primitives::utils::Keccak256",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::Keccak256",
                    "new",
                    [],
                    []
                  |),
                  []
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::Keccak256",
                    "update",
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, hasher |); M.read (| bytes |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::Keccak256",
                    "finalize_into_raw",
                    [],
                    []
                  |),
                  [
                    M.read (| hasher |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              []
                          ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ Value.Integer IntegerKind.Usize 32 ]
                                  []
                              ],
                            "as_mut_ptr",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, output |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ],
                  "assume_init",
                  [],
                  []
                |),
                [ M.read (| output |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_keccak256 :
      M.IsFunction.C "alloy_primitives::utils::keccak256::keccak256" keccak256.
    Admitted.
    Global Typeclasses Opaque keccak256.
  End keccak256.
  
  Module keccak256_state.
    (* StructTuple
      {
        name := "State";
        const_params := [];
        ty_params := [];
        fields := [ Ty.path "tiny_keccak::keccak::Keccak" ];
      } *)
    
    Module Impl_core_clone_Clone_for_alloy_primitives_utils_keccak256_state_State.
      Definition Self : Ty.t := Ty.path "alloy_primitives::utils::keccak256_state::State".
      
      (*             Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "alloy_primitives::utils::keccak256_state::State"
              [
                M.call_closure (|
                  Ty.path "tiny_keccak::keccak::Keccak",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "tiny_keccak::keccak::Keccak",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::utils::keccak256_state::State",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_alloy_primitives_utils_keccak256_state_State.
    
    Module Impl_alloy_primitives_utils_keccak256_state_State.
      Definition Self : Ty.t := Ty.path "alloy_primitives::utils::keccak256_state::State".
      
      (*
                      pub(super) fn new() -> Self {
                          Self(tiny_keccak::Keccak::v256())
                      }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "alloy_primitives::utils::keccak256_state::State"
              [
                M.call_closure (|
                  Ty.path "tiny_keccak::keccak::Keccak",
                  M.get_associated_function (|
                    Ty.path "tiny_keccak::keccak::Keccak",
                    "v256",
                    [],
                    []
                  |),
                  []
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
                      pub(super) fn finalize_into(self, output: &mut [u8; 32]) {
                          self.0.finalize(output);
                      }
      *)
      Definition finalize_into (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; output ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let output := M.alloc (| output |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "tiny_keccak::Hasher",
                      Ty.path "tiny_keccak::keccak::Keccak",
                      [],
                      [],
                      "finalize",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          self,
                          "alloy_primitives::utils::keccak256_state::State",
                          0
                        |)
                      |);
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_finalize_into :
        M.IsAssociatedFunction.C Self "finalize_into" finalize_into.
      Admitted.
      Global Typeclasses Opaque finalize_into.
      
      (*
                      pub(super) fn update(&mut self, bytes: &[u8]) {
                          self.0.update(bytes);
                      }
      *)
      Definition update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; bytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let bytes := M.alloc (| bytes |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "tiny_keccak::Hasher",
                      Ty.path "tiny_keccak::keccak::Keccak",
                      [],
                      [],
                      "update",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "alloy_primitives::utils::keccak256_state::State",
                          0
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_update : M.IsAssociatedFunction.C Self "update" update.
      Admitted.
      Global Typeclasses Opaque update.
    End Impl_alloy_primitives_utils_keccak256_state_State.
  End keccak256_state.
  
  (* StructRecord
    {
      name := "Keccak256";
      const_params := [];
      ty_params := [];
      fields := [ ("state", Ty.path "alloy_primitives::utils::keccak256_state::State") ];
    } *)
  
  Module Impl_core_clone_Clone_for_alloy_primitives_utils_Keccak256.
    Definition Self : Ty.t := Ty.path "alloy_primitives::utils::Keccak256".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "alloy_primitives::utils::Keccak256"
            [
              ("state",
                M.call_closure (|
                  Ty.path "alloy_primitives::utils::keccak256_state::State",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloy_primitives::utils::keccak256_state::State",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "alloy_primitives::utils::Keccak256",
                            "state"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_alloy_primitives_utils_Keccak256.
  
  Module Impl_core_default_Default_for_alloy_primitives_utils_Keccak256.
    Definition Self : Ty.t := Ty.path "alloy_primitives::utils::Keccak256".
    
    (*
        fn default() -> Self {
            Self::new()
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.path "alloy_primitives::utils::Keccak256",
            M.get_associated_function (|
              Ty.path "alloy_primitives::utils::Keccak256",
              "new",
              [],
              []
            |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_alloy_primitives_utils_Keccak256.
  
  Module Impl_core_fmt_Debug_for_alloy_primitives_utils_Keccak256.
    Definition Self : Ty.t := Ty.path "alloy_primitives::utils::Keccak256".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Keccak256").finish_non_exhaustive()
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugStruct",
              "finish_non_exhaustive",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_struct",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Keccak256" |) |) |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_alloy_primitives_utils_Keccak256.
  
  Module Impl_alloy_primitives_utils_Keccak256.
    Definition Self : Ty.t := Ty.path "alloy_primitives::utils::Keccak256".
    
    (*
        pub fn new() -> Self {
            Self { state: keccak256_state::State::new() }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "alloy_primitives::utils::Keccak256"
            [
              ("state",
                M.call_closure (|
                  Ty.path "alloy_primitives::utils::keccak256_state::State",
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::keccak256_state::State",
                    "new",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn update(&mut self, bytes: impl AsRef<[u8]>) {
            self.state.update(bytes.as_ref());
        }
    *)
    Definition update (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ impl_AsRef__u8__ ], [ self; bytes ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let bytes := M.alloc (| bytes |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::keccak256_state::State",
                    "update",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "alloy_primitives::utils::Keccak256",
                        "state"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_trait_method (|
                            "core::convert::AsRef",
                            impl_AsRef__u8__,
                            [],
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            "as_ref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_update : M.IsAssociatedFunction.C Self "update" update.
    Admitted.
    Global Typeclasses Opaque update.
    
    (*
        pub fn finalize(self) -> B256 {
            let mut output = MaybeUninit::<B256>::uninit();
            // SAFETY: The output is 32-bytes.
            unsafe { self.finalize_into_raw(output.as_mut_ptr().cast()) };
            // SAFETY: Initialized above.
            unsafe { output.assume_init() }
        }
    *)
    Definition finalize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ output :
                Ty.apply
                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      []
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          []
                      ],
                    "uninit",
                    [],
                    []
                  |),
                  []
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::Keccak256",
                    "finalize_into_raw",
                    [],
                    []
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              []
                          ],
                        "cast",
                        [],
                        [ Ty.path "u8" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                []
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                                  [ Value.Integer IntegerKind.Usize 32 ]
                                  []
                              ],
                            "as_mut_ptr",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, output |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloy_primitives::bits::fixed::FixedBytes")
                        [ Value.Integer IntegerKind.Usize 32 ]
                        []
                    ],
                  "assume_init",
                  [],
                  []
                |),
                [ M.read (| output |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_finalize : M.IsAssociatedFunction.C Self "finalize" finalize.
    Admitted.
    Global Typeclasses Opaque finalize.
    
    (*
        pub fn finalize_into(self, output: &mut [u8]) {
            self.finalize_into_array(output.try_into().unwrap())
        }
    *)
    Definition finalize_into (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; output ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_associated_function (|
              Ty.path "alloy_primitives::utils::Keccak256",
              "finalize_into_array",
              [],
              []
            |),
            [
              M.read (| self |);
              M.call_closure (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [ Ty.path "u8" ]
                          ];
                        Ty.path "core::array::TryFromSliceError"
                      ],
                    M.get_trait_method (|
                      "core::convert::TryInto",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [ Ty.path "u8" ]
                          ]
                      ],
                      "try_into",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_finalize_into :
      M.IsAssociatedFunction.C Self "finalize_into" finalize_into.
    Admitted.
    Global Typeclasses Opaque finalize_into.
    
    (*
        pub fn finalize_into_array(self, output: &mut [u8; 32]) {
            self.state.finalize_into(output.into());
        }
    *)
    Definition finalize_into_array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; output ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let output := M.alloc (| output |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "alloy_primitives::utils::keccak256_state::State",
                    "finalize_into",
                    [],
                    []
                  |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "alloy_primitives::utils::Keccak256",
                        "state"
                      |)
                    |);
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ]
                        ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [ Ty.path "u8" ]
                          ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                [ Ty.path "u8" ]
                            ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| output |) |) |) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_finalize_into_array :
      M.IsAssociatedFunction.C Self "finalize_into_array" finalize_into_array.
    Admitted.
    Global Typeclasses Opaque finalize_into_array.
    
    (*
        pub unsafe fn finalize_into_raw(self, output: *mut u8) {
            self.finalize_into_array(&mut *output.cast::<[u8; 32]>())
        }
    *)
    Definition finalize_into_raw (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; output ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let output := M.alloc (| output |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_associated_function (|
              Ty.path "alloy_primitives::utils::Keccak256",
              "finalize_into_array",
              [],
              []
            |),
            [
              M.read (| self |);
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [ Ty.path "u8" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          "cast",
                          [],
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [ Ty.path "u8" ]
                          ]
                        |),
                        [ M.read (| output |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_finalize_into_raw :
      M.IsAssociatedFunction.C Self "finalize_into_raw" finalize_into_raw.
    Admitted.
    Global Typeclasses Opaque finalize_into_raw.
  End Impl_alloy_primitives_utils_Keccak256.
End utils.
