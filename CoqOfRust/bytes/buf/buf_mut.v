(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module buf.
  Module buf_mut.
    (* Trait *)
    Module BufMut.
      Definition has_remaining_mut
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.gt,
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "bytes::buf::buf_mut::BufMut",
                    Self,
                    [],
                    [],
                    "remaining_mut",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |);
                Value.Integer IntegerKind.Usize 0
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_has_remaining_mut :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "has_remaining_mut" has_remaining_mut.
      Definition put (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "bytes::buf::buf_mut::BufMut",
                                      Ty.apply (Ty.path "&mut") [] [ Self ],
                                      [],
                                      [],
                                      "remaining_mut",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "bytes::buf::buf_impl::Buf",
                                      T,
                                      [],
                                      [],
                                      "remaining",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, src |) ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "bytes::buf::buf_impl::Buf",
                                    T,
                                    [],
                                    [],
                                    "remaining",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, src |) ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "bytes::buf::buf_mut::BufMut",
                                    Ty.apply (Ty.path "&mut") [] [ Self ],
                                    [],
                                    [],
                                    "remaining_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.loop (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "bytes::buf::buf_impl::Buf",
                                    T,
                                    [],
                                    [],
                                    "has_remaining",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, src |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ s :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "bytes::buf::buf_impl::Buf",
                                  T,
                                  [],
                                  [],
                                  "chunk",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, src |) ]
                              |)
                            |) in
                          let~ d :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ]
                                ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                                M.get_trait_method (|
                                  "bytes::buf::buf_mut::BufMut",
                                  Self,
                                  [],
                                  [],
                                  "chunk_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ cnt : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.path "usize",
                                  [],
                                  [],
                                  "min",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                      "len",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| d |) |) |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                  "copy_from_slice",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                                        M.get_trait_method (|
                                          "core::ops::index::IndexMut",
                                          Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeTo")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| d |) |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::RangeTo"
                                            []
                                            [ Ty.path "usize" ]
                                            [ ("end_", M.read (| cnt |)) ]
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeTo")
                                                  []
                                                  [ Ty.path "usize" ]
                                              ],
                                              "index",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| s |) |)
                                              |);
                                              Value.StructRecord
                                                "core::ops::range::RangeTo"
                                                []
                                                [ Ty.path "usize" ]
                                                [ ("end_", M.read (| cnt |)) ]
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "bytes::buf::buf_mut::BufMut",
                                  Self,
                                  [],
                                  [],
                                  "advance_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "bytes::buf::buf_impl::Buf",
                                  T,
                                  [],
                                  [],
                                  "advance",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, src |); M.read (| cnt |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put : M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put" put.
      Definition put_slice
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "bytes::buf::buf_mut::BufMut",
                                      Ty.apply (Ty.path "&mut") [] [ Self ],
                                      [],
                                      [],
                                      "remaining_mut",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "bytes::buf::buf_mut::BufMut",
                                    Ty.apply (Ty.path "&mut") [] [ Self ],
                                    [],
                                    [],
                                    "remaining_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.loop (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ dst :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ]
                                ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                                M.get_trait_method (|
                                  "bytes::buf::buf_mut::BufMut",
                                  Self,
                                  [],
                                  [],
                                  "chunk_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ cnt : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.path "usize",
                                  [],
                                  [],
                                  "min",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| dst |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                  "copy_from_slice",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                                        M.get_trait_method (|
                                          "core::ops::index::IndexMut",
                                          Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::ops::range::RangeTo")
                                              []
                                              [ Ty.path "usize" ]
                                          ],
                                          "index_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| dst |) |)
                                          |);
                                          Value.StructRecord
                                            "core::ops::range::RangeTo"
                                            []
                                            [ Ty.path "usize" ]
                                            [ ("end_", M.read (| cnt |)) ]
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::ops::range::RangeTo")
                                                  []
                                                  [ Ty.path "usize" ]
                                              ],
                                              "index",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| src |) |)
                                              |);
                                              Value.StructRecord
                                                "core::ops::range::RangeTo"
                                                []
                                                [ Ty.path "usize" ]
                                                [ ("end_", M.read (| cnt |)) ]
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                src,
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                          M.get_trait_method (|
                                            "core::ops::index::Index",
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "core::ops::range::RangeFrom")
                                                []
                                                [ Ty.path "usize" ]
                                            ],
                                            "index",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| src |) |)
                                            |);
                                            Value.StructRecord
                                              "core::ops::range::RangeFrom"
                                              []
                                              [ Ty.path "usize" ]
                                              [ ("start", M.read (| cnt |)) ]
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "bytes::buf::buf_mut::BufMut",
                                  Self,
                                  [],
                                  [],
                                  "advance_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_slice :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_slice" put_slice.
      Definition put_bytes
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; val; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "bytes::buf::buf_mut::BufMut",
                                      Ty.apply (Ty.path "&mut") [] [ Self ],
                                      [],
                                      [],
                                      "remaining_mut",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.read (| cnt |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_trait_method (|
                                    "bytes::buf::buf_mut::BufMut",
                                    Ty.apply (Ty.path "&mut") [] [ Self ],
                                    [],
                                    [],
                                    "remaining_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.loop (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| cnt |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ dst :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ]
                                ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                                M.get_trait_method (|
                                  "bytes::buf::buf_mut::BufMut",
                                  Self,
                                  [],
                                  [],
                                  "chunk_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |)
                                ]
                              |)
                            |) in
                          let~ dst_len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.path "usize",
                                  [],
                                  [],
                                  "min",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| dst |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_function (|
                                  "core::intrinsics::write_bytes",
                                  [],
                                  [ Ty.path "u8" ]
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    M.get_associated_function (|
                                      Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                      "as_mut_ptr",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| dst |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| val |);
                                  M.read (| dst_len |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "bytes::buf::buf_mut::BufMut",
                                  Self,
                                  [],
                                  [],
                                  "advance_mut",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |);
                                  M.read (| dst_len |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              let β := cnt in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [ M.read (| β |); M.read (| dst_len |) ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_bytes :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_bytes" put_bytes.
      Definition put_u8 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ src :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 1 ]
                        [ Ty.path "u8" ]
                    ] :=
                M.alloc (| Value.Array [ M.read (| n |) ] |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, src |) |)
                        |))
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u8 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u8" put_u8.
      Definition put_i8 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ src :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 1 ]
                        [ Ty.path "u8" ]
                    ] :=
                M.alloc (| Value.Array [ M.cast (Ty.path "u8") (M.read (| n |)) ] |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "bytes::buf::buf_mut::BufMut",
                    Self,
                    [],
                    [],
                    "put_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.borrow (| Pointer.Kind.Ref, src |) |)
                      |))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i8 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i8" put_i8.
      Definition put_u16 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 2 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u16", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u16 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u16" put_u16.
      Definition put_u16_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 2 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u16", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u16_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u16_le" put_u16_le.
      Definition put_u16_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 2 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u16", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u16_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u16_ne" put_u16_ne.
      Definition put_i16 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 2 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i16", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i16 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i16" put_i16.
      Definition put_i16_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 2 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i16", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i16_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i16_le" put_i16_le.
      Definition put_i16_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 2 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i16", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i16_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i16_ne" put_i16_ne.
      Definition put_u32 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 4 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u32", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u32 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u32" put_u32.
      Definition put_u32_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 4 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u32", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u32_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u32_le" put_u32_le.
      Definition put_u32_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 4 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u32", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u32_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u32_ne" put_u32_ne.
      Definition put_i32 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 4 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i32", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i32 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i32" put_i32.
      Definition put_i32_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 4 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i32", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i32_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i32_le" put_i32_le.
      Definition put_i32_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 4 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i32", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i32_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i32_ne" put_i32_ne.
      Definition put_u64 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 8 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u64", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u64 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u64" put_u64.
      Definition put_u64_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 8 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u64", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u64_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u64_le" put_u64_le.
      Definition put_u64_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 8 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u64", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u64_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u64_ne" put_u64_ne.
      Definition put_i64 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 8 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i64", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i64 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i64" put_i64.
      Definition put_i64_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 8 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i64", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i64_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i64_le" put_i64_le.
      Definition put_i64_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 8 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i64", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i64_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i64_ne" put_i64_ne.
      Definition put_u128 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 16 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u128", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u128 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u128" put_u128.
      Definition put_u128_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 16 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u128", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u128_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u128_le" put_u128_le.
      Definition put_u128_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 16 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "u128", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_u128_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_u128_ne" put_u128_ne.
      Definition put_i128 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 16 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i128", "to_be_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i128 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i128" put_i128.
      Definition put_i128_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 16 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i128", "to_le_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i128_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i128_le" put_i128_le.
      Definition put_i128_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                Self,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 16 ]
                              [ Ty.path "u8" ],
                            M.get_associated_function (| Ty.path "i128", "to_ne_bytes", [], [] |),
                            [ M.read (| n |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_i128_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_i128_ne" put_i128_ne.
      Definition put_uint (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n; nbytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let nbytes := M.alloc (| nbytes |) in
            M.read (|
              let~ start : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.copy (|
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::mem::size_of_val", [], [ Ty.path "u64" ] |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                              |)
                            ]
                          |);
                          M.read (| nbytes |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let start := M.copy (| γ0_0 |) in
                          start));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "bytes::panic_does_not_fit", [], [] |),
                                [
                                  M.read (| nbytes |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_function (|
                                      "core::mem::size_of_val",
                                      [],
                                      [ Ty.path "u64" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 8 ]
                                    [ Ty.path "u8" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 8 ]
                                          [ Ty.path "u8" ],
                                        M.get_associated_function (|
                                          Ty.path "u64",
                                          "to_be_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| n |) ]
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeFrom"
                                    []
                                    [ Ty.path "usize" ]
                                    [ ("start", M.read (| start |)) ]
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_uint :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_uint" put_uint.
      Definition put_uint_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n; nbytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let nbytes := M.alloc (| nbytes |) in
            M.read (|
              let~ slice :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 8 ]
                        [ Ty.path "u8" ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 8 ]
                      [ Ty.path "u8" ],
                    M.get_associated_function (| Ty.path "u64", "to_le_bytes", [], [] |),
                    [ M.read (| n |) ]
                  |)
                |) in
              let~ slice :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ]
                        |),
                        [
                          (* Unsize *) M.pointer_coercion (M.borrow (| Pointer.Kind.Ref, slice |));
                          Value.StructRecord
                            "core::ops::range::RangeTo"
                            []
                            [ Ty.path "usize" ]
                            [ ("end_", M.read (| nbytes |)) ]
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let slice := M.copy (| γ0_0 |) in
                          slice));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "bytes::panic_does_not_fit", [], [] |),
                                [
                                  M.read (| nbytes |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion (M.borrow (| Pointer.Kind.Ref, slice |))
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_uint_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_uint_le" put_uint_le.
      Definition put_uint_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n; nbytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let nbytes := M.alloc (| nbytes |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool false |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "bytes::buf::buf_mut::BufMut",
                            Self,
                            [],
                            [],
                            "put_uint",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.read (| n |);
                            M.read (| nbytes |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "bytes::buf::buf_mut::BufMut",
                            Self,
                            [],
                            [],
                            "put_uint_le",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.read (| n |);
                            M.read (| nbytes |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_uint_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_uint_ne" put_uint_ne.
      Definition put_int (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n; nbytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let nbytes := M.alloc (| nbytes |) in
            M.read (|
              let~ start : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.copy (|
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::mem::size_of_val", [], [ Ty.path "i64" ] |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                              |)
                            ]
                          |);
                          M.read (| nbytes |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let start := M.copy (| γ0_0 |) in
                          start));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "bytes::panic_does_not_fit", [], [] |),
                                [
                                  M.read (| nbytes |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_function (|
                                      "core::mem::size_of_val",
                                      [],
                                      [ Ty.path "i64" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 8 ]
                                    [ Ty.path "u8" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::ops::range::RangeFrom")
                                      []
                                      [ Ty.path "usize" ]
                                  ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 8 ]
                                          [ Ty.path "u8" ],
                                        M.get_associated_function (|
                                          Ty.path "i64",
                                          "to_be_bytes",
                                          [],
                                          []
                                        |),
                                        [ M.read (| n |) ]
                                      |)
                                    |)
                                  |);
                                  Value.StructRecord
                                    "core::ops::range::RangeFrom"
                                    []
                                    [ Ty.path "usize" ]
                                    [ ("start", M.read (| start |)) ]
                                ]
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_int :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_int" put_int.
      Definition put_int_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n; nbytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let nbytes := M.alloc (| nbytes |) in
            M.read (|
              let~ slice :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 8 ]
                        [ Ty.path "u8" ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 8 ]
                      [ Ty.path "u8" ],
                    M.get_associated_function (| Ty.path "i64", "to_le_bytes", [], [] |),
                    [ M.read (| n |) ]
                  |)
                |) in
              let~ slice :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "get",
                          [],
                          [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ]
                        |),
                        [
                          (* Unsize *) M.pointer_coercion (M.borrow (| Pointer.Kind.Ref, slice |));
                          Value.StructRecord
                            "core::ops::range::RangeTo"
                            []
                            [ Ty.path "usize" ]
                            [ ("end_", M.read (| nbytes |)) ]
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let slice := M.copy (| γ0_0 |) in
                          slice));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "bytes::panic_does_not_fit", [], [] |),
                                [
                                  M.read (| nbytes |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion (M.borrow (| Pointer.Kind.Ref, slice |))
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_int_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_int_le" put_int_le.
      Definition put_int_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n; nbytes ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            let nbytes := M.alloc (| nbytes |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool false |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "bytes::buf::buf_mut::BufMut",
                            Self,
                            [],
                            [],
                            "put_int",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.read (| n |);
                            M.read (| nbytes |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "bytes::buf::buf_mut::BufMut",
                            Self,
                            [],
                            [],
                            "put_int_le",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.read (| n |);
                            M.read (| nbytes |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_int_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_int_ne" put_int_ne.
      Definition put_f32 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_u32",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "u32",
                        M.get_associated_function (| Ty.path "f32", "to_bits", [], [] |),
                        [ M.read (| n |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_f32 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_f32" put_f32.
      Definition put_f32_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_u32_le",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "u32",
                        M.get_associated_function (| Ty.path "f32", "to_bits", [], [] |),
                        [ M.read (| n |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_f32_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_f32_le" put_f32_le.
      Definition put_f32_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_u32_ne",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "u32",
                        M.get_associated_function (| Ty.path "f32", "to_bits", [], [] |),
                        [ M.read (| n |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_f32_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_f32_ne" put_f32_ne.
      Definition put_f64 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_u64",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                        [ M.read (| n |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_f64 :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_f64" put_f64.
      Definition put_f64_le
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_u64_le",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                        [ M.read (| n |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_f64_le :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_f64_le" put_f64_le.
      Definition put_f64_ne
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Self,
                      [],
                      [],
                      "put_u64_ne",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                        [ M.read (| n |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_put_f64_ne :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "put_f64_ne" put_f64_ne.
      Definition limit (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; limit ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let limit := M.alloc (| limit |) in
            M.call_closure (|
              Ty.apply (Ty.path "bytes::buf::limit::Limit") [] [ Self ],
              M.get_function (| "bytes::buf::limit::new", [], [ Self ] |),
              [ M.read (| self |); M.read (| limit |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_limit : M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "limit" limit.
      Definition writer (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "bytes::buf::writer::Writer") [] [ Self ],
              M.get_function (| "bytes::buf::writer::new", [], [ Self ] |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_writer :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "writer" writer.
      Definition chain_mut
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [ U ], [ self; next ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let next := M.alloc (| next |) in
            M.call_closure (|
              Ty.apply (Ty.path "bytes::buf::chain::Chain") [] [ Self; U ],
              M.get_associated_function (|
                Ty.apply (Ty.path "bytes::buf::chain::Chain") [] [ Self; U ],
                "new",
                [],
                []
              |),
              [ M.read (| self |); M.read (| next |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_chain_mut :
        M.IsProvidedMethod "bytes::buf::buf_mut::BufMut" "chain_mut" chain_mut.
    End BufMut.
    
    Module Impl_bytes_buf_buf_mut_BufMut_where_bytes_buf_buf_mut_BufMut_T_where_core_marker_Sized_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (*
              fn remaining_mut(&self) -> usize {
                  ( **self).remaining_mut()
              }
      *)
      Definition remaining_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "remaining_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn chunk_mut(&mut self) -> &mut UninitSlice {
                  ( **self).chunk_mut()
              }
      *)
      Definition chunk_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                      M.get_trait_method (|
                        "bytes::buf::buf_mut::BufMut",
                        T,
                        [],
                        [],
                        "chunk_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn advance_mut(&mut self, cnt: usize) {
                  ( **self).advance_mut(cnt)
              }
      *)
      Definition advance_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let cnt := M.alloc (| cnt |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "advance_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| cnt |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_slice(&mut self, src: &[u8]) {
                  ( **self).put_slice(src)
              }
      *)
      Definition put_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u8(&mut self, n: u8) {
                  ( **self).put_u8(n)
              }
      *)
      Definition put_u8 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u8", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i8(&mut self, n: i8) {
                  ( **self).put_i8(n)
              }
      *)
      Definition put_i8 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i8", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u16(&mut self, n: u16) {
                  ( **self).put_u16(n)
              }
      *)
      Definition put_u16 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u16", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u16_le(&mut self, n: u16) {
                  ( **self).put_u16_le(n)
              }
      *)
      Definition put_u16_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u16_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u16_ne(&mut self, n: u16) {
                  ( **self).put_u16_ne(n)
              }
      *)
      Definition put_u16_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u16_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i16(&mut self, n: i16) {
                  ( **self).put_i16(n)
              }
      *)
      Definition put_i16 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i16", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i16_le(&mut self, n: i16) {
                  ( **self).put_i16_le(n)
              }
      *)
      Definition put_i16_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i16_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i16_ne(&mut self, n: i16) {
                  ( **self).put_i16_ne(n)
              }
      *)
      Definition put_i16_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i16_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u32(&mut self, n: u32) {
                  ( **self).put_u32(n)
              }
      *)
      Definition put_u32 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u32", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u32_le(&mut self, n: u32) {
                  ( **self).put_u32_le(n)
              }
      *)
      Definition put_u32_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u32_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u32_ne(&mut self, n: u32) {
                  ( **self).put_u32_ne(n)
              }
      *)
      Definition put_u32_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u32_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i32(&mut self, n: i32) {
                  ( **self).put_i32(n)
              }
      *)
      Definition put_i32 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i32", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i32_le(&mut self, n: i32) {
                  ( **self).put_i32_le(n)
              }
      *)
      Definition put_i32_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i32_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i32_ne(&mut self, n: i32) {
                  ( **self).put_i32_ne(n)
              }
      *)
      Definition put_i32_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i32_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u64(&mut self, n: u64) {
                  ( **self).put_u64(n)
              }
      *)
      Definition put_u64 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u64", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u64_le(&mut self, n: u64) {
                  ( **self).put_u64_le(n)
              }
      *)
      Definition put_u64_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u64_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u64_ne(&mut self, n: u64) {
                  ( **self).put_u64_ne(n)
              }
      *)
      Definition put_u64_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u64_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i64(&mut self, n: i64) {
                  ( **self).put_i64(n)
              }
      *)
      Definition put_i64 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i64", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i64_le(&mut self, n: i64) {
                  ( **self).put_i64_le(n)
              }
      *)
      Definition put_i64_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i64_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i64_ne(&mut self, n: i64) {
                  ( **self).put_i64_ne(n)
              }
      *)
      Definition put_i64_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i64_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "bytes::buf::buf_mut::BufMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("remaining_mut", InstanceField.Method (remaining_mut T));
            ("chunk_mut", InstanceField.Method (chunk_mut T));
            ("advance_mut", InstanceField.Method (advance_mut T));
            ("put_slice", InstanceField.Method (put_slice T));
            ("put_u8", InstanceField.Method (put_u8 T));
            ("put_i8", InstanceField.Method (put_i8 T));
            ("put_u16", InstanceField.Method (put_u16 T));
            ("put_u16_le", InstanceField.Method (put_u16_le T));
            ("put_u16_ne", InstanceField.Method (put_u16_ne T));
            ("put_i16", InstanceField.Method (put_i16 T));
            ("put_i16_le", InstanceField.Method (put_i16_le T));
            ("put_i16_ne", InstanceField.Method (put_i16_ne T));
            ("put_u32", InstanceField.Method (put_u32 T));
            ("put_u32_le", InstanceField.Method (put_u32_le T));
            ("put_u32_ne", InstanceField.Method (put_u32_ne T));
            ("put_i32", InstanceField.Method (put_i32 T));
            ("put_i32_le", InstanceField.Method (put_i32_le T));
            ("put_i32_ne", InstanceField.Method (put_i32_ne T));
            ("put_u64", InstanceField.Method (put_u64 T));
            ("put_u64_le", InstanceField.Method (put_u64_le T));
            ("put_u64_ne", InstanceField.Method (put_u64_ne T));
            ("put_i64", InstanceField.Method (put_i64 T));
            ("put_i64_le", InstanceField.Method (put_i64_le T));
            ("put_i64_ne", InstanceField.Method (put_i64_ne T))
          ].
    End Impl_bytes_buf_buf_mut_BufMut_where_bytes_buf_buf_mut_BufMut_T_where_core_marker_Sized_T_for_ref_mut_T.
    
    Module Impl_bytes_buf_buf_mut_BufMut_where_bytes_buf_buf_mut_BufMut_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "alloc::boxed::Box") [] [ T; Ty.path "alloc::alloc::Global" ].
      
      (*
              fn remaining_mut(&self) -> usize {
                  ( **self).remaining_mut()
              }
      *)
      Definition remaining_mut
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "remaining_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn chunk_mut(&mut self) -> &mut UninitSlice {
                  ( **self).chunk_mut()
              }
      *)
      Definition chunk_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                      M.get_trait_method (|
                        "bytes::buf::buf_mut::BufMut",
                        T,
                        [],
                        [],
                        "chunk_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn advance_mut(&mut self, cnt: usize) {
                  ( **self).advance_mut(cnt)
              }
      *)
      Definition advance_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let cnt := M.alloc (| cnt |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "advance_mut",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| cnt |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_slice(&mut self, src: &[u8]) {
                  ( **self).put_slice(src)
              }
      *)
      Definition put_slice (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_slice",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u8(&mut self, n: u8) {
                  ( **self).put_u8(n)
              }
      *)
      Definition put_u8 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u8", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i8(&mut self, n: i8) {
                  ( **self).put_i8(n)
              }
      *)
      Definition put_i8 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i8", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u16(&mut self, n: u16) {
                  ( **self).put_u16(n)
              }
      *)
      Definition put_u16 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u16", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u16_le(&mut self, n: u16) {
                  ( **self).put_u16_le(n)
              }
      *)
      Definition put_u16_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u16_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u16_ne(&mut self, n: u16) {
                  ( **self).put_u16_ne(n)
              }
      *)
      Definition put_u16_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u16_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i16(&mut self, n: i16) {
                  ( **self).put_i16(n)
              }
      *)
      Definition put_i16 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i16", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i16_le(&mut self, n: i16) {
                  ( **self).put_i16_le(n)
              }
      *)
      Definition put_i16_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i16_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i16_ne(&mut self, n: i16) {
                  ( **self).put_i16_ne(n)
              }
      *)
      Definition put_i16_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i16_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u32(&mut self, n: u32) {
                  ( **self).put_u32(n)
              }
      *)
      Definition put_u32 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u32", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u32_le(&mut self, n: u32) {
                  ( **self).put_u32_le(n)
              }
      *)
      Definition put_u32_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u32_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u32_ne(&mut self, n: u32) {
                  ( **self).put_u32_ne(n)
              }
      *)
      Definition put_u32_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u32_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i32(&mut self, n: i32) {
                  ( **self).put_i32(n)
              }
      *)
      Definition put_i32 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i32", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i32_le(&mut self, n: i32) {
                  ( **self).put_i32_le(n)
              }
      *)
      Definition put_i32_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i32_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i32_ne(&mut self, n: i32) {
                  ( **self).put_i32_ne(n)
              }
      *)
      Definition put_i32_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i32_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u64(&mut self, n: u64) {
                  ( **self).put_u64(n)
              }
      *)
      Definition put_u64 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_u64", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u64_le(&mut self, n: u64) {
                  ( **self).put_u64_le(n)
              }
      *)
      Definition put_u64_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u64_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_u64_ne(&mut self, n: u64) {
                  ( **self).put_u64_ne(n)
              }
      *)
      Definition put_u64_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_u64_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i64(&mut self, n: i64) {
                  ( **self).put_i64(n)
              }
      *)
      Definition put_i64 (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "bytes::buf::buf_mut::BufMut", T, [], [], "put_i64", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i64_le(&mut self, n: i64) {
                  ( **self).put_i64_le(n)
              }
      *)
      Definition put_i64_le (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i64_le",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn put_i64_ne(&mut self, n: i64) {
                  ( **self).put_i64_ne(n)
              }
      *)
      Definition put_i64_ne (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (|
                "bytes::buf::buf_mut::BufMut",
                T,
                [],
                [],
                "put_i64_ne",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |);
                M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "bytes::buf::buf_mut::BufMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("remaining_mut", InstanceField.Method (remaining_mut T));
            ("chunk_mut", InstanceField.Method (chunk_mut T));
            ("advance_mut", InstanceField.Method (advance_mut T));
            ("put_slice", InstanceField.Method (put_slice T));
            ("put_u8", InstanceField.Method (put_u8 T));
            ("put_i8", InstanceField.Method (put_i8 T));
            ("put_u16", InstanceField.Method (put_u16 T));
            ("put_u16_le", InstanceField.Method (put_u16_le T));
            ("put_u16_ne", InstanceField.Method (put_u16_ne T));
            ("put_i16", InstanceField.Method (put_i16 T));
            ("put_i16_le", InstanceField.Method (put_i16_le T));
            ("put_i16_ne", InstanceField.Method (put_i16_ne T));
            ("put_u32", InstanceField.Method (put_u32 T));
            ("put_u32_le", InstanceField.Method (put_u32_le T));
            ("put_u32_ne", InstanceField.Method (put_u32_ne T));
            ("put_i32", InstanceField.Method (put_i32 T));
            ("put_i32_le", InstanceField.Method (put_i32_le T));
            ("put_i32_ne", InstanceField.Method (put_i32_ne T));
            ("put_u64", InstanceField.Method (put_u64 T));
            ("put_u64_le", InstanceField.Method (put_u64_le T));
            ("put_u64_ne", InstanceField.Method (put_u64_ne T));
            ("put_i64", InstanceField.Method (put_i64 T));
            ("put_i64_le", InstanceField.Method (put_i64_le T));
            ("put_i64_ne", InstanceField.Method (put_i64_ne T))
          ].
    End Impl_bytes_buf_buf_mut_BufMut_where_bytes_buf_buf_mut_BufMut_T_where_core_marker_Sized_T_for_alloc_boxed_Box_T_alloc_alloc_Global.
    
    Module Impl_bytes_buf_buf_mut_BufMut_for_ref_mut_slice_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
      
      (*
          fn remaining_mut(&self) -> usize {
              self.len()
          }
      *)
      Definition remaining_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn chunk_mut(&mut self) -> &mut UninitSlice {
              UninitSlice::new(self)
          }
      *)
      Definition chunk_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                      M.get_associated_function (|
                        Ty.path "bytes::buf::uninit_slice::UninitSlice",
                        "new",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn advance_mut(&mut self, cnt: usize) {
              if self.len() < cnt {
                  panic_advance(cnt, self.len());
              }
      
              // Lifetime dance taken from `impl Write for &mut [u8]`.
              let (_, b) = core::mem::replace(self, &mut []).split_at_mut(cnt);
              *self = b;
          }
      *)
      Definition advance_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.read (| cnt |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "split_at_mut",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_function (|
                              "core::mem::replace",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (| Pointer.Kind.MutRef, M.alloc (| Value.Array [] |) |)
                                  |)
                                |))
                            ]
                          |)
                        |)
                      |);
                      M.read (| cnt |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let b := M.copy (| γ0_1 |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.alloc (|
                          M.write (|
                            M.deref (| M.read (| self |) |),
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| b |) |) |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn put_slice(&mut self, src: &[u8]) {
              if self.len() < src.len() {
                  panic_advance(src.len(), self.len());
              }
      
              self[..src.len()].copy_from_slice(src);
              // SAFETY: We just initialized `src.len()` bytes.
              unsafe { self.advance_mut(src.len()) };
          }
      *)
      Definition put_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "copy_from_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::index::IndexMut",
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ops::range::RangeTo")
                                  []
                                  [ Ty.path "usize" ]
                              ],
                              "index_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                []
                                [ Ty.path "usize" ]
                                [
                                  ("end_",
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| src |) |)
                                        |)
                                      ]
                                    |))
                                ]
                            ]
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      [],
                      [],
                      "advance_mut",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn put_bytes(&mut self, val: u8, cnt: usize) {
              if self.len() < cnt {
                  panic_advance(cnt, self.len());
              }
      
              // SAFETY: We just checked that the pointer is valid for `cnt` bytes.
              unsafe {
                  ptr::write_bytes(self.as_mut_ptr(), val, cnt);
                  self.advance_mut(cnt);
              }
          }
      *)
      Definition put_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.read (| cnt |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::intrinsics::write_bytes", [], [ Ty.path "u8" ] |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_mut_ptr",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                          |)
                        ]
                      |);
                      M.read (| val |);
                      M.read (| cnt |)
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      [],
                      [],
                      "advance_mut",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| cnt |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "bytes::buf::buf_mut::BufMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("remaining_mut", InstanceField.Method remaining_mut);
            ("chunk_mut", InstanceField.Method chunk_mut);
            ("advance_mut", InstanceField.Method advance_mut);
            ("put_slice", InstanceField.Method put_slice);
            ("put_bytes", InstanceField.Method put_bytes)
          ].
    End Impl_bytes_buf_buf_mut_BufMut_for_ref_mut_slice_u8.
    
    Module Impl_bytes_buf_buf_mut_BufMut_for_ref_mut_slice_core_mem_maybe_uninit_MaybeUninit_u8.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "&mut")
          []
          [
            Ty.apply
              (Ty.path "slice")
              []
              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ] ]
          ].
      
      (*
          fn remaining_mut(&self) -> usize {
              self.len()
          }
      *)
      Definition remaining_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ] ],
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn chunk_mut(&mut self) -> &mut UninitSlice {
              UninitSlice::uninit(self)
          }
      *)
      Definition chunk_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                      M.get_associated_function (|
                        Ty.path "bytes::buf::uninit_slice::UninitSlice",
                        "uninit",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn advance_mut(&mut self, cnt: usize) {
              if self.len() < cnt {
                  panic_advance(cnt, self.len());
              }
      
              // Lifetime dance taken from `impl Write for &mut [u8]`.
              let (_, b) = core::mem::replace(self, &mut []).split_at_mut(cnt);
              *self = b;
          }
      *)
      Definition advance_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "u8" ]
                                        ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.read (| cnt |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "u8" ]
                                      ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ]
                          ];
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ],
                      "split_at_mut",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                              ],
                            M.get_function (|
                              "core::mem::replace",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "u8" ]
                                      ]
                                  ]
                              ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (| Pointer.Kind.MutRef, M.alloc (| Value.Array [] |) |)
                                  |)
                                |))
                            ]
                          |)
                        |)
                      |);
                      M.read (| cnt |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let b := M.copy (| γ0_1 |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.alloc (|
                          M.write (|
                            M.deref (| M.read (| self |) |),
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| b |) |) |)
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn put_slice(&mut self, src: &[u8]) {
              if self.len() < src.len() {
                  panic_advance(src.len(), self.len());
              }
      
              // SAFETY: We just checked that the pointer is valid for `src.len()` bytes.
              unsafe {
                  ptr::copy_nonoverlapping(src.as_ptr(), self.as_mut_ptr().cast(), src.len());
                  self.advance_mut(src.len());
              }
          }
      *)
      Definition put_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "u8" ]
                                        ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| src |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
                                  ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "u8" ]
                                      ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::intrinsics::copy_nonoverlapping",
                      [],
                      [ Ty.path "u8" ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ],
                          "cast",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ],
                              "as_mut_ptr",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                              |)
                            ]
                          |)
                        ]
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) ]
                      |)
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ]
                        ],
                      [],
                      [],
                      "advance_mut",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn put_bytes(&mut self, val: u8, cnt: usize) {
              if self.len() < cnt {
                  panic_advance(cnt, self.len());
              }
      
              // SAFETY: We just checked that the pointer is valid for `cnt` bytes.
              unsafe {
                  ptr::write_bytes(self.as_mut_ptr() as *mut u8, val, cnt);
                  self.advance_mut(cnt);
              }
          }
      *)
      Definition put_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "u8" ]
                                        ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| cnt |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [
                                M.read (| cnt |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "u8" ]
                                      ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (| "core::intrinsics::write_bytes", [], [ Ty.path "u8" ] |),
                    [
                      M.cast
                        (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                        (M.call_closure (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ],
                            "as_mut_ptr",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                            |)
                          ]
                        |));
                      M.read (| val |);
                      M.read (| cnt |)
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "bytes::buf::buf_mut::BufMut",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ]
                        ],
                      [],
                      [],
                      "advance_mut",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| cnt |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "bytes::buf::buf_mut::BufMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("remaining_mut", InstanceField.Method remaining_mut);
            ("chunk_mut", InstanceField.Method chunk_mut);
            ("advance_mut", InstanceField.Method advance_mut);
            ("put_slice", InstanceField.Method put_slice);
            ("put_bytes", InstanceField.Method put_bytes)
          ].
    End Impl_bytes_buf_buf_mut_BufMut_for_ref_mut_slice_core_mem_maybe_uninit_MaybeUninit_u8.
    
    Module Impl_bytes_buf_buf_mut_BufMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn remaining_mut(&self) -> usize {
              // A vector can never have more than isize::MAX bytes
              core::isize::MAX as usize - self.len()
          }
      *)
      Definition remaining_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.sub,
              [
                M.cast
                  (Ty.path "usize")
                  (M.read (| get_constant (| "core::isize::MAX", Ty.path "isize" |) |));
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn advance_mut(&mut self, cnt: usize) {
              let len = self.len();
              let remaining = self.capacity() - len;
      
              if remaining < cnt {
                  panic_advance(cnt, remaining);
              }
      
              // Addition will not overflow since the sum is at most the capacity.
              self.set_len(len + cnt);
          }
      *)
      Definition advance_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ remaining : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.sub,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "capacity",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| len |)
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| remaining |); M.read (| cnt |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "bytes::panic_advance", [], [] |),
                              [ M.read (| cnt |); M.read (| remaining |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "set_len",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [ M.read (| len |); M.read (| cnt |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn chunk_mut(&mut self) -> &mut UninitSlice {
              if self.capacity() == self.len() {
                  self.reserve(64); // Grow the vec
              }
      
              let cap = self.capacity();
              let len = self.len();
      
              let ptr = self.as_mut_ptr();
              // SAFETY: Since `ptr` is valid for `cap` bytes, `ptr.add(len)` must be
              // valid for `cap - len` bytes. The subtraction will not underflow since
              // `len <= cap`.
              unsafe { UninitSlice::from_raw_parts_mut(ptr.add(len), cap - len) }
          }
      *)
      Definition chunk_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                          "capacity",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.tuple [],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                    "reserve",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| self |) |)
                                    |);
                                    Value.Integer IntegerKind.Usize 64
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "capacity",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |) in
                  let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |) in
                  let~ ptr :
                      Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "as_mut_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                              M.get_associated_function (|
                                Ty.path "bytes::buf::uninit_slice::UninitSlice",
                                "from_raw_parts_mut",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    "add",
                                    [],
                                    []
                                  |),
                                  [ M.read (| ptr |); M.read (| len |) ]
                                |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [ M.read (| cap |); M.read (| len |) ]
                                |)
                              ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn put<T: super::Buf>(&mut self, mut src: T)
          where
              Self: Sized,
          {
              // In case the src isn't contiguous, reserve upfront.
              self.reserve(src.remaining());
      
              while src.has_remaining() {
                  let s = src.chunk();
                  let l = s.len();
                  self.extend_from_slice(s);
                  src.advance(l);
              }
          }
      *)
      Definition put (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "reserve",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "bytes::buf::buf_impl::Buf",
                          T,
                          [],
                          [],
                          "remaining",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, src |) ]
                      |)
                    ]
                  |)
                |) in
              M.loop (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                ltac:(M.monadic
                  (M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "bytes::buf::buf_impl::Buf",
                                    T,
                                    [],
                                    [],
                                    "has_remaining",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, src |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ s :
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "bytes::buf::buf_impl::Buf",
                                  T,
                                  [],
                                  [],
                                  "chunk",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, src |) ]
                              |)
                            |) in
                          let~ l : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                  "extend_from_slice",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |);
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |)
                                ]
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_trait_method (|
                                  "bytes::buf::buf_impl::Buf",
                                  T,
                                  [],
                                  [],
                                  "advance",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, src |); M.read (| l |) ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn put_slice(&mut self, src: &[u8]) {
              self.extend_from_slice(src);
          }
      *)
      Definition put_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; src ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let src := M.alloc (| src |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "extend_from_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn put_bytes(&mut self, val: u8, cnt: usize) {
              // If the addition overflows, then the `resize` will fail.
              let new_len = self.len().saturating_add(cnt);
              self.resize(new_len, val);
          }
      *)
      Definition put_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; val; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let val := M.alloc (| val |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ new_len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (| Ty.path "usize", "saturating_add", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| cnt |)
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "resize",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| new_len |);
                      M.read (| val |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "bytes::buf::buf_mut::BufMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("remaining_mut", InstanceField.Method remaining_mut);
            ("advance_mut", InstanceField.Method advance_mut);
            ("chunk_mut", InstanceField.Method chunk_mut);
            ("put", InstanceField.Method put);
            ("put_slice", InstanceField.Method put_slice);
            ("put_bytes", InstanceField.Method put_bytes)
          ].
    End Impl_bytes_buf_buf_mut_BufMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    
    (* fn _assert_trait_object(_b: &dyn BufMut) {} *)
    Definition _assert_trait_object (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ _b ] =>
        ltac:(M.monadic
          (let _b := M.alloc (| _b |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction__assert_trait_object :
      M.IsFunction.C "bytes::buf::buf_mut::_assert_trait_object" _assert_trait_object.
    Admitted.
    Global Typeclasses Opaque _assert_trait_object.
  End buf_mut.
End buf.
