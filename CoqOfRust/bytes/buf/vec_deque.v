(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module buf.
  Module vec_deque.
    Module Impl_bytes_buf_buf_impl_Buf_for_alloc_collections_vec_deque_VecDeque_u8_alloc_alloc_Global.
      Definition Self : Ty.t :=
        Ty.apply
          (Ty.path "alloc::collections::vec_deque::VecDeque")
          []
          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn remaining(&self) -> usize {
              self.len()
          }
      *)
      Definition remaining (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::collections::vec_deque::VecDeque")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                "len",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn chunk(&self) -> &[u8] {
              let (s1, s2) = self.as_slices();
              if s1.is_empty() {
                  s2
              } else {
                  s1
              }
          }
      *)
      Definition chunk (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::vec_deque::VecDeque")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      "as_slices",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let s1 := M.copy (| γ0_0 |) in
                      let s2 := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                          ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        "is_empty",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| s1 |) |)
                                        |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s2 |) |) |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s1 |) |) |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn advance(&mut self, cnt: usize) {
              self.drain(..cnt);
          }
      *)
      Definition advance (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; cnt ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let cnt := M.alloc (| cnt |) in
            M.read (|
              let~ _ :
                  Ty.apply
                    (Ty.path "alloc::collections::vec_deque::drain::Drain")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::collections::vec_deque::drain::Drain")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::vec_deque::VecDeque")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "drain",
                    [],
                    [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ]
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    Value.StructRecord
                      "core::ops::range::RangeTo"
                      []
                      [ Ty.path "usize" ]
                      [ ("end_", M.read (| cnt |)) ]
                  ]
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "bytes::buf::buf_impl::Buf"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("remaining", InstanceField.Method remaining);
            ("chunk", InstanceField.Method chunk);
            ("advance", InstanceField.Method advance)
          ].
    End Impl_bytes_buf_buf_impl_Buf_for_alloc_collections_vec_deque_VecDeque_u8_alloc_alloc_Global.
  End vec_deque.
End buf.
