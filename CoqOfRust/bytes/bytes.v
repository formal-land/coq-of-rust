(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bytes.
  (* StructRecord
    {
      name := "Bytes";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("ptr", Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ]);
          ("len", Ty.path "usize");
          ("data", Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ]);
          ("vtable", Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Vtable" ])
        ];
    } *)
  
  (* StructRecord
    {
      name := "Vtable";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("clone",
            Ty.function
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ] ];
                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ];
                Ty.path "usize"
              ]
              (Ty.path "bytes::bytes::Bytes"));
          ("to_vec",
            Ty.function
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ] ];
                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ];
                Ty.path "usize"
              ]
              (Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]));
          ("to_mut",
            Ty.function
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ] ];
                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ];
                Ty.path "usize"
              ]
              (Ty.path "bytes::bytes_mut::BytesMut"));
          ("is_unique",
            Ty.function
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ] ]
              ]
              (Ty.path "bool"));
          ("drop",
            Ty.function
              [
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ] ];
                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ];
                Ty.path "usize"
              ]
              (Ty.tuple []))
        ];
    } *)
  
  Module Impl_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        pub const fn new() -> Self {
            // Make it a named const to work around
            // "unsizing casts are not allowed in const fn"
            const EMPTY: &[u8] = &[];
            Bytes::from_static(EMPTY)
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "from_static", [], [] |),
            [
              M.read (|
                get_constant (|
                  "bytes::bytes::new::EMPTY",
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub const fn from_static(bytes: &'static [u8]) -> Self {
            Bytes {
                ptr: bytes.as_ptr(),
                len: bytes.len(),
                data: AtomicPtr::new(ptr::null_mut()),
                vtable: &STATIC_VTABLE,
            }
        }
    *)
    Definition from_static (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          Value.StructRecord
            "bytes::bytes::Bytes"
            []
            []
            [
              ("ptr",
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
                |));
              ("len",
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
                |));
              ("data",
                M.call_closure (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                    "new",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                      M.get_function (| "core::ptr::null_mut", [], [ Ty.tuple [] ] |),
                      []
                    |)
                  ]
                |));
              ("vtable",
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      get_constant (|
                        "bytes::bytes::STATIC_VTABLE",
                        Ty.path "bytes::bytes::Vtable"
                      |)
                    |)
                  |)
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_static :
      M.IsAssociatedFunction.C Self "from_static" from_static.
    Admitted.
    Global Typeclasses Opaque from_static.
    
    (*
        pub const fn len(&self) -> usize {
            self.len
        }
    *)
    Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "bytes::bytes::Bytes",
              "len"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_len : M.IsAssociatedFunction.C Self "len" len.
    Admitted.
    Global Typeclasses Opaque len.
    
    (*
        pub const fn is_empty(&self) -> bool {
            self.len == 0
        }
    *)
    Definition is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "bytes::bytes::Bytes",
                  "len"
                |)
              |);
              Value.Integer IntegerKind.Usize 0
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_empty : M.IsAssociatedFunction.C Self "is_empty" is_empty.
    Admitted.
    Global Typeclasses Opaque is_empty.
    
    (*
        pub fn is_unique(&self) -> bool {
            unsafe { (self.vtable.is_unique)(&self.data) }
        }
    *)
    Definition is_unique (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "vtable"
                    |)
                  |)
                |),
                "bytes::bytes::Vtable",
                "is_unique"
              |)
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "data"
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_unique :
      M.IsAssociatedFunction.C Self "is_unique" is_unique.
    Admitted.
    Global Typeclasses Opaque is_unique.
    
    (*
        pub fn copy_from_slice(data: &[u8]) -> Self {
            data.to_vec().into()
        }
    *)
    Definition copy_from_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.path "bytes::bytes::Bytes" ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "to_vec",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_copy_from_slice :
      M.IsAssociatedFunction.C Self "copy_from_slice" copy_from_slice.
    Admitted.
    Global Typeclasses Opaque copy_from_slice.
    
    (*
        pub fn slice(&self, range: impl RangeBounds<usize>) -> Self {
            use core::ops::Bound;
    
            let len = self.len();
    
            let begin = match range.start_bound() {
                Bound::Included(&n) => n,
                Bound::Excluded(&n) => n.checked_add(1).expect("out of range"),
                Bound::Unbounded => 0,
            };
    
            let end = match range.end_bound() {
                Bound::Included(&n) => n.checked_add(1).expect("out of range"),
                Bound::Excluded(&n) => n,
                Bound::Unbounded => len,
            };
    
            assert!(
                begin <= end,
                "range start must not be greater than end: {:?} <= {:?}",
                begin,
                end,
            );
            assert!(
                end <= len,
                "range end out of bounds: {:?} <= {:?}",
                end,
                len,
            );
    
            if end == begin {
                return Bytes::new();
            }
    
            let mut ret = self.clone();
    
            ret.len = end - begin;
            ret.ptr = unsafe { ret.ptr.add(begin) };
    
            ret
        }
    *)
    Definition slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ impl_RangeBounds_usize_ ], [ self; range ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let range := M.alloc (| range |) in
          M.catch_return (Ty.path "bytes::bytes::Bytes") (|
            ltac:(M.monadic
              (M.read (|
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "len", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ begin : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::range::Bound")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                          M.get_trait_method (|
                            "core::ops::range::RangeBounds",
                            impl_RangeBounds_usize_,
                            [],
                            [ Ty.path "usize" ],
                            "start_bound",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, range |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::range::Bound::Included",
                                0
                              |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let n := M.copy (| γ0_0 |) in
                            n));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::range::Bound::Excluded",
                                0
                              |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let n := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "expect",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_add",
                                      [],
                                      []
                                    |),
                                    [ M.read (| n |); Value.Integer IntegerKind.Usize 1 ]
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "out of range" |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                            M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
                      ]
                    |)
                  |) in
                let~ end_ : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::range::Bound")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                          M.get_trait_method (|
                            "core::ops::range::RangeBounds",
                            impl_RangeBounds_usize_,
                            [],
                            [ Ty.path "usize" ],
                            "end_bound",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, range |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::range::Bound::Included",
                                0
                              |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let n := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "expect",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "usize" ],
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_add",
                                      [],
                                      []
                                    |),
                                    [ M.read (| n |); Value.Integer IntegerKind.Usize 1 ]
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "out of range" |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::range::Bound::Excluded",
                                0
                              |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let n := M.copy (| γ0_0 |) in
                            n));
                        fun γ =>
                          ltac:(M.monadic
                            (let _ :=
                              M.is_struct_tuple (| γ, "core::ops::range::Bound::Unbounded" |) in
                            len))
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.le,
                                    [ M.read (| begin |); M.read (| end_ |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      [
                                        Value.Integer IntegerKind.Usize 2;
                                        Value.Integer IntegerKind.Usize 2
                                      ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (|
                                                    "range start must not be greater than end: "
                                                  |);
                                                  mk_str (| " <= " |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, begin |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, end_ |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.le,
                                    [ M.read (| end_ |); M.read (| len |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      [
                                        Value.Integer IntegerKind.Usize 2;
                                        Value.Integer IntegerKind.Usize 2
                                      ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (| "range end out of bounds: " |);
                                                  mk_str (| " <= " |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, end_ |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, len |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| end_ |); M.read (| begin |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes::Bytes",
                                      "new",
                                      [],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ ret : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "bytes::bytes::Bytes",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (| ret, "bytes::bytes::Bytes", "len" |),
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| end_ |); M.read (| begin |) ]
                      |)
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (| ret, "bytes::bytes::Bytes", "ptr" |),
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              ret,
                              "bytes::bytes::Bytes",
                              "ptr"
                            |)
                          |);
                          M.read (| begin |)
                        ]
                      |)
                    |)
                  |) in
                ret
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_slice : M.IsAssociatedFunction.C Self "slice" slice.
    Admitted.
    Global Typeclasses Opaque slice.
    
    (*
        pub fn slice_ref(&self, subset: &[u8]) -> Self {
            // Empty slice and empty Bytes may have their pointers reset
            // so explicitly allow empty slice to be a subslice of any slice.
            if subset.is_empty() {
                return Bytes::new();
            }
    
            let bytes_p = self.as_ptr() as usize;
            let bytes_len = self.len();
    
            let sub_p = subset.as_ptr() as usize;
            let sub_len = subset.len();
    
            assert!(
                sub_p >= bytes_p,
                "subset pointer ({:p}) is smaller than self pointer ({:p})",
                subset.as_ptr(),
                self.as_ptr(),
            );
            assert!(
                sub_p + sub_len <= bytes_p + bytes_len,
                "subset is out of bounds: self = ({:p}, {}), subset = ({:p}, {})",
                self.as_ptr(),
                bytes_len,
                subset.as_ptr(),
                sub_len,
            );
    
            let sub_offset = sub_p - bytes_p;
    
            self.slice(sub_offset..(sub_offset + sub_len))
        }
    *)
    Definition slice_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; subset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let subset := M.alloc (| subset |) in
          M.catch_return (Ty.path "bytes::bytes::Bytes") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "is_empty",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| subset |) |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes::Bytes",
                                      "new",
                                      [],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ bytes_p : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "usize")
                      (M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "bytes::bytes::Bytes",
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            |)
                          |)
                        ]
                      |))
                  |) in
                let~ bytes_len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "len", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ sub_p : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "usize")
                      (M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| subset |) |) |) ]
                      |))
                  |) in
                let~ sub_len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| subset |) |) |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [ M.read (| sub_p |); M.read (| bytes_p |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      [
                                        Value.Integer IntegerKind.Usize 3;
                                        Value.Integer IntegerKind.Usize 2
                                      ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (| "subset pointer (" |);
                                                  mk_str (| ") is smaller than self pointer (" |);
                                                  mk_str (| ")" |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_pointer",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "*const")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*const")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.read (| subset |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_pointer",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "*const")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*const")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "slice")
                                                                              []
                                                                              [ Ty.path "u8" ]
                                                                          ],
                                                                        M.get_trait_method (|
                                                                          "core::ops::deref::Deref",
                                                                          Ty.path
                                                                            "bytes::bytes::Bytes",
                                                                          [],
                                                                          [],
                                                                          "deref",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| self |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.le,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ M.read (| sub_p |); M.read (| sub_len |) ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ M.read (| bytes_p |); M.read (| bytes_len |) ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      [
                                        Value.Integer IntegerKind.Usize 5;
                                        Value.Integer IntegerKind.Usize 4
                                      ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (| "subset is out of bounds: self = (" |);
                                                  mk_str (| ", " |);
                                                  mk_str (| "), subset = (" |);
                                                  mk_str (| ", " |);
                                                  mk_str (| ")" |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_pointer",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "*const")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*const")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "slice")
                                                                              []
                                                                              [ Ty.path "u8" ]
                                                                          ],
                                                                        M.get_trait_method (|
                                                                          "core::ops::deref::Deref",
                                                                          Ty.path
                                                                            "bytes::bytes::Bytes",
                                                                          [],
                                                                          [],
                                                                          "deref",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| self |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_display",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, bytes_len |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_pointer",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "*const")
                                                          []
                                                          [ Ty.path "u8" ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*const")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.read (| subset |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_display",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, sub_len |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ sub_offset : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [ M.read (| sub_p |); M.read (| bytes_p |) ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.path "bytes::bytes::Bytes",
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "slice",
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      Value.StructRecord
                        "core::ops::range::Range"
                        []
                        [ Ty.path "usize" ]
                        [
                          ("start", M.read (| sub_offset |));
                          ("end_",
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| sub_offset |); M.read (| sub_len |) ]
                            |))
                        ]
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_slice_ref :
      M.IsAssociatedFunction.C Self "slice_ref" slice_ref.
    Admitted.
    Global Typeclasses Opaque slice_ref.
    
    (*
        pub fn split_off(&mut self, at: usize) -> Self {
            if at == self.len() {
                return Bytes::new();
            }
    
            if at == 0 {
                return mem::replace(self, Bytes::new());
            }
    
            assert!(
                at <= self.len(),
                "split_off out of bounds: {:?} <= {:?}",
                at,
                self.len(),
            );
    
            let mut ret = self.clone();
    
            self.len = at;
    
            unsafe { ret.inc_start(at) };
    
            ret
        }
    *)
    Definition split_off (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; at_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let at_ := M.alloc (| at_ |) in
          M.catch_return (Ty.path "bytes::bytes::Bytes") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.read (| at_ |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes::Bytes",
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes::Bytes",
                                      "new",
                                      [],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| at_ |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_function (|
                                      "core::mem::replace",
                                      [],
                                      [ Ty.path "bytes::bytes::Bytes" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "bytes::bytes::Bytes",
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes::Bytes",
                                          "new",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.le,
                                    [
                                      M.read (| at_ |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes::Bytes",
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      [
                                        Value.Integer IntegerKind.Usize 2;
                                        Value.Integer IntegerKind.Usize 2
                                      ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (| "split_off out of bounds: " |);
                                                  mk_str (| " <= " |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, at_ |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                M.get_associated_function (|
                                                                  Ty.path "bytes::bytes::Bytes",
                                                                  "len",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ ret : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "bytes::bytes::Bytes",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "bytes::bytes::Bytes",
                        "len"
                      |),
                      M.read (| at_ |)
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.path "bytes::bytes::Bytes",
                        "inc_start",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, ret |); M.read (| at_ |) ]
                    |)
                  |) in
                ret
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_split_off :
      M.IsAssociatedFunction.C Self "split_off" split_off.
    Admitted.
    Global Typeclasses Opaque split_off.
    
    (*
        pub fn split_to(&mut self, at: usize) -> Self {
            if at == self.len() {
                return mem::replace(self, Bytes::new());
            }
    
            if at == 0 {
                return Bytes::new();
            }
    
            assert!(
                at <= self.len(),
                "split_to out of bounds: {:?} <= {:?}",
                at,
                self.len(),
            );
    
            let mut ret = self.clone();
    
            unsafe { self.inc_start(at) };
    
            ret.len = at;
            ret
        }
    *)
    Definition split_to (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; at_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let at_ := M.alloc (| at_ |) in
          M.catch_return (Ty.path "bytes::bytes::Bytes") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.read (| at_ |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes::Bytes",
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_function (|
                                      "core::mem::replace",
                                      [],
                                      [ Ty.path "bytes::bytes::Bytes" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "bytes::bytes::Bytes",
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes::Bytes",
                                          "new",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| at_ |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes::Bytes",
                                      "new",
                                      [],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.le,
                                    [
                                      M.read (| at_ |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes::Bytes",
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      [
                                        Value.Integer IntegerKind.Usize 2;
                                        Value.Integer IntegerKind.Usize 2
                                      ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (| "split_to out of bounds: " |);
                                                  mk_str (| " <= " |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, at_ |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                M.get_associated_function (|
                                                                  Ty.path "bytes::bytes::Bytes",
                                                                  "len",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ ret : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "bytes::bytes::Bytes",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.path "bytes::bytes::Bytes",
                        "inc_start",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.read (| at_ |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (| ret, "bytes::bytes::Bytes", "len" |),
                      M.read (| at_ |)
                    |)
                  |) in
                ret
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_split_to : M.IsAssociatedFunction.C Self "split_to" split_to.
    Admitted.
    Global Typeclasses Opaque split_to.
    
    (*
        pub fn truncate(&mut self, len: usize) {
            if len < self.len {
                // The Vec "promotable" vtables do not store the capacity,
                // so we cannot truncate while using this repr. We *have* to
                // promote using `split_off` so the capacity can be stored.
                if self.vtable as *const Vtable == &PROMOTABLE_EVEN_VTABLE
                    || self.vtable as *const Vtable == &PROMOTABLE_ODD_VTABLE
                {
                    drop(self.split_off(len));
                } else {
                    self.len = len;
                }
            }
        }
    *)
    Definition truncate (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.lt,
                            [
                              M.read (| len |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "bytes::bytes::Bytes",
                                  "len"
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "*const")
                                          []
                                          [ Ty.path "bytes::bytes::Vtable" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "*const")
                                            []
                                            [ Ty.path "bytes::bytes::Vtable" ]
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.use
                                            (M.alloc (|
                                              M.borrow (|
                                                Pointer.Kind.ConstPointer,
                                                M.deref (|
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "bytes::bytes::Bytes",
                                                      "vtable"
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |))
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.borrow (|
                                              Pointer.Kind.ConstPointer,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      get_constant (|
                                                        "bytes::bytes::PROMOTABLE_EVEN_VTABLE",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "bytes::bytes::Vtable" ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "*const")
                                            []
                                            [ Ty.path "bytes::bytes::Vtable" ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "*const")
                                              []
                                              [ Ty.path "bytes::bytes::Vtable" ]
                                          ],
                                          "eq",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.use
                                              (M.alloc (|
                                                M.borrow (|
                                                  Pointer.Kind.ConstPointer,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "bytes::bytes::Bytes",
                                                        "vtable"
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |))
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              M.borrow (|
                                                Pointer.Kind.ConstPointer,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.read (|
                                                        get_constant (|
                                                          "bytes::bytes::PROMOTABLE_ODD_VTABLE",
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "bytes::bytes::Vtable" ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.tuple [],
                                  M.get_function (|
                                    "core::mem::drop",
                                    [],
                                    [ Ty.path "bytes::bytes::Bytes" ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "bytes::bytes::Bytes",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes::Bytes",
                                        "split_off",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| len |)
                                      ]
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.write (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "bytes::bytes::Bytes",
                                    "len"
                                  |),
                                  M.read (| len |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                      ]
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_truncate : M.IsAssociatedFunction.C Self "truncate" truncate.
    Admitted.
    Global Typeclasses Opaque truncate.
    
    (*
        pub fn clear(&mut self) {
            self.truncate(0);
        }
    *)
    Definition clear (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "truncate", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    Value.Integer IntegerKind.Usize 0
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_clear : M.IsAssociatedFunction.C Self "clear" clear.
    Admitted.
    Global Typeclasses Opaque clear.
    
    (*
        pub fn try_into_mut(self) -> Result<BytesMut, Bytes> {
            if self.is_unique() {
                Ok(self.into())
            } else {
                Err(self)
            }
        }
    *)
    Definition try_into_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "bytes::bytes_mut::BytesMut"; Ty.path "bytes::bytes::Bytes" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.path "bytes::bytes::Bytes",
                              "is_unique",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, self |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        []
                        [ Ty.path "bytes::bytes_mut::BytesMut"; Ty.path "bytes::bytes::Bytes" ]
                        [
                          M.call_closure (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            M.get_trait_method (|
                              "core::convert::Into",
                              Ty.path "bytes::bytes::Bytes",
                              [],
                              [ Ty.path "bytes::bytes_mut::BytesMut" ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        []
                        [ Ty.path "bytes::bytes_mut::BytesMut"; Ty.path "bytes::bytes::Bytes" ]
                        [ M.read (| self |) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_into_mut :
      M.IsAssociatedFunction.C Self "try_into_mut" try_into_mut.
    Admitted.
    Global Typeclasses Opaque try_into_mut.
    
    (*
        pub(crate) unsafe fn with_vtable(
            ptr: *const u8,
            len: usize,
            data: AtomicPtr<()>,
            vtable: &'static Vtable,
        ) -> Bytes {
            Bytes {
                ptr,
                len,
                data,
                vtable,
            }
        }
    *)
    Definition with_vtable (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ ptr; len; data; vtable ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let len := M.alloc (| len |) in
          let data := M.alloc (| data |) in
          let vtable := M.alloc (| vtable |) in
          Value.StructRecord
            "bytes::bytes::Bytes"
            []
            []
            [
              ("ptr", M.read (| ptr |));
              ("len", M.read (| len |));
              ("data", M.read (| data |));
              ("vtable", M.read (| vtable |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_with_vtable :
      M.IsAssociatedFunction.C Self "with_vtable" with_vtable.
    Admitted.
    Global Typeclasses Opaque with_vtable.
    
    (*
        fn as_slice(&self) -> &[u8] {
            unsafe { slice::from_raw_parts(self.ptr, self.len) }
        }
    *)
    Definition as_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_function (| "core::slice::raw::from_raw_parts", [], [ Ty.path "u8" ] |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "ptr"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "len"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_slice : M.IsAssociatedFunction.C Self "as_slice" as_slice.
    Admitted.
    Global Typeclasses Opaque as_slice.
    
    (*
        unsafe fn inc_start(&mut self, by: usize) {
            // should already be asserted, but debug assert for tests
            debug_assert!(self.len >= by, "internal: inc_start out of bounds");
            self.len -= by;
            self.ptr = self.ptr.add(by);
        }
    *)
    Definition inc_start (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; by_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let by_ := M.alloc (| by_ |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.ge,
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "bytes::bytes::Bytes",
                                                "len"
                                              |)
                                            |);
                                            M.read (| by_ |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "internal: inc_start out of bounds" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                let β :=
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes::Bytes",
                    "len"
                  |) in
                M.write (|
                  β,
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.sub,
                    [ M.read (| β |); M.read (| by_ |) ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes::Bytes",
                    "ptr"
                  |),
                  M.call_closure (|
                    Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                      "add",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "bytes::bytes::Bytes",
                          "ptr"
                        |)
                      |);
                      M.read (| by_ |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_inc_start :
      M.IsAssociatedFunction.C Self "inc_start" inc_start.
    Admitted.
    Global Typeclasses Opaque inc_start.
  End Impl_bytes_bytes_Bytes.
  
  Module Impl_core_marker_Send_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Send"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Send_for_bytes_bytes_Bytes.
  
  Module Impl_core_marker_Sync_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Sync"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Sync_for_bytes_bytes_Bytes.
  
  Module Impl_core_ops_drop_Drop_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn drop(&mut self) {
            unsafe { (self.vtable.drop)(&mut self.data, self.ptr, self.len) }
        }
    *)
    Definition drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.tuple [],
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "vtable"
                    |)
                  |)
                |),
                "bytes::bytes::Vtable",
                "drop"
              |)
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "data"
                    |)
                  |)
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "bytes::bytes::Bytes",
                  "ptr"
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "bytes::bytes::Bytes",
                  "len"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("drop", InstanceField.Method drop) ].
  End Impl_core_ops_drop_Drop_for_bytes_bytes_Bytes.
  
  Module Impl_core_clone_Clone_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn clone(&self) -> Bytes {
            unsafe { (self.vtable.clone)(&self.data, self.ptr, self.len) }
        }
    *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "vtable"
                    |)
                  |)
                |),
                "bytes::bytes::Vtable",
                "clone"
              |)
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes::Bytes",
                      "data"
                    |)
                  |)
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "bytes::bytes::Bytes",
                  "ptr"
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "bytes::bytes::Bytes",
                  "len"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_bytes_bytes_Bytes.
  
  Module Impl_bytes_buf_buf_impl_Buf_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn remaining(&self) -> usize {
            self.len()
        }
    *)
    Definition remaining (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "len", [], [] |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn chunk(&self) -> &[u8] {
            self.as_slice()
        }
    *)
    Definition chunk (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "as_slice", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn advance(&mut self, cnt: usize) {
            assert!(
                cnt <= self.len(),
                "cannot advance past `remaining`: {:?} <= {:?}",
                cnt,
                self.len(),
            );
    
            unsafe {
                self.inc_start(cnt);
            }
        }
    *)
    Definition advance (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; cnt ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cnt := M.alloc (| cnt |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.le,
                                [
                                  M.read (| cnt |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes::Bytes",
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 2;
                                    Value.Integer IntegerKind.Usize 2
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "cannot advance past `remaining`: " |);
                                              mk_str (| " <= " |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.Ref, cnt |)
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.path "bytes::bytes::Bytes",
                                                              "len",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes::Bytes",
                    "inc_start",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| cnt |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn copy_to_bytes(&mut self, len: usize) -> Self {
            self.split_to(len)
        }
    *)
    Definition copy_to_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "split_to", [], [] |),
            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |); M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "bytes::buf::buf_impl::Buf"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("remaining", InstanceField.Method remaining);
          ("chunk", InstanceField.Method chunk);
          ("advance", InstanceField.Method advance);
          ("copy_to_bytes", InstanceField.Method copy_to_bytes)
        ].
  End Impl_bytes_buf_buf_impl_Buf_for_bytes_bytes_Bytes.
  
  Module Impl_core_ops_deref_Deref_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*     type Target = [u8]; *)
    Definition _Target : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
    
    (*
        fn deref(&self) -> &[u8] {
            self.as_slice()
        }
    *)
    Definition deref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "as_slice", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
  End Impl_core_ops_deref_Deref_for_bytes_bytes_Bytes.
  
  Module Impl_core_convert_AsRef_slice_u8_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn as_ref(&self) -> &[u8] {
            self.as_slice()
        }
    *)
    Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "as_slice", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::AsRef"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
  End Impl_core_convert_AsRef_slice_u8_for_bytes_bytes_Bytes.
  
  Module Impl_core_hash_Hash_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn hash<H>(&self, state: &mut H)
        where
            H: hash::Hasher,
        {
            self.as_slice().hash(state);
        }
    *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "hash",
                    [],
                    [ H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (|
                            Ty.path "bytes::bytes::Bytes",
                            "as_slice",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_bytes_bytes_Bytes.
  
  Module Impl_core_borrow_Borrow_slice_u8_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn borrow(&self) -> &[u8] {
            self.as_slice()
        }
    *)
    Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "as_slice", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::borrow::Borrow"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
  End Impl_core_borrow_Borrow_slice_u8_for_bytes_bytes_Bytes.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*     type Item = u8; *)
    Definition _Item : Ty.t := Ty.path "u8".
    
    (*     type IntoIter = IntoIter<Bytes>; *)
    Definition _IntoIter : Ty.t :=
      Ty.apply (Ty.path "bytes::buf::iter::IntoIter") [] [ Ty.path "bytes::bytes::Bytes" ].
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            IntoIter::new(self)
        }
    *)
    Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "bytes::buf::iter::IntoIter") [] [ Ty.path "bytes::bytes::Bytes" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "bytes::buf::iter::IntoIter") [] [ Ty.path "bytes::bytes::Bytes" ],
              "new",
              [],
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("Item", InstanceField.Ty _Item);
          ("IntoIter", InstanceField.Ty _IntoIter);
          ("into_iter", InstanceField.Method into_iter)
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_bytes_bytes_Bytes.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_ref__bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ].
    
    (*     type Item = &'a u8; *)
    Definition _Item : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "u8" ].
    
    (*     type IntoIter = core::slice::Iter<'a, u8>; *)
    Definition _IntoIter : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ].
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            self.as_slice().iter()
        }
    *)
    Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              "iter",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("Item", InstanceField.Ty _Item);
          ("IntoIter", InstanceField.Ty _IntoIter);
          ("into_iter", InstanceField.Method into_iter)
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_ref__bytes_bytes_Bytes.
  
  Module Impl_core_iter_traits_collect_FromIterator_u8_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn from_iter<T: IntoIterator<Item = u8>>(into_iter: T) -> Self {
            Vec::from_iter(into_iter).into()
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ into_iter ] =>
        ltac:(M.monadic
          (let into_iter := M.alloc (| into_iter |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
              [],
              [ Ty.path "bytes::bytes::Bytes" ],
              "into",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  [],
                  [ Ty.path "u8" ],
                  "from_iter",
                  [],
                  [ T ]
                |),
                [ M.read (| into_iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        Self
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_u8_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            self.as_slice() == other.as_slice()
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn partial_cmp(&self, other: &Bytes) -> Option<cmp::Ordering> {
            self.as_slice().partial_cmp(other.as_slice())
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_Ord_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn cmp(&self, other: &Bytes) -> cmp::Ordering {
            self.as_slice().cmp(other.as_slice())
        }
    *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [],
              "cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_Eq_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_cmp_Eq_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_slice_u8_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn eq(&self, other: &[u8]) -> bool {
            self.as_slice() == other
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, other |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_slice_u8_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialOrd_slice_u8_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering> {
            self.as_slice().partial_cmp(other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_slice_u8_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_slice_u8.
    Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_slice_u8.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_slice_u8.
    Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
    
    (*
        fn partial_cmp(&self, other: &Bytes) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self, other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes::Bytes",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_slice_u8.
  
  Module Impl_core_cmp_PartialEq_str_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn eq(&self, other: &str) -> bool {
            self.as_slice() == other.as_bytes()
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "str" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_str_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialOrd_str_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {
            self.as_slice().partial_cmp(other.as_bytes())
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "str" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_str_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_str.
    Definition Self : Ty.t := Ty.path "str".
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ Ty.path "str" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_str.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_str.
    Definition Self : Ty.t := Ty.path "str".
    
    (*
        fn partial_cmp(&self, other: &Bytes) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes::Bytes",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_str.
  
  Module Impl_core_cmp_PartialEq_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn eq(&self, other: &Vec<u8>) -> bool {
            *self == other[..]
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialOrd_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn partial_cmp(&self, other: &Vec<u8>) -> Option<cmp::Ordering> {
            self.as_slice().partial_cmp(&other[..])
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.path "core::ops::range::RangeFull" ],
                          "index",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
                          Value.StructTuple "core::ops::range::RangeFull" [] [] []
                        ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn partial_cmp(&self, other: &Bytes) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self, other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes::Bytes",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  Module Impl_core_cmp_PartialEq_alloc_string_String_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn eq(&self, other: &String) -> bool {
            *self == other[..]
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ Ty.path "str" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_alloc_string_String_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialOrd_alloc_string_String_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {
            self.as_slice().partial_cmp(other.as_bytes())
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes::Bytes",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "alloc::string::String",
                      "as_bytes",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_alloc_string_String_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_alloc_string_String.
    Definition Self : Ty.t := Ty.path "alloc::string::String".
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ Ty.path "alloc::string::String" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_alloc_string_String.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_alloc_string_String.
    Definition Self : Ty.t := Ty.path "alloc::string::String".
    
    (*
        fn partial_cmp(&self, other: &Bytes) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "alloc::string::String",
                      "as_bytes",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes::Bytes",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_alloc_string_String.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_ref__slice_u8.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_ref__slice_u8.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_ref__slice_u8.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
    
    (*
        fn partial_cmp(&self, other: &Bytes) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self, other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes::Bytes",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_ref__slice_u8.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_ref__str.
    Definition Self : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "str" ].
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_ref__str.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_ref__str.
    Definition Self : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "str" ].
    
    (*
        fn partial_cmp(&self, other: &Bytes) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                      |)
                    ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes::Bytes",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_Bytes_for_ref__str.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_bytes_bytes_Bytes_T_ref__T_for_bytes_bytes_Bytes.
    Definition Self (T : Ty.t) : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn eq(&self, other: &&'a T) -> bool {
            *self == **other
        }
    *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ T ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_bytes_bytes_Bytes_T_ref__T_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_bytes_bytes_Bytes_T_ref__T_for_bytes_bytes_Bytes.
    Definition Self (T : Ty.t) : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering> {
            self.partial_cmp(&**other)
        }
    *)
    Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "bytes::bytes::Bytes",
              [],
              [ T ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_bytes_bytes_Bytes_T_ref__T_for_bytes_bytes_Bytes.
  
  Module Impl_core_default_Default_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn default() -> Bytes {
            Bytes::new()
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "new", [], [] |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_bytes_bytes_Bytes.
  
  Module Impl_core_convert_From_ref__slice_u8_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn from(slice: &'static [u8]) -> Bytes {
            Bytes::from_static(slice)
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "from_static", [], [] |),
            [ M.read (| slice |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__slice_u8_for_bytes_bytes_Bytes.
  
  Module Impl_core_convert_From_ref__str_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn from(slice: &'static str) -> Bytes {
            Bytes::from_static(slice.as_bytes())
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "from_static", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_bytes_bytes_Bytes.
  
  Module Impl_core_convert_From_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn from(vec: Vec<u8>) -> Bytes {
            let mut vec = ManuallyDrop::new(vec);
            let ptr = vec.as_mut_ptr();
            let len = vec.len();
            let cap = vec.capacity();
    
            // Avoid an extra allocation if possible.
            if len == cap {
                let vec = ManuallyDrop::into_inner(vec);
                return Bytes::from(vec.into_boxed_slice());
            }
    
            let shared = Box::new(Shared {
                buf: ptr,
                cap,
                ref_cnt: AtomicUsize::new(1),
            });
    
            let shared = Box::into_raw(shared);
            // The pointer should be aligned, so this assert should
            // always succeed.
            debug_assert!(
                0 == (shared as usize & KIND_MASK),
                "internal: Box<Shared> should have an aligned pointer",
            );
            Bytes {
                ptr,
                len,
                data: AtomicPtr::new(shared as _),
                vtable: &SHARED_VTABLE,
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ vec ] =>
        ltac:(M.monadic
          (let vec := M.alloc (| vec |) in
          M.catch_return (Ty.path "bytes::bytes::Bytes") (|
            ltac:(M.monadic
              (M.read (|
                let~ vec :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ],
                        "new",
                        [],
                        []
                      |),
                      [ M.read (| vec |) ]
                    |)
                  |) in
                let~ ptr :
                    Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        "as_mut_ptr",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::DerefMut",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ],
                                [],
                                [],
                                "deref_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, vec |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, vec |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        "capacity",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, vec |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| len |); M.read (| cap |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ vec :
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ] :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                          ],
                                        "into_inner",
                                        [],
                                        []
                                      |),
                                      [ M.read (| vec |) ]
                                    |)
                                  |) in
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_trait_method (|
                                      "core::convert::From",
                                      Ty.path "bytes::bytes::Bytes",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ],
                                      "from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                          "into_boxed_slice",
                                          [],
                                          []
                                        |),
                                        [ M.read (| vec |) ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ shared :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        []
                        [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        Value.StructRecord
                          "bytes::bytes::Shared"
                          []
                          []
                          [
                            ("buf", M.read (| ptr |));
                            ("cap", M.read (| cap |));
                            ("ref_cnt",
                              M.call_closure (|
                                Ty.path "core::sync::atomic::AtomicUsize",
                                M.get_associated_function (|
                                  Ty.path "core::sync::atomic::AtomicUsize",
                                  "new",
                                  [],
                                  []
                                |),
                                [ Value.Integer IntegerKind.Usize 1 ]
                              |))
                          ]
                      ]
                    |)
                  |) in
                let~ shared :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [ Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                        "into_raw",
                        [],
                        []
                      |),
                      [ M.read (| shared |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.eq,
                                              [
                                                Value.Integer IntegerKind.Usize 0;
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.bit_and,
                                                  [
                                                    M.cast (Ty.path "usize") (M.read (| shared |));
                                                    M.read (|
                                                      get_constant (|
                                                        "bytes::bytes::KIND_MASK",
                                                        Ty.path "usize"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "internal: Box<Shared> should have an aligned pointer"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "bytes::bytes::Bytes"
                    []
                    []
                    [
                      ("ptr", (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)));
                      ("len", M.read (| len |));
                      ("data",
                        M.call_closure (|
                          Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                            "new",
                            [],
                            []
                          |),
                          [
                            M.cast
                              (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                              (M.read (| shared |))
                          ]
                        |));
                      ("vtable",
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  get_constant (|
                                    "bytes::bytes::SHARED_VTABLE",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Vtable" ]
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
  
  Module Impl_core_convert_From_alloc_boxed_Box_slice_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn from(slice: Box<[u8]>) -> Bytes {
            // Box<[u8]> doesn't contain a heap allocation for empty slices,
            // so the pointer isn't aligned enough for the KIND_VEC stashing to
            // work.
            if slice.is_empty() {
                return Bytes::new();
            }
    
            let len = slice.len();
            let ptr = Box::into_raw(slice) as *mut u8;
    
            if ptr as usize & 0x1 == 0 {
                let data = ptr_map(ptr, |addr| addr | KIND_VEC);
                Bytes {
                    ptr,
                    len,
                    data: AtomicPtr::new(data.cast()),
                    vtable: &PROMOTABLE_EVEN_VTABLE,
                }
            } else {
                Bytes {
                    ptr,
                    len,
                    data: AtomicPtr::new(ptr.cast()),
                    vtable: &PROMOTABLE_ODD_VTABLE,
                }
            }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.catch_return (Ty.path "bytes::bytes::Bytes") (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                    "is_empty",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| slice |) |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "bytes::bytes::Bytes",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes::Bytes",
                                      "new",
                                      [],
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |)
                  |) in
                let~ ptr :
                    Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                  M.alloc (|
                    M.cast
                      (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                      (M.call_closure (|
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "into_raw",
                          [],
                          []
                        |),
                        [ M.read (| slice |) ]
                      |))
                  |) in
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.bit_and,
                                    [
                                      M.cast (Ty.path "usize") (M.read (| ptr |));
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 0
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ data :
                            Ty.apply
                              (Ty.path "*")
                              []
                              [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              M.get_function (|
                                "bytes::bytes::ptr_map",
                                [],
                                [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize") ]
                              |),
                              [
                                M.read (| ptr |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [ Ty.tuple [ Ty.path "usize" ] ]
                                                  (Ty.path "usize")
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let addr := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.bit_or,
                                                    [
                                                      M.read (| addr |);
                                                      M.read (|
                                                        get_constant (|
                                                          "bytes::bytes::KIND_VEC",
                                                          Ty.path "usize"
                                                        |)
                                                      |)
                                                    ]
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          |) in
                        M.alloc (|
                          Value.StructRecord
                            "bytes::bytes::Bytes"
                            []
                            []
                            [
                              ("ptr",
                                (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)));
                              ("len", M.read (| len |));
                              ("data",
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::sync::atomic::AtomicPtr")
                                    []
                                    [ Ty.tuple [] ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::sync::atomic::AtomicPtr")
                                      []
                                      [ Ty.tuple [] ],
                                    "new",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                        "cast",
                                        [],
                                        [ Ty.tuple [] ]
                                      |),
                                      [ M.read (| data |) ]
                                    |)
                                  ]
                                |));
                              ("vtable",
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          get_constant (|
                                            "bytes::bytes::PROMOTABLE_EVEN_VTABLE",
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.path "bytes::bytes::Vtable" ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |))
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructRecord
                            "bytes::bytes::Bytes"
                            []
                            []
                            [
                              ("ptr",
                                (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |)));
                              ("len", M.read (| len |));
                              ("data",
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::sync::atomic::AtomicPtr")
                                    []
                                    [ Ty.tuple [] ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::sync::atomic::AtomicPtr")
                                      []
                                      [ Ty.tuple [] ],
                                    "new",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                        "cast",
                                        [],
                                        [ Ty.tuple [] ]
                                      |),
                                      [ M.read (| ptr |) ]
                                    |)
                                  ]
                                |));
                              ("vtable",
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          get_constant (|
                                            "bytes::bytes::PROMOTABLE_ODD_VTABLE",
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.path "bytes::bytes::Vtable" ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                |))
                            ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [
          Ty.apply
            (Ty.path "alloc::boxed::Box")
            []
            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]; Ty.path "alloc::alloc::Global" ]
        ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_boxed_Box_slice_u8_alloc_alloc_Global_for_bytes_bytes_Bytes.
  
  Module Impl_core_convert_From_bytes_bytes_Bytes_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn from(bytes: Bytes) -> Self {
            let bytes = ManuallyDrop::new(bytes);
            unsafe { (bytes.vtable.to_mut)(&bytes.data, bytes.ptr, bytes.len) }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.read (|
            let~ bytes :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.path "bytes::bytes::Bytes" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.path "bytes::bytes::Bytes" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.path "bytes::bytes::Bytes" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| bytes |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bytes::bytes_mut::BytesMut",
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ Ty.path "bytes::bytes::Bytes" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                            |)
                          |),
                          "bytes::bytes::Bytes",
                          "vtable"
                        |)
                      |)
                    |),
                    "bytes::bytes::Vtable",
                    "to_mut"
                  |)
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ Ty.path "bytes::bytes::Bytes" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                            |)
                          |),
                          "bytes::bytes::Bytes",
                          "data"
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.path "bytes::bytes::Bytes" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                        |)
                      |),
                      "bytes::bytes::Bytes",
                      "ptr"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.path "bytes::bytes::Bytes" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                        |)
                      |),
                      "bytes::bytes::Bytes",
                      "len"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_bytes_bytes_Bytes_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_convert_From_alloc_string_String_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn from(s: String) -> Bytes {
            Bytes::from(s.into_bytes())
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "bytes::bytes::Bytes",
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
              "from",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.path "alloc::string::String",
                  "into_bytes",
                  [],
                  []
                |),
                [ M.read (| s |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_alloc_string_String_for_bytes_bytes_Bytes.
  
  Module Impl_core_convert_From_bytes_bytes_Bytes_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(bytes: Bytes) -> Vec<u8> {
            let bytes = ManuallyDrop::new(bytes);
            unsafe { (bytes.vtable.to_vec)(&bytes.data, bytes.ptr, bytes.len) }
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.read (|
            let~ bytes :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.path "bytes::bytes::Bytes" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.path "bytes::bytes::Bytes" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.path "bytes::bytes::Bytes" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| bytes |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ Ty.path "bytes::bytes::Bytes" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                            |)
                          |),
                          "bytes::bytes::Bytes",
                          "vtable"
                        |)
                      |)
                    |),
                    "bytes::bytes::Vtable",
                    "to_vec"
                  |)
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ Ty.path "bytes::bytes::Bytes" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                            |)
                          |),
                          "bytes::bytes::Bytes",
                          "data"
                        |)
                      |)
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.path "bytes::bytes::Bytes" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                        |)
                      |),
                      "bytes::bytes::Bytes",
                      "ptr"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Bytes" ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.path "bytes::bytes::Bytes" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                        |)
                      |),
                      "bytes::bytes::Bytes",
                      "len"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_bytes_bytes_Bytes_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  Module Impl_core_fmt_Debug_for_bytes_bytes_Vtable.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Vtable".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Vtable")
                .field("clone", &(self.clone as *const ()))
                .field("drop", &(self.drop as *const ()))
                .finish()
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugStruct",
              "finish",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugStruct",
                      "field",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "core::fmt::builders::DebugStruct" ],
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "core::fmt::builders::DebugStruct",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Formatter",
                                      "debug_struct",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| f |) |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "Vtable" |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "clone" |) |) |);
                              (* Unsize *)
                              M.pointer_coercion
                                (M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.cast
                                          (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "bytes::bytes::Vtable",
                                              "clone"
                                            |)
                                          |))
                                      |)
                                    |)
                                  |)
                                |))
                            ]
                          |)
                        |)
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "drop" |) |) |);
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.cast
                                  (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "bytes::bytes::Vtable",
                                      "drop"
                                    |)
                                  |))
                              |)
                            |)
                          |)
                        |))
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_bytes_bytes_Vtable.
  
  Definition value_STATIC_VTABLE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.StructRecord
          "bytes::bytes::Vtable"
          []
          []
          [
            ("clone",
              (* ReifyFnPointer *)
              M.pointer_coercion (M.get_function (| "bytes::bytes::static_clone", [], [] |)));
            ("to_vec",
              (* ReifyFnPointer *)
              M.pointer_coercion (M.get_function (| "bytes::bytes::static_to_vec", [], [] |)));
            ("to_mut",
              (* ReifyFnPointer *)
              M.pointer_coercion (M.get_function (| "bytes::bytes::static_to_mut", [], [] |)));
            ("is_unique",
              (* UnsafeFnPointer *)
              M.pointer_coercion
                (* ReifyFnPointer *)
                (M.pointer_coercion
                  (M.get_function (| "bytes::bytes::static_is_unique", [], [] |))));
            ("drop",
              (* ReifyFnPointer *)
              M.pointer_coercion (M.get_function (| "bytes::bytes::static_drop", [], [] |)))
          ]
      |))).
  
  Global Instance Instance_IsConstant_value_STATIC_VTABLE :
    M.IsFunction.C "bytes::bytes::STATIC_VTABLE" value_STATIC_VTABLE.
  Admitted.
  Global Typeclasses Opaque value_STATIC_VTABLE.
  
  (*
  unsafe fn static_clone(_: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {
      let slice = slice::from_raw_parts(ptr, len);
      Bytes::from_static(slice)
  }
  *)
  Definition static_clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ β0; ptr; len ] =>
      ltac:(M.monadic
        (let β0 := M.alloc (| β0 |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.match_operator (|
          Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ],
          β0,
          [
            fun γ =>
              ltac:(M.monadic
                (M.read (|
                  let~ slice :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_function (|
                          "core::slice::raw::from_raw_parts",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [ M.read (| ptr |); M.read (| len |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes::Bytes",
                        "from_static",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |)
                  |)
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_static_clone :
    M.IsFunction.C "bytes::bytes::static_clone" static_clone.
  Admitted.
  Global Typeclasses Opaque static_clone.
  
  (*
  unsafe fn static_to_vec(_: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Vec<u8> {
      let slice = slice::from_raw_parts(ptr, len);
      slice.to_vec()
  }
  *)
  Definition static_to_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ β0; ptr; len ] =>
      ltac:(M.monadic
        (let β0 := M.alloc (| β0 |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.match_operator (|
          Ty.apply
            (Ty.path "*")
            []
            [
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
            ],
          β0,
          [
            fun γ =>
              ltac:(M.monadic
                (M.read (|
                  let~ slice :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_function (|
                          "core::slice::raw::from_raw_parts",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [ M.read (| ptr |); M.read (| len |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "to_vec",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                    |)
                  |)
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_static_to_vec :
    M.IsFunction.C "bytes::bytes::static_to_vec" static_to_vec.
  Admitted.
  Global Typeclasses Opaque static_to_vec.
  
  (*
  unsafe fn static_to_mut(_: &AtomicPtr<()>, ptr: *const u8, len: usize) -> BytesMut {
      let slice = slice::from_raw_parts(ptr, len);
      BytesMut::from(slice)
  }
  *)
  Definition static_to_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ β0; ptr; len ] =>
      ltac:(M.monadic
        (let β0 := M.alloc (| β0 |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.match_operator (|
          Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ],
          β0,
          [
            fun γ =>
              ltac:(M.monadic
                (M.read (|
                  let~ slice :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_function (|
                          "core::slice::raw::from_raw_parts",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [ M.read (| ptr |); M.read (| len |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.path "bytes::bytes_mut::BytesMut",
                        [],
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                        ],
                        "from",
                        [],
                        []
                      |),
                      [ M.read (| slice |) ]
                    |)
                  |)
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_static_to_mut :
    M.IsFunction.C "bytes::bytes::static_to_mut" static_to_mut.
  Admitted.
  Global Typeclasses Opaque static_to_mut.
  
  (*
  fn static_is_unique(_: &AtomicPtr<()>) -> bool {
      false
  }
  *)
  Definition static_is_unique (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ β0 ] =>
      ltac:(M.monadic
        (let β0 := M.alloc (| β0 |) in
        M.match_operator (|
          Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
          β0,
          [ fun γ => ltac:(M.monadic (Value.Bool false)) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_static_is_unique :
    M.IsFunction.C "bytes::bytes::static_is_unique" static_is_unique.
  Admitted.
  Global Typeclasses Opaque static_is_unique.
  
  (*
  unsafe fn static_drop(_: &mut AtomicPtr<()>, _: *const u8, _: usize) {
      // nothing to drop for &'static [u8]
  }
  *)
  Definition static_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ β0; β1; β2 ] =>
      ltac:(M.monadic
        (let β0 := M.alloc (| β0 |) in
        let β1 := M.alloc (| β1 |) in
        let β2 := M.alloc (| β2 |) in
        M.match_operator (|
          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
          β0,
          [
            fun γ =>
              ltac:(M.monadic
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  β1,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          β2,
                          [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                        |)))
                  ]
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_static_drop :
    M.IsFunction.C "bytes::bytes::static_drop" static_drop.
  Admitted.
  Global Typeclasses Opaque static_drop.
  
  Definition value_PROMOTABLE_EVEN_VTABLE
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.alloc (|
          Value.StructRecord
            "bytes::bytes::Vtable"
            []
            []
            [
              ("clone",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_even_clone", [], [] |)));
              ("to_vec",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_even_to_vec", [], [] |)));
              ("to_mut",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_even_to_mut", [], [] |)));
              ("is_unique",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_is_unique", [], [] |)));
              ("drop",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_even_drop", [], [] |)))
            ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_PROMOTABLE_EVEN_VTABLE :
    M.IsFunction.C "bytes::bytes::PROMOTABLE_EVEN_VTABLE" value_PROMOTABLE_EVEN_VTABLE.
  Admitted.
  Global Typeclasses Opaque value_PROMOTABLE_EVEN_VTABLE.
  
  Definition value_PROMOTABLE_ODD_VTABLE
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.alloc (|
          Value.StructRecord
            "bytes::bytes::Vtable"
            []
            []
            [
              ("clone",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_odd_clone", [], [] |)));
              ("to_vec",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_odd_to_vec", [], [] |)));
              ("to_mut",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_odd_to_mut", [], [] |)));
              ("is_unique",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_is_unique", [], [] |)));
              ("drop",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes::promotable_odd_drop", [], [] |)))
            ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_PROMOTABLE_ODD_VTABLE :
    M.IsFunction.C "bytes::bytes::PROMOTABLE_ODD_VTABLE" value_PROMOTABLE_ODD_VTABLE.
  Admitted.
  Global Typeclasses Opaque value_PROMOTABLE_ODD_VTABLE.
  
  (*
  unsafe fn promotable_even_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {
      let shared = data.load(Ordering::Acquire);
      let kind = shared as usize & KIND_MASK;
  
      if kind == KIND_ARC {
          shallow_clone_arc(shared.cast(), ptr, len)
      } else {
          debug_assert_eq!(kind, KIND_VEC);
          let buf = ptr_map(shared.cast(), |addr| addr & !KIND_MASK);
          shallow_clone_vec(data, shared, buf, ptr, len)
      }
  }
  *)
  Definition promotable_even_clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |) in
          let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.bit_and,
                [
                  M.cast (Ty.path "usize") (M.read (| shared |));
                  M.read (| get_constant (| "bytes::bytes::KIND_MASK", Ty.path "usize" |) |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| kind |);
                            M.read (|
                              get_constant (| "bytes::bytes::KIND_ARC", Ty.path "usize" |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_function (| "bytes::bytes::shallow_clone_arc", [], [] |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            "cast",
                            [],
                            [ Ty.path "bytes::bytes::Shared" ]
                          |),
                          [ M.read (| shared |) ]
                        |);
                        M.read (| ptr |);
                        M.read (| len |)
                      ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.borrow (| Pointer.Kind.Ref, kind |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_constant (| "bytes::bytes::KIND_VEC", Ty.path "usize" |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "core::panicking::AssertKind"
                                                          ] :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                          []
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ buf :
                      Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_function (|
                          "bytes::bytes::ptr_map",
                          [],
                          [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize") ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                              "cast",
                              [],
                              [ Ty.path "u8" ]
                            |),
                            [ M.read (| shared |) ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [ Ty.tuple [ Ty.path "usize" ] ]
                                            (Ty.path "usize")
                                        ],
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let addr := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.path "usize",
                                              BinOp.Wrap.bit_and,
                                              [
                                                M.read (| addr |);
                                                UnOp.not (|
                                                  M.read (|
                                                    get_constant (|
                                                      "bytes::bytes::KIND_MASK",
                                                      Ty.path "usize"
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_function (| "bytes::bytes::shallow_clone_vec", [], [] |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                        (* MutToConstPointer *) M.pointer_coercion (M.read (| shared |));
                        M.read (| buf |);
                        M.read (| ptr |);
                        M.read (| len |)
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_even_clone :
    M.IsFunction.C "bytes::bytes::promotable_even_clone" promotable_even_clone.
  Admitted.
  Global Typeclasses Opaque promotable_even_clone.
  
  (*
  unsafe fn promotable_to_vec(
      data: &AtomicPtr<()>,
      ptr: *const u8,
      len: usize,
      f: fn( *mut ()) -> *mut u8,
  ) -> Vec<u8> {
      let shared = data.load(Ordering::Acquire);
      let kind = shared as usize & KIND_MASK;
  
      if kind == KIND_ARC {
          shared_to_vec_impl(shared.cast(), ptr, len)
      } else {
          // If Bytes holds a Vec, then the offset must be 0.
          debug_assert_eq!(kind, KIND_VEC);
  
          let buf = f(shared);
  
          let cap = offset_from(ptr, buf) + len;
  
          // Copy back buffer
          ptr::copy(ptr, buf, len);
  
          Vec::from_raw_parts(buf, len, cap)
      }
  }
  *)
  Definition promotable_to_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len; f ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        let f := M.alloc (| f |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |) in
          let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.bit_and,
                [
                  M.cast (Ty.path "usize") (M.read (| shared |));
                  M.read (| get_constant (| "bytes::bytes::KIND_MASK", Ty.path "usize" |) |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "*")
              []
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| kind |);
                            M.read (|
                              get_constant (| "bytes::bytes::KIND_ARC", Ty.path "usize" |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      M.get_function (| "bytes::bytes::shared_to_vec_impl", [], [] |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            "cast",
                            [],
                            [ Ty.path "bytes::bytes::Shared" ]
                          |),
                          [ M.read (| shared |) ]
                        |);
                        M.read (| ptr |);
                        M.read (| len |)
                      ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.borrow (| Pointer.Kind.Ref, kind |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_constant (| "bytes::bytes::KIND_VEC", Ty.path "usize" |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "core::panicking::AssertKind"
                                                          ] :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                          []
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ buf :
                      Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.read (| f |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "bytes::offset_from", [], [] |),
                            [
                              M.read (| ptr |);
                              (* MutToConstPointer *) M.pointer_coercion (M.read (| buf |))
                            ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::copy", [], [ Ty.path "u8" ] |),
                        [ M.read (| ptr |); M.read (| buf |); M.read (| len |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        "from_raw_parts",
                        [],
                        []
                      |),
                      [ M.read (| buf |); M.read (| len |); M.read (| cap |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_to_vec :
    M.IsFunction.C "bytes::bytes::promotable_to_vec" promotable_to_vec.
  Admitted.
  Global Typeclasses Opaque promotable_to_vec.
  
  (*
  unsafe fn promotable_to_mut(
      data: &AtomicPtr<()>,
      ptr: *const u8,
      len: usize,
      f: fn( *mut ()) -> *mut u8,
  ) -> BytesMut {
      let shared = data.load(Ordering::Acquire);
      let kind = shared as usize & KIND_MASK;
  
      if kind == KIND_ARC {
          shared_to_mut_impl(shared.cast(), ptr, len)
      } else {
          // KIND_VEC is a view of an underlying buffer at a certain offset.
          // The ptr + len always represents the end of that buffer.
          // Before truncating it, it is first promoted to KIND_ARC.
          // Thus, we can safely reconstruct a Vec from it without leaking memory.
          debug_assert_eq!(kind, KIND_VEC);
  
          let buf = f(shared);
          let off = offset_from(ptr, buf);
          let cap = off + len;
          let v = Vec::from_raw_parts(buf, cap, cap);
  
          let mut b = BytesMut::from_vec(v);
          b.advance_unchecked(off);
          b
      }
  }
  *)
  Definition promotable_to_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len; f ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        let f := M.alloc (| f |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |) in
          let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.bit_and,
                [
                  M.cast (Ty.path "usize") (M.read (| shared |));
                  M.read (| get_constant (| "bytes::bytes::KIND_MASK", Ty.path "usize" |) |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| kind |);
                            M.read (|
                              get_constant (| "bytes::bytes::KIND_ARC", Ty.path "usize" |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      M.get_function (| "bytes::bytes::shared_to_mut_impl", [], [] |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            "cast",
                            [],
                            [ Ty.path "bytes::bytes::Shared" ]
                          |),
                          [ M.read (| shared |) ]
                        |);
                        M.read (| ptr |);
                        M.read (| len |)
                      ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.borrow (| Pointer.Kind.Ref, kind |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_constant (| "bytes::bytes::KIND_VEC", Ty.path "usize" |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "core::panicking::AssertKind"
                                                          ] :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                          []
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ buf :
                      Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.read (| f |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  let~ off : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_function (| "bytes::offset_from", [], [] |),
                        [
                          M.read (| ptr |);
                          (* MutToConstPointer *) M.pointer_coercion (M.read (| buf |))
                        ]
                      |)
                    |) in
                  let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [ M.read (| off |); M.read (| len |) ]
                      |)
                    |) in
                  let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "from_raw_parts",
                          [],
                          []
                        |),
                        [ M.read (| buf |); M.read (| cap |); M.read (| cap |) ]
                      |)
                    |) in
                  let~ b : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        M.get_associated_function (|
                          Ty.path "bytes::bytes_mut::BytesMut",
                          "from_vec",
                          [],
                          []
                        |),
                        [ M.read (| v |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.path "bytes::bytes_mut::BytesMut",
                          "advance_unchecked",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, b |); M.read (| off |) ]
                      |)
                    |) in
                  b))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_to_mut :
    M.IsFunction.C "bytes::bytes::promotable_to_mut" promotable_to_mut.
  Admitted.
  Global Typeclasses Opaque promotable_to_mut.
  
  (*
  unsafe fn promotable_even_to_vec(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Vec<u8> {
      promotable_to_vec(data, ptr, len, |shared| {
          ptr_map(shared.cast(), |addr| addr & !KIND_MASK)
      })
  }
  *)
  Definition promotable_even_to_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.call_closure (|
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
          M.get_function (| "bytes::bytes::promotable_to_vec", [], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
            M.read (| ptr |);
            M.read (| len |);
            (* ClosureFnPointer(Safe) *)
            M.pointer_coercion
              (M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] ]
                                (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let shared := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                  M.get_function (|
                                    "bytes::bytes::ptr_map",
                                    [],
                                    [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                        "cast",
                                        [],
                                        [ Ty.path "u8" ]
                                      |),
                                      [ M.read (| shared |) ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.function
                                                      [ Ty.tuple [ Ty.path "usize" ] ]
                                                      (Ty.path "usize")
                                                  ],
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let addr := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.bit_and,
                                                        [
                                                          M.read (| addr |);
                                                          UnOp.not (|
                                                            M.read (|
                                                              get_constant (|
                                                                "bytes::bytes::KIND_MASK",
                                                                Ty.path "usize"
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_even_to_vec :
    M.IsFunction.C "bytes::bytes::promotable_even_to_vec" promotable_even_to_vec.
  Admitted.
  Global Typeclasses Opaque promotable_even_to_vec.
  
  (*
  unsafe fn promotable_even_to_mut(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> BytesMut {
      promotable_to_mut(data, ptr, len, |shared| {
          ptr_map(shared.cast(), |addr| addr & !KIND_MASK)
      })
  }
  *)
  Definition promotable_even_to_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.call_closure (|
          Ty.path "bytes::bytes_mut::BytesMut",
          M.get_function (| "bytes::bytes::promotable_to_mut", [], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
            M.read (| ptr |);
            M.read (| len |);
            (* ClosureFnPointer(Safe) *)
            M.pointer_coercion
              (M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] ]
                                (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let shared := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                  M.get_function (|
                                    "bytes::bytes::ptr_map",
                                    [],
                                    [ Ty.function [ Ty.tuple [ Ty.path "usize" ] ] (Ty.path "usize")
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                        "cast",
                                        [],
                                        [ Ty.path "u8" ]
                                      |),
                                      [ M.read (| shared |) ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.function
                                                      [ Ty.tuple [ Ty.path "usize" ] ]
                                                      (Ty.path "usize")
                                                  ],
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let addr := M.copy (| γ |) in
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.bit_and,
                                                        [
                                                          M.read (| addr |);
                                                          UnOp.not (|
                                                            M.read (|
                                                              get_constant (|
                                                                "bytes::bytes::KIND_MASK",
                                                                Ty.path "usize"
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_even_to_mut :
    M.IsFunction.C "bytes::bytes::promotable_even_to_mut" promotable_even_to_mut.
  Admitted.
  Global Typeclasses Opaque promotable_even_to_mut.
  
  (*
  unsafe fn promotable_even_drop(data: &mut AtomicPtr<()>, ptr: *const u8, len: usize) {
      data.with_mut(|shared| {
          let shared = *shared;
          let kind = shared as usize & KIND_MASK;
  
          if kind == KIND_ARC {
              release_shared(shared.cast());
          } else {
              debug_assert_eq!(kind, KIND_VEC);
              let buf = ptr_map(shared.cast(), |addr| addr & !KIND_MASK);
              free_boxed_slice(buf, ptr, len);
          }
      });
  }
  *)
  Definition promotable_even_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "bytes::loom::sync::atomic::AtomicMut",
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  [],
                  [ Ty.tuple [] ],
                  "with_mut",
                  [],
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                          ]
                      ]
                      (Ty.tuple []);
                    Ty.tuple []
                  ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                                        ]
                                    ]
                                    (Ty.tuple [])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let shared := M.copy (| γ |) in
                                    M.read (|
                                      let~ shared :
                                          Ty.apply
                                            (Ty.path "*")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
                                        M.copy (| M.deref (| M.read (| shared |) |) |) in
                                      let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.bit_and,
                                            [
                                              M.cast (Ty.path "usize") (M.read (| shared |));
                                              M.read (|
                                                get_constant (|
                                                  "bytes::bytes::KIND_MASK",
                                                  Ty.path "usize"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (| kind |);
                                                        M.read (|
                                                          get_constant (|
                                                            "bytes::bytes::KIND_ARC",
                                                            Ty.path "usize"
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_function (|
                                                      "bytes::bytes::release_shared",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [ Ty.path "bytes::bytes::Shared" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [ Ty.tuple [] ],
                                                          "cast",
                                                          [],
                                                          [ Ty.path "bytes::bytes::Shared" ]
                                                        |),
                                                        [ M.read (| shared |) ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.match_operator (|
                                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use (M.alloc (| Value.Bool true |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        let~ _ :
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ] :=
                                                          M.match_operator (|
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ],
                                                            M.alloc (|
                                                              Value.Tuple
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    kind
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    get_constant (|
                                                                      "bytes::bytes::KIND_VEC",
                                                                      Ty.path "usize"
                                                                    |)
                                                                  |)
                                                                ]
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let left_val :=
                                                                    M.copy (| γ0_0 |) in
                                                                  let right_val :=
                                                                    M.copy (| γ0_1 |) in
                                                                  M.match_operator (|
                                                                    Ty.apply
                                                                      (Ty.path "*")
                                                                      []
                                                                      [ Ty.tuple [] ],
                                                                    M.alloc (| Value.Tuple [] |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let γ :=
                                                                            M.use
                                                                              (M.alloc (|
                                                                                UnOp.not (|
                                                                                  M.call_closure (|
                                                                                    Ty.path "bool",
                                                                                    BinOp.eq,
                                                                                    [
                                                                                      M.read (|
                                                                                        M.deref (|
                                                                                          M.read (|
                                                                                            left_val
                                                                                          |)
                                                                                        |)
                                                                                      |);
                                                                                      M.read (|
                                                                                        M.deref (|
                                                                                          M.read (|
                                                                                            right_val
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                |)
                                                                              |)) in
                                                                          let _ :=
                                                                            is_constant_or_break_match (|
                                                                              M.read (| γ |),
                                                                              Value.Bool true
                                                                            |) in
                                                                          M.alloc (|
                                                                            M.never_to_any (|
                                                                              M.read (|
                                                                                let~ kind :
                                                                                    Ty.apply
                                                                                      (Ty.path "*")
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "core::panicking::AssertKind"
                                                                                      ] :=
                                                                                  M.alloc (|
                                                                                    Value.StructTuple
                                                                                      "core::panicking::AssertKind::Eq"
                                                                                      []
                                                                                      []
                                                                                      []
                                                                                  |) in
                                                                                M.alloc (|
                                                                                  M.call_closure (|
                                                                                    Ty.path "never",
                                                                                    M.get_function (|
                                                                                      "core::panicking::assert_failed",
                                                                                      [],
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize";
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ]
                                                                                    |),
                                                                                    [
                                                                                      M.read (|
                                                                                        kind
                                                                                      |);
                                                                                      M.borrow (|
                                                                                        Pointer.Kind.Ref,
                                                                                        M.deref (|
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                left_val
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |);
                                                                                      M.borrow (|
                                                                                        Pointer.Kind.Ref,
                                                                                        M.deref (|
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                right_val
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |);
                                                                                      Value.StructTuple
                                                                                        "core::option::Option::None"
                                                                                        []
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::Arguments"
                                                                                        ]
                                                                                        []
                                                                                    ]
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)));
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (M.alloc (|
                                                                            Value.Tuple []
                                                                          |)))
                                                                    ]
                                                                  |)))
                                                            ]
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |) in
                                              let~ buf :
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ]
                                                    ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                                    M.get_function (|
                                                      "bytes::bytes::ptr_map",
                                                      [],
                                                      [
                                                        Ty.function
                                                          [ Ty.tuple [ Ty.path "usize" ] ]
                                                          (Ty.path "usize")
                                                      ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [ Ty.tuple [] ],
                                                          "cast",
                                                          [],
                                                          [ Ty.path "u8" ]
                                                        |),
                                                        [ M.read (| shared |) ]
                                                      |);
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              ltac:(M.monadic
                                                                (M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path "*")
                                                                    []
                                                                    [
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [ Ty.path "usize" ]
                                                                        ]
                                                                        (Ty.path "usize")
                                                                    ],
                                                                  M.alloc (| α0 |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let addr :=
                                                                          M.copy (| γ |) in
                                                                        M.call_closure (|
                                                                          Ty.path "usize",
                                                                          BinOp.Wrap.bit_and,
                                                                          [
                                                                            M.read (| addr |);
                                                                            UnOp.not (|
                                                                              M.read (|
                                                                                get_constant (|
                                                                                  "bytes::bytes::KIND_MASK",
                                                                                  Ty.path "usize"
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |)))
                                                                  ]
                                                                |)))
                                                            | _ =>
                                                              M.impossible
                                                                "wrong number of arguments"
                                                            end))
                                                    ]
                                                  |)
                                                |) in
                                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_function (|
                                                      "bytes::bytes::free_boxed_slice",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.read (| buf |);
                                                      M.read (| ptr |);
                                                      M.read (| len |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_even_drop :
    M.IsFunction.C "bytes::bytes::promotable_even_drop" promotable_even_drop.
  Admitted.
  Global Typeclasses Opaque promotable_even_drop.
  
  (*
  unsafe fn promotable_odd_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {
      let shared = data.load(Ordering::Acquire);
      let kind = shared as usize & KIND_MASK;
  
      if kind == KIND_ARC {
          shallow_clone_arc(shared as _, ptr, len)
      } else {
          debug_assert_eq!(kind, KIND_VEC);
          shallow_clone_vec(data, shared, shared.cast(), ptr, len)
      }
  }
  *)
  Definition promotable_odd_clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |) in
          let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.bit_and,
                [
                  M.cast (Ty.path "usize") (M.read (| shared |));
                  M.read (| get_constant (| "bytes::bytes::KIND_MASK", Ty.path "usize" |) |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| kind |);
                            M.read (|
                              get_constant (| "bytes::bytes::KIND_ARC", Ty.path "usize" |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_function (| "bytes::bytes::shallow_clone_arc", [], [] |),
                      [
                        M.cast
                          (Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ])
                          (M.read (| shared |));
                        M.read (| ptr |);
                        M.read (| len |)
                      ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.borrow (| Pointer.Kind.Ref, kind |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_constant (| "bytes::bytes::KIND_VEC", Ty.path "usize" |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "core::panicking::AssertKind"
                                                          ] :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                          []
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_function (| "bytes::bytes::shallow_clone_vec", [], [] |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                        (* MutToConstPointer *) M.pointer_coercion (M.read (| shared |));
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            "cast",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| shared |) ]
                        |);
                        M.read (| ptr |);
                        M.read (| len |)
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_odd_clone :
    M.IsFunction.C "bytes::bytes::promotable_odd_clone" promotable_odd_clone.
  Admitted.
  Global Typeclasses Opaque promotable_odd_clone.
  
  (*
  unsafe fn promotable_odd_to_vec(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Vec<u8> {
      promotable_to_vec(data, ptr, len, |shared| shared.cast())
  }
  *)
  Definition promotable_odd_to_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.call_closure (|
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
          M.get_function (| "bytes::bytes::promotable_to_vec", [], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
            M.read (| ptr |);
            M.read (| len |);
            (* ClosureFnPointer(Safe) *)
            M.pointer_coercion
              (M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] ]
                                (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let shared := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                    "cast",
                                    [],
                                    [ Ty.path "u8" ]
                                  |),
                                  [ M.read (| shared |) ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_odd_to_vec :
    M.IsFunction.C "bytes::bytes::promotable_odd_to_vec" promotable_odd_to_vec.
  Admitted.
  Global Typeclasses Opaque promotable_odd_to_vec.
  
  (*
  unsafe fn promotable_odd_to_mut(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> BytesMut {
      promotable_to_mut(data, ptr, len, |shared| shared.cast())
  }
  *)
  Definition promotable_odd_to_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.call_closure (|
          Ty.path "bytes::bytes_mut::BytesMut",
          M.get_function (| "bytes::bytes::promotable_to_mut", [], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
            M.read (| ptr |);
            M.read (| len |);
            (* ClosureFnPointer(Safe) *)
            M.pointer_coercion
              (M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] ]
                                (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let shared := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                    "cast",
                                    [],
                                    [ Ty.path "u8" ]
                                  |),
                                  [ M.read (| shared |) ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_odd_to_mut :
    M.IsFunction.C "bytes::bytes::promotable_odd_to_mut" promotable_odd_to_mut.
  Admitted.
  Global Typeclasses Opaque promotable_odd_to_mut.
  
  (*
  unsafe fn promotable_odd_drop(data: &mut AtomicPtr<()>, ptr: *const u8, len: usize) {
      data.with_mut(|shared| {
          let shared = *shared;
          let kind = shared as usize & KIND_MASK;
  
          if kind == KIND_ARC {
              release_shared(shared.cast());
          } else {
              debug_assert_eq!(kind, KIND_VEC);
  
              free_boxed_slice(shared.cast(), ptr, len);
          }
      });
  }
  *)
  Definition promotable_odd_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "bytes::loom::sync::atomic::AtomicMut",
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  [],
                  [ Ty.tuple [] ],
                  "with_mut",
                  [],
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                          ]
                      ]
                      (Ty.tuple []);
                    Ty.tuple []
                  ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                                        ]
                                    ]
                                    (Ty.tuple [])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let shared := M.copy (| γ |) in
                                    M.read (|
                                      let~ shared :
                                          Ty.apply
                                            (Ty.path "*")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
                                        M.copy (| M.deref (| M.read (| shared |) |) |) in
                                      let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.bit_and,
                                            [
                                              M.cast (Ty.path "usize") (M.read (| shared |));
                                              M.read (|
                                                get_constant (|
                                                  "bytes::bytes::KIND_MASK",
                                                  Ty.path "usize"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (| kind |);
                                                        M.read (|
                                                          get_constant (|
                                                            "bytes::bytes::KIND_ARC",
                                                            Ty.path "usize"
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_function (|
                                                      "bytes::bytes::release_shared",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [ Ty.path "bytes::bytes::Shared" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [ Ty.tuple [] ],
                                                          "cast",
                                                          [],
                                                          [ Ty.path "bytes::bytes::Shared" ]
                                                        |),
                                                        [ M.read (| shared |) ]
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.match_operator (|
                                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                  M.alloc (| Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use (M.alloc (| Value.Bool true |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        let~ _ :
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ] :=
                                                          M.match_operator (|
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ],
                                                            M.alloc (|
                                                              Value.Tuple
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    kind
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    get_constant (|
                                                                      "bytes::bytes::KIND_VEC",
                                                                      Ty.path "usize"
                                                                    |)
                                                                  |)
                                                                ]
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let left_val :=
                                                                    M.copy (| γ0_0 |) in
                                                                  let right_val :=
                                                                    M.copy (| γ0_1 |) in
                                                                  M.match_operator (|
                                                                    Ty.apply
                                                                      (Ty.path "*")
                                                                      []
                                                                      [ Ty.tuple [] ],
                                                                    M.alloc (| Value.Tuple [] |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let γ :=
                                                                            M.use
                                                                              (M.alloc (|
                                                                                UnOp.not (|
                                                                                  M.call_closure (|
                                                                                    Ty.path "bool",
                                                                                    BinOp.eq,
                                                                                    [
                                                                                      M.read (|
                                                                                        M.deref (|
                                                                                          M.read (|
                                                                                            left_val
                                                                                          |)
                                                                                        |)
                                                                                      |);
                                                                                      M.read (|
                                                                                        M.deref (|
                                                                                          M.read (|
                                                                                            right_val
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                |)
                                                                              |)) in
                                                                          let _ :=
                                                                            is_constant_or_break_match (|
                                                                              M.read (| γ |),
                                                                              Value.Bool true
                                                                            |) in
                                                                          M.alloc (|
                                                                            M.never_to_any (|
                                                                              M.read (|
                                                                                let~ kind :
                                                                                    Ty.apply
                                                                                      (Ty.path "*")
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "core::panicking::AssertKind"
                                                                                      ] :=
                                                                                  M.alloc (|
                                                                                    Value.StructTuple
                                                                                      "core::panicking::AssertKind::Eq"
                                                                                      []
                                                                                      []
                                                                                      []
                                                                                  |) in
                                                                                M.alloc (|
                                                                                  M.call_closure (|
                                                                                    Ty.path "never",
                                                                                    M.get_function (|
                                                                                      "core::panicking::assert_failed",
                                                                                      [],
                                                                                      [
                                                                                        Ty.path
                                                                                          "usize";
                                                                                        Ty.path
                                                                                          "usize"
                                                                                      ]
                                                                                    |),
                                                                                    [
                                                                                      M.read (|
                                                                                        kind
                                                                                      |);
                                                                                      M.borrow (|
                                                                                        Pointer.Kind.Ref,
                                                                                        M.deref (|
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                left_val
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |);
                                                                                      M.borrow (|
                                                                                        Pointer.Kind.Ref,
                                                                                        M.deref (|
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.read (|
                                                                                                right_val
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |);
                                                                                      Value.StructTuple
                                                                                        "core::option::Option::None"
                                                                                        []
                                                                                        [
                                                                                          Ty.path
                                                                                            "core::fmt::Arguments"
                                                                                        ]
                                                                                        []
                                                                                    ]
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)));
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (M.alloc (|
                                                                            Value.Tuple []
                                                                          |)))
                                                                    ]
                                                                  |)))
                                                            ]
                                                          |) in
                                                        M.alloc (| Value.Tuple [] |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Tuple [] |)))
                                                  ]
                                                |) in
                                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_function (|
                                                      "bytes::bytes::free_boxed_slice",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [ Ty.tuple [] ],
                                                          "cast",
                                                          [],
                                                          [ Ty.path "u8" ]
                                                        |),
                                                        [ M.read (| shared |) ]
                                                      |);
                                                      M.read (| ptr |);
                                                      M.read (| len |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_odd_drop :
    M.IsFunction.C "bytes::bytes::promotable_odd_drop" promotable_odd_drop.
  Admitted.
  Global Typeclasses Opaque promotable_odd_drop.
  
  (*
  unsafe fn promotable_is_unique(data: &AtomicPtr<()>) -> bool {
      let shared = data.load(Ordering::Acquire);
      let kind = shared as usize & KIND_MASK;
  
      if kind == KIND_ARC {
          let ref_cnt = ( *shared.cast::<Shared>()).ref_cnt.load(Ordering::Relaxed);
          ref_cnt == 1
      } else {
          true
      }
  }
  *)
  Definition promotable_is_unique (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |) in
          let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.bit_and,
                [
                  M.cast (Ty.path "usize") (M.read (| shared |));
                  M.read (| get_constant (| "bytes::bytes::KIND_MASK", Ty.path "usize" |) |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| kind |);
                            M.read (|
                              get_constant (| "bytes::bytes::KIND_ARC", Ty.path "usize" |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ ref_cnt : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          "load",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                    "cast",
                                    [],
                                    [ Ty.path "bytes::bytes::Shared" ]
                                  |),
                                  [ M.read (| shared |) ]
                                |)
                              |),
                              "bytes::bytes::Shared",
                              "ref_cnt"
                            |)
                          |);
                          Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.eq,
                      [ M.read (| ref_cnt |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_promotable_is_unique :
    M.IsFunction.C "bytes::bytes::promotable_is_unique" promotable_is_unique.
  Admitted.
  Global Typeclasses Opaque promotable_is_unique.
  
  (*
  unsafe fn free_boxed_slice(buf: *mut u8, offset: *const u8, len: usize) {
      let cap = offset_from(offset, buf) + len;
      dealloc(buf, Layout::from_size_align(cap, 1).unwrap())
  }
  *)
  Definition free_boxed_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ buf; offset; len ] =>
      ltac:(M.monadic
        (let buf := M.alloc (| buf |) in
        let offset := M.alloc (| offset |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (| "bytes::offset_from", [], [] |),
                    [
                      M.read (| offset |);
                      (* MutToConstPointer *) M.pointer_coercion (M.read (| buf |))
                    ]
                  |);
                  M.read (| len |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "alloc::alloc::dealloc", [], [] |),
              [
                M.read (| buf |);
                M.call_closure (|
                  Ty.path "core::alloc::layout::Layout",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "core::alloc::layout::Layout";
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "core::alloc::layout::Layout";
                          Ty.path "core::alloc::layout::LayoutError"
                        ],
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "from_size_align",
                        [],
                        []
                      |),
                      [ M.read (| cap |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  ]
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_free_boxed_slice :
    M.IsFunction.C "bytes::bytes::free_boxed_slice" free_boxed_slice.
  Admitted.
  Global Typeclasses Opaque free_boxed_slice.
  
  (* StructRecord
    {
      name := "Shared";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("buf", Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ]);
          ("cap", Ty.path "usize");
          ("ref_cnt", Ty.path "core::sync::atomic::AtomicUsize")
        ];
    } *)
  
  Module Impl_core_ops_drop_Drop_for_bytes_bytes_Shared.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Shared".
    
    (*
        fn drop(&mut self) {
            unsafe { dealloc(self.buf, Layout::from_size_align(self.cap, 1).unwrap()) }
        }
    *)
    Definition drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_function (| "alloc::alloc::dealloc", [], [] |),
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "bytes::bytes::Shared",
                  "buf"
                |)
              |);
              M.call_closure (|
                Ty.path "core::alloc::layout::Layout",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "core::alloc::layout::Layout";
                      Ty.path "core::alloc::layout::LayoutError"
                    ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.path "core::alloc::layout::Layout";
                        Ty.path "core::alloc::layout::LayoutError"
                      ],
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "from_size_align",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "bytes::bytes::Shared",
                          "cap"
                        |)
                      |);
                      Value.Integer IntegerKind.Usize 1
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("drop", InstanceField.Method drop) ].
  End Impl_core_ops_drop_Drop_for_bytes_bytes_Shared.
  
  Definition value_SHARED_VTABLE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.alloc (|
          Value.StructRecord
            "bytes::bytes::Vtable"
            []
            []
            [
              ("clone",
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_function (| "bytes::bytes::shared_clone", [], [] |)));
              ("to_vec",
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_function (| "bytes::bytes::shared_to_vec", [], [] |)));
              ("to_mut",
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_function (| "bytes::bytes::shared_to_mut", [], [] |)));
              ("is_unique",
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_function (| "bytes::bytes::shared_is_unique", [], [] |)));
              ("drop",
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_function (| "bytes::bytes::shared_drop", [], [] |)))
            ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_SHARED_VTABLE :
    M.IsFunction.C "bytes::bytes::SHARED_VTABLE" value_SHARED_VTABLE.
  Admitted.
  Global Typeclasses Opaque value_SHARED_VTABLE.
  
  Definition value_KIND_ARC (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |))).
  
  Global Instance Instance_IsConstant_value_KIND_ARC :
    M.IsFunction.C "bytes::bytes::KIND_ARC" value_KIND_ARC.
  Admitted.
  Global Typeclasses Opaque value_KIND_ARC.
  
  Definition value_KIND_VEC (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1 |))).
  
  Global Instance Instance_IsConstant_value_KIND_VEC :
    M.IsFunction.C "bytes::bytes::KIND_VEC" value_KIND_VEC.
  Admitted.
  Global Typeclasses Opaque value_KIND_VEC.
  
  Definition value_KIND_MASK (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1 |))).
  
  Global Instance Instance_IsConstant_value_KIND_MASK :
    M.IsFunction.C "bytes::bytes::KIND_MASK" value_KIND_MASK.
  Admitted.
  Global Typeclasses Opaque value_KIND_MASK.
  
  (*
  unsafe fn shared_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {
      let shared = data.load(Ordering::Relaxed);
      shallow_clone_arc(shared as _, ptr, len)
  }
  *)
  Definition shared_clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "bytes::bytes::Bytes",
              M.get_function (| "bytes::bytes::shallow_clone_arc", [], [] |),
              [
                M.cast
                  (Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ])
                  (M.read (| shared |));
                M.read (| ptr |);
                M.read (| len |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_clone :
    M.IsFunction.C "bytes::bytes::shared_clone" shared_clone.
  Admitted.
  Global Typeclasses Opaque shared_clone.
  
  (*
  unsafe fn shared_to_vec_impl(shared: *mut Shared, ptr: *const u8, len: usize) -> Vec<u8> {
      // Check that the ref_cnt is 1 (unique).
      //
      // If it is unique, then it is set to 0 with AcqRel fence for the same
      // reason in release_shared.
      //
      // Otherwise, we take the other branch and call release_shared.
      if ( *shared)
          .ref_cnt
          .compare_exchange(1, 0, Ordering::AcqRel, Ordering::Relaxed)
          .is_ok()
      {
          // Deallocate the `Shared` instance without running its destructor.
          let shared = *Box::from_raw(shared);
          let shared = ManuallyDrop::new(shared);
          let buf = shared.buf;
          let cap = shared.cap;
  
          // Copy back buffer
          ptr::copy(ptr, buf, len);
  
          Vec::from_raw_parts(buf, len, cap)
      } else {
          let v = slice::from_raw_parts(ptr, len).to_vec();
          release_shared(shared);
          v
      }
  }
  *)
  Definition shared_to_vec_impl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ shared; ptr; len ] =>
      ltac:(M.monadic
        (let shared := M.alloc (| shared |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          M.match_operator (|
            Ty.apply
              (Ty.path "*")
              []
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.path "usize"; Ty.path "usize" ],
                            "is_ok",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "usize" ],
                                  M.get_associated_function (|
                                    Ty.path "core::sync::atomic::AtomicUsize",
                                    "compare_exchange",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| shared |) |),
                                        "bytes::bytes::Shared",
                                        "ref_cnt"
                                      |)
                                    |);
                                    Value.Integer IntegerKind.Usize 1;
                                    Value.Integer IntegerKind.Usize 0;
                                    Value.StructTuple
                                      "core::sync::atomic::Ordering::AcqRel"
                                      []
                                      []
                                      [];
                                    Value.StructTuple
                                      "core::sync::atomic::Ordering::Relaxed"
                                      []
                                      []
                                      []
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ shared : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Shared" ] :=
                    M.copy (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                            "from_raw",
                            [],
                            []
                          |),
                          [ M.read (| shared |) ]
                        |)
                      |)
                    |) in
                  let~ shared :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [ Ty.path "bytes::bytes::Shared" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.path "bytes::bytes::Shared" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [ Ty.path "bytes::bytes::Shared" ],
                          "new",
                          [],
                          []
                        |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  let~ buf :
                      Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Shared" ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.path "bytes::bytes::Shared" ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, shared |) ]
                          |)
                        |),
                        "bytes::bytes::Shared",
                        "buf"
                      |)
                    |) in
                  let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Shared" ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.path "bytes::bytes::Shared" ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, shared |) ]
                          |)
                        |),
                        "bytes::bytes::Shared",
                        "cap"
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::copy", [], [ Ty.path "u8" ] |),
                        [ M.read (| ptr |); M.read (| buf |); M.read (| len |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        "from_raw_parts",
                        [],
                        []
                      |),
                      [ M.read (| buf |); M.read (| len |); M.read (| cap |) ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "to_vec",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_function (|
                                  "core::slice::raw::from_raw_parts",
                                  [],
                                  [ Ty.path "u8" ]
                                |),
                                [ M.read (| ptr |); M.read (| len |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "bytes::bytes::release_shared", [], [] |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  v))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_to_vec_impl :
    M.IsFunction.C "bytes::bytes::shared_to_vec_impl" shared_to_vec_impl.
  Admitted.
  Global Typeclasses Opaque shared_to_vec_impl.
  
  (*
  unsafe fn shared_to_vec(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Vec<u8> {
      shared_to_vec_impl(data.load(Ordering::Relaxed).cast(), ptr, len)
  }
  *)
  Definition shared_to_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.call_closure (|
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
          M.get_function (| "bytes::bytes::shared_to_vec_impl", [], [] |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                "cast",
                [],
                [ Ty.path "bytes::bytes::Shared" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                    "load",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                  ]
                |)
              ]
            |);
            M.read (| ptr |);
            M.read (| len |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_to_vec :
    M.IsFunction.C "bytes::bytes::shared_to_vec" shared_to_vec.
  Admitted.
  Global Typeclasses Opaque shared_to_vec.
  
  (*
  unsafe fn shared_to_mut_impl(shared: *mut Shared, ptr: *const u8, len: usize) -> BytesMut {
      // The goal is to check if the current handle is the only handle
      // that currently has access to the buffer. This is done by
      // checking if the `ref_cnt` is currently 1.
      //
      // The `Acquire` ordering synchronizes with the `Release` as
      // part of the `fetch_sub` in `release_shared`. The `fetch_sub`
      // operation guarantees that any mutations done in other threads
      // are ordered before the `ref_cnt` is decremented. As such,
      // this `Acquire` will guarantee that those mutations are
      // visible to the current thread.
      //
      // Otherwise, we take the other branch, copy the data and call `release_shared`.
      if ( *shared).ref_cnt.load(Ordering::Acquire) == 1 {
          // Deallocate the `Shared` instance without running its destructor.
          let shared = *Box::from_raw(shared);
          let shared = ManuallyDrop::new(shared);
          let buf = shared.buf;
          let cap = shared.cap;
  
          // Rebuild Vec
          let off = offset_from(ptr, buf);
          let v = Vec::from_raw_parts(buf, len + off, cap);
  
          let mut b = BytesMut::from_vec(v);
          b.advance_unchecked(off);
          b
      } else {
          // Copy the data from Shared in a new Vec, then release it
          let v = slice::from_raw_parts(ptr, len).to_vec();
          release_shared(shared);
          BytesMut::from_vec(v)
      }
  }
  *)
  Definition shared_to_mut_impl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ shared; ptr; len ] =>
      ltac:(M.monadic
        (let shared := M.alloc (| shared |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.path "core::sync::atomic::AtomicUsize",
                                "load",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| shared |) |),
                                    "bytes::bytes::Shared",
                                    "ref_cnt"
                                  |)
                                |);
                                Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                              ]
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ shared : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Shared" ] :=
                    M.copy (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                            "from_raw",
                            [],
                            []
                          |),
                          [ M.read (| shared |) ]
                        |)
                      |)
                    |) in
                  let~ shared :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [ Ty.path "bytes::bytes::Shared" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.path "bytes::bytes::Shared" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [ Ty.path "bytes::bytes::Shared" ],
                          "new",
                          [],
                          []
                        |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  let~ buf :
                      Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Shared" ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.path "bytes::bytes::Shared" ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, shared |) ]
                          |)
                        |),
                        "bytes::bytes::Shared",
                        "buf"
                      |)
                    |) in
                  let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Shared" ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                []
                                [ Ty.path "bytes::bytes::Shared" ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, shared |) ]
                          |)
                        |),
                        "bytes::bytes::Shared",
                        "cap"
                      |)
                    |) in
                  let~ off : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_function (| "bytes::offset_from", [], [] |),
                        [
                          M.read (| ptr |);
                          (* MutToConstPointer *) M.pointer_coercion (M.read (| buf |))
                        ]
                      |)
                    |) in
                  let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "from_raw_parts",
                          [],
                          []
                        |),
                        [
                          M.read (| buf |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.add,
                            [ M.read (| len |); M.read (| off |) ]
                          |);
                          M.read (| cap |)
                        ]
                      |)
                    |) in
                  let~ b : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        M.get_associated_function (|
                          Ty.path "bytes::bytes_mut::BytesMut",
                          "from_vec",
                          [],
                          []
                        |),
                        [ M.read (| v |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.path "bytes::bytes_mut::BytesMut",
                          "advance_unchecked",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, b |); M.read (| off |) ]
                      |)
                    |) in
                  b));
              fun γ =>
                ltac:(M.monadic
                  (let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "to_vec",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_function (|
                                  "core::slice::raw::from_raw_parts",
                                  [],
                                  [ Ty.path "u8" ]
                                |),
                                [ M.read (| ptr |); M.read (| len |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "bytes::bytes::release_shared", [], [] |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "from_vec",
                        [],
                        []
                      |),
                      [ M.read (| v |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_to_mut_impl :
    M.IsFunction.C "bytes::bytes::shared_to_mut_impl" shared_to_mut_impl.
  Admitted.
  Global Typeclasses Opaque shared_to_mut_impl.
  
  (*
  unsafe fn shared_to_mut(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> BytesMut {
      shared_to_mut_impl(data.load(Ordering::Relaxed).cast(), ptr, len)
  }
  *)
  Definition shared_to_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.call_closure (|
          Ty.path "bytes::bytes_mut::BytesMut",
          M.get_function (| "bytes::bytes::shared_to_mut_impl", [], [] |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                "cast",
                [],
                [ Ty.path "bytes::bytes::Shared" ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                    "load",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                  ]
                |)
              ]
            |);
            M.read (| ptr |);
            M.read (| len |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_to_mut :
    M.IsFunction.C "bytes::bytes::shared_to_mut" shared_to_mut.
  Admitted.
  Global Typeclasses Opaque shared_to_mut.
  
  (*
  pub(crate) unsafe fn shared_is_unique(data: &AtomicPtr<()>) -> bool {
      let shared = data.load(Ordering::Acquire);
      let ref_cnt = ( *shared.cast::<Shared>()).ref_cnt.load(Ordering::Relaxed);
      ref_cnt == 1
  }
  *)
  Definition shared_is_unique (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |) in
          let~ ref_cnt : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::sync::atomic::AtomicUsize",
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            "cast",
                            [],
                            [ Ty.path "bytes::bytes::Shared" ]
                          |),
                          [ M.read (| shared |) ]
                        |)
                      |),
                      "bytes::bytes::Shared",
                      "ref_cnt"
                    |)
                  |);
                  Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [ M.read (| ref_cnt |); Value.Integer IntegerKind.Usize 1 ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_is_unique :
    M.IsFunction.C "bytes::bytes::shared_is_unique" shared_is_unique.
  Admitted.
  Global Typeclasses Opaque shared_is_unique.
  
  (*
  unsafe fn shared_drop(data: &mut AtomicPtr<()>, _ptr: *const u8, _len: usize) {
      data.with_mut(|shared| {
          release_shared(shared.cast());
      });
  }
  *)
  Definition shared_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; _ptr; _len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let _ptr := M.alloc (| _ptr |) in
        let _len := M.alloc (| _len |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "bytes::loom::sync::atomic::AtomicMut",
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  [],
                  [ Ty.tuple [] ],
                  "with_mut",
                  [],
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                          ]
                      ]
                      (Ty.tuple []);
                    Ty.tuple []
                  ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                                        ]
                                    ]
                                    (Ty.tuple [])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let shared := M.copy (| γ |) in
                                    M.read (|
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (|
                                              "bytes::bytes::release_shared",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "*mut")
                                                  []
                                                  [ Ty.path "bytes::bytes::Shared" ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                                  "cast",
                                                  [],
                                                  [ Ty.path "bytes::bytes::Shared" ]
                                                |),
                                                [ M.read (| M.deref (| M.read (| shared |) |) |) ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_drop :
    M.IsFunction.C "bytes::bytes::shared_drop" shared_drop.
  Admitted.
  Global Typeclasses Opaque shared_drop.
  
  (*
  unsafe fn shallow_clone_arc(shared: *mut Shared, ptr: *const u8, len: usize) -> Bytes {
      let old_size = ( *shared).ref_cnt.fetch_add(1, Ordering::Relaxed);
  
      if old_size > usize::MAX >> 1 {
          crate::abort();
      }
  
      Bytes {
          ptr,
          len,
          data: AtomicPtr::new(shared as _),
          vtable: &SHARED_VTABLE,
      }
  }
  *)
  Definition shallow_clone_arc (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ shared; ptr; len ] =>
      ltac:(M.monadic
        (let shared := M.alloc (| shared |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ old_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::sync::atomic::AtomicUsize",
                  "fetch_add",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| shared |) |),
                      "bytes::bytes::Shared",
                      "ref_cnt"
                    |)
                  |);
                  Value.Integer IntegerKind.Usize 1;
                  Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [
                              M.read (| old_size |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.shr,
                                [
                                  M.read (|
                                    get_constant (| "core::usize::MAX", Ty.path "usize" |)
                                  |);
                                  Value.Integer IntegerKind.I32 1
                                ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "bytes::abort", [], [] |),
                          []
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            Value.StructRecord
              "bytes::bytes::Bytes"
              []
              []
              [
                ("ptr", M.read (| ptr |));
                ("len", M.read (| len |));
                ("data",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                      "new",
                      [],
                      []
                    |),
                    [ M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]) (M.read (| shared |)) ]
                  |));
                ("vtable",
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.read (|
                            get_constant (|
                              "bytes::bytes::SHARED_VTABLE",
                              Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Vtable" ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shallow_clone_arc :
    M.IsFunction.C "bytes::bytes::shallow_clone_arc" shallow_clone_arc.
  Admitted.
  Global Typeclasses Opaque shallow_clone_arc.
  
  (*
  unsafe fn shallow_clone_vec(
      atom: &AtomicPtr<()>,
      ptr: *const (),
      buf: *mut u8,
      offset: *const u8,
      len: usize,
  ) -> Bytes {
      // If  the buffer is still tracked in a `Vec<u8>`. It is time to
      // promote the vec to an `Arc`. This could potentially be called
      // concurrently, so some care must be taken.
  
      // First, allocate a new `Shared` instance containing the
      // `Vec` fields. It's important to note that `ptr`, `len`,
      // and `cap` cannot be mutated without having `&mut self`.
      // This means that these fields will not be concurrently
      // updated and since the buffer hasn't been promoted to an
      // `Arc`, those three fields still are the components of the
      // vector.
      let shared = Box::new(Shared {
          buf,
          cap: offset_from(offset, buf) + len,
          // Initialize refcount to 2. One for this reference, and one
          // for the new clone that will be returned from
          // `shallow_clone`.
          ref_cnt: AtomicUsize::new(2),
      });
  
      let shared = Box::into_raw(shared);
  
      // The pointer should be aligned, so this assert should
      // always succeed.
      debug_assert!(
          0 == (shared as usize & KIND_MASK),
          "internal: Box<Shared> should have an aligned pointer",
      );
  
      // Try compare & swapping the pointer into the `arc` field.
      // `Release` is used synchronize with other threads that
      // will load the `arc` field.
      //
      // If the `compare_exchange` fails, then the thread lost the
      // race to promote the buffer to shared. The `Acquire`
      // ordering will synchronize with the `compare_exchange`
      // that happened in the other thread and the `Shared`
      // pointed to by `actual` will be visible.
      match atom.compare_exchange(ptr as _, shared as _, Ordering::AcqRel, Ordering::Acquire) {
          Ok(actual) => {
              debug_assert!(actual as usize == ptr as usize);
              // The upgrade was successful, the new handle can be
              // returned.
              Bytes {
                  ptr: offset,
                  len,
                  data: AtomicPtr::new(shared as _),
                  vtable: &SHARED_VTABLE,
              }
          }
          Err(actual) => {
              // The upgrade failed, a concurrent clone happened. Release
              // the allocation that was made in this thread, it will not
              // be needed.
              let shared = Box::from_raw(shared);
              mem::forget( *shared);
  
              // Buffer already promoted to shared storage, so increment ref
              // count.
              shallow_clone_arc(actual as _, offset, len)
          }
      }
  }
  *)
  Definition shallow_clone_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ atom; ptr; buf; offset; len ] =>
      ltac:(M.monadic
        (let atom := M.alloc (| atom |) in
        let ptr := M.alloc (| ptr |) in
        let buf := M.alloc (| buf |) in
        let offset := M.alloc (| offset |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ shared :
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                  "new",
                  [],
                  []
                |),
                [
                  Value.StructRecord
                    "bytes::bytes::Shared"
                    []
                    []
                    [
                      ("buf", M.read (| buf |));
                      ("cap",
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.add,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "bytes::offset_from", [], [] |),
                              [
                                M.read (| offset |);
                                (* MutToConstPointer *) M.pointer_coercion (M.read (| buf |))
                              ]
                            |);
                            M.read (| len |)
                          ]
                        |));
                      ("ref_cnt",
                        M.call_closure (|
                          Ty.path "core::sync::atomic::AtomicUsize",
                          M.get_associated_function (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            "new",
                            [],
                            []
                          |),
                          [ Value.Integer IntegerKind.Usize 2 ]
                        |))
                    ]
                ]
              |)
            |) in
          let~ shared :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                  "into_raw",
                  [],
                  []
                |),
                [ M.read (| shared |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          Value.Integer IntegerKind.Usize 0;
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.bit_and,
                                            [
                                              M.cast (Ty.path "usize") (M.read (| shared |));
                                              M.read (|
                                                get_constant (|
                                                  "bytes::bytes::KIND_MASK",
                                                  Ty.path "usize"
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [
                                      mk_str (|
                                        "internal: Box<Shared> should have an aligned pointer"
                                      |)
                                    ]
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ],
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ];
                    Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]
                  ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "compare_exchange",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| atom |) |) |);
                  M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]) (M.read (| ptr |));
                  M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]) (M.read (| shared |));
                  Value.StructTuple "core::sync::atomic::Ordering::AcqRel" [] [] [];
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                  let actual := M.copy (| γ0_0 |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.eq,
                                                [
                                                  M.cast (Ty.path "usize") (M.read (| actual |));
                                                  M.cast (Ty.path "usize") (M.read (| ptr |))
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (| "core::panicking::panic", [], [] |),
                                            [
                                              mk_str (|
                                                "assertion failed: actual as usize == ptr as usize"
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructRecord
                      "bytes::bytes::Bytes"
                      []
                      []
                      [
                        ("ptr", M.read (| offset |));
                        ("len", M.read (| len |));
                        ("data",
                          M.call_closure (|
                            Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                              "new",
                              [],
                              []
                            |),
                            [
                              M.cast
                                (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                                (M.read (| shared |))
                            ]
                          |));
                        ("vtable",
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    get_constant (|
                                      "bytes::bytes::SHARED_VTABLE",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Vtable" ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |))
                      ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                  let actual := M.copy (| γ0_0 |) in
                  let~ shared :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                          "from_raw",
                          [],
                          []
                        |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (|
                          "core::mem::forget",
                          [],
                          [ Ty.path "bytes::bytes::Shared" ]
                        |),
                        [ M.read (| M.deref (| M.read (| shared |) |) |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes::Bytes",
                      M.get_function (| "bytes::bytes::shallow_clone_arc", [], [] |),
                      [
                        M.cast
                          (Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes::Shared" ])
                          (M.read (| actual |));
                        M.read (| offset |);
                        M.read (| len |)
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shallow_clone_vec :
    M.IsFunction.C "bytes::bytes::shallow_clone_vec" shallow_clone_vec.
  Admitted.
  Global Typeclasses Opaque shallow_clone_vec.
  
  (*
  unsafe fn release_shared(ptr: *mut Shared) {
      // `Shared` storage... follow the drop steps from Arc.
      if ( *ptr).ref_cnt.fetch_sub(1, Ordering::Release) != 1 {
          return;
      }
  
      // This fence is needed to prevent reordering of use of the data and
      // deletion of the data.  Because it is marked `Release`, the decreasing
      // of the reference count synchronizes with this `Acquire` fence. This
      // means that use of the data happens before decreasing the reference
      // count, which happens before this fence, which happens before the
      // deletion of the data.
      //
      // As explained in the [Boost documentation][1],
      //
      // > It is important to enforce any possible access to the object in one
      // > thread (through an existing reference) to *happen before* deleting
      // > the object in a different thread. This is achieved by a "release"
      // > operation after dropping a reference (any access to the object
      // > through this reference must obviously happened before), and an
      // > "acquire" operation before deleting the object.
      //
      // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)
      //
      // Thread sanitizer does not support atomic fences. Use an atomic load
      // instead.
      ( *ptr).ref_cnt.load(Ordering::Acquire);
  
      // Drop the data
      drop(Box::from_raw(ptr));
  }
  *)
  Definition release_shared (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.catch_return (Ty.tuple []) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ne,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "fetch_sub",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| ptr |) |),
                                          "bytes::bytes::Shared",
                                          "ref_cnt"
                                        |)
                                      |);
                                      Value.Integer IntegerKind.Usize 1;
                                      Value.StructTuple
                                        "core::sync::atomic::Ordering::Release"
                                        []
                                        []
                                        []
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicUsize",
                      "load",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| ptr |) |),
                          "bytes::bytes::Shared",
                          "ref_cnt"
                        |)
                      |);
                      Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::mem::drop",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "bytes::bytes::Shared"; Ty.path "alloc::alloc::Global" ],
                          "from_raw",
                          [],
                          []
                        |),
                        [ M.read (| ptr |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_release_shared :
    M.IsFunction.C "bytes::bytes::release_shared" release_shared.
  Admitted.
  Global Typeclasses Opaque release_shared.
  
  (*
  fn ptr_map<F>(ptr: *mut u8, f: F) -> *mut u8
  where
      F: FnOnce(usize) -> usize,
  {
      let old_addr = ptr as usize;
      let new_addr = f(old_addr);
      new_addr as *mut u8
  }
  *)
  Definition ptr_map (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F ], [ ptr; f ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        let f := M.alloc (| f |) in
        M.read (|
          let~ old_addr : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (| M.cast (Ty.path "usize") (M.read (| ptr |)) |) in
          let~ new_addr : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "core::ops::function::FnOnce",
                  F,
                  [],
                  [ Ty.tuple [ Ty.path "usize" ] ],
                  "call_once",
                  [],
                  []
                |),
                [ M.read (| f |); Value.Tuple [ M.read (| old_addr |) ] ]
              |)
            |) in
          M.alloc (|
            M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ]) (M.read (| new_addr |))
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ptr_map : M.IsFunction.C "bytes::bytes::ptr_map" ptr_map.
  Admitted.
  Global Typeclasses Opaque ptr_map.
  
  (* fn _split_to_must_use() {} *)
  Definition _split_to_must_use (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction__split_to_must_use :
    M.IsFunction.C "bytes::bytes::_split_to_must_use" _split_to_must_use.
  Admitted.
  Global Typeclasses Opaque _split_to_must_use.
  
  (* fn _split_off_must_use() {} *)
  Definition _split_off_must_use (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction__split_off_must_use :
    M.IsFunction.C "bytes::bytes::_split_off_must_use" _split_off_must_use.
  Admitted.
  Global Typeclasses Opaque _split_off_must_use.
End bytes.
