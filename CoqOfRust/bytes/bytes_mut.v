(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bytes_mut.
  (* StructRecord
    {
      name := "BytesMut";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("ptr", Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ]);
          ("len", Ty.path "usize");
          ("cap", Ty.path "usize");
          ("data", Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ])
        ];
    } *)
  
  (* StructRecord
    {
      name := "Shared";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("vec",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]);
          ("original_capacity_repr", Ty.path "usize");
          ("ref_count", Ty.path "core::sync::atomic::AtomicUsize")
        ];
    } *)
  
  Definition value_KIND_ARC (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |))).
  
  Global Instance Instance_IsConstant_value_KIND_ARC :
    M.IsFunction.C "bytes::bytes_mut::KIND_ARC" value_KIND_ARC.
  Admitted.
  Global Typeclasses Opaque value_KIND_ARC.
  
  Definition value_KIND_VEC (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1 |))).
  
  Global Instance Instance_IsConstant_value_KIND_VEC :
    M.IsFunction.C "bytes::bytes_mut::KIND_VEC" value_KIND_VEC.
  Admitted.
  Global Typeclasses Opaque value_KIND_VEC.
  
  Definition value_KIND_MASK (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1 |))).
  
  Global Instance Instance_IsConstant_value_KIND_MASK :
    M.IsFunction.C "bytes::bytes_mut::KIND_MASK" value_KIND_MASK.
  Admitted.
  Global Typeclasses Opaque value_KIND_MASK.
  
  Definition value_MAX_ORIGINAL_CAPACITY_WIDTH
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 17 |))).
  
  Global Instance Instance_IsConstant_value_MAX_ORIGINAL_CAPACITY_WIDTH :
    M.IsFunction.C
      "bytes::bytes_mut::MAX_ORIGINAL_CAPACITY_WIDTH"
      value_MAX_ORIGINAL_CAPACITY_WIDTH.
  Admitted.
  Global Typeclasses Opaque value_MAX_ORIGINAL_CAPACITY_WIDTH.
  
  Definition value_MIN_ORIGINAL_CAPACITY_WIDTH
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 10 |))).
  
  Global Instance Instance_IsConstant_value_MIN_ORIGINAL_CAPACITY_WIDTH :
    M.IsFunction.C
      "bytes::bytes_mut::MIN_ORIGINAL_CAPACITY_WIDTH"
      value_MIN_ORIGINAL_CAPACITY_WIDTH.
  Admitted.
  Global Typeclasses Opaque value_MIN_ORIGINAL_CAPACITY_WIDTH.
  
  Definition value_ORIGINAL_CAPACITY_MASK
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 28 |))).
  
  Global Instance Instance_IsConstant_value_ORIGINAL_CAPACITY_MASK :
    M.IsFunction.C "bytes::bytes_mut::ORIGINAL_CAPACITY_MASK" value_ORIGINAL_CAPACITY_MASK.
  Admitted.
  Global Typeclasses Opaque value_ORIGINAL_CAPACITY_MASK.
  
  Definition value_ORIGINAL_CAPACITY_OFFSET
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 2 |))).
  
  Global Instance Instance_IsConstant_value_ORIGINAL_CAPACITY_OFFSET :
    M.IsFunction.C "bytes::bytes_mut::ORIGINAL_CAPACITY_OFFSET" value_ORIGINAL_CAPACITY_OFFSET.
  Admitted.
  Global Typeclasses Opaque value_ORIGINAL_CAPACITY_OFFSET.
  
  Definition value_VEC_POS_OFFSET (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 5 |))).
  
  Global Instance Instance_IsConstant_value_VEC_POS_OFFSET :
    M.IsFunction.C "bytes::bytes_mut::VEC_POS_OFFSET" value_VEC_POS_OFFSET.
  Admitted.
  Global Typeclasses Opaque value_VEC_POS_OFFSET.
  
  Definition value_MAX_VEC_POS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "usize",
          BinOp.Wrap.shr,
          [
            M.read (| get_constant (| "core::usize::MAX", Ty.path "usize" |) |);
            M.read (| get_constant (| "bytes::bytes_mut::VEC_POS_OFFSET", Ty.path "usize" |) |)
          ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_MAX_VEC_POS :
    M.IsFunction.C "bytes::bytes_mut::MAX_VEC_POS" value_MAX_VEC_POS.
  Admitted.
  Global Typeclasses Opaque value_MAX_VEC_POS.
  
  Definition value_NOT_VEC_POS_MASK (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 31 |))).
  
  Global Instance Instance_IsConstant_value_NOT_VEC_POS_MASK :
    M.IsFunction.C "bytes::bytes_mut::NOT_VEC_POS_MASK" value_NOT_VEC_POS_MASK.
  Admitted.
  Global Typeclasses Opaque value_NOT_VEC_POS_MASK.
  
  Definition value_PTR_WIDTH (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 64 |))).
  
  Global Instance Instance_IsConstant_value_PTR_WIDTH :
    M.IsFunction.C "bytes::bytes_mut::PTR_WIDTH" value_PTR_WIDTH.
  Admitted.
  Global Typeclasses Opaque value_PTR_WIDTH.
  
  Module Impl_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        pub fn with_capacity(capacity: usize) -> BytesMut {
            BytesMut::from_vec(Vec::with_capacity(capacity))
        }
    *)
    Definition with_capacity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ capacity ] =>
        ltac:(M.monadic
          (let capacity := M.alloc (| capacity |) in
          M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_associated_function (|
              Ty.path "bytes::bytes_mut::BytesMut",
              "from_vec",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  "with_capacity",
                  [],
                  []
                |),
                [ M.read (| capacity |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_with_capacity :
      M.IsAssociatedFunction.C Self "with_capacity" with_capacity.
    Admitted.
    Global Typeclasses Opaque with_capacity.
    
    (*
        pub fn new() -> BytesMut {
            BytesMut::with_capacity(0)
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_associated_function (|
              Ty.path "bytes::bytes_mut::BytesMut",
              "with_capacity",
              [],
              []
            |),
            [ Value.Integer IntegerKind.Usize 0 ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn len(&self) -> usize {
            self.len
        }
    *)
    Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "bytes::bytes_mut::BytesMut",
              "len"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_len : M.IsAssociatedFunction.C Self "len" len.
    Admitted.
    Global Typeclasses Opaque len.
    
    (*
        pub fn is_empty(&self) -> bool {
            self.len == 0
        }
    *)
    Definition is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "bytes::bytes_mut::BytesMut",
                  "len"
                |)
              |);
              Value.Integer IntegerKind.Usize 0
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_empty : M.IsAssociatedFunction.C Self "is_empty" is_empty.
    Admitted.
    Global Typeclasses Opaque is_empty.
    
    (*
        pub fn capacity(&self) -> usize {
            self.cap
        }
    *)
    Definition capacity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "bytes::bytes_mut::BytesMut",
              "cap"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_capacity : M.IsAssociatedFunction.C Self "capacity" capacity.
    Admitted.
    Global Typeclasses Opaque capacity.
    
    (*
        pub fn freeze(self) -> Bytes {
            let bytes = ManuallyDrop::new(self);
            if bytes.kind() == KIND_VEC {
                // Just re-use `Bytes` internal Vec vtable
                unsafe {
                    let off = bytes.get_vec_pos();
                    let vec = rebuild_vec(bytes.ptr.as_ptr(), bytes.len, bytes.cap, off);
                    let mut b: Bytes = vec.into();
                    b.advance(off);
                    b
                }
            } else {
                debug_assert_eq!(bytes.kind(), KIND_ARC);
    
                let ptr = bytes.ptr.as_ptr();
                let len = bytes.len;
                let data = AtomicPtr::new(bytes.data.cast());
                unsafe { Bytes::with_vtable(ptr, len, data, &SHARED_VTABLE) }
            }
        }
    *)
    Definition freeze (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ bytes :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.path "bytes::bytes_mut::BytesMut" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [ Ty.path "bytes::bytes_mut::BytesMut" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [ Ty.path "bytes::bytes_mut::BytesMut" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "bytes::bytes_mut::BytesMut",
                                  "kind",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                get_constant (| "bytes::bytes_mut::KIND_VEC", Ty.path "usize" |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ off : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            "get_vec_pos",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                      []
                                      [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ vec :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          M.get_function (| "bytes::bytes_mut::rebuild_vec", [], [] |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                      |)
                                    |),
                                    "bytes::bytes_mut::BytesMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        []
                                        [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                  |)
                                |),
                                "bytes::bytes_mut::BytesMut",
                                "len"
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        []
                                        [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                  |)
                                |),
                                "bytes::bytes_mut::BytesMut",
                                "cap"
                              |)
                            |);
                            M.read (| off |)
                          ]
                        |)
                      |) in
                    let~ b : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes::Bytes" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bytes::bytes::Bytes",
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                            [],
                            [ Ty.path "bytes::bytes::Bytes" ],
                            "into",
                            [],
                            []
                          |),
                          [ M.read (| vec |) ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "bytes::buf::buf_impl::Buf",
                            Ty.path "bytes::bytes::Bytes",
                            [],
                            [],
                            "advance",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, b |); M.read (| off |) ]
                        |)
                      |) in
                    b));
                fun γ =>
                  ltac:(M.monadic
                    (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Value.Bool true |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (|
                                    Value.Tuple
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.path "bytes::bytes_mut::BytesMut",
                                                "kind",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::mem::manually_drop::ManuallyDrop")
                                                          []
                                                          [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                                        [],
                                                        [],
                                                        "deref",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_constant (|
                                            "bytes::bytes_mut::KIND_ARC",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val := M.copy (| γ0_0 |) in
                                        let right_val := M.copy (| γ0_1 |) in
                                        M.match_operator (|
                                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (|
                                                              M.deref (| M.read (| left_val |) |)
                                                            |);
                                                            M.read (|
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      let~ kind :
                                                          Ty.apply
                                                            (Ty.path "*")
                                                            []
                                                            [ Ty.path "core::panicking::AssertKind"
                                                            ] :=
                                                        M.alloc (|
                                                          Value.StructTuple
                                                            "core::panicking::AssertKind::Eq"
                                                            []
                                                            []
                                                            []
                                                        |) in
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "never",
                                                          M.get_function (|
                                                            "core::panicking::assert_failed",
                                                            [],
                                                            [ Ty.path "usize"; Ty.path "usize" ]
                                                          |),
                                                          [
                                                            M.read (| kind |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| left_val |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| right_val |)
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            Value.StructTuple
                                                              "core::option::Option::None"
                                                              []
                                                              [ Ty.path "core::fmt::Arguments" ]
                                                              []
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ ptr :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                        []
                                        [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                  |)
                                |),
                                "bytes::bytes_mut::BytesMut",
                                "ptr"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.copy (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes_mut::BytesMut" ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                            |)
                          |),
                          "bytes::bytes_mut::BytesMut",
                          "len"
                        |)
                      |) in
                    let~ data :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                            "new",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                                "cast",
                                [],
                                [ Ty.tuple [] ]
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                      |)
                                    |),
                                    "bytes::bytes_mut::BytesMut",
                                    "data"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bytes::bytes::Bytes",
                        M.get_associated_function (|
                          Ty.path "bytes::bytes::Bytes",
                          "with_vtable",
                          [],
                          []
                        |),
                        [
                          (* MutToConstPointer *) M.pointer_coercion (M.read (| ptr |));
                          M.read (| len |);
                          M.read (| data |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.read (|
                                    get_constant (|
                                      "bytes::bytes_mut::SHARED_VTABLE",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Vtable" ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_freeze : M.IsAssociatedFunction.C Self "freeze" freeze.
    Admitted.
    Global Typeclasses Opaque freeze.
    
    (*
        pub fn zeroed(len: usize) -> BytesMut {
            BytesMut::from_vec(vec![0; len])
        }
    *)
    Definition zeroed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ len ] =>
        ltac:(M.monadic
          (let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_associated_function (|
              Ty.path "bytes::bytes_mut::BytesMut",
              "from_vec",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_function (| "alloc::vec::from_elem", [], [ Ty.path "u8" ] |),
                [ Value.Integer IntegerKind.U8 0; M.read (| len |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_zeroed : M.IsAssociatedFunction.C Self "zeroed" zeroed.
    Admitted.
    Global Typeclasses Opaque zeroed.
    
    (*
        pub fn split_off(&mut self, at: usize) -> BytesMut {
            assert!(
                at <= self.capacity(),
                "split_off out of bounds: {:?} <= {:?}",
                at,
                self.capacity(),
            );
            unsafe {
                let mut other = self.shallow_clone();
                // SAFETY: We've checked that `at` <= `self.capacity()` above.
                other.advance_unchecked(at);
                self.cap = at;
                self.len = cmp::min(self.len, at);
                other
            }
        }
    *)
    Definition split_off (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; at_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let at_ := M.alloc (| at_ |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.le,
                                [
                                  M.read (| at_ |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes_mut::BytesMut",
                                      "capacity",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 2;
                                    Value.Integer IntegerKind.Usize 2
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "split_off out of bounds: " |);
                                              mk_str (| " <= " |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.Ref, at_ |)
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.path "bytes::bytes_mut::BytesMut",
                                                              "capacity",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ other : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "bytes::bytes_mut::BytesMut",
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "shallow_clone",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "advance_unchecked",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, other |); M.read (| at_ |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes_mut::BytesMut",
                    "cap"
                  |),
                  M.read (| at_ |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes_mut::BytesMut",
                    "len"
                  |),
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "bytes::bytes_mut::BytesMut",
                          "len"
                        |)
                      |);
                      M.read (| at_ |)
                    ]
                  |)
                |)
              |) in
            other
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_split_off :
      M.IsAssociatedFunction.C Self "split_off" split_off.
    Admitted.
    Global Typeclasses Opaque split_off.
    
    (*
        pub fn split(&mut self) -> BytesMut {
            let len = self.len();
            self.split_to(len)
        }
    *)
    Definition split (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bytes::bytes_mut::BytesMut",
                M.get_associated_function (|
                  Ty.path "bytes::bytes_mut::BytesMut",
                  "split_to",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  M.read (| len |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_split : M.IsAssociatedFunction.C Self "split" split.
    Admitted.
    Global Typeclasses Opaque split.
    
    (*
        pub fn split_to(&mut self, at: usize) -> BytesMut {
            assert!(
                at <= self.len(),
                "split_to out of bounds: {:?} <= {:?}",
                at,
                self.len(),
            );
    
            unsafe {
                let mut other = self.shallow_clone();
                // SAFETY: We've checked that `at` <= `self.len()` and we know that `self.len()` <=
                // `self.capacity()`.
                self.advance_unchecked(at);
                other.cap = at;
                other.len = at;
                other
            }
        }
    *)
    Definition split_to (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; at_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let at_ := M.alloc (| at_ |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.le,
                                [
                                  M.read (| at_ |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes_mut::BytesMut",
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 2;
                                    Value.Integer IntegerKind.Usize 2
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "split_to out of bounds: " |);
                                              mk_str (| " <= " |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.Ref, at_ |)
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.path "bytes::bytes_mut::BytesMut",
                                                              "len",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ other : Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "bytes::bytes_mut::BytesMut",
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "shallow_clone",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "advance_unchecked",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| at_ |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    other,
                    "bytes::bytes_mut::BytesMut",
                    "cap"
                  |),
                  M.read (| at_ |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    other,
                    "bytes::bytes_mut::BytesMut",
                    "len"
                  |),
                  M.read (| at_ |)
                |)
              |) in
            other
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_split_to : M.IsAssociatedFunction.C Self "split_to" split_to.
    Admitted.
    Global Typeclasses Opaque split_to.
    
    (*
        pub fn truncate(&mut self, len: usize) {
            if len <= self.len() {
                // SAFETY: Shrinking the buffer cannot expose uninitialized bytes.
                unsafe { self.set_len(len) };
            }
        }
    *)
    Definition truncate (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.le,
                            [
                              M.read (| len |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "bytes::bytes_mut::BytesMut",
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            "set_len",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.read (| len |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_truncate : M.IsAssociatedFunction.C Self "truncate" truncate.
    Admitted.
    Global Typeclasses Opaque truncate.
    
    (*
        pub fn clear(&mut self) {
            // SAFETY: Setting the length to zero cannot expose uninitialized bytes.
            unsafe { self.set_len(0) };
        }
    *)
    Definition clear (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "set_len",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    Value.Integer IntegerKind.Usize 0
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_clear : M.IsAssociatedFunction.C Self "clear" clear.
    Admitted.
    Global Typeclasses Opaque clear.
    
    (*
        pub fn resize(&mut self, new_len: usize, value: u8) {
            let additional = if let Some(additional) = new_len.checked_sub(self.len()) {
                additional
            } else {
                self.truncate(new_len);
                return;
            };
    
            if additional == 0 {
                return;
            }
    
            self.reserve(additional);
            let dst = self.spare_capacity_mut().as_mut_ptr();
            // SAFETY: `spare_capacity_mut` returns a valid, properly aligned pointer and we've
            // reserved enough space to write `additional` bytes.
            unsafe { ptr::write_bytes(dst, value, additional) };
    
            // SAFETY: There are at least `new_len` initialized bytes in the buffer so no
            // uninitialized bytes are being exposed.
            unsafe { self.set_len(new_len) };
        }
    *)
    Definition resize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; new_len; value ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let new_len := M.alloc (| new_len |) in
          let value := M.alloc (| value |) in
          M.catch_return (Ty.tuple []) (|
            ltac:(M.monadic
              (M.read (|
                let~ additional : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_sub",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (| new_len |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let additional := M.copy (| γ0_0 |) in
                            additional));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes_mut::BytesMut",
                                          "truncate",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          M.read (| new_len |)
                                        ]
                                      |)
                                    |) in
                                  M.return_ (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| additional |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "reserve",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.read (| additional |)
                      ]
                    |)
                  |) in
                let~ dst :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "*mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ],
                        "as_mut_ptr",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        []
                                        [ Ty.path "u8" ]
                                    ]
                                ],
                              M.get_associated_function (|
                                Ty.path "bytes::bytes_mut::BytesMut",
                                "spare_capacity_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (|
                        "core::intrinsics::write_bytes",
                        [],
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ]
                      |),
                      [ M.read (| dst |); M.read (| value |); M.read (| additional |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "set_len",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.read (| new_len |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_resize : M.IsAssociatedFunction.C Self "resize" resize.
    Admitted.
    Global Typeclasses Opaque resize.
    
    (*
        pub unsafe fn set_len(&mut self, len: usize) {
            debug_assert!(len <= self.cap, "set_len out of bounds");
            self.len = len;
        }
    *)
    Definition set_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.le,
                                          [
                                            M.read (| len |);
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "bytes::bytes_mut::BytesMut",
                                                "cap"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "set_len out of bounds" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes_mut::BytesMut",
                    "len"
                  |),
                  M.read (| len |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_set_len : M.IsAssociatedFunction.C Self "set_len" set_len.
    Admitted.
    Global Typeclasses Opaque set_len.
    
    (*
        pub fn reserve(&mut self, additional: usize) {
            let len = self.len();
            let rem = self.capacity() - len;
    
            if additional <= rem {
                // The handle can already store at least `additional` more bytes, so
                // there is no further work needed to be done.
                return;
            }
    
            // will always succeed
            let _ = self.reserve_inner(additional, true);
        }
    *)
    Definition reserve (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let additional := M.alloc (| additional |) in
          M.catch_return (Ty.tuple []) (|
            ltac:(M.monadic
              (M.read (|
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ rem : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            "capacity",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |);
                        M.read (| len |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ M.read (| additional |); M.read (| rem |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bool",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "reserve_inner",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.read (| additional |);
                        Value.Bool true
                      ]
                    |)
                  |),
                  [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_reserve : M.IsAssociatedFunction.C Self "reserve" reserve.
    Admitted.
    Global Typeclasses Opaque reserve.
    
    (*
        fn reserve_inner(&mut self, additional: usize, allocate: bool) -> bool {
            let len = self.len();
            let kind = self.kind();
    
            if kind == KIND_VEC {
                // If there's enough free space before the start of the buffer, then
                // just copy the data backwards and reuse the already-allocated
                // space.
                //
                // Otherwise, since backed by a vector, use `Vec::reserve`
                //
                // We need to make sure that this optimization does not kill the
                // amortized runtimes of BytesMut's operations.
                unsafe {
                    let off = self.get_vec_pos();
    
                    // Only reuse space if we can satisfy the requested additional space.
                    //
                    // Also check if the value of `off` suggests that enough bytes
                    // have been read to account for the overhead of shifting all
                    // the data (in an amortized analysis).
                    // Hence the condition `off >= self.len()`.
                    //
                    // This condition also already implies that the buffer is going
                    // to be (at least) half-empty in the end; so we do not break
                    // the (amortized) runtime with future resizes of the underlying
                    // `Vec`.
                    //
                    // [For more details check issue #524, and PR #525.]
                    if self.capacity() - self.len() + off >= additional && off >= self.len() {
                        // There's enough space, and it's not too much overhead:
                        // reuse the space!
                        //
                        // Just move the pointer back to the start after copying
                        // data back.
                        let base_ptr = self.ptr.as_ptr().sub(off);
                        // Since `off >= self.len()`, the two regions don't overlap.
                        ptr::copy_nonoverlapping(self.ptr.as_ptr(), base_ptr, self.len);
                        self.ptr = vptr(base_ptr);
                        self.set_vec_pos(0);
    
                        // Length stays constant, but since we moved backwards we
                        // can gain capacity back.
                        self.cap += off;
                    } else {
                        if !allocate {
                            return false;
                        }
                        // Not enough space, or reusing might be too much overhead:
                        // allocate more space!
                        let mut v =
                            ManuallyDrop::new(rebuild_vec(self.ptr.as_ptr(), self.len, self.cap, off));
                        v.reserve(additional);
    
                        // Update the info
                        self.ptr = vptr(v.as_mut_ptr().add(off));
                        self.cap = v.capacity() - off;
                        debug_assert_eq!(self.len, v.len() - off);
                    }
    
                    return true;
                }
            }
    
            debug_assert_eq!(kind, KIND_ARC);
            let shared: *mut Shared = self.data;
    
            // Reserving involves abandoning the currently shared buffer and
            // allocating a new vector with the requested capacity.
            //
            // Compute the new capacity
            let mut new_cap = match len.checked_add(additional) {
                Some(new_cap) => new_cap,
                None if !allocate => return false,
                None => panic!("overflow"),
            };
    
            unsafe {
                // First, try to reclaim the buffer. This is possible if the current
                // handle is the only outstanding handle pointing to the buffer.
                if ( *shared).is_unique() {
                    // This is the only handle to the buffer. It can be reclaimed.
                    // However, before doing the work of copying data, check to make
                    // sure that the vector has enough capacity.
                    let v = &mut ( *shared).vec;
    
                    let v_capacity = v.capacity();
                    let ptr = v.as_mut_ptr();
    
                    let offset = offset_from(self.ptr.as_ptr(), ptr);
    
                    // Compare the condition in the `kind == KIND_VEC` case above
                    // for more details.
                    if v_capacity >= new_cap + offset {
                        self.cap = new_cap;
                        // no copy is necessary
                    } else if v_capacity >= new_cap && offset >= len {
                        // The capacity is sufficient, and copying is not too much
                        // overhead: reclaim the buffer!
    
                        // `offset >= len` means: no overlap
                        ptr::copy_nonoverlapping(self.ptr.as_ptr(), ptr, len);
    
                        self.ptr = vptr(ptr);
                        self.cap = v.capacity();
                    } else {
                        if !allocate {
                            return false;
                        }
                        // calculate offset
                        let off = (self.ptr.as_ptr() as usize) - (v.as_ptr() as usize);
    
                        // new_cap is calculated in terms of `BytesMut`, not the underlying
                        // `Vec`, so it does not take the offset into account.
                        //
                        // Thus we have to manually add it here.
                        new_cap = new_cap.checked_add(off).expect("overflow");
    
                        // The vector capacity is not sufficient. The reserve request is
                        // asking for more than the initial buffer capacity. Allocate more
                        // than requested if `new_cap` is not much bigger than the current
                        // capacity.
                        //
                        // There are some situations, using `reserve_exact` that the
                        // buffer capacity could be below `original_capacity`, so do a
                        // check.
                        let double = v.capacity().checked_shl(1).unwrap_or(new_cap);
    
                        new_cap = cmp::max(double, new_cap);
    
                        // No space - allocate more
                        //
                        // The length field of `Shared::vec` is not used by the `BytesMut`;
                        // instead we use the `len` field in the `BytesMut` itself. However,
                        // when calling `reserve`, it doesn't guarantee that data stored in
                        // the unused capacity of the vector is copied over to the new
                        // allocation, so we need to ensure that we don't have any data we
                        // care about in the unused capacity before calling `reserve`.
                        debug_assert!(off + len <= v.capacity());
                        v.set_len(off + len);
                        v.reserve(new_cap - v.len());
    
                        // Update the info
                        self.ptr = vptr(v.as_mut_ptr().add(off));
                        self.cap = v.capacity() - off;
                    }
    
                    return true;
                }
            }
            if !allocate {
                return false;
            }
    
            let original_capacity_repr = unsafe { ( *shared).original_capacity_repr };
            let original_capacity = original_capacity_from_repr(original_capacity_repr);
    
            new_cap = cmp::max(new_cap, original_capacity);
    
            // Create a new vector to store the data
            let mut v = ManuallyDrop::new(Vec::with_capacity(new_cap));
    
            // Copy the bytes
            v.extend_from_slice(self.as_ref());
    
            // Release the shared handle. This must be done *after* the bytes are
            // copied.
            unsafe { release_shared(shared) };
    
            // Update self
            let data = (original_capacity_repr << ORIGINAL_CAPACITY_OFFSET) | KIND_VEC;
            self.data = invalid_ptr(data);
            self.ptr = vptr(v.as_mut_ptr());
            self.cap = v.capacity();
            debug_assert_eq!(self.len, v.len());
            return true;
        }
    *)
    Definition reserve_inner (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; additional; allocate ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let additional := M.alloc (| additional |) in
          let allocate := M.alloc (| allocate |) in
          M.catch_return (Ty.path "bool") (|
            ltac:(M.monadic
              (M.never_to_any (|
                M.read (|
                  let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.path "bytes::bytes_mut::BytesMut",
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |) in
                  let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.path "bytes::bytes_mut::BytesMut",
                          "kind",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.read (| kind |);
                                      M.read (|
                                        get_constant (|
                                          "bytes::bytes_mut::KIND_VEC",
                                          Ty.path "usize"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ off : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes_mut::BytesMut",
                                          "get_vec_pos",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  LogicalOp.and (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.ge,
                                                      [
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.add,
                                                          [
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              BinOp.Wrap.sub,
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "bytes::bytes_mut::BytesMut",
                                                                    "capacity",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| self |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |);
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "bytes::bytes_mut::BytesMut",
                                                                    "len",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| self |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |);
                                                            M.read (| off |)
                                                          ]
                                                        |);
                                                        M.read (| additional |)
                                                      ]
                                                    |),
                                                    ltac:(M.monadic
                                                      (M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.ge,
                                                        [
                                                          M.read (| off |);
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.path "bytes::bytes_mut::BytesMut",
                                                              "len",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)))
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let~ base_ptr :
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ]
                                                  ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                                    "sub",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "core::ptr::non_null::NonNull")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        "as_ptr",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "bytes::bytes_mut::BytesMut",
                                                            "ptr"
                                                          |)
                                                        |)
                                                      ]
                                                    |);
                                                    M.read (| off |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_function (|
                                                    "core::intrinsics::copy_nonoverlapping",
                                                    [],
                                                    [ Ty.path "u8" ]
                                                  |),
                                                  [
                                                    (* MutToConstPointer *)
                                                    M.pointer_coercion
                                                      (M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::ptr::non_null::NonNull")
                                                            []
                                                            [ Ty.path "u8" ],
                                                          "as_ptr",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "bytes::bytes_mut::BytesMut",
                                                              "ptr"
                                                            |)
                                                          |)
                                                        ]
                                                      |));
                                                    M.read (| base_ptr |);
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "bytes::bytes_mut::BytesMut",
                                                        "len"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "bytes::bytes_mut::BytesMut",
                                                    "ptr"
                                                  |),
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::ptr::non_null::NonNull")
                                                      []
                                                      [ Ty.path "u8" ],
                                                    M.get_function (|
                                                      "bytes::bytes_mut::vptr",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| base_ptr |) ]
                                                  |)
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_associated_function (|
                                                    Ty.path "bytes::bytes_mut::BytesMut",
                                                    "set_vec_pos",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| self |) |)
                                                    |);
                                                    Value.Integer IntegerKind.Usize 0
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                let β :=
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "bytes::bytes_mut::BytesMut",
                                                    "cap"
                                                  |) in
                                                M.write (|
                                                  β,
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.add,
                                                    [ M.read (| β |); M.read (| off |) ]
                                                  |)
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.match_operator (|
                                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use
                                                          (M.alloc (|
                                                            UnOp.not (| M.read (| allocate |) |)
                                                          |)) in
                                                      let _ :=
                                                        is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (| Value.Bool false |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            let~ v :
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::manually_drop::ManuallyDrop")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          []
                                                          [
                                                            Ty.path "u8";
                                                            Ty.path "alloc::alloc::Global"
                                                          ]
                                                      ]
                                                  ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::mem::manually_drop::ManuallyDrop")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [
                                                          Ty.path "u8";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::manually_drop::ManuallyDrop")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          []
                                                          [
                                                            Ty.path "u8";
                                                            Ty.path "alloc::alloc::Global"
                                                          ]
                                                      ],
                                                    "new",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [
                                                          Ty.path "u8";
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      M.get_function (|
                                                        "bytes::bytes_mut::rebuild_vec",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [ Ty.path "u8" ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            "as_ptr",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "bytes::bytes_mut::BytesMut",
                                                                "ptr"
                                                              |)
                                                            |)
                                                          ]
                                                        |);
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "bytes::bytes_mut::BytesMut",
                                                            "len"
                                                          |)
                                                        |);
                                                        M.read (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "bytes::bytes_mut::BytesMut",
                                                            "cap"
                                                          |)
                                                        |);
                                                        M.read (| off |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "reserve",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "&mut")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                []
                                                                [
                                                                  Ty.path "u8";
                                                                  Ty.path "alloc::alloc::Global"
                                                                ]
                                                            ],
                                                          M.get_trait_method (|
                                                            "core::ops::deref::DerefMut",
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::mem::manually_drop::ManuallyDrop")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  []
                                                                  [
                                                                    Ty.path "u8";
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ]
                                                              ],
                                                            [],
                                                            [],
                                                            "deref_mut",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.borrow (| Pointer.Kind.MutRef, v |) ]
                                                        |)
                                                      |)
                                                    |);
                                                    M.read (| additional |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "bytes::bytes_mut::BytesMut",
                                                    "ptr"
                                                  |),
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::ptr::non_null::NonNull")
                                                      []
                                                      [ Ty.path "u8" ],
                                                    M.get_function (|
                                                      "bytes::bytes_mut::vptr",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "*mut")
                                                          []
                                                          [ Ty.path "u8" ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            []
                                                            [ Ty.path "u8" ],
                                                          "add",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "*mut")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                []
                                                                [
                                                                  Ty.path "u8";
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              "as_mut_ptr",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.deref (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path "&mut")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          []
                                                                          [
                                                                            Ty.path "u8";
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::ops::deref::DerefMut",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::mem::manually_drop::ManuallyDrop")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::vec::Vec")
                                                                            []
                                                                            [
                                                                              Ty.path "u8";
                                                                              Ty.path
                                                                                "alloc::alloc::Global"
                                                                            ]
                                                                        ],
                                                                      [],
                                                                      [],
                                                                      "deref_mut",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        v
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |);
                                                          M.read (| off |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "bytes::bytes_mut::BytesMut",
                                                    "cap"
                                                  |),
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    BinOp.Wrap.sub,
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [
                                                              Ty.path "u8";
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          "capacity",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      []
                                                                      [
                                                                        Ty.path "u8";
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ]
                                                                  ],
                                                                M.get_trait_method (|
                                                                  "core::ops::deref::Deref",
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::mem::manually_drop::ManuallyDrop")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        []
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ],
                                                                  [],
                                                                  [],
                                                                  "deref",
                                                                  [],
                                                                  []
                                                                |),
                                                                [ M.borrow (| Pointer.Kind.Ref, v |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |);
                                                      M.read (| off |)
                                                    ]
                                                  |)
                                                |)
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.match_operator (|
                                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.use (M.alloc (| Value.Bool true |)) in
                                                      let _ :=
                                                        is_constant_or_break_match (|
                                                          M.read (| γ |),
                                                          Value.Bool true
                                                        |) in
                                                      let~ _ :
                                                          Ty.apply
                                                            (Ty.path "*")
                                                            []
                                                            [ Ty.tuple [] ] :=
                                                        M.match_operator (|
                                                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                          M.alloc (|
                                                            Value.Tuple
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "bytes::bytes_mut::BytesMut",
                                                                    "len"
                                                                  |)
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.alloc (|
                                                                    M.call_closure (|
                                                                      Ty.path "usize",
                                                                      BinOp.Wrap.sub,
                                                                      [
                                                                        M.call_closure (|
                                                                          Ty.path "usize",
                                                                          M.get_associated_function (|
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::vec::Vec")
                                                                              []
                                                                              [
                                                                                Ty.path "u8";
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ],
                                                                            "len",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.call_closure (|
                                                                                  Ty.apply
                                                                                    (Ty.path "&")
                                                                                    []
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "alloc::vec::Vec")
                                                                                        []
                                                                                        [
                                                                                          Ty.path
                                                                                            "u8";
                                                                                          Ty.path
                                                                                            "alloc::alloc::Global"
                                                                                        ]
                                                                                    ],
                                                                                  M.get_trait_method (|
                                                                                    "core::ops::deref::Deref",
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::mem::manually_drop::ManuallyDrop")
                                                                                      []
                                                                                      [
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "alloc::vec::Vec")
                                                                                          []
                                                                                          [
                                                                                            Ty.path
                                                                                              "u8";
                                                                                            Ty.path
                                                                                              "alloc::alloc::Global"
                                                                                          ]
                                                                                      ],
                                                                                    [],
                                                                                    [],
                                                                                    "deref",
                                                                                    [],
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      v
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |);
                                                                        M.read (| off |)
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              ]
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    0
                                                                  |) in
                                                                let γ0_1 :=
                                                                  M.SubPointer.get_tuple_field (|
                                                                    γ,
                                                                    1
                                                                  |) in
                                                                let left_val := M.copy (| γ0_0 |) in
                                                                let right_val :=
                                                                  M.copy (| γ0_1 |) in
                                                                M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path "*")
                                                                    []
                                                                    [ Ty.tuple [] ],
                                                                  M.alloc (| Value.Tuple [] |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ :=
                                                                          M.use
                                                                            (M.alloc (|
                                                                              UnOp.not (|
                                                                                M.call_closure (|
                                                                                  Ty.path "bool",
                                                                                  BinOp.eq,
                                                                                  [
                                                                                    M.read (|
                                                                                      M.deref (|
                                                                                        M.read (|
                                                                                          left_val
                                                                                        |)
                                                                                      |)
                                                                                    |);
                                                                                    M.read (|
                                                                                      M.deref (|
                                                                                        M.read (|
                                                                                          right_val
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |)) in
                                                                        let _ :=
                                                                          is_constant_or_break_match (|
                                                                            M.read (| γ |),
                                                                            Value.Bool true
                                                                          |) in
                                                                        M.alloc (|
                                                                          M.never_to_any (|
                                                                            M.read (|
                                                                              let~ kind :
                                                                                  Ty.apply
                                                                                    (Ty.path "*")
                                                                                    []
                                                                                    [
                                                                                      Ty.path
                                                                                        "core::panicking::AssertKind"
                                                                                    ] :=
                                                                                M.alloc (|
                                                                                  Value.StructTuple
                                                                                    "core::panicking::AssertKind::Eq"
                                                                                    []
                                                                                    []
                                                                                    []
                                                                                |) in
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  Ty.path "never",
                                                                                  M.get_function (|
                                                                                    "core::panicking::assert_failed",
                                                                                    [],
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize";
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      kind
                                                                                    |);
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.deref (|
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              left_val
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    |);
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.deref (|
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              right_val
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    |);
                                                                                    Value.StructTuple
                                                                                      "core::option::Option::None"
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "core::fmt::Arguments"
                                                                                      ]
                                                                                      []
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        |)));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (M.alloc (|
                                                                          Value.Tuple []
                                                                        |)))
                                                                  ]
                                                                |)))
                                                          ]
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)));
                                                  fun γ =>
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                ]
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.return_ (| Value.Bool true |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.borrow (| Pointer.Kind.Ref, kind |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        get_constant (|
                                          "bytes::bytes_mut::KIND_ARC",
                                          Ty.path "usize"
                                        |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "core::panicking::AssertKind"
                                                          ] :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                          []
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ shared :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ] ] :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "bytes::bytes_mut::BytesMut",
                        "data"
                      |)
                    |) in
                  let~ new_cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.copy (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (| Ty.path "usize", "checked_add", [], [] |),
                            [ M.read (| len |); M.read (| additional |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let new_cap := M.copy (| γ0_0 |) in
                              new_cap));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              let γ := M.alloc (| UnOp.not (| M.read (| allocate |) |) |) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic", [], [] |),
                                    [ mk_str (| "overflow" |) ]
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes_mut::Shared",
                                      "is_unique",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| shared |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ v :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ] :=
                                    M.alloc (|
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| shared |) |),
                                          "bytes::bytes_mut::Shared",
                                          "vec"
                                        |)
                                      |)
                                    |) in
                                  let~ v_capacity : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                          "capacity",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| v |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ ptr :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                          "as_mut_ptr",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| v |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ offset : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_function (| "bytes::offset_from", [], [] |),
                                        [
                                          (* MutToConstPointer *)
                                          M.pointer_coercion
                                            (M.call_closure (|
                                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::ptr::non_null::NonNull")
                                                  []
                                                  [ Ty.path "u8" ],
                                                "as_ptr",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "bytes::bytes_mut::BytesMut",
                                                    "ptr"
                                                  |)
                                                |)
                                              ]
                                            |));
                                          (* MutToConstPointer *)
                                          M.pointer_coercion (M.read (| ptr |))
                                        ]
                                      |)
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.ge,
                                                    [
                                                      M.read (| v_capacity |);
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.add,
                                                        [ M.read (| new_cap |); M.read (| offset |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.write (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "bytes::bytes_mut::BytesMut",
                                                    "cap"
                                                  |),
                                                  M.read (| new_cap |)
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          LogicalOp.and (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              BinOp.ge,
                                                              [
                                                                M.read (| v_capacity |);
                                                                M.read (| new_cap |)
                                                              ]
                                                            |),
                                                            ltac:(M.monadic
                                                              (M.call_closure (|
                                                                Ty.path "bool",
                                                                BinOp.ge,
                                                                [
                                                                  M.read (| offset |);
                                                                  M.read (| len |)
                                                                ]
                                                              |)))
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.tuple [],
                                                          M.get_function (|
                                                            "core::intrinsics::copy_nonoverlapping",
                                                            [],
                                                            [ Ty.path "u8" ]
                                                          |),
                                                          [
                                                            (* MutToConstPointer *)
                                                            M.pointer_coercion
                                                              (M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*mut")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ptr::non_null::NonNull")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      M.deref (|
                                                                        M.read (| self |)
                                                                      |),
                                                                      "bytes::bytes_mut::BytesMut",
                                                                      "ptr"
                                                                    |)
                                                                  |)
                                                                ]
                                                              |));
                                                            M.read (| ptr |);
                                                            M.read (| len |)
                                                          ]
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "bytes::bytes_mut::BytesMut",
                                                            "ptr"
                                                          |),
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            M.get_function (|
                                                              "bytes::bytes_mut::vptr",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.read (| ptr |) ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "bytes::bytes_mut::BytesMut",
                                                            "cap"
                                                          |),
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                []
                                                                [
                                                                  Ty.path "u8";
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              "capacity",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| v |) |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.match_operator (|
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (|
                                                                    UnOp.not (|
                                                                      M.read (| allocate |)
                                                                    |)
                                                                  |)) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              M.alloc (|
                                                                M.never_to_any (|
                                                                  M.read (|
                                                                    M.return_ (| Value.Bool false |)
                                                                  |)
                                                                |)
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.alloc (| Value.Tuple [] |)))
                                                        ]
                                                      |) in
                                                    let~ off :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "usize" ] :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          BinOp.Wrap.sub,
                                                          [
                                                            M.cast
                                                              (Ty.path "usize")
                                                              (M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*mut")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "core::ptr::non_null::NonNull")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (|
                                                                    M.SubPointer.get_struct_record_field (|
                                                                      M.deref (|
                                                                        M.read (| self |)
                                                                      |),
                                                                      "bytes::bytes_mut::BytesMut",
                                                                      "ptr"
                                                                    |)
                                                                  |)
                                                                ]
                                                              |));
                                                            M.cast
                                                              (Ty.path "usize")
                                                              (M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*const")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "alloc::vec::Vec")
                                                                    []
                                                                    [
                                                                      Ty.path "u8";
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ],
                                                                  "as_ptr",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| v |) |)
                                                                  |)
                                                                ]
                                                              |))
                                                          ]
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          new_cap,
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.path "usize" ],
                                                              "expect",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  []
                                                                  [ Ty.path "usize" ],
                                                                M.get_associated_function (|
                                                                  Ty.path "usize",
                                                                  "checked_add",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| new_cap |);
                                                                  M.read (| off |)
                                                                ]
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  mk_str (| "overflow" |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ double :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "usize" ] :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [ Ty.path "usize" ],
                                                            "unwrap_or",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                []
                                                                [ Ty.path "usize" ],
                                                              M.get_associated_function (|
                                                                Ty.path "usize",
                                                                "checked_shl",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      []
                                                                      [
                                                                        Ty.path "u8";
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    "capacity",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (| M.read (| v |) |)
                                                                    |)
                                                                  ]
                                                                |);
                                                                Value.Integer IntegerKind.U32 1
                                                              ]
                                                            |);
                                                            M.read (| new_cap |)
                                                          ]
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          new_cap,
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_function (|
                                                              "core::cmp::max",
                                                              [],
                                                              [ Ty.path "usize" ]
                                                            |),
                                                            [
                                                              M.read (| double |);
                                                              M.read (| new_cap |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.match_operator (|
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                        M.alloc (| Value.Tuple [] |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ :=
                                                                M.use
                                                                  (M.alloc (| Value.Bool true |)) in
                                                              let _ :=
                                                                is_constant_or_break_match (|
                                                                  M.read (| γ |),
                                                                  Value.Bool true
                                                                |) in
                                                              let~ _ :
                                                                  Ty.apply
                                                                    (Ty.path "*")
                                                                    []
                                                                    [ Ty.tuple [] ] :=
                                                                M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path "*")
                                                                    []
                                                                    [ Ty.tuple [] ],
                                                                  M.alloc (| Value.Tuple [] |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ :=
                                                                          M.use
                                                                            (M.alloc (|
                                                                              UnOp.not (|
                                                                                M.call_closure (|
                                                                                  Ty.path "bool",
                                                                                  BinOp.le,
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      Ty.path
                                                                                        "usize",
                                                                                      BinOp.Wrap.add,
                                                                                      [
                                                                                        M.read (|
                                                                                          off
                                                                                        |);
                                                                                        M.read (|
                                                                                          len
                                                                                        |)
                                                                                      ]
                                                                                    |);
                                                                                    M.call_closure (|
                                                                                      Ty.path
                                                                                        "usize",
                                                                                      M.get_associated_function (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "alloc::vec::Vec")
                                                                                          []
                                                                                          [
                                                                                            Ty.path
                                                                                              "u8";
                                                                                            Ty.path
                                                                                              "alloc::alloc::Global"
                                                                                          ],
                                                                                        "capacity",
                                                                                        [],
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              v
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      ]
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |)) in
                                                                        let _ :=
                                                                          is_constant_or_break_match (|
                                                                            M.read (| γ |),
                                                                            Value.Bool true
                                                                          |) in
                                                                        M.alloc (|
                                                                          M.never_to_any (|
                                                                            M.call_closure (|
                                                                              Ty.path "never",
                                                                              M.get_function (|
                                                                                "core::panicking::panic",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                mk_str (|
                                                                                  "assertion failed: off + len <= v.capacity()"
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |)));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (M.alloc (|
                                                                          Value.Tuple []
                                                                        |)))
                                                                  ]
                                                                |) in
                                                              M.alloc (| Value.Tuple [] |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.alloc (| Value.Tuple [] |)))
                                                        ]
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.tuple [],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [
                                                                Ty.path "u8";
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            "set_len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.deref (| M.read (| v |) |)
                                                            |);
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              BinOp.Wrap.add,
                                                              [ M.read (| off |); M.read (| len |) ]
                                                            |)
                                                          ]
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.tuple [],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [
                                                                Ty.path "u8";
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            "reserve",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.deref (| M.read (| v |) |)
                                                            |);
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              BinOp.Wrap.sub,
                                                              [
                                                                M.read (| new_cap |);
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      []
                                                                      [
                                                                        Ty.path "u8";
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    "len",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (| M.read (| v |) |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "bytes::bytes_mut::BytesMut",
                                                            "ptr"
                                                          |),
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::ptr::non_null::NonNull")
                                                              []
                                                              [ Ty.path "u8" ],
                                                            M.get_function (|
                                                              "bytes::bytes_mut::vptr",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "*mut")
                                                                  []
                                                                  [ Ty.path "u8" ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "*mut")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  "add",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path "*mut")
                                                                      []
                                                                      [ Ty.path "u8" ],
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        []
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ],
                                                                      "as_mut_ptr",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.deref (| M.read (| v |) |)
                                                                      |)
                                                                    ]
                                                                  |);
                                                                  M.read (| off |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let~ _ :
                                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                                      M.alloc (|
                                                        M.write (|
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "bytes::bytes_mut::BytesMut",
                                                            "cap"
                                                          |),
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.sub,
                                                            [
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "alloc::vec::Vec")
                                                                    []
                                                                    [
                                                                      Ty.path "u8";
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ],
                                                                  "capacity",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| v |) |)
                                                                  |)
                                                                ]
                                                              |);
                                                              M.read (| off |)
                                                            ]
                                                          |)
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |) in
                                  M.return_ (| Value.Bool true |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| UnOp.not (| M.read (| allocate |) |) |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ original_capacity_repr : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.copy (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| shared |) |),
                        "bytes::bytes_mut::Shared",
                        "original_capacity_repr"
                      |)
                    |) in
                  let~ original_capacity : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_function (|
                          "bytes::bytes_mut::original_capacity_from_repr",
                          [],
                          []
                        |),
                        [ M.read (| original_capacity_repr |) ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.write (|
                        new_cap,
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_function (| "core::cmp::max", [], [ Ty.path "usize" ] |),
                          [ M.read (| new_cap |); M.read (| original_capacity |) ]
                        |)
                      |)
                    |) in
                  let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ],
                          "new",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              "with_capacity",
                              [],
                              []
                            |),
                            [ M.read (| new_cap |) ]
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "extend_from_slice",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ],
                                M.get_trait_method (|
                                  "core::ops::deref::DerefMut",
                                  Ty.apply
                                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                    ],
                                  [],
                                  [],
                                  "deref_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, v |) ]
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::convert::AsRef",
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                  [],
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  "as_ref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, self |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "bytes::bytes_mut::release_shared", [], [] |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  let~ data : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.bit_or,
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.shl,
                            [
                              M.read (| original_capacity_repr |);
                              M.read (|
                                get_constant (|
                                  "bytes::bytes_mut::ORIGINAL_CAPACITY_OFFSET",
                                  Ty.path "usize"
                                |)
                              |)
                            ]
                          |);
                          M.read (|
                            get_constant (| "bytes::bytes_mut::KIND_VEC", Ty.path "usize" |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "bytes::bytes_mut::BytesMut",
                          "data"
                        |),
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                          M.get_function (|
                            "bytes::bytes_mut::invalid_ptr",
                            [],
                            [ Ty.path "bytes::bytes_mut::Shared" ]
                          |),
                          [ M.read (| data |) ]
                        |)
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "bytes::bytes_mut::BytesMut",
                          "ptr"
                        |),
                        M.call_closure (|
                          Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                          M.get_function (| "bytes::bytes_mut::vptr", [], [] |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                "as_mut_ptr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::deref::DerefMut",
                                        Ty.apply
                                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                          ],
                                        [],
                                        [],
                                        "deref_mut",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.MutRef, v |) ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "bytes::bytes_mut::BytesMut",
                          "cap"
                        |),
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                            "capacity",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, v |) ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "bytes::bytes_mut::BytesMut",
                                          "len"
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                              "len",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          []
                                                          [
                                                            Ty.path "u8";
                                                            Ty.path "alloc::alloc::Global"
                                                          ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::mem::manually_drop::ManuallyDrop")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [
                                                              Ty.path "u8";
                                                              Ty.path "alloc::alloc::Global"
                                                            ]
                                                        ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, v |) ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let left_val := M.copy (| γ0_0 |) in
                                      let right_val := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    UnOp.not (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.eq,
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| left_val |) |)
                                                          |);
                                                          M.read (|
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.apply
                                                          (Ty.path "*")
                                                          []
                                                          [ Ty.path "core::panicking::AssertKind"
                                                          ] :=
                                                      M.alloc (|
                                                        Value.StructTuple
                                                          "core::panicking::AssertKind::Eq"
                                                          []
                                                          []
                                                          []
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.return_ (| Value.Bool true |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_reserve_inner :
      M.IsAssociatedFunction.C Self "reserve_inner" reserve_inner.
    Admitted.
    Global Typeclasses Opaque reserve_inner.
    
    (*
        pub fn try_reclaim(&mut self, additional: usize) -> bool {
            let len = self.len();
            let rem = self.capacity() - len;
    
            if additional <= rem {
                // The handle can already store at least `additional` more bytes, so
                // there is no further work needed to be done.
                return true;
            }
    
            self.reserve_inner(additional, false)
        }
    *)
    Definition try_reclaim (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; additional ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let additional := M.alloc (| additional |) in
          M.catch_return (Ty.path "bool") (|
            ltac:(M.monadic
              (M.read (|
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ rem : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            "capacity",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |);
                        M.read (| len |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ M.read (| additional |); M.read (| rem |) ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Bool true |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "reserve_inner",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| additional |);
                      Value.Bool false
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_reclaim :
      M.IsAssociatedFunction.C Self "try_reclaim" try_reclaim.
    Admitted.
    Global Typeclasses Opaque try_reclaim.
    
    (*
        pub fn extend_from_slice(&mut self, extend: &[u8]) {
            let cnt = extend.len();
            self.reserve(cnt);
    
            unsafe {
                let dst = self.spare_capacity_mut();
                // Reserved above
                debug_assert!(dst.len() >= cnt);
    
                ptr::copy_nonoverlapping(extend.as_ptr(), dst.as_mut_ptr().cast(), cnt);
            }
    
            unsafe {
                self.advance_mut(cnt);
            }
        }
    *)
    Definition extend_from_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; extend ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let extend := M.alloc (| extend |) in
          M.read (|
            let~ cnt : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "len",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| extend |) |) |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "reserve",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| cnt |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              let~ dst :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ]
                        ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "spare_capacity_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.ge,
                                            [
                                              M.call_closure (|
                                                Ty.path "usize",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "slice")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::mem::maybe_uninit::MaybeUninit")
                                                        []
                                                        [ Ty.path "u8" ]
                                                    ],
                                                  "len",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| dst |) |)
                                                  |)
                                                ]
                                              |);
                                              M.read (| cnt |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (| "core::panicking::panic", [], [] |),
                                        [ mk_str (| "assertion failed: dst.len() >= cnt" |) ]
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::intrinsics::copy_nonoverlapping",
                      [],
                      [ Ty.path "u8" ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| extend |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "*mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ],
                          "cast",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "*mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ],
                              "as_mut_ptr",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |) ]
                          |)
                        ]
                      |);
                      M.read (| cnt |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "bytes::buf::buf_mut::BufMut",
                    Ty.path "bytes::bytes_mut::BytesMut",
                    [],
                    [],
                    "advance_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| cnt |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_extend_from_slice :
      M.IsAssociatedFunction.C Self "extend_from_slice" extend_from_slice.
    Admitted.
    Global Typeclasses Opaque extend_from_slice.
    
    (*
        pub fn unsplit(&mut self, other: BytesMut) {
            if self.is_empty() {
                *self = other;
                return;
            }
    
            if let Err(other) = self.try_unsplit(other) {
                self.extend_from_slice(other.as_ref());
            }
        }
    *)
    Definition unsplit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.catch_return (Ty.tuple []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.path "bytes::bytes_mut::BytesMut",
                                    "is_empty",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                  M.alloc (|
                                    M.write (|
                                      M.deref (| M.read (| self |) |),
                                      M.read (| other |)
                                    |)
                                  |) in
                                M.return_ (| Value.Tuple [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "bytes::bytes_mut::BytesMut" ],
                              M.get_associated_function (|
                                Ty.path "bytes::bytes_mut::BytesMut",
                                "try_unsplit",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                                M.read (| other |)
                              ]
                            |)
                          |) in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let other := M.copy (| γ0_0 |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Ty.path "bytes::bytes_mut::BytesMut",
                                "extend_from_slice",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_trait_method (|
                                        "core::convert::AsRef",
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        [],
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        "as_ref",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, other |) ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unsplit : M.IsAssociatedFunction.C Self "unsplit" unsplit.
    Admitted.
    Global Typeclasses Opaque unsplit.
    
    (*
        pub(crate) fn from_vec(vec: Vec<u8>) -> BytesMut {
            let mut vec = ManuallyDrop::new(vec);
            let ptr = vptr(vec.as_mut_ptr());
            let len = vec.len();
            let cap = vec.capacity();
    
            let original_capacity_repr = original_capacity_to_repr(cap);
            let data = (original_capacity_repr << ORIGINAL_CAPACITY_OFFSET) | KIND_VEC;
    
            BytesMut {
                ptr,
                len,
                cap,
                data: invalid_ptr(data),
            }
        }
    *)
    Definition from_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ vec ] =>
        ltac:(M.monadic
          (let vec := M.alloc (| vec |) in
          M.read (|
            let~ vec :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::manually_drop::ManuallyDrop")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::manually_drop::ManuallyDrop")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| vec |) ]
                |)
              |) in
            let~ ptr :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                  M.get_function (| "bytes::bytes_mut::vptr", [], [] |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        "as_mut_ptr",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::DerefMut",
                                Ty.apply
                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ],
                                [],
                                [],
                                "deref_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, vec |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "len",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                              ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, vec |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "capacity",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                              ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, vec |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ original_capacity_repr : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "bytes::bytes_mut::original_capacity_to_repr", [], [] |),
                  [ M.read (| cap |) ]
                |)
              |) in
            let~ data : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.bit_or,
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.shl,
                      [
                        M.read (| original_capacity_repr |);
                        M.read (|
                          get_constant (|
                            "bytes::bytes_mut::ORIGINAL_CAPACITY_OFFSET",
                            Ty.path "usize"
                          |)
                        |)
                      ]
                    |);
                    M.read (| get_constant (| "bytes::bytes_mut::KIND_VEC", Ty.path "usize" |) |)
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "bytes::bytes_mut::BytesMut"
                []
                []
                [
                  ("ptr", M.read (| ptr |));
                  ("len", M.read (| len |));
                  ("cap", M.read (| cap |));
                  ("data",
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                      M.get_function (|
                        "bytes::bytes_mut::invalid_ptr",
                        [],
                        [ Ty.path "bytes::bytes_mut::Shared" ]
                      |),
                      [ M.read (| data |) ]
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_vec : M.IsAssociatedFunction.C Self "from_vec" from_vec.
    Admitted.
    Global Typeclasses Opaque from_vec.
    
    (*
        fn as_slice(&self) -> &[u8] {
            unsafe { slice::from_raw_parts(self.ptr.as_ptr(), self.len) }
        }
    *)
    Definition as_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_function (| "core::slice::raw::from_raw_parts", [], [ Ty.path "u8" ] |),
                [
                  (* MutToConstPointer *)
                  M.pointer_coercion
                    (M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "bytes::bytes_mut::BytesMut",
                            "ptr"
                          |)
                        |)
                      ]
                    |));
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes_mut::BytesMut",
                      "len"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_slice : M.IsAssociatedFunction.C Self "as_slice" as_slice.
    Admitted.
    Global Typeclasses Opaque as_slice.
    
    (*
        fn as_slice_mut(&mut self) -> &mut [u8] {
            unsafe { slice::from_raw_parts_mut(self.ptr.as_ptr(), self.len) }
        }
    *)
    Definition as_slice_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_function (|
                          "core::slice::raw::from_raw_parts_mut",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "bytes::bytes_mut::BytesMut",
                                  "ptr"
                                |)
                              |)
                            ]
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "bytes::bytes_mut::BytesMut",
                              "len"
                            |)
                          |)
                        ]
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_slice_mut :
      M.IsAssociatedFunction.C Self "as_slice_mut" as_slice_mut.
    Admitted.
    Global Typeclasses Opaque as_slice_mut.
    
    (*
        pub(crate) unsafe fn advance_unchecked(&mut self, count: usize) {
            // Setting the start to 0 is a no-op, so return early if this is the
            // case.
            if count == 0 {
                return;
            }
    
            debug_assert!(count <= self.cap, "internal: set_start out of bounds");
    
            let kind = self.kind();
    
            if kind == KIND_VEC {
                // Setting the start when in vec representation is a little more
                // complicated. First, we have to track how far ahead the
                // "start" of the byte buffer from the beginning of the vec. We
                // also have to ensure that we don't exceed the maximum shift.
                let pos = self.get_vec_pos() + count;
    
                if pos <= MAX_VEC_POS {
                    self.set_vec_pos(pos);
                } else {
                    // The repr must be upgraded to ARC. This will never happen
                    // on 64 bit systems and will only happen on 32 bit systems
                    // when shifting past 134,217,727 bytes. As such, we don't
                    // worry too much about performance here.
                    self.promote_to_shared(/*ref_count = */ 1);
                }
            }
    
            // Updating the start of the view is setting `ptr` to point to the
            // new start and updating the `len` field to reflect the new length
            // of the view.
            self.ptr = vptr(self.ptr.as_ptr().add(count));
            self.len = self.len.checked_sub(count).unwrap_or(0);
            self.cap -= count;
        }
    *)
    Definition advance_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; count ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let count := M.alloc (| count |) in
          M.catch_return (Ty.tuple []) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.le,
                                              [
                                                M.read (| count |);
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "bytes::bytes_mut::BytesMut",
                                                    "cap"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [ mk_str (| "internal: set_start out of bounds" |) ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "kind",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.read (| kind |);
                                    M.read (|
                                      get_constant (|
                                        "bytes::bytes_mut::KIND_VEC",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ pos : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "bytes::bytes_mut::BytesMut",
                                      "get_vec_pos",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |);
                                  M.read (| count |)
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.le,
                                          [
                                            M.read (| pos |);
                                            M.read (|
                                              get_constant (|
                                                "bytes::bytes_mut::MAX_VEC_POS",
                                                Ty.path "usize"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes_mut::BytesMut",
                                          "set_vec_pos",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          M.read (| pos |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes_mut::BytesMut",
                                          "promote_to_shared",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "bytes::bytes_mut::BytesMut",
                        "ptr"
                      |),
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        M.get_function (| "bytes::bytes_mut::vptr", [], [] |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.path "u8" ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "bytes::bytes_mut::BytesMut",
                                      "ptr"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (| count |)
                            ]
                          |)
                        ]
                      |)
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "bytes::bytes_mut::BytesMut",
                        "len"
                      |),
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          "unwrap_or",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "bytes::bytes_mut::BytesMut",
                                  "len"
                                |)
                              |);
                              M.read (| count |)
                            ]
                          |);
                          Value.Integer IntegerKind.Usize 0
                        ]
                      |)
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (|
                    let β :=
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "bytes::bytes_mut::BytesMut",
                        "cap"
                      |) in
                    M.write (|
                      β,
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| β |); M.read (| count |) ]
                      |)
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_advance_unchecked :
      M.IsAssociatedFunction.C Self "advance_unchecked" advance_unchecked.
    Admitted.
    Global Typeclasses Opaque advance_unchecked.
    
    (*
        fn try_unsplit(&mut self, other: BytesMut) -> Result<(), BytesMut> {
            if other.capacity() == 0 {
                return Ok(());
            }
    
            let ptr = unsafe { self.ptr.as_ptr().add(self.len) };
            if ptr == other.ptr.as_ptr()
                && self.kind() == KIND_ARC
                && other.kind() == KIND_ARC
                && self.data == other.data
            {
                // Contiguous blocks, just combine directly
                self.len += other.len;
                self.cap += other.cap;
                Ok(())
            } else {
                Err(other)
            }
        }
    *)
    Definition try_unsplit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "bytes::bytes_mut::BytesMut" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        "capacity",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, other |) ]
                                    |);
                                    Value.Integer IntegerKind.Usize 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Ok"
                                    []
                                    [ Ty.tuple []; Ty.path "bytes::bytes_mut::BytesMut" ]
                                    [ Value.Tuple [] ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ ptr :
                    Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                            "as_ptr",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "ptr"
                              |)
                            |)
                          ]
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "bytes::bytes_mut::BytesMut",
                            "len"
                          |)
                        |)
                      ]
                    |)
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "bytes::bytes_mut::BytesMut" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| ptr |);
                                        M.call_closure (|
                                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::ptr::non_null::NonNull")
                                              []
                                              [ Ty.path "u8" ],
                                            "as_ptr",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                other,
                                                "bytes::bytes_mut::BytesMut",
                                                "ptr"
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.path "bytes::bytes_mut::BytesMut",
                                              "kind",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |)
                                            ]
                                          |);
                                          M.read (|
                                            get_constant (|
                                              "bytes::bytes_mut::KIND_ARC",
                                              Ty.path "usize"
                                            |)
                                          |)
                                        ]
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.path "bytes::bytes_mut::BytesMut",
                                            "kind",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, other |) ]
                                        |);
                                        M.read (|
                                          get_constant (|
                                            "bytes::bytes_mut::KIND_ARC",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "bytes::bytes_mut::BytesMut",
                                          "data"
                                        |)
                                      |);
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          other,
                                          "bytes::bytes_mut::BytesMut",
                                          "data"
                                        |)
                                      |)
                                    ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            let β :=
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "len"
                              |) in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [
                                  M.read (| β |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      other,
                                      "bytes::bytes_mut::BytesMut",
                                      "len"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            let β :=
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "cap"
                              |) in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [
                                  M.read (| β |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      other,
                                      "bytes::bytes_mut::BytesMut",
                                      "cap"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            []
                            [ Ty.tuple []; Ty.path "bytes::bytes_mut::BytesMut" ]
                            [ Value.Tuple [] ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            []
                            [ Ty.tuple []; Ty.path "bytes::bytes_mut::BytesMut" ]
                            [ M.read (| other |) ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_try_unsplit :
      M.IsAssociatedFunction.C Self "try_unsplit" try_unsplit.
    Admitted.
    Global Typeclasses Opaque try_unsplit.
    
    (*
        fn kind(&self) -> usize {
            self.data as usize & KIND_MASK
        }
    *)
    Definition kind (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.bit_and,
            [
              M.cast
                (Ty.path "usize")
                (M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes_mut::BytesMut",
                    "data"
                  |)
                |));
              M.read (| get_constant (| "bytes::bytes_mut::KIND_MASK", Ty.path "usize" |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_kind : M.IsAssociatedFunction.C Self "kind" kind.
    Admitted.
    Global Typeclasses Opaque kind.
    
    (*
        unsafe fn promote_to_shared(&mut self, ref_cnt: usize) {
            debug_assert_eq!(self.kind(), KIND_VEC);
            debug_assert!(ref_cnt == 1 || ref_cnt == 2);
    
            let original_capacity_repr =
                (self.data as usize & ORIGINAL_CAPACITY_MASK) >> ORIGINAL_CAPACITY_OFFSET;
    
            // The vec offset cannot be concurrently mutated, so there
            // should be no danger reading it.
            let off = (self.data as usize) >> VEC_POS_OFFSET;
    
            // First, allocate a new `Shared` instance containing the
            // `Vec` fields. It's important to note that `ptr`, `len`,
            // and `cap` cannot be mutated without having `&mut self`.
            // This means that these fields will not be concurrently
            // updated and since the buffer hasn't been promoted to an
            // `Arc`, those three fields still are the components of the
            // vector.
            let shared = Box::new(Shared {
                vec: rebuild_vec(self.ptr.as_ptr(), self.len, self.cap, off),
                original_capacity_repr,
                ref_count: AtomicUsize::new(ref_cnt),
            });
    
            let shared = Box::into_raw(shared);
    
            // The pointer should be aligned, so this assert should
            // always succeed.
            debug_assert_eq!(shared as usize & KIND_MASK, KIND_ARC);
    
            self.data = shared;
        }
    *)
    Definition promote_to_shared (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; ref_cnt ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let ref_cnt := M.alloc (| ref_cnt |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        "kind",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_constant (| "bytes::bytes_mut::KIND_VEC", Ty.path "usize" |)
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.eq,
                                                  [
                                                    M.read (|
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.read (|
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind :
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [ Ty.path "core::panicking::AssertKind" ] :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                      [ Ty.path "core::fmt::Arguments" ]
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        LogicalOp.or (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| ref_cnt |);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |),
                                          ltac:(M.monadic
                                            (M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.eq,
                                              [
                                                M.read (| ref_cnt |);
                                                Value.Integer IntegerKind.Usize 2
                                              ]
                                            |)))
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [
                                        mk_str (|
                                          "assertion failed: ref_cnt == 1 || ref_cnt == 2"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ original_capacity_repr : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.shr,
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.bit_and,
                      [
                        M.cast
                          (Ty.path "usize")
                          (M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "bytes::bytes_mut::BytesMut",
                              "data"
                            |)
                          |));
                        M.read (|
                          get_constant (|
                            "bytes::bytes_mut::ORIGINAL_CAPACITY_MASK",
                            Ty.path "usize"
                          |)
                        |)
                      ]
                    |);
                    M.read (|
                      get_constant (|
                        "bytes::bytes_mut::ORIGINAL_CAPACITY_OFFSET",
                        Ty.path "usize"
                      |)
                    |)
                  ]
                |)
              |) in
            let~ off : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.shr,
                  [
                    M.cast
                      (Ty.path "usize")
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "bytes::bytes_mut::BytesMut",
                          "data"
                        |)
                      |));
                    M.read (|
                      get_constant (| "bytes::bytes_mut::VEC_POS_OFFSET", Ty.path "usize" |)
                    |)
                  ]
                |)
              |) in
            let~ shared :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "bytes::bytes_mut::Shared"; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    []
                    [ Ty.path "bytes::bytes_mut::Shared"; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "bytes::bytes_mut::Shared"; Ty.path "alloc::alloc::Global" ],
                    "new",
                    [],
                    []
                  |),
                  [
                    Value.StructRecord
                      "bytes::bytes_mut::Shared"
                      []
                      []
                      [
                        ("vec",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                            M.get_function (| "bytes::bytes_mut::rebuild_vec", [], [] |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::ptr::non_null::NonNull")
                                    []
                                    [ Ty.path "u8" ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "bytes::bytes_mut::BytesMut",
                                      "ptr"
                                    |)
                                  |)
                                ]
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "bytes::bytes_mut::BytesMut",
                                  "len"
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "bytes::bytes_mut::BytesMut",
                                  "cap"
                                |)
                              |);
                              M.read (| off |)
                            ]
                          |));
                        ("original_capacity_repr", M.read (| original_capacity_repr |));
                        ("ref_count",
                          M.call_closure (|
                            Ty.path "core::sync::atomic::AtomicUsize",
                            M.get_associated_function (|
                              Ty.path "core::sync::atomic::AtomicUsize",
                              "new",
                              [],
                              []
                            |),
                            [ M.read (| ref_cnt |) ]
                          |))
                      ]
                  ]
                |)
              |) in
            let~ shared :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      []
                      [ Ty.path "bytes::bytes_mut::Shared"; Ty.path "alloc::alloc::Global" ],
                    "into_raw",
                    [],
                    []
                  |),
                  [ M.read (| shared |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      BinOp.Wrap.bit_and,
                                      [
                                        M.cast (Ty.path "usize") (M.read (| shared |));
                                        M.read (|
                                          get_constant (|
                                            "bytes::bytes_mut::KIND_MASK",
                                            Ty.path "usize"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_constant (| "bytes::bytes_mut::KIND_ARC", Ty.path "usize" |)
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.eq,
                                                  [
                                                    M.read (|
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.read (|
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind :
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [ Ty.path "core::panicking::AssertKind" ] :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                      [ Ty.path "core::fmt::Arguments" ]
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes_mut::BytesMut",
                    "data"
                  |),
                  M.read (| shared |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_promote_to_shared :
      M.IsAssociatedFunction.C Self "promote_to_shared" promote_to_shared.
    Admitted.
    Global Typeclasses Opaque promote_to_shared.
    
    (*
        unsafe fn shallow_clone(&mut self) -> BytesMut {
            if self.kind() == KIND_ARC {
                increment_shared(self.data);
                ptr::read(self)
            } else {
                self.promote_to_shared(/*ref_count = */ 2);
                ptr::read(self)
            }
        }
    *)
    Definition shallow_clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.path "bytes::bytes_mut::BytesMut",
                                  "kind",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |);
                              M.read (|
                                get_constant (| "bytes::bytes_mut::KIND_ARC", Ty.path "usize" |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (| "bytes::bytes_mut::increment_shared", [], [] |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "data"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        M.get_function (|
                          "core::ptr::read",
                          [],
                          [ Ty.path "bytes::bytes_mut::BytesMut" ]
                        |),
                        [ M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| self |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            "promote_to_shared",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            Value.Integer IntegerKind.Usize 2
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        M.get_function (|
                          "core::ptr::read",
                          [],
                          [ Ty.path "bytes::bytes_mut::BytesMut" ]
                        |),
                        [ M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| self |) |) |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_shallow_clone :
      M.IsAssociatedFunction.C Self "shallow_clone" shallow_clone.
    Admitted.
    Global Typeclasses Opaque shallow_clone.
    
    (*
        unsafe fn get_vec_pos(&self) -> usize {
            debug_assert_eq!(self.kind(), KIND_VEC);
    
            self.data as usize >> VEC_POS_OFFSET
        }
    *)
    Definition get_vec_pos (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        "kind",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_constant (| "bytes::bytes_mut::KIND_VEC", Ty.path "usize" |)
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.eq,
                                                  [
                                                    M.read (|
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.read (|
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind :
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [ Ty.path "core::panicking::AssertKind" ] :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                      [ Ty.path "core::fmt::Arguments" ]
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.shr,
                [
                  M.cast
                    (Ty.path "usize")
                    (M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "bytes::bytes_mut::BytesMut",
                        "data"
                      |)
                    |));
                  M.read (|
                    get_constant (| "bytes::bytes_mut::VEC_POS_OFFSET", Ty.path "usize" |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_vec_pos :
      M.IsAssociatedFunction.C Self "get_vec_pos" get_vec_pos.
    Admitted.
    Global Typeclasses Opaque get_vec_pos.
    
    (*
        unsafe fn set_vec_pos(&mut self, pos: usize) {
            debug_assert_eq!(self.kind(), KIND_VEC);
            debug_assert!(pos <= MAX_VEC_POS);
    
            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));
        }
    *)
    Definition set_vec_pos (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; pos ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let pos := M.alloc (| pos |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (|
                            Value.Tuple
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        "kind",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  get_constant (| "bytes::bytes_mut::KIND_VEC", Ty.path "usize" |)
                                |)
                              ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let left_val := M.copy (| γ0_0 |) in
                                let right_val := M.copy (| γ0_1 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.not (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.eq,
                                                  [
                                                    M.read (|
                                                      M.deref (| M.read (| left_val |) |)
                                                    |);
                                                    M.read (|
                                                      M.deref (| M.read (| right_val |) |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind :
                                                  Ty.apply
                                                    (Ty.path "*")
                                                    []
                                                    [ Ty.path "core::panicking::AssertKind" ] :=
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    []
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                      [ Ty.path "core::fmt::Arguments" ]
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.le,
                                          [
                                            M.read (| pos |);
                                            M.read (|
                                              get_constant (|
                                                "bytes::bytes_mut::MAX_VEC_POS",
                                                Ty.path "usize"
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: pos <= MAX_VEC_POS" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes_mut::BytesMut",
                    "data"
                  |),
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                    M.get_function (|
                      "bytes::bytes_mut::invalid_ptr",
                      [],
                      [ Ty.path "bytes::bytes_mut::Shared" ]
                    |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.bit_or,
                        [
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.shl,
                            [
                              M.read (| pos |);
                              M.read (|
                                get_constant (|
                                  "bytes::bytes_mut::VEC_POS_OFFSET",
                                  Ty.path "usize"
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.bit_and,
                            [
                              M.cast
                                (Ty.path "usize")
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "bytes::bytes_mut::BytesMut",
                                    "data"
                                  |)
                                |));
                              M.read (|
                                get_constant (|
                                  "bytes::bytes_mut::NOT_VEC_POS_MASK",
                                  Ty.path "usize"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_set_vec_pos :
      M.IsAssociatedFunction.C Self "set_vec_pos" set_vec_pos.
    Admitted.
    Global Typeclasses Opaque set_vec_pos.
    
    (*
        pub fn spare_capacity_mut(&mut self) -> &mut [MaybeUninit<u8>] {
            unsafe {
                let ptr = self.ptr.as_ptr().add(self.len);
                let len = self.cap - self.len;
    
                slice::from_raw_parts_mut(ptr.cast(), len)
            }
        }
    *)
    Definition spare_capacity_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.read (|
                    let~ ptr :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            "add",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "bytes::bytes_mut::BytesMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "len"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "cap"
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "len"
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                              ],
                            M.get_function (|
                              "core::slice::raw::from_raw_parts_mut",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "*mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                  "cast",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                                |),
                                [ M.read (| ptr |) ]
                              |);
                              M.read (| len |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_spare_capacity_mut :
      M.IsAssociatedFunction.C Self "spare_capacity_mut" spare_capacity_mut.
    Admitted.
    Global Typeclasses Opaque spare_capacity_mut.
  End Impl_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_ops_drop_Drop_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn drop(&mut self) {
            let kind = self.kind();
    
            if kind == KIND_VEC {
                unsafe {
                    let off = self.get_vec_pos();
    
                    // Vector storage, free the vector
                    let _ = rebuild_vec(self.ptr.as_ptr(), self.len, self.cap, off);
                }
            } else if kind == KIND_ARC {
                unsafe { release_shared(self.data) };
            }
        }
    *)
    Definition drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "kind",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [
                              M.read (| kind |);
                              M.read (|
                                get_constant (| "bytes::bytes_mut::KIND_VEC", Ty.path "usize" |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ off : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            "get_vec_pos",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          M.get_function (| "bytes::bytes_mut::rebuild_vec", [], [] |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "bytes::bytes_mut::BytesMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "len"
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "bytes::bytes_mut::BytesMut",
                                "cap"
                              |)
                            |);
                            M.read (| off |)
                          ]
                        |)
                      |),
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.read (| kind |);
                                      M.read (|
                                        get_constant (|
                                          "bytes::bytes_mut::KIND_ARC",
                                          Ty.path "usize"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.tuple [],
                                  M.get_function (| "bytes::bytes_mut::release_shared", [], [] |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "bytes::bytes_mut::BytesMut",
                                        "data"
                                      |)
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("drop", InstanceField.Method drop) ].
  End Impl_core_ops_drop_Drop_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_bytes_buf_buf_impl_Buf_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn remaining(&self) -> usize {
            self.len()
        }
    *)
    Definition remaining (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (| Ty.path "bytes::bytes_mut::BytesMut", "len", [], [] |),
            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn chunk(&self) -> &[u8] {
            self.as_slice()
        }
    *)
    Definition chunk (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (|
                  Ty.path "bytes::bytes_mut::BytesMut",
                  "as_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn advance(&mut self, cnt: usize) {
            assert!(
                cnt <= self.remaining(),
                "cannot advance past `remaining`: {:?} <= {:?}",
                cnt,
                self.remaining(),
            );
            unsafe {
                // SAFETY: We've checked that `cnt` <= `self.remaining()` and we know that
                // `self.remaining()` <= `self.cap`.
                self.advance_unchecked(cnt);
            }
        }
    *)
    Definition advance (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; cnt ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cnt := M.alloc (| cnt |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.le,
                                [
                                  M.read (| cnt |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "bytes::buf::buf_impl::Buf",
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                      [],
                                      [],
                                      "remaining",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 2;
                                    Value.Integer IntegerKind.Usize 2
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "cannot advance past `remaining`: " |);
                                              mk_str (| " <= " |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.Ref, cnt |)
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_debug",
                                                  [],
                                                  [ Ty.path "usize" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            M.get_trait_method (|
                                                              "bytes::buf::buf_impl::Buf",
                                                              Ty.apply
                                                                (Ty.path "&mut")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "bytes::bytes_mut::BytesMut"
                                                                ],
                                                              [],
                                                              [],
                                                              "remaining",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.borrow (| Pointer.Kind.Ref, self |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "advance_unchecked",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| cnt |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn copy_to_bytes(&mut self, len: usize) -> Bytes {
            self.split_to(len).freeze()
        }
    *)
    Definition copy_to_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_associated_function (| Ty.path "bytes::bytes_mut::BytesMut", "freeze", [], [] |),
            [
              M.call_closure (|
                Ty.path "bytes::bytes_mut::BytesMut",
                M.get_associated_function (|
                  Ty.path "bytes::bytes_mut::BytesMut",
                  "split_to",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  M.read (| len |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "bytes::buf::buf_impl::Buf"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("remaining", InstanceField.Method remaining);
          ("chunk", InstanceField.Method chunk);
          ("advance", InstanceField.Method advance);
          ("copy_to_bytes", InstanceField.Method copy_to_bytes)
        ].
  End Impl_bytes_buf_buf_impl_Buf_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_bytes_buf_buf_mut_BufMut_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn remaining_mut(&self) -> usize {
            usize::MAX - self.len()
        }
    *)
    Definition remaining_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.sub,
            [
              M.read (| get_constant (| "core::usize::MAX", Ty.path "usize" |) |);
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (| Ty.path "bytes::bytes_mut::BytesMut", "len", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        unsafe fn advance_mut(&mut self, cnt: usize) {
            let remaining = self.cap - self.len();
            if cnt > remaining {
                super::panic_advance(cnt, remaining);
            }
            // Addition won't overflow since it is at most `self.cap`.
            self.len = self.len() + cnt;
        }
    *)
    Definition advance_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; cnt ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let cnt := M.alloc (| cnt |) in
          M.read (|
            let~ remaining : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.sub,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "bytes::bytes_mut::BytesMut",
                        "cap"
                      |)
                    |);
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "len",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [ M.read (| cnt |); M.read (| remaining |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "bytes::panic_advance", [], [] |),
                            [ M.read (| cnt |); M.read (| remaining |) ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "bytes::bytes_mut::BytesMut",
                    "len"
                  |),
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.add,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.path "bytes::bytes_mut::BytesMut",
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.read (| cnt |)
                    ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn chunk_mut(&mut self) -> &mut UninitSlice {
            if self.capacity() == self.len() {
                self.reserve(64);
            }
            self.spare_capacity_mut().into()
        }
    *)
    Definition chunk_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        "capacity",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.path "bytes::bytes_mut::BytesMut",
                                        "len",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.path "bytes::bytes_mut::BytesMut",
                                  "reserve",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.read (| self |) |)
                                  |);
                                  Value.Integer IntegerKind.Usize 64
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ],
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ]
                        ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [ Ty.path "bytes::buf::uninit_slice::UninitSlice" ]
                      ],
                      "into",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                              ],
                            M.get_associated_function (|
                              Ty.path "bytes::bytes_mut::BytesMut",
                              "spare_capacity_mut",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn put<T: Buf>(&mut self, mut src: T)
        where
            Self: Sized,
        {
            while src.has_remaining() {
                let s = src.chunk();
                let l = s.len();
                self.extend_from_slice(s);
                src.advance(l);
            }
        }
    *)
    Definition put (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self; src ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let src := M.alloc (| src |) in
          M.read (|
            M.loop (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              ltac:(M.monadic
                (M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "bytes::buf::buf_impl::Buf",
                                  T,
                                  [],
                                  [],
                                  "has_remaining",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, src |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ s :
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                              ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.get_trait_method (|
                                "bytes::buf::buf_impl::Buf",
                                T,
                                [],
                                [],
                                "chunk",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, src |) ]
                            |)
                          |) in
                        let~ l : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_associated_function (|
                                Ty.path "bytes::bytes_mut::BytesMut",
                                "extend_from_slice",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |)
                              ]
                            |)
                          |) in
                        let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_trait_method (|
                                "bytes::buf::buf_impl::Buf",
                                T,
                                [],
                                [],
                                "advance",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, src |); M.read (| l |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                              M.alloc (| Value.Tuple [] |)
                            |)
                          |)
                        |)))
                  ]
                |)))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn put_slice(&mut self, src: &[u8]) {
            self.extend_from_slice(src);
        }
    *)
    Definition put_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; src ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let src := M.alloc (| src |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "extend_from_slice",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn put_bytes(&mut self, val: u8, cnt: usize) {
            self.reserve(cnt);
            unsafe {
                let dst = self.spare_capacity_mut();
                // Reserved above
                debug_assert!(dst.len() >= cnt);
    
                ptr::write_bytes(dst.as_mut_ptr(), val, cnt);
    
                self.advance_mut(cnt);
            }
        }
    *)
    Definition put_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; val; cnt ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let val := M.alloc (| val |) in
          let cnt := M.alloc (| cnt |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "reserve",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| cnt |)
                  ]
                |)
              |) in
            let~ dst :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ]
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.path "bytes::bytes_mut::BytesMut",
                    "spare_capacity_mut",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.ge,
                                          [
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ Ty.path "u8" ]
                                                  ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| dst |) |)
                                                |)
                                              ]
                                            |);
                                            M.read (| cnt |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (| "core::panicking::panic", [], [] |),
                                      [ mk_str (| "assertion failed: dst.len() >= cnt" |) ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_function (|
                    "core::intrinsics::write_bytes",
                    [],
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "*mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ],
                        "as_mut_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |) ]
                    |);
                    M.read (| val |);
                    M.read (| cnt |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "bytes::buf::buf_mut::BufMut",
                    Ty.path "bytes::bytes_mut::BytesMut",
                    [],
                    [],
                    "advance_mut",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| cnt |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "bytes::buf::buf_mut::BufMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("remaining_mut", InstanceField.Method remaining_mut);
          ("advance_mut", InstanceField.Method advance_mut);
          ("chunk_mut", InstanceField.Method chunk_mut);
          ("put", InstanceField.Method put);
          ("put_slice", InstanceField.Method put_slice);
          ("put_bytes", InstanceField.Method put_bytes)
        ].
  End Impl_bytes_buf_buf_mut_BufMut_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_convert_AsRef_slice_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn as_ref(&self) -> &[u8] {
            self.as_slice()
        }
    *)
    Definition as_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (|
                  Ty.path "bytes::bytes_mut::BytesMut",
                  "as_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::AsRef"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
  End Impl_core_convert_AsRef_slice_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_ops_deref_Deref_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*     type Target = [u8]; *)
    Definition _Target : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
    
    (*
        fn deref(&self) -> &[u8] {
            self.as_ref()
        }
    *)
    Definition deref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_trait_method (|
                  "core::convert::AsRef",
                  Ty.path "bytes::bytes_mut::BytesMut",
                  [],
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  "as_ref",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
  End Impl_core_ops_deref_Deref_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_convert_AsMut_slice_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn as_mut(&mut self) -> &mut [u8] {
            self.as_slice_mut()
        }
    *)
    Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "as_slice_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::AsMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("as_mut", InstanceField.Method as_mut) ].
  End Impl_core_convert_AsMut_slice_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_ops_deref_DerefMut_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn deref_mut(&mut self) -> &mut [u8] {
            self.as_mut()
        }
    *)
    Definition deref_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::convert::AsMut",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      "as_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::DerefMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("deref_mut", InstanceField.Method deref_mut) ].
  End Impl_core_ops_deref_DerefMut_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_convert_From_ref__slice_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn from(src: &'a [u8]) -> BytesMut {
            BytesMut::from_vec(src.to_vec())
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_associated_function (|
              Ty.path "bytes::bytes_mut::BytesMut",
              "from_vec",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                  "to_vec",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__slice_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_convert_From_ref__str_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn from(src: &'a str) -> BytesMut {
            BytesMut::from(src.as_bytes())
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "from",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__str_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_convert_From_bytes_bytes_mut_BytesMut_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn from(src: BytesMut) -> Bytes {
            src.freeze()
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.call_closure (|
            Ty.path "bytes::bytes::Bytes",
            M.get_associated_function (| Ty.path "bytes::bytes_mut::BytesMut", "freeze", [], [] |),
            [ M.read (| src |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_bytes_bytes_mut_BytesMut_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            self.as_slice() == other.as_slice()
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn partial_cmp(&self, other: &BytesMut) -> Option<cmp::Ordering> {
            self.as_slice().partial_cmp(other.as_slice())
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_Ord_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn cmp(&self, other: &BytesMut) -> cmp::Ordering {
            self.as_slice().cmp(other.as_slice())
        }
    *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [],
              "cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      "as_slice",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_Eq_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_cmp_Eq_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_default_Default_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn default() -> BytesMut {
            BytesMut::new()
        }
    *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_associated_function (| Ty.path "bytes::bytes_mut::BytesMut", "new", [], [] |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_hash_Hash_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn hash<H>(&self, state: &mut H)
        where
            H: hash::Hasher,
        {
            let s: &[u8] = self.as_ref();
            s.hash(state);
        }
    *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ s :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                  ] :=
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::convert::AsRef",
                        Ty.path "bytes::bytes_mut::BytesMut",
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "as_ref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "hash",
                    [],
                    [ H ]
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_borrow_Borrow_slice_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn borrow(&self) -> &[u8] {
            self.as_ref()
        }
    *)
    Definition borrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_trait_method (|
                  "core::convert::AsRef",
                  Ty.path "bytes::bytes_mut::BytesMut",
                  [],
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  "as_ref",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::borrow::Borrow"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
  End Impl_core_borrow_Borrow_slice_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_borrow_BorrowMut_slice_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn borrow_mut(&mut self) -> &mut [u8] {
            self.as_mut()
        }
    *)
    Definition borrow_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::convert::AsMut",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      "as_mut",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::borrow::BorrowMut"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("borrow_mut", InstanceField.Method borrow_mut) ].
  End Impl_core_borrow_BorrowMut_slice_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_fmt_Write_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn write_str(&mut self, s: &str) -> fmt::Result {
            if self.remaining_mut() >= s.len() {
                self.put_slice(s.as_bytes());
                Ok(())
            } else {
                Err(fmt::Error)
            }
        }
    *)
    Definition write_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.ge,
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "bytes::buf::buf_mut::BufMut",
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                  [],
                                  [],
                                  "remaining_mut",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, self |) ]
                              |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (| Ty.path "str", "len", [], [] |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_trait_method (|
                            "bytes::buf::buf_mut::BufMut",
                            Ty.path "bytes::bytes_mut::BytesMut",
                            [],
                            [],
                            "put_slice",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                        [ Value.Tuple [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                        [ Value.StructTuple "core::fmt::Error" [] [] [] ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> fmt::Result {
            fmt::write(self, args)
        }
    *)
    Definition write_fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; args ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let args := M.alloc (| args |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_function (| "core::fmt::write", [], [] |),
            [
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |));
              M.read (| args |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Write"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("write_str", InstanceField.Method write_str);
          ("write_fmt", InstanceField.Method write_fmt)
        ].
  End Impl_core_fmt_Write_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_clone_Clone_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn clone(&self) -> BytesMut {
            BytesMut::from(&self[..])
        }
    *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "from",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "bytes::bytes_mut::BytesMut",
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*     type Item = u8; *)
    Definition _Item : Ty.t := Ty.path "u8".
    
    (*     type IntoIter = IntoIter<BytesMut>; *)
    Definition _IntoIter : Ty.t :=
      Ty.apply (Ty.path "bytes::buf::iter::IntoIter") [] [ Ty.path "bytes::bytes_mut::BytesMut" ].
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            IntoIter::new(self)
        }
    *)
    Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "bytes::buf::iter::IntoIter")
              []
              [ Ty.path "bytes::bytes_mut::BytesMut" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "bytes::buf::iter::IntoIter")
                []
                [ Ty.path "bytes::bytes_mut::BytesMut" ],
              "new",
              [],
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("Item", InstanceField.Ty _Item);
          ("IntoIter", InstanceField.Ty _IntoIter);
          ("into_iter", InstanceField.Method into_iter)
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_ref__bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes_mut::BytesMut" ].
    
    (*     type Item = &'a u8; *)
    Definition _Item : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "u8" ].
    
    (*     type IntoIter = core::slice::Iter<'a, u8>; *)
    Definition _IntoIter : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ].
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            self.as_ref().iter()
        }
    *)
    Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              "iter",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("Item", InstanceField.Ty _Item);
          ("IntoIter", InstanceField.Ty _IntoIter);
          ("into_iter", InstanceField.Method into_iter)
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_ref__bytes_bytes_mut_BytesMut.
  
  Module Impl_core_iter_traits_collect_Extend_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn extend<T>(&mut self, iter: T)
        where
            T: IntoIterator<Item = u8>,
        {
            let iter = iter.into_iter();
    
            let (lower, _) = iter.size_hint();
            self.reserve(lower);
    
            // TODO: optimize
            // 1. If self.kind() == KIND_VEC, use Vec::extend
            for b in iter {
                self.put_u8(b);
            }
        }
    *)
    Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self; iter ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let iter := M.alloc (| iter |) in
          M.read (|
            let~ iter :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter"
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.associated_in_trait
                    "core::iter::traits::collect::IntoIterator"
                    []
                    []
                    T
                    "IntoIter",
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    T,
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [ M.read (| iter |) ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter",
                    [],
                    [],
                    "size_hint",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, iter |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let lower := M.copy (| γ0_0 |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::BytesMut",
                            "reserve",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                            M.read (| lower |)
                          ]
                        |)
                      |) in
                    M.use
                      (M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              T
                              "IntoIter",
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.associated_in_trait
                                "core::iter::traits::collect::IntoIterator"
                                []
                                []
                                T
                                "IntoIter",
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| iter |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                ltac:(M.monadic
                                  (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "u8" ],
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.associated_in_trait
                                              "core::iter::traits::collect::IntoIterator"
                                              []
                                              []
                                              T
                                              "IntoIter",
                                            [],
                                            [],
                                            "next",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let _ :=
                                              M.is_struct_tuple (|
                                                γ,
                                                "core::option::Option::None"
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let b := M.copy (| γ0_0 |) in
                                            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  Ty.tuple [],
                                                  M.get_trait_method (|
                                                    "bytes::buf::buf_mut::BufMut",
                                                    Ty.path "bytes::bytes_mut::BytesMut",
                                                    [],
                                                    [],
                                                    "put_u8",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (| M.read (| self |) |)
                                                    |);
                                                    M.read (| b |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |))))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::Extend"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        Self
        (* Instance *) [ ("extend", InstanceField.Method extend) ].
  End Impl_core_iter_traits_collect_Extend_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_iter_traits_collect_Extend_ref__u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn extend<T>(&mut self, iter: T)
        where
            T: IntoIterator<Item = &'a u8>,
        {
            self.extend(iter.into_iter().copied())
        }
    *)
    Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self; iter ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let iter := M.alloc (| iter |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "core::iter::traits::collect::Extend",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.path "u8" ],
              "extend",
              [],
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::copied::Copied")
                  []
                  [
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter"
                  ]
              ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::copied::Copied")
                  []
                  [
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter"
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.associated_in_trait
                    "core::iter::traits::collect::IntoIterator"
                    []
                    []
                    T
                    "IntoIter",
                  [],
                  [],
                  "copied",
                  [],
                  [ Ty.path "u8" ]
                |),
                [
                  M.call_closure (|
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter",
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      T,
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| iter |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::Extend"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("extend", InstanceField.Method extend) ].
  End Impl_core_iter_traits_collect_Extend_ref__u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_iter_traits_collect_Extend_bytes_bytes_Bytes_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn extend<T>(&mut self, iter: T)
        where
            T: IntoIterator<Item = Bytes>,
        {
            for bytes in iter {
                self.extend_from_slice(&bytes)
            }
        }
    *)
    Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self; iter ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let iter := M.alloc (| iter |) in
          M.read (|
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter",
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      T,
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| iter |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "bytes::bytes::Bytes" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      T
                                      "IntoIter",
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let bytes := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.path "bytes::bytes_mut::BytesMut",
                                          "extend_from_slice",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::ops::deref::Deref",
                                                  Ty.path "bytes::bytes::Bytes",
                                                  [],
                                                  [],
                                                  "deref",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.Ref, bytes |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::Extend"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("extend", InstanceField.Method extend) ].
  End Impl_core_iter_traits_collect_Extend_bytes_bytes_Bytes_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_iter_traits_collect_FromIterator_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn from_iter<T: IntoIterator<Item = u8>>(into_iter: T) -> Self {
            BytesMut::from_vec(Vec::from_iter(into_iter))
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ into_iter ] =>
        ltac:(M.monadic
          (let into_iter := M.alloc (| into_iter |) in
          M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_associated_function (|
              Ty.path "bytes::bytes_mut::BytesMut",
              "from_vec",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "core::iter::traits::collect::FromIterator",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  [],
                  [ Ty.path "u8" ],
                  "from_iter",
                  [],
                  [ T ]
                |),
                [ M.read (| into_iter |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        Self
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_iter_traits_collect_FromIterator_ref__u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn from_iter<T: IntoIterator<Item = &'a u8>>(into_iter: T) -> Self {
            BytesMut::from_iter(into_iter.into_iter().copied())
        }
    *)
    Definition from_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ into_iter ] =>
        ltac:(M.monadic
          (let into_iter := M.alloc (| into_iter |) in
          M.call_closure (|
            Ty.path "bytes::bytes_mut::BytesMut",
            M.get_trait_method (|
              "core::iter::traits::collect::FromIterator",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.path "u8" ],
              "from_iter",
              [],
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::copied::Copied")
                  []
                  [
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter"
                  ]
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::copied::Copied")
                  []
                  [
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter"
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.associated_in_trait
                    "core::iter::traits::collect::IntoIterator"
                    []
                    []
                    T
                    "IntoIter",
                  [],
                  [],
                  "copied",
                  [],
                  [ Ty.path "u8" ]
                |),
                [
                  M.call_closure (|
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      T
                      "IntoIter",
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      T,
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| into_iter |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::FromIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("from_iter", InstanceField.Method from_iter) ].
  End Impl_core_iter_traits_collect_FromIterator_ref__u8_for_bytes_bytes_mut_BytesMut.
  
  (*
  unsafe fn increment_shared(ptr: *mut Shared) {
      let old_size = ( *ptr).ref_count.fetch_add(1, Ordering::Relaxed);
  
      if old_size > isize::MAX as usize {
          crate::abort();
      }
  }
  *)
  Definition increment_shared (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.read (|
          let~ old_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::sync::atomic::AtomicUsize",
                  "fetch_add",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| ptr |) |),
                      "bytes::bytes_mut::Shared",
                      "ref_count"
                    |)
                  |);
                  Value.Integer IntegerKind.Usize 1;
                  Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.gt,
                          [
                            M.read (| old_size |);
                            M.cast
                              (Ty.path "usize")
                              (M.read (| get_constant (| "core::isize::MAX", Ty.path "isize" |) |))
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "bytes::abort", [], [] |),
                        []
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_increment_shared :
    M.IsFunction.C "bytes::bytes_mut::increment_shared" increment_shared.
  Admitted.
  Global Typeclasses Opaque increment_shared.
  
  (*
  unsafe fn release_shared(ptr: *mut Shared) {
      // `Shared` storage... follow the drop steps from Arc.
      if ( *ptr).ref_count.fetch_sub(1, Ordering::Release) != 1 {
          return;
      }
  
      // This fence is needed to prevent reordering of use of the data and
      // deletion of the data.  Because it is marked `Release`, the decreasing
      // of the reference count synchronizes with this `Acquire` fence. This
      // means that use of the data happens before decreasing the reference
      // count, which happens before this fence, which happens before the
      // deletion of the data.
      //
      // As explained in the [Boost documentation][1],
      //
      // > It is important to enforce any possible access to the object in one
      // > thread (through an existing reference) to *happen before* deleting
      // > the object in a different thread. This is achieved by a "release"
      // > operation after dropping a reference (any access to the object
      // > through this reference must obviously happened before), and an
      // > "acquire" operation before deleting the object.
      //
      // [1]: (www.boost.org/doc/libs/1_55_0/doc/html/atomic/usage_examples.html)
      //
      // Thread sanitizer does not support atomic fences. Use an atomic load
      // instead.
      ( *ptr).ref_count.load(Ordering::Acquire);
  
      // Drop the data
      drop(Box::from_raw(ptr));
  }
  *)
  Definition release_shared (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.catch_return (Ty.tuple []) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ne,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "core::sync::atomic::AtomicUsize",
                                      "fetch_sub",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| ptr |) |),
                                          "bytes::bytes_mut::Shared",
                                          "ref_count"
                                        |)
                                      |);
                                      Value.Integer IntegerKind.Usize 1;
                                      Value.StructTuple
                                        "core::sync::atomic::Ordering::Release"
                                        []
                                        []
                                        []
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.path "core::sync::atomic::AtomicUsize",
                      "load",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| ptr |) |),
                          "bytes::bytes_mut::Shared",
                          "ref_count"
                        |)
                      |);
                      Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                    ]
                  |)
                |) in
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_function (|
                      "core::mem::drop",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes_mut::Shared"; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.path "bytes::bytes_mut::Shared"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "bytes::bytes_mut::Shared"; Ty.path "alloc::alloc::Global" ],
                          "from_raw",
                          [],
                          []
                        |),
                        [ M.read (| ptr |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_release_shared :
    M.IsFunction.C "bytes::bytes_mut::release_shared" release_shared.
  Admitted.
  Global Typeclasses Opaque release_shared.
  
  Module Impl_bytes_bytes_mut_Shared.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::Shared".
    
    (*
        fn is_unique(&self) -> bool {
            // The goal is to check if the current handle is the only handle
            // that currently has access to the buffer. This is done by
            // checking if the `ref_count` is currently 1.
            //
            // The `Acquire` ordering synchronizes with the `Release` as
            // part of the `fetch_sub` in `release_shared`. The `fetch_sub`
            // operation guarantees that any mutations done in other threads
            // are ordered before the `ref_count` is decremented. As such,
            // this `Acquire` will guarantee that those mutations are
            // visible to the current thread.
            self.ref_count.load(Ordering::Acquire) == 1
        }
    *)
    Definition is_unique (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::sync::atomic::AtomicUsize",
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "bytes::bytes_mut::Shared",
                      "ref_count"
                    |)
                  |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |);
              Value.Integer IntegerKind.Usize 1
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_unique :
      M.IsAssociatedFunction.C Self "is_unique" is_unique.
    Admitted.
    Global Typeclasses Opaque is_unique.
  End Impl_bytes_bytes_mut_Shared.
  
  (*
  fn original_capacity_to_repr(cap: usize) -> usize {
      let width = PTR_WIDTH - ((cap >> MIN_ORIGINAL_CAPACITY_WIDTH).leading_zeros() as usize);
      cmp::min(
          width,
          MAX_ORIGINAL_CAPACITY_WIDTH - MIN_ORIGINAL_CAPACITY_WIDTH,
      )
  }
  *)
  Definition original_capacity_to_repr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ cap ] =>
      ltac:(M.monadic
        (let cap := M.alloc (| cap |) in
        M.read (|
          let~ width : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.sub,
                [
                  M.read (| get_constant (| "bytes::bytes_mut::PTR_WIDTH", Ty.path "usize" |) |);
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (| Ty.path "usize", "leading_zeros", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.shr,
                          [
                            M.read (| cap |);
                            M.read (|
                              get_constant (|
                                "bytes::bytes_mut::MIN_ORIGINAL_CAPACITY_WIDTH",
                                Ty.path "usize"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |))
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::cmp::min", [], [ Ty.path "usize" ] |),
              [
                M.read (| width |);
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.sub,
                  [
                    M.read (|
                      get_constant (|
                        "bytes::bytes_mut::MAX_ORIGINAL_CAPACITY_WIDTH",
                        Ty.path "usize"
                      |)
                    |);
                    M.read (|
                      get_constant (|
                        "bytes::bytes_mut::MIN_ORIGINAL_CAPACITY_WIDTH",
                        Ty.path "usize"
                      |)
                    |)
                  ]
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_original_capacity_to_repr :
    M.IsFunction.C "bytes::bytes_mut::original_capacity_to_repr" original_capacity_to_repr.
  Admitted.
  Global Typeclasses Opaque original_capacity_to_repr.
  
  (*
  fn original_capacity_from_repr(repr: usize) -> usize {
      if repr == 0 {
          return 0;
      }
  
      1 << (repr + (MIN_ORIGINAL_CAPACITY_WIDTH - 1))
  }
  *)
  Definition original_capacity_from_repr
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ repr ] =>
      ltac:(M.monadic
        (let repr := M.alloc (| repr |) in
        M.catch_return (Ty.path "usize") (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.eq,
                                [ M.read (| repr |); Value.Integer IntegerKind.Usize 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (| M.return_ (| Value.Integer IntegerKind.Usize 0 |) |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.shl,
                  [
                    Value.Integer IntegerKind.Usize 1;
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [
                        M.read (| repr |);
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [
                            M.read (|
                              get_constant (|
                                "bytes::bytes_mut::MIN_ORIGINAL_CAPACITY_WIDTH",
                                Ty.path "usize"
                              |)
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_original_capacity_from_repr :
    M.IsFunction.C "bytes::bytes_mut::original_capacity_from_repr" original_capacity_from_repr.
  Admitted.
  Global Typeclasses Opaque original_capacity_from_repr.
  
  Module Impl_core_marker_Send_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Send"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Send_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_marker_Sync_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Sync"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Sync_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialEq_slice_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn eq(&self, other: &[u8]) -> bool {
            &**self == other
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "bytes::bytes_mut::BytesMut",
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, other |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_slice_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialOrd_slice_u8_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn partial_cmp(&self, other: &[u8]) -> Option<cmp::Ordering> {
            ( **self).partial_cmp(other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_slice_u8_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_slice_u8.
    Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_slice_u8.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_slice_u8.
    Definition Self : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
    
    (*
        fn partial_cmp(&self, other: &BytesMut) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self, other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_slice_u8.
  
  Module Impl_core_cmp_PartialEq_str_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn eq(&self, other: &str) -> bool {
            &**self == other.as_bytes()
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "bytes::bytes_mut::BytesMut",
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "str" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_str_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialOrd_str_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn partial_cmp(&self, other: &str) -> Option<cmp::Ordering> {
            ( **self).partial_cmp(other.as_bytes())
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "str" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_str_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_str.
    Definition Self : Ty.t := Ty.path "str".
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.path "str" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_str.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_str.
    Definition Self : Ty.t := Ty.path "str".
    
    (*
        fn partial_cmp(&self, other: &BytesMut) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_str.
  
  Module Impl_core_cmp_PartialEq_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn eq(&self, other: &Vec<u8>) -> bool {
            *self == other[..]
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialOrd_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn partial_cmp(&self, other: &Vec<u8>) -> Option<cmp::Ordering> {
            ( **self).partial_cmp(&other[..])
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.path "core::ops::range::RangeFull" ],
                          "index",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
                          Value.StructTuple "core::ops::range::RangeFull" [] [] []
                        ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ] ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_alloc_vec_Vec_u8_alloc_alloc_Global_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn partial_cmp(&self, other: &BytesMut) -> Option<cmp::Ordering> {
            other.partial_cmp(self)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  Module Impl_core_cmp_PartialEq_alloc_string_String_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn eq(&self, other: &String) -> bool {
            *self == other[..]
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.path "str" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.path "alloc::string::String",
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_alloc_string_String_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialOrd_alloc_string_String_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn partial_cmp(&self, other: &String) -> Option<cmp::Ordering> {
            ( **self).partial_cmp(other.as_bytes())
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "alloc::string::String",
                      "as_bytes",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "alloc::string::String" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_alloc_string_String_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_alloc_string_String.
    Definition Self : Ty.t := Ty.path "alloc::string::String".
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.path "alloc::string::String" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_alloc_string_String.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_alloc_string_String.
    Definition Self : Ty.t := Ty.path "alloc::string::String".
    
    (*
        fn partial_cmp(&self, other: &BytesMut) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self.as_bytes(), other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_associated_function (|
                      Ty.path "alloc::string::String",
                      "as_bytes",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_alloc_string_String.
  
  Module Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_T_ref__T_for_bytes_bytes_mut_BytesMut.
    Definition Self (T : Ty.t) : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn eq(&self, other: &&'a T) -> bool {
            *self == **other
        }
    *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ T ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_where_core_marker_Sized_T_where_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_T_ref__T_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_T_ref__T_for_bytes_bytes_mut_BytesMut.
    Definition Self (T : Ty.t) : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn partial_cmp(&self, other: &&'a T) -> Option<cmp::Ordering> {
            self.partial_cmp( *other)
        }
    *)
    Definition partial_cmp (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ T ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| other |) |) |) |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "&") [] [ T ] ]
        (Self T)
        (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
  End Impl_core_cmp_PartialOrd_where_core_marker_Sized_T_where_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_T_ref__T_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_ref__slice_u8.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_ref__slice_u8.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_ref__slice_u8.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ].
    
    (*
        fn partial_cmp(&self, other: &BytesMut) -> Option<cmp::Ordering> {
            <[u8] as PartialOrd<[u8]>>::partial_cmp(self, other)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.path "bytes::bytes_mut::BytesMut",
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_ref__slice_u8.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_ref__str.
    Definition Self : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "str" ].
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            *other == *self
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_ref__str.
  
  Module Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_ref__str.
    Definition Self : Ty.t := Ty.apply (Ty.path "&") [] [ Ty.path "str" ].
    
    (*
        fn partial_cmp(&self, other: &BytesMut) -> Option<cmp::Ordering> {
            other.partial_cmp(self)
        }
    *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "bytes::bytes_mut::BytesMut",
              [],
              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_bytes_bytes_mut_BytesMut_for_ref__str.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_bytes_bytes_Bytes.
    Definition Self : Ty.t := Ty.path "bytes::bytes::Bytes".
    
    (*
        fn eq(&self, other: &BytesMut) -> bool {
            other[..] == self[..]
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "bytes::bytes_mut::BytesMut",
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                          |)
                        |)
                      |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "bytes::bytes::Bytes",
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_mut_BytesMut_for_bytes_bytes_Bytes.
  
  Module Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_bytes_bytes_mut_BytesMut.
    Definition Self : Ty.t := Ty.path "bytes::bytes_mut::BytesMut".
    
    (*
        fn eq(&self, other: &Bytes) -> bool {
            other[..] == self[..]
        }
    *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
              [],
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "bytes::bytes::Bytes",
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                          |)
                        |)
                      |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      [],
                      [ Ty.path "core::ops::range::RangeFull" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "bytes::bytes_mut::BytesMut",
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |);
                      Value.StructTuple "core::ops::range::RangeFull" [] [] []
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes::Bytes" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_bytes_bytes_Bytes_for_bytes_bytes_mut_BytesMut.
  
  Module Impl_core_convert_From_bytes_bytes_mut_BytesMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [] [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(bytes: BytesMut) -> Self {
            let kind = bytes.kind();
            let bytes = ManuallyDrop::new(bytes);
    
            let mut vec = if kind == KIND_VEC {
                unsafe {
                    let off = bytes.get_vec_pos();
                    rebuild_vec(bytes.ptr.as_ptr(), bytes.len, bytes.cap, off)
                }
            } else {
                let shared = bytes.data as *mut Shared;
    
                if unsafe { ( *shared).is_unique() } {
                    let vec = mem::replace(unsafe { &mut ( *shared).vec }, Vec::new());
    
                    unsafe { release_shared(shared) };
    
                    vec
                } else {
                    return ManuallyDrop::into_inner(bytes).deref().to_vec();
                }
            };
    
            let len = bytes.len;
    
            unsafe {
                ptr::copy(bytes.ptr.as_ptr(), vec.as_mut_ptr(), len);
                vec.set_len(len);
            }
    
            vec
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.catch_return
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ kind : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "kind",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                    |)
                  |) in
                let~ bytes :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.path "bytes::bytes_mut::BytesMut" ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::mem::manually_drop::ManuallyDrop")
                        []
                        [ Ty.path "bytes::bytes_mut::BytesMut" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::manually_drop::ManuallyDrop")
                          []
                          [ Ty.path "bytes::bytes_mut::BytesMut" ],
                        "new",
                        [],
                        []
                      |),
                      [ M.read (| bytes |) ]
                    |)
                  |) in
                let~ vec :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ] :=
                  M.copy (|
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.read (| kind |);
                                      M.read (|
                                        get_constant (|
                                          "bytes::bytes_mut::KIND_VEC",
                                          Ty.path "usize"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ off : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.path "bytes::bytes_mut::BytesMut",
                                    "get_vec_pos",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                              []
                                              [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                M.get_function (| "bytes::bytes_mut::rebuild_vec", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ptr::non_null::NonNull")
                                        []
                                        [ Ty.path "u8" ],
                                      "as_ptr",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.apply
                                                  (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                                  []
                                                  [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                                [],
                                                [],
                                                "deref",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                            |)
                                          |),
                                          "bytes::bytes_mut::BytesMut",
                                          "ptr"
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                              []
                                              [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                        |)
                                      |),
                                      "bytes::bytes_mut::BytesMut",
                                      "len"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                              []
                                              [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                        |)
                                      |),
                                      "bytes::bytes_mut::BytesMut",
                                      "cap"
                                    |)
                                  |);
                                  M.read (| off |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let~ shared :
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "*mut")
                                      []
                                      [ Ty.path "bytes::bytes_mut::Shared" ]
                                  ] :=
                              M.alloc (|
                                M.cast
                                  (Ty.apply
                                    (Ty.path "*mut")
                                    []
                                    [ Ty.path "bytes::bytes_mut::Shared" ])
                                  (M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                              []
                                              [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                        |)
                                      |),
                                      "bytes::bytes_mut::BytesMut",
                                      "data"
                                    |)
                                  |))
                              |) in
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_associated_function (|
                                              Ty.path "bytes::bytes_mut::Shared",
                                              "is_unique",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| shared |) |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ vec :
                                        Ty.apply
                                          (Ty.path "*")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                          ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                          M.get_function (|
                                            "core::mem::replace",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| shared |) |),
                                                        "bytes::bytes_mut::Shared",
                                                        "vec"
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |);
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                                "new",
                                                [],
                                                []
                                              |),
                                              []
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_function (|
                                            "bytes::bytes_mut::release_shared",
                                            [],
                                            []
                                          |),
                                          [ M.read (| shared |) ]
                                        |)
                                      |) in
                                    vec));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                                "to_vec",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            []
                                                            [ Ty.path "u8" ]
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.path "bytes::bytes_mut::BytesMut",
                                                        [],
                                                        [],
                                                        "deref",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.path "bytes::bytes_mut::BytesMut",
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::mem::manually_drop::ManuallyDrop")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "bytes::bytes_mut::BytesMut"
                                                                  ],
                                                                "into_inner",
                                                                [],
                                                                []
                                                              |),
                                                              [ M.read (| bytes |) ]
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                      ]
                    |)
                  |) in
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes_mut::BytesMut" ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "core::mem::manually_drop::ManuallyDrop")
                              []
                              [ Ty.path "bytes::bytes_mut::BytesMut" ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                        |)
                      |),
                      "bytes::bytes_mut::BytesMut",
                      "len"
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::copy", [], [ Ty.path "u8" ] |),
                        [
                          (* MutToConstPointer *)
                          M.pointer_coercion
                            (M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::ptr::non_null::NonNull")
                                  []
                                  [ Ty.path "u8" ],
                                "as_ptr",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "core::mem::manually_drop::ManuallyDrop")
                                            []
                                            [ Ty.path "bytes::bytes_mut::BytesMut" ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, bytes |) ]
                                      |)
                                    |),
                                    "bytes::bytes_mut::BytesMut",
                                    "ptr"
                                  |)
                                |)
                              ]
                            |));
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              "as_mut_ptr",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, vec |) ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "set_len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, vec |); M.read (| len |) ]
                      |)
                    |) in
                  M.alloc (| Value.Tuple [] |) in
                vec
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "bytes::bytes_mut::BytesMut" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_bytes_bytes_mut_BytesMut_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  (*
  fn vptr(ptr: *mut u8) -> NonNull<u8> {
      if cfg!(debug_assertions) {
          NonNull::new(ptr).expect("Vec pointer should be non-null")
      } else {
          unsafe { NonNull::new_unchecked(ptr) }
      }
  }
  *)
  Definition vptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        M.read (|
          M.match_operator (|
            Ty.apply
              (Ty.path "*")
              []
              [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use (M.alloc (| Value.Bool true |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ],
                        "expect",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ]
                            ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| ptr |) ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "Vec pointer should be non-null" |) |)
                        |)
                      ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_vptr : M.IsFunction.C "bytes::bytes_mut::vptr" vptr.
  Admitted.
  Global Typeclasses Opaque vptr.
  
  (*
  fn invalid_ptr<T>(addr: usize) -> *mut T {
      let ptr = core::ptr::null_mut::<u8>().wrapping_add(addr);
      debug_assert_eq!(ptr as usize, addr);
      ptr.cast::<T>()
  }
  *)
  Definition invalid_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ addr ] =>
      ltac:(M.monadic
        (let addr := M.alloc (| addr |) in
        M.read (|
          let~ ptr : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  "wrapping_add",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                    M.get_function (| "core::ptr::null_mut", [], [ Ty.path "u8" ] |),
                    []
                  |);
                  M.read (| addr |)
                ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          Value.Tuple
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (| M.cast (Ty.path "usize") (M.read (| ptr |)) |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, addr |)
                            ]
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                              let left_val := M.copy (| γ0_0 |) in
                              let right_val := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.eq,
                                                [
                                                  M.read (| M.deref (| M.read (| left_val |) |) |);
                                                  M.read (| M.deref (| M.read (| right_val |) |) |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ kind :
                                                Ty.apply
                                                  (Ty.path "*")
                                                  []
                                                  [ Ty.path "core::panicking::AssertKind" ] :=
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::panicking::AssertKind::Eq"
                                                  []
                                                  []
                                                  []
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "never",
                                                M.get_function (|
                                                  "core::panicking::assert_failed",
                                                  [],
                                                  [ Ty.path "usize"; Ty.path "usize" ]
                                                |),
                                                [
                                                  M.read (| kind |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| left_val |) |)
                                                      |)
                                                    |)
                                                  |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| right_val |) |)
                                                      |)
                                                    |)
                                                  |);
                                                  Value.StructTuple
                                                    "core::option::Option::None"
                                                    []
                                                    [ Ty.path "core::fmt::Arguments" ]
                                                    []
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)))
                        ]
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "*mut") [] [ T ],
              M.get_associated_function (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                "cast",
                [],
                [ T ]
              |),
              [ M.read (| ptr |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_invalid_ptr :
    M.IsFunction.C "bytes::bytes_mut::invalid_ptr" invalid_ptr.
  Admitted.
  Global Typeclasses Opaque invalid_ptr.
  
  (*
  unsafe fn rebuild_vec(ptr: *mut u8, mut len: usize, mut cap: usize, off: usize) -> Vec<u8> {
      let ptr = ptr.sub(off);
      len += off;
      cap += off;
  
      Vec::from_raw_parts(ptr, len, cap)
  }
  *)
  Definition rebuild_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ ptr; len; cap; off ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        let cap := M.alloc (| cap |) in
        let off := M.alloc (| off |) in
        M.read (|
          let~ ptr : Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                  "sub",
                  [],
                  []
                |),
                [ M.read (| ptr |); M.read (| off |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              let β := len in
              M.write (|
                β,
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.add,
                  [ M.read (| β |); M.read (| off |) ]
                |)
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              let β := cap in
              M.write (|
                β,
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.add,
                  [ M.read (| β |); M.read (| off |) ]
                |)
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                "from_raw_parts",
                [],
                []
              |),
              [ M.read (| ptr |); M.read (| len |); M.read (| cap |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rebuild_vec :
    M.IsFunction.C "bytes::bytes_mut::rebuild_vec" rebuild_vec.
  Admitted.
  Global Typeclasses Opaque rebuild_vec.
  
  Definition value_SHARED_VTABLE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.alloc (|
          Value.StructRecord
            "bytes::bytes::Vtable"
            []
            []
            [
              ("clone",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes_mut::shared_v_clone", [], [] |)));
              ("to_vec",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes_mut::shared_v_to_vec", [], [] |)));
              ("to_mut",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes_mut::shared_v_to_mut", [], [] |)));
              ("is_unique",
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_function (| "bytes::bytes_mut::shared_v_is_unique", [], [] |)));
              ("drop",
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_function (| "bytes::bytes_mut::shared_v_drop", [], [] |)))
            ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_SHARED_VTABLE :
    M.IsFunction.C "bytes::bytes_mut::SHARED_VTABLE" value_SHARED_VTABLE.
  Admitted.
  Global Typeclasses Opaque value_SHARED_VTABLE.
  
  (*
  unsafe fn shared_v_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {
      let shared = data.load(Ordering::Relaxed) as *mut Shared;
      increment_shared(shared);
  
      let data = AtomicPtr::new(shared as *mut ());
      Bytes::with_vtable(ptr, len, data, &SHARED_VTABLE)
  }
  *)
  Definition shared_v_clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ shared :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ] ] :=
            M.alloc (|
              M.cast
                (Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ])
                (M.call_closure (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                    "load",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                    Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                  ]
                |))
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_function (| "bytes::bytes_mut::increment_shared", [], [] |),
                [ M.read (| shared |) ]
              |)
            |) in
          let~ data :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "new",
                  [],
                  []
                |),
                [ M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ]) (M.read (| shared |)) ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "bytes::bytes::Bytes",
              M.get_associated_function (| Ty.path "bytes::bytes::Bytes", "with_vtable", [], [] |),
              [
                M.read (| ptr |);
                M.read (| len |);
                M.read (| data |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.read (|
                          get_constant (|
                            "bytes::bytes_mut::SHARED_VTABLE",
                            Ty.apply (Ty.path "&") [] [ Ty.path "bytes::bytes::Vtable" ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_v_clone :
    M.IsFunction.C "bytes::bytes_mut::shared_v_clone" shared_v_clone.
  Admitted.
  Global Typeclasses Opaque shared_v_clone.
  
  (*
  unsafe fn shared_v_to_vec(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Vec<u8> {
      let shared: *mut Shared = data.load(Ordering::Relaxed).cast();
  
      if ( *shared).is_unique() {
          let shared = &mut *shared;
  
          // Drop shared
          let mut vec = mem::replace(&mut shared.vec, Vec::new());
          release_shared(shared);
  
          // Copy back buffer
          ptr::copy(ptr, vec.as_mut_ptr(), len);
          vec.set_len(len);
  
          vec
      } else {
          let v = slice::from_raw_parts(ptr, len).to_vec();
          release_shared(shared);
          v
      }
  }
  *)
  Definition shared_v_to_vec (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ shared :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  "cast",
                  [],
                  [ Ty.path "bytes::bytes_mut::Shared" ]
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                      "load",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                    ]
                  |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "*")
              []
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::Shared",
                            "is_unique",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| shared |) |) |) ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ shared :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "bytes::bytes_mut::Shared" ] ] :=
                    M.alloc (|
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| shared |) |) |)
                    |) in
                  let~ vec :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        M.get_function (|
                          "core::mem::replace",
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| shared |) |),
                                  "bytes::bytes_mut::Shared",
                                  "vec"
                                |)
                              |)
                            |)
                          |);
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              "new",
                              [],
                              []
                            |),
                            []
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "bytes::bytes_mut::release_shared", [], [] |),
                        [ M.borrow (| Pointer.Kind.MutPointer, M.deref (| M.read (| shared |) |) |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::copy", [], [ Ty.path "u8" ] |),
                        [
                          M.read (| ptr |);
                          M.call_closure (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              "as_mut_ptr",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, vec |) ]
                          |);
                          M.read (| len |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "set_len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, vec |); M.read (| len |) ]
                      |)
                    |) in
                  vec));
              fun γ =>
                ltac:(M.monadic
                  (let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "to_vec",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_function (|
                                  "core::slice::raw::from_raw_parts",
                                  [],
                                  [ Ty.path "u8" ]
                                |),
                                [ M.read (| ptr |); M.read (| len |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "bytes::bytes_mut::release_shared", [], [] |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  v))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_v_to_vec :
    M.IsFunction.C "bytes::bytes_mut::shared_v_to_vec" shared_v_to_vec.
  Admitted.
  Global Typeclasses Opaque shared_v_to_vec.
  
  (*
  unsafe fn shared_v_to_mut(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> BytesMut {
      let shared: *mut Shared = data.load(Ordering::Relaxed).cast();
  
      if ( *shared).is_unique() {
          let shared = &mut *shared;
  
          // The capacity is always the original capacity of the buffer
          // minus the offset from the start of the buffer
          let v = &mut shared.vec;
          let v_capacity = v.capacity();
          let v_ptr = v.as_mut_ptr();
          let offset = offset_from(ptr as *mut u8, v_ptr);
          let cap = v_capacity - offset;
  
          let ptr = vptr(ptr as *mut u8);
  
          BytesMut {
              ptr,
              len,
              cap,
              data: shared,
          }
      } else {
          let v = slice::from_raw_parts(ptr, len).to_vec();
          release_shared(shared);
          BytesMut::from_vec(v)
      }
  }
  *)
  Definition shared_v_to_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; ptr; len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let ptr := M.alloc (| ptr |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ shared :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                  "cast",
                  [],
                  [ Ty.path "bytes::bytes_mut::Shared" ]
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                      "load",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                      Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                    ]
                  |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "bytes::bytes_mut::BytesMut" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_associated_function (|
                            Ty.path "bytes::bytes_mut::Shared",
                            "is_unique",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| shared |) |) |) ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ shared :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.apply (Ty.path "&mut") [] [ Ty.path "bytes::bytes_mut::Shared" ] ] :=
                    M.alloc (|
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| shared |) |) |)
                    |) in
                  let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ] :=
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| shared |) |),
                          "bytes::bytes_mut::Shared",
                          "vec"
                        |)
                      |)
                    |) in
                  let~ v_capacity : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "capacity",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                      |)
                    |) in
                  let~ v_ptr :
                      Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          "as_mut_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| v |) |) |) ]
                      |)
                    |) in
                  let~ offset : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_function (| "bytes::offset_from", [], [] |),
                        [
                          (* MutToConstPointer *)
                          M.pointer_coercion
                            (M.cast
                              (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                              (M.read (| ptr |)));
                          (* MutToConstPointer *) M.pointer_coercion (M.read (| v_ptr |))
                        ]
                      |)
                    |) in
                  let~ cap : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [ M.read (| v_capacity |); M.read (| offset |) ]
                      |)
                    |) in
                  let~ ptr :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                        M.get_function (| "bytes::bytes_mut::vptr", [], [] |),
                        [ M.cast (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ]) (M.read (| ptr |))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructRecord
                      "bytes::bytes_mut::BytesMut"
                      []
                      []
                      [
                        ("ptr", M.read (| ptr |));
                        ("len", M.read (| len |));
                        ("cap", M.read (| cap |));
                        ("data",
                          M.borrow (| Pointer.Kind.MutPointer, M.deref (| M.read (| shared |) |) |))
                      ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ v :
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "to_vec",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                M.get_function (|
                                  "core::slice::raw::from_raw_parts",
                                  [],
                                  [ Ty.path "u8" ]
                                |),
                                [ M.read (| ptr |); M.read (| len |) ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "bytes::bytes_mut::release_shared", [], [] |),
                        [ M.read (| shared |) ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "bytes::bytes_mut::BytesMut",
                      M.get_associated_function (|
                        Ty.path "bytes::bytes_mut::BytesMut",
                        "from_vec",
                        [],
                        []
                      |),
                      [ M.read (| v |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_v_to_mut :
    M.IsFunction.C "bytes::bytes_mut::shared_v_to_mut" shared_v_to_mut.
  Admitted.
  Global Typeclasses Opaque shared_v_to_mut.
  
  (*
  unsafe fn shared_v_is_unique(data: &AtomicPtr<()>) -> bool {
      let shared = data.load(Ordering::Acquire);
      let ref_count = ( *shared.cast::<Shared>()).ref_count.load(Ordering::Relaxed);
      ref_count == 1
  }
  *)
  Definition shared_v_is_unique (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        M.read (|
          let~ shared :
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |);
                  Value.StructTuple "core::sync::atomic::Ordering::Acquire" [] [] []
                ]
              |)
            |) in
          let~ ref_count : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::sync::atomic::AtomicUsize",
                  "load",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "*mut") [] [ Ty.path "bytes::bytes_mut::Shared" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                            "cast",
                            [],
                            [ Ty.path "bytes::bytes_mut::Shared" ]
                          |),
                          [ M.read (| shared |) ]
                        |)
                      |),
                      "bytes::bytes_mut::Shared",
                      "ref_count"
                    |)
                  |);
                  Value.StructTuple "core::sync::atomic::Ordering::Relaxed" [] [] []
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [ M.read (| ref_count |); Value.Integer IntegerKind.Usize 1 ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_v_is_unique :
    M.IsFunction.C "bytes::bytes_mut::shared_v_is_unique" shared_v_is_unique.
  Admitted.
  Global Typeclasses Opaque shared_v_is_unique.
  
  (*
  unsafe fn shared_v_drop(data: &mut AtomicPtr<()>, _ptr: *const u8, _len: usize) {
      data.with_mut(|shared| {
          release_shared( *shared as *mut Shared);
      });
  }
  *)
  Definition shared_v_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data; _ptr; _len ] =>
      ltac:(M.monadic
        (let data := M.alloc (| data |) in
        let _ptr := M.alloc (| _ptr |) in
        let _len := M.alloc (| _len |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "bytes::loom::sync::atomic::AtomicMut",
                  Ty.apply (Ty.path "core::sync::atomic::AtomicPtr") [] [ Ty.tuple [] ],
                  [],
                  [ Ty.tuple [] ],
                  "with_mut",
                  [],
                  [
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                          ]
                      ]
                      (Ty.tuple []);
                    Ty.tuple []
                  ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| data |) |) |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [ Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ] ]
                                        ]
                                    ]
                                    (Ty.tuple [])
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let shared := M.copy (| γ |) in
                                    M.read (|
                                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_function (|
                                              "bytes::bytes_mut::release_shared",
                                              [],
                                              []
                                            |),
                                            [
                                              M.cast
                                                (Ty.apply
                                                  (Ty.path "*mut")
                                                  []
                                                  [ Ty.path "bytes::bytes_mut::Shared" ])
                                                (M.read (| M.deref (| M.read (| shared |) |) |))
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_shared_v_drop :
    M.IsFunction.C "bytes::bytes_mut::shared_v_drop" shared_v_drop.
  Admitted.
  Global Typeclasses Opaque shared_v_drop.
  
  (* fn _split_to_must_use() {} *)
  Definition _split_to_must_use (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction__split_to_must_use :
    M.IsFunction.C "bytes::bytes_mut::_split_to_must_use" _split_to_must_use.
  Admitted.
  Global Typeclasses Opaque _split_to_must_use.
  
  (* fn _split_off_must_use() {} *)
  Definition _split_off_must_use (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction__split_off_must_use :
    M.IsFunction.C "bytes::bytes_mut::_split_off_must_use" _split_off_must_use.
  Admitted.
  Global Typeclasses Opaque _split_off_must_use.
  
  (* fn _split_must_use() {} *)
  Definition _split_must_use (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction__split_must_use :
    M.IsFunction.C "bytes::bytes_mut::_split_must_use" _split_must_use.
  Admitted.
  Global Typeclasses Opaque _split_must_use.
End bytes_mut.
