(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(*
fn abort() -> ! {
    #[cfg(feature = "std")]
    {
        std::process::abort();
    }

    #[cfg(not(feature = "std"))]
    {
        struct Abort;
        impl Drop for Abort {
            fn drop(&mut self) {
                panic!();
            }
        }
        let _a = Abort;
        panic!("abort");
    }
}
*)
Definition abort (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [] =>
    ltac:(M.monadic
      (M.call_closure (|
        Ty.path "never",
        M.get_function (| "std::process::abort", [], [] |),
        []
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_abort : M.IsFunction.C "bytes::abort" abort.
Admitted.
Global Typeclasses Opaque abort.

(*
fn saturating_sub_usize_u64(a: usize, b: u64) -> usize {
    use core::convert::TryFrom;
    match usize::try_from(b) {
        Ok(b) => a.saturating_sub(b),
        Err(_) => 0,
    }
}
*)
Definition saturating_sub_usize_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ a; b ] =>
    ltac:(M.monadic
      (let a := M.alloc (| Ty.path "usize", a |) in
      let b := M.alloc (| Ty.path "u64", b |) in
      M.match_operator (|
        Ty.path "usize",
        M.alloc (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ],
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "usize",
              [],
              [ Ty.path "u64" ],
              "try_from",
              [],
              []
            |),
            [ M.read (| b |) ]
          |)
        |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ0_0 :=
                M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
              let b := M.copy (| Ty.path "usize", γ0_0 |) in
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (| Ty.path "usize", "saturating_sub", [], [] |),
                [ M.read (| a |); M.read (| b |) ]
              |)));
          fun γ =>
            ltac:(M.monadic
              (let γ0_0 :=
                M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
              Value.Integer IntegerKind.Usize 0))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_saturating_sub_usize_u64 :
  M.IsFunction.C "bytes::saturating_sub_usize_u64" saturating_sub_usize_u64.
Admitted.
Global Typeclasses Opaque saturating_sub_usize_u64.

(*
fn min_u64_usize(a: u64, b: usize) -> usize {
    use core::convert::TryFrom;
    match usize::try_from(a) {
        Ok(a) => usize::min(a, b),
        Err(_) => b,
    }
}
*)
Definition min_u64_usize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ a; b ] =>
    ltac:(M.monadic
      (let a := M.alloc (| Ty.path "u64", a |) in
      let b := M.alloc (| Ty.path "usize", b |) in
      M.match_operator (|
        Ty.path "usize",
        M.alloc (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ],
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ],
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.path "usize",
              [],
              [ Ty.path "u64" ],
              "try_from",
              [],
              []
            |),
            [ M.read (| a |) ]
          |)
        |),
        [
          fun γ =>
            ltac:(M.monadic
              (let γ0_0 :=
                M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
              let a := M.copy (| Ty.path "usize", γ0_0 |) in
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], [], "min", [], [] |),
                [ M.read (| a |); M.read (| b |) ]
              |)));
          fun γ =>
            ltac:(M.monadic
              (let γ0_0 :=
                M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
              M.read (| b |)))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_min_u64_usize :
  M.IsFunction.C "bytes::min_u64_usize" min_u64_usize.
Admitted.
Global Typeclasses Opaque min_u64_usize.

(*
fn panic_advance(idx: usize, len: usize) -> ! {
    panic!(
        "advance out of bounds: the len is {} but advancing by {}",
        len, idx
    );
}
*)
Definition panic_advance (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ idx; len ] =>
    ltac:(M.monadic
      (let idx := M.alloc (| Ty.path "usize", idx |) in
      let len := M.alloc (| Ty.path "usize", len |) in
      M.call_closure (|
        Ty.path "never",
        M.get_function (| "core::panicking::panic_fmt", [], [] |),
        [
          M.call_closure (|
            Ty.path "core::fmt::Arguments",
            M.get_associated_function (|
              Ty.path "core::fmt::Arguments",
              "new_v1",
              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2 ],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 2 ]
                        [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                      Value.Array
                        [
                          mk_str (| "advance out of bounds: the len is " |);
                          mk_str (| " but advancing by " |)
                        ]
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 2 ]
                        [ Ty.path "core::fmt::rt::Argument" ],
                      Value.Array
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::rt::Argument",
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [],
                              [ Ty.path "usize" ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, len |) |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.path "core::fmt::rt::Argument",
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [],
                              [ Ty.path "usize" ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, idx |) |)
                              |)
                            ]
                          |)
                        ]
                    |)
                  |)
                |)
              |)
            ]
          |)
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_panic_advance :
  M.IsFunction.C "bytes::panic_advance" panic_advance.
Admitted.
Global Typeclasses Opaque panic_advance.

(*
fn panic_does_not_fit(size: usize, nbytes: usize) -> ! {
    panic!(
        "size too large: the integer type can fit {} bytes, but nbytes is {}",
        size, nbytes
    );
}
*)
Definition panic_does_not_fit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ size; nbytes ] =>
    ltac:(M.monadic
      (let size := M.alloc (| Ty.path "usize", size |) in
      let nbytes := M.alloc (| Ty.path "usize", nbytes |) in
      M.call_closure (|
        Ty.path "never",
        M.get_function (| "core::panicking::panic_fmt", [], [] |),
        [
          M.call_closure (|
            Ty.path "core::fmt::Arguments",
            M.get_associated_function (|
              Ty.path "core::fmt::Arguments",
              "new_v1",
              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2 ],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 2 ]
                        [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                      Value.Array
                        [
                          mk_str (| "size too large: the integer type can fit " |);
                          mk_str (| " bytes, but nbytes is " |)
                        ]
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 2 ]
                        [ Ty.path "core::fmt::rt::Argument" ],
                      Value.Array
                        [
                          M.call_closure (|
                            Ty.path "core::fmt::rt::Argument",
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [],
                              [ Ty.path "usize" ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, size |) |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.path "core::fmt::rt::Argument",
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [],
                              [ Ty.path "usize" ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, nbytes |) |)
                              |)
                            ]
                          |)
                        ]
                    |)
                  |)
                |)
              |)
            ]
          |)
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_panic_does_not_fit :
  M.IsFunction.C "bytes::panic_does_not_fit" panic_does_not_fit.
Admitted.
Global Typeclasses Opaque panic_does_not_fit.

(*
fn offset_from(dst: *const u8, original: *const u8) -> usize {
    dst as usize - original as usize
}
*)
Definition offset_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
  match ε, τ, α with
  | [], [], [ dst; original ] =>
    ltac:(M.monadic
      (let dst := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ], dst |) in
      let original := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ], original |) in
      M.call_closure (|
        Ty.path "usize",
        BinOp.Wrap.sub,
        [
          M.cast (Ty.path "usize") (M.read (| dst |));
          M.cast (Ty.path "usize") (M.read (| original |))
        ]
      |)))
  | _, _, _ => M.impossible "wrong number of arguments"
  end.

Global Instance Instance_IsFunction_offset_from : M.IsFunction.C "bytes::offset_from" offset_from.
Admitted.
Global Typeclasses Opaque offset_from.
