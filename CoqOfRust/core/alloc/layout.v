(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module alloc.
  Module layout.
    (*
    const fn size_align<T>() -> (usize, usize) {
        (mem::size_of::<T>(), mem::align_of::<T>())
    }
    *)
    Definition size_align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [] =>
        ltac:(M.monadic
          (Value.Tuple
            [
              M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |);
              M.call_closure (| M.get_function (| "core::mem::align_of", [ T ] |), [] |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_size_align : M.IsFunction "core::alloc::layout::size_align" size_align.
    
    (* StructRecord
      {
        name := "Layout";
        const_params := [];
        ty_params := [];
        fields :=
          [ ("size", Ty.path "usize"); ("align", Ty.path "core::ptr::alignment::Alignment") ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_alloc_layout_Layout.
    
    Module Impl_core_clone_Clone_for_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_alloc_layout_Layout.
    
    Module Impl_core_fmt_Debug_for_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                []
              |),
              [
                M.read (| f |);
                M.read (| Value.String "Layout" |);
                M.read (| Value.String "size" |);
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::alloc::layout::Layout",
                  "size"
                |);
                M.read (| Value.String "align" |);
                M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::alloc::layout::Layout",
                    "align"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_alloc_layout_Layout.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_alloc_layout_Layout.
    
    Module Impl_core_cmp_PartialEq_for_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              BinOp.eq (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::alloc::layout::Layout",
                    "size"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| other |),
                    "core::alloc::layout::Layout",
                    "size"
                  |)
                |)
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "core::ptr::alignment::Alignment",
                    [ Ty.path "core::ptr::alignment::Alignment" ],
                    "eq",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::alloc::layout::Layout",
                      "align"
                    |);
                    M.SubPointer.get_struct_record_field (|
                      M.read (| other |),
                      "core::alloc::layout::Layout",
                      "align"
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_alloc_layout_Layout.
    
    Module Impl_core_cmp_Eq_for_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_alloc_layout_Layout.
    
    Module Impl_core_hash_Hash_for_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      (* Hash *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::hash::Hash",
                      Ty.path "usize",
                      [],
                      "hash",
                      [ __H ]
                    |),
                    [
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::alloc::layout::Layout",
                        "size"
                      |);
                      M.read (| state |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "core::ptr::alignment::Alignment",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::alloc::layout::Layout",
                      "align"
                    |);
                    M.read (| state |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_core_alloc_layout_Layout.
    
    Module Impl_core_alloc_layout_Layout.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::Layout".
      
      (*
          pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {
              if Layout::is_size_align_valid(size, align) {
                  // SAFETY: Layout::is_size_align_valid checks the preconditions for this call.
                  unsafe { Ok(Layout { size, align: mem::transmute(align) }) }
              } else {
                  Err(LayoutError)
              }
          }
      *)
      Definition from_size_align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ size; align ] =>
          ltac:(M.monadic
            (let size := M.alloc (| size |) in
            let align := M.alloc (| align |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "is_size_align_valid",
                                []
                              |),
                              [ M.read (| size |); M.read (| align |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [
                            Value.StructRecord
                              "core::alloc::layout::Layout"
                              [
                                ("size", M.read (| size |));
                                ("align",
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::transmute",
                                      [ Ty.path "usize"; Ty.path "core::ptr::alignment::Alignment" ]
                                    |),
                                    [ M.read (| align |) ]
                                  |))
                              ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::alloc::layout::LayoutError" [] ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_size_align :
        M.IsAssociatedFunction Self "from_size_align" from_size_align.
      
      (*
          const fn is_size_align_valid(size: usize, align: usize) -> bool {
              let Some(align) = Alignment::new(align) else { return false };
              if size > Self::max_size_for_align(align) {
                  return false;
              }
              true
          }
      *)
      Definition is_size_align_valid (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ size; align ] =>
          ltac:(M.monadic
            (let size := M.alloc (| size |) in
            let align := M.alloc (| align |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::ptr::alignment::Alignment",
                          "new",
                          []
                        |),
                        [ M.read (| align |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let align := M.copy (| γ0_0 |) in
                          let~ _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.gt (|
                                            M.read (| size |),
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "core::alloc::layout::Layout",
                                                "max_size_for_align",
                                                []
                                              |),
                                              [ M.read (| align |) ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (| M.return_ (| Value.Bool false |) |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Bool true |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_is_size_align_valid :
        M.IsAssociatedFunction Self "is_size_align_valid" is_size_align_valid.
      
      (*
          const fn max_size_for_align(align: Alignment) -> usize {
              // (power-of-two implies align != 0.)
      
              // Rounded up size is:
              //   size_rounded_up = (size + align - 1) & !(align - 1);
              //
              // We know from above that align != 0. If adding (align - 1)
              // does not overflow, then rounding up will be fine.
              //
              // Conversely, &-masking with !(align - 1) will subtract off
              // only low-order-bits. Thus if overflow occurs with the sum,
              // the &-mask cannot subtract enough to undo that overflow.
              //
              // Above implies that checking for summation overflow is both
              // necessary and sufficient.
              isize::MAX as usize - (align.as_usize() - 1)
          }
      *)
      Definition max_size_for_align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ align ] =>
          ltac:(M.monadic
            (let align := M.alloc (| align |) in
            BinOp.Wrap.sub (|
              M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)),
              BinOp.Wrap.sub (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::ptr::alignment::Alignment",
                    "as_usize",
                    []
                  |),
                  [ M.read (| align |) ]
                |),
                Value.Integer IntegerKind.Usize 1
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_max_size_for_align :
        M.IsAssociatedFunction Self "max_size_for_align" max_size_for_align.
      
      (*
          const fn from_size_alignment(size: usize, align: Alignment) -> Result<Self, LayoutError> {
              if size > Self::max_size_for_align(align) {
                  return Err(LayoutError);
              }
      
              // SAFETY: Layout::size invariants checked above.
              Ok(Layout { size, align })
          }
      *)
      Definition from_size_alignment (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ size; align ] =>
          ltac:(M.monadic
            (let size := M.alloc (| size |) in
            let align := M.alloc (| align |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.gt (|
                                    M.read (| size |),
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::alloc::layout::Layout",
                                        "max_size_for_align",
                                        []
                                      |),
                                      [ M.read (| align |) ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Err"
                                      [ Value.StructTuple "core::alloc::layout::LayoutError" [] ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructRecord
                          "core::alloc::layout::Layout"
                          [ ("size", M.read (| size |)); ("align", M.read (| align |)) ]
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_size_alignment :
        M.IsAssociatedFunction Self "from_size_alignment" from_size_alignment.
      
      (*
          pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {
              assert_unsafe_precondition!(
                  check_library_ub,
                  "Layout::from_size_align_unchecked requires that align is a power of 2 \
                  and the rounded-up allocation size does not exceed isize::MAX",
                  (
                      size: usize = size,
                      align: usize = align,
                  ) => Layout::is_size_align_valid(size, align)
              );
              // SAFETY: the caller is required to uphold the preconditions.
              unsafe { Layout { size, align: mem::transmute(align) } }
          }
      *)
      Definition from_size_align_unchecked
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ size; align ] =>
          ltac:(M.monadic
            (let size := M.alloc (| size |) in
            let align := M.alloc (| align |) in
            M.read (|
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_function (| "core::intrinsics::ub_checks", [] |),
                                []
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Self,
                                "precondition_check.from_size_align_unchecked",
                                []
                              |),
                              [ M.read (| size |); M.read (| align |) ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::alloc::layout::Layout"
                  [
                    ("size", M.read (| size |));
                    ("align",
                      M.call_closure (|
                        M.get_function (|
                          "core::intrinsics::transmute",
                          [ Ty.path "usize"; Ty.path "core::ptr::alignment::Alignment" ]
                        |),
                        [ M.read (| align |) ]
                      |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_from_size_align_unchecked :
        M.IsAssociatedFunction Self "from_size_align_unchecked" from_size_align_unchecked.
      
      (*
          pub const fn size(&self) -> usize {
              self.size
          }
      *)
      Definition size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::alloc::layout::Layout",
                "size"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_size : M.IsAssociatedFunction Self "size" size.
      
      (*
          pub const fn align(&self) -> usize {
              self.align.as_usize()
          }
      *)
      Definition align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::ptr::alignment::Alignment",
                "as_usize",
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::alloc::layout::Layout",
                    "align"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_align : M.IsAssociatedFunction Self "align" align.
      
      (*
          pub const fn new<T>() -> Self {
              let (size, align) = size_align::<T>();
              // SAFETY: if the type is instantiated, rustc already ensures that its
              // layout is valid. Use the unchecked constructor to avoid inserting a
              // panicking codepath that needs to be optimized out.
              unsafe { Layout::from_size_align_unchecked(size, align) }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [] =>
          ltac:(M.monadic
            (M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::alloc::layout::size_align", [ T ] |),
                    []
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let size := M.copy (| γ0_0 |) in
                      let align := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::alloc::layout::Layout",
                            "from_size_align_unchecked",
                            []
                          |),
                          [ M.read (| size |); M.read (| align |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
          pub const fn for_value<T: ?Sized>(t: &T) -> Self {
              let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));
              // SAFETY: see rationale in `new` for why this is using the unsafe variant
              unsafe { Layout::from_size_align_unchecked(size, align) }
          }
      *)
      Definition for_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ t ] =>
          ltac:(M.monadic
            (let t := M.alloc (| t |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  Value.Tuple
                    [
                      M.call_closure (|
                        M.get_function (| "core::mem::size_of_val", [ T ] |),
                        [ M.read (| t |) ]
                      |);
                      M.call_closure (|
                        M.get_function (| "core::mem::align_of_val", [ T ] |),
                        [ M.read (| t |) ]
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let size := M.copy (| γ0_0 |) in
                      let align := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::alloc::layout::Layout",
                            "from_size_align_unchecked",
                            []
                          |),
                          [ M.read (| size |); M.read (| align |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_for_value : M.IsAssociatedFunction Self "for_value" for_value.
      
      (*
          pub const unsafe fn for_value_raw<T: ?Sized>(t: *const T) -> Self {
              // SAFETY: we pass along the prerequisites of these functions to the caller
              let (size, align) = unsafe { (mem::size_of_val_raw(t), mem::align_of_val_raw(t)) };
              // SAFETY: see rationale in `new` for why this is using the unsafe variant
              unsafe { Layout::from_size_align_unchecked(size, align) }
          }
      *)
      Definition for_value_raw (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ t ] =>
          ltac:(M.monadic
            (let t := M.alloc (| t |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  Value.Tuple
                    [
                      M.call_closure (|
                        M.get_function (| "core::mem::size_of_val_raw", [ T ] |),
                        [ M.read (| t |) ]
                      |);
                      M.call_closure (|
                        M.get_function (| "core::mem::align_of_val_raw", [ T ] |),
                        [ M.read (| t |) ]
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let size := M.copy (| γ0_0 |) in
                      let align := M.copy (| γ0_1 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::alloc::layout::Layout",
                            "from_size_align_unchecked",
                            []
                          |),
                          [ M.read (| size |); M.read (| align |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_for_value_raw :
        M.IsAssociatedFunction Self "for_value_raw" for_value_raw.
      
      (*
          pub const fn dangling(&self) -> NonNull<u8> {
              // SAFETY: align is guaranteed to be non-zero
              unsafe { NonNull::new_unchecked(crate::ptr::without_provenance_mut::<u8>(self.align())) }
          }
      *)
      Definition dangling (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::ptr::non_null::NonNull") [] [ Ty.path "u8" ],
                "new_unchecked",
                []
              |),
              [
                M.call_closure (|
                  M.get_function (| "core::ptr::without_provenance_mut", [ Ty.path "u8" ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "align",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_dangling : M.IsAssociatedFunction Self "dangling" dangling.
      
      (*
          pub fn align_to(&self, align: usize) -> Result<Self, LayoutError> {
              Layout::from_size_align(self.size(), cmp::max(self.align(), align))
          }
      *)
      Definition align_to (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let align := M.alloc (| align |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::alloc::layout::Layout",
                "from_size_align",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (| Ty.path "core::alloc::layout::Layout", "size", [] |),
                  [ M.read (| self |) ]
                |);
                M.call_closure (|
                  M.get_function (| "core::cmp::max", [ Ty.path "usize" ] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "align",
                        []
                      |),
                      [ M.read (| self |) ]
                    |);
                    M.read (| align |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_align_to : M.IsAssociatedFunction Self "align_to" align_to.
      
      (*
          pub const fn padding_needed_for(&self, align: usize) -> usize {
              let len = self.size();
      
              // Rounded up value is:
              //   len_rounded_up = (len + align - 1) & !(align - 1);
              // and then we return the padding difference: `len_rounded_up - len`.
              //
              // We use modular arithmetic throughout:
              //
              // 1. align is guaranteed to be > 0, so align - 1 is always
              //    valid.
              //
              // 2. `len + align - 1` can overflow by at most `align - 1`,
              //    so the &-mask with `!(align - 1)` will ensure that in the
              //    case of overflow, `len_rounded_up` will itself be 0.
              //    Thus the returned padding, when added to `len`, yields 0,
              //    which trivially satisfies the alignment `align`.
              //
              // (Of course, attempts to allocate blocks of memory whose
              // size and padding overflow in the above manner should cause
              // the allocator to yield an error anyway.)
      
              let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);
              len_rounded_up.wrapping_sub(len)
          }
      *)
      Definition padding_needed_for (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; align ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let align := M.alloc (| align |) in
            M.read (|
              let~ len :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "size",
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ len_rounded_up :=
                M.alloc (|
                  BinOp.bit_and
                    (M.call_closure (|
                      M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                          [ M.read (| len |); M.read (| align |) ]
                        |);
                        Value.Integer IntegerKind.Usize 1
                      ]
                    |))
                    (UnOp.not (|
                      M.call_closure (|
                        M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                        [ M.read (| align |); Value.Integer IntegerKind.Usize 1 ]
                      |)
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                  [ M.read (| len_rounded_up |); M.read (| len |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_padding_needed_for :
        M.IsAssociatedFunction Self "padding_needed_for" padding_needed_for.
      
      (*
          pub const fn pad_to_align(&self) -> Layout {
              let pad = self.padding_needed_for(self.align());
              // This cannot overflow. Quoting from the invariant of Layout:
              // > `size`, when rounded up to the nearest multiple of `align`,
              // > must not overflow isize (i.e., the rounded value must be
              // > less than or equal to `isize::MAX`)
              let new_size = self.size() + pad;
      
              // SAFETY: padded size is guaranteed to not exceed `isize::MAX`.
              unsafe { Layout::from_size_align_unchecked(new_size, self.align()) }
          }
      *)
      Definition pad_to_align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ pad :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "core::alloc::layout::Layout",
                      "padding_needed_for",
                      []
                    |),
                    [
                      M.read (| self |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "align",
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              let~ new_size :=
                M.alloc (|
                  BinOp.Wrap.add (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "size",
                        []
                      |),
                      [ M.read (| self |) ]
                    |),
                    M.read (| pad |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::alloc::layout::Layout",
                    "from_size_align_unchecked",
                    []
                  |),
                  [
                    M.read (| new_size |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "align",
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_pad_to_align :
        M.IsAssociatedFunction Self "pad_to_align" pad_to_align.
      
      (*
          pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {
              // This cannot overflow. Quoting from the invariant of Layout:
              // > `size`, when rounded up to the nearest multiple of `align`,
              // > must not overflow isize (i.e., the rounded value must be
              // > less than or equal to `isize::MAX`)
              let padded_size = self.size() + self.padding_needed_for(self.align());
              let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError)?;
      
              // The safe constructor is called here to enforce the isize size limit.
              let layout = Layout::from_size_alignment(alloc_size, self.align)?;
              Ok((layout, padded_size))
          }
      *)
      Definition repeat (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ padded_size :=
                    M.alloc (|
                      BinOp.Wrap.add (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::alloc::layout::Layout",
                            "size",
                            []
                          |),
                          [ M.read (| self |) ]
                        |),
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::alloc::layout::Layout",
                            "padding_needed_for",
                            []
                          |),
                          [
                            M.read (| self |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::alloc::layout::Layout",
                                "align",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          ]
                        |)
                      |)
                    |) in
                  let~ alloc_size :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "usize"; Ty.path "core::alloc::layout::LayoutError" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "ok_or",
                                  [ Ty.path "core::alloc::layout::LayoutError" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_mul",
                                      []
                                    |),
                                    [ M.read (| padded_size |); M.read (| n |) ]
                                  |);
                                  Value.StructTuple "core::alloc::layout::LayoutError" []
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "core::alloc::layout::Layout";
                                                  Ty.path "usize"
                                                ];
                                              Ty.path "core::alloc::layout::LayoutError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::alloc::layout::LayoutError"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ layout :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::alloc::layout::Layout";
                                  Ty.path "core::alloc::layout::LayoutError"
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::alloc::layout::Layout",
                                  "from_size_alignment",
                                  []
                                |),
                                [
                                  M.read (| alloc_size |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::alloc::layout::Layout",
                                      "align"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "core::alloc::layout::Layout";
                                                  Ty.path "usize"
                                                ];
                                              Ty.path "core::alloc::layout::LayoutError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::alloc::layout::LayoutError"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [ Value.Tuple [ M.read (| layout |); M.read (| padded_size |) ] ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_repeat : M.IsAssociatedFunction Self "repeat" repeat.
      
      (*
          pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutError> {
              let new_align = cmp::max(self.align, next.align);
              let pad = self.padding_needed_for(next.align());
      
              let offset = self.size().checked_add(pad).ok_or(LayoutError)?;
              let new_size = offset.checked_add(next.size()).ok_or(LayoutError)?;
      
              // The safe constructor is called here to enforce the isize size limit.
              let layout = Layout::from_size_alignment(new_size, new_align)?;
              Ok((layout, offset))
          }
      *)
      Definition extend (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; next ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let next := M.alloc (| next |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ new_align :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "core::cmp::max",
                          [ Ty.path "core::ptr::alignment::Alignment" ]
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::alloc::layout::Layout",
                              "align"
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              next,
                              "core::alloc::layout::Layout",
                              "align"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ pad :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::alloc::layout::Layout",
                          "padding_needed_for",
                          []
                        |),
                        [
                          M.read (| self |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::alloc::layout::Layout",
                              "align",
                              []
                            |),
                            [ next ]
                          |)
                        ]
                      |)
                    |) in
                  let~ offset :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "usize"; Ty.path "core::alloc::layout::LayoutError" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "ok_or",
                                  [ Ty.path "core::alloc::layout::LayoutError" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_add",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::alloc::layout::Layout",
                                          "size",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |);
                                      M.read (| pad |)
                                    ]
                                  |);
                                  Value.StructTuple "core::alloc::layout::LayoutError" []
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "core::alloc::layout::Layout";
                                                  Ty.path "usize"
                                                ];
                                              Ty.path "core::alloc::layout::LayoutError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::alloc::layout::LayoutError"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ new_size :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "usize"; Ty.path "core::alloc::layout::LayoutError" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "ok_or",
                                  [ Ty.path "core::alloc::layout::LayoutError" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_add",
                                      []
                                    |),
                                    [
                                      M.read (| offset |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::alloc::layout::Layout",
                                          "size",
                                          []
                                        |),
                                        [ next ]
                                      |)
                                    ]
                                  |);
                                  Value.StructTuple "core::alloc::layout::LayoutError" []
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "core::alloc::layout::Layout";
                                                  Ty.path "usize"
                                                ];
                                              Ty.path "core::alloc::layout::LayoutError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::alloc::layout::LayoutError"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ layout :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::alloc::layout::Layout";
                                  Ty.path "core::alloc::layout::LayoutError"
                                ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::alloc::layout::Layout",
                                  "from_size_alignment",
                                  []
                                |),
                                [ M.read (| new_size |); M.read (| new_align |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "core::alloc::layout::Layout";
                                                  Ty.path "usize"
                                                ];
                                              Ty.path "core::alloc::layout::LayoutError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::alloc::layout::LayoutError"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [ Value.Tuple [ M.read (| layout |); M.read (| offset |) ] ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_extend : M.IsAssociatedFunction Self "extend" extend.
      
      (*
          pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutError> {
              let size = self.size().checked_mul(n).ok_or(LayoutError)?;
              // The safe constructor is called here to enforce the isize size limit.
              Layout::from_size_alignment(size, self.align)
          }
      *)
      Definition repeat_packed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ size :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "usize"; Ty.path "core::alloc::layout::LayoutError" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "ok_or",
                                  [ Ty.path "core::alloc::layout::LayoutError" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_mul",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::alloc::layout::Layout",
                                          "size",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |);
                                      M.read (| n |)
                                    ]
                                  |);
                                  Value.StructTuple "core::alloc::layout::LayoutError" []
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::alloc::layout::Layout";
                                              Ty.path "core::alloc::layout::LayoutError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::alloc::layout::LayoutError"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "from_size_alignment",
                        []
                      |),
                      [
                        M.read (| size |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::alloc::layout::Layout",
                            "align"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_repeat_packed :
        M.IsAssociatedFunction Self "repeat_packed" repeat_packed.
      
      (*
          pub fn extend_packed(&self, next: Self) -> Result<Self, LayoutError> {
              let new_size = self.size().checked_add(next.size()).ok_or(LayoutError)?;
              // The safe constructor is called here to enforce the isize size limit.
              Layout::from_size_alignment(new_size, self.align)
          }
      *)
      Definition extend_packed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; next ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let next := M.alloc (| next |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ new_size :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "usize"; Ty.path "core::alloc::layout::LayoutError" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "ok_or",
                                  [ Ty.path "core::alloc::layout::LayoutError" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "checked_add",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::alloc::layout::Layout",
                                          "size",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::alloc::layout::Layout",
                                          "size",
                                          []
                                        |),
                                        [ next ]
                                      |)
                                    ]
                                  |);
                                  Value.StructTuple "core::alloc::layout::LayoutError" []
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::alloc::layout::Layout";
                                              Ty.path "core::alloc::layout::LayoutError"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::alloc::layout::LayoutError"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::alloc::layout::Layout",
                        "from_size_alignment",
                        []
                      |),
                      [
                        M.read (| new_size |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::alloc::layout::Layout",
                            "align"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_extend_packed :
        M.IsAssociatedFunction Self "extend_packed" extend_packed.
      
      (*
          pub const fn array<T>(n: usize) -> Result<Self, LayoutError> {
              // Reduce the amount of code we need to monomorphize per `T`.
              return inner(mem::size_of::<T>(), Alignment::of::<T>(), n);
      
              #[inline]
              const fn inner(
                  element_size: usize,
                  align: Alignment,
                  n: usize,
              ) -> Result<Layout, LayoutError> {
                  // We need to check two things about the size:
                  //  - That the total size won't overflow a `usize`, and
                  //  - That the total size still fits in an `isize`.
                  // By using division we can check them both with a single threshold.
                  // That'd usually be a bad idea, but thankfully here the element size
                  // and alignment are constants, so the compiler will fold all of it.
                  if element_size != 0 && n > Layout::max_size_for_align(align) / element_size {
                      return Err(LayoutError);
                  }
      
                  // SAFETY: We just checked that we won't overflow `usize` when we multiply.
                  // This is a useless hint inside this function, but after inlining this helps
                  // deduplicate checks for whether the overall capacity is zero (e.g., in RawVec's
                  // allocation path) before/after this multiplication.
                  let array_size = unsafe { element_size.unchecked_mul(n) };
      
                  // SAFETY: We just checked above that the `array_size` will not
                  // exceed `isize::MAX` even when rounded up to the alignment.
                  // And `Alignment` guarantees it's a power of two.
                  unsafe { Ok(Layout::from_size_align_unchecked(array_size, align.as_usize())) }
              }
          }
      *)
      Definition array (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ T ], [ n ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.never_to_any (|
                  M.read (|
                    M.return_ (|
                      M.call_closure (|
                        M.get_associated_function (| Self, "inner.array", [] |),
                        [
                          M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::ptr::alignment::Alignment",
                              "of",
                              [ T ]
                            |),
                            []
                          |);
                          M.read (| n |)
                        ]
                      |)
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_array : M.IsAssociatedFunction Self "array" array.
    End Impl_core_alloc_layout_Layout.
    
    Axiom LayoutErr :
      (Ty.path "core::alloc::layout::LayoutErr") = (Ty.path "core::alloc::layout::LayoutError").
    
    (* StructTuple
      {
        name := "LayoutError";
        const_params := [];
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_core_alloc_layout_LayoutError.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::LayoutError".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::alloc::layout::LayoutError" []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_alloc_layout_LayoutError.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_alloc_layout_LayoutError.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::LayoutError".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_alloc_layout_LayoutError.
    
    Module Impl_core_cmp_PartialEq_for_core_alloc_layout_LayoutError.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::LayoutError".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_alloc_layout_LayoutError.
    
    Module Impl_core_cmp_Eq_for_core_alloc_layout_LayoutError.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::LayoutError".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_alloc_layout_LayoutError.
    
    Module Impl_core_fmt_Debug_for_core_alloc_layout_LayoutError.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::LayoutError".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [ M.read (| f |); M.read (| Value.String "LayoutError" |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_alloc_layout_LayoutError.
    
    Module Impl_core_error_Error_for_core_alloc_layout_LayoutError.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::LayoutError".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::error::Error"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_error_Error_for_core_alloc_layout_LayoutError.
    
    Module Impl_core_fmt_Display_for_core_alloc_layout_LayoutError.
      Definition Self : Ty.t := Ty.path "core::alloc::layout::LayoutError".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              f.write_str("invalid parameters to Layout::from_size_align")
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
              [
                M.read (| f |);
                M.read (| Value.String "invalid parameters to Layout::from_size_align" |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_core_alloc_layout_LayoutError.
  End layout.
End alloc.
