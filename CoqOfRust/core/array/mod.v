(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module array.
  (*
  pub fn from_fn<T, const N: usize, F>(cb: F) -> [T; N]
  where
      F: FnMut(usize) -> T,
  {
      try_from_fn(NeverShortCircuit::wrap_mut_1(cb)).0
  }
  *)
  Definition from_fn (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; F ], [ cb ] =>
      ltac:(M.monadic
        (let cb := M.alloc (| cb |) in
        M.read (|
          M.SubPointer.get_struct_tuple_field (|
            M.alloc (|
              M.call_closure (|
                M.get_function (|
                  "core::array::try_from_fn",
                  [
                    Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ T ];
                    Ty.associated
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ T ],
                      "wrap_mut_1",
                      [ Ty.path "usize"; F ]
                    |),
                    [ M.read (| cb |) ]
                  |)
                ]
              |)
            |),
            "core::ops::try_trait::NeverShortCircuit",
            0
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn try_from_fn<R, const N: usize, F>(cb: F) -> ChangeOutputType<R, [R::Output; N]>
  where
      F: FnMut(usize) -> R,
      R: Try,
      R::Residual: Residual<[R::Output; N]>,
  {
      let mut array = MaybeUninit::uninit_array::<N>();
      match try_from_fn_erased(&mut array, cb) {
          ControlFlow::Break(r) => FromResidual::from_residual(r),
          ControlFlow::Continue(()) => {
              // SAFETY: All elements of the array were populated.
              try { unsafe { MaybeUninit::array_assume_init(array) } }
          }
      }
  }
  *)
  Definition try_from_fn (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ R; F ], [ cb ] =>
      ltac:(M.monadic
        (let cb := M.alloc (| cb |) in
        M.read (|
          let array :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.associated ],
                  "uninit_array",
                  []
                |),
                []
              |)
            |) in
          M.match_operator (|
            M.alloc (|
              M.call_closure (|
                M.get_function (| "core::array::try_from_fn_erased", [ Ty.associated; R; F ] |),
                [ (* Unsize *) M.pointer_coercion array; M.read (| cb |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "core::ops::control_flow::ControlFlow::Break",
                      0
                    |) in
                  let r := M.copy (| γ0_0 |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::FromResidual",
                        Ty.associated,
                        [ Ty.associated ],
                        "from_residual",
                        []
                      |),
                      [ M.read (| r |) ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (|
                      γ,
                      "core::ops::control_flow::ControlFlow::Continue",
                      0
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.associated,
                        [],
                        "from_output",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              [ Ty.associated ],
                            "array_assume_init",
                            []
                          |),
                          [ M.read (| array |) ]
                        |)
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub const fn from_ref<T>(s: &T) -> &[T; 1] {
      // SAFETY: Converting `&T` to `&[T; 1]` is sound.
      unsafe { &*(s as *const T).cast::<[T; 1]>() }
  }
  *)
  Definition from_ref (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.call_closure (|
          M.get_associated_function (|
            Ty.apply (Ty.path "*const") [ T ],
            "cast",
            [ Ty.apply (Ty.path "array") [ T ] ]
          |),
          [ M.read (| M.use (M.alloc (| M.read (| s |) |)) |) ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub const fn from_mut<T>(s: &mut T) -> &mut [T; 1] {
      // SAFETY: Converting `&mut T` to `&mut [T; 1]` is sound.
      unsafe { &mut *(s as *mut T).cast::<[T; 1]>() }
  }
  *)
  Definition from_mut (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.call_closure (|
          M.get_associated_function (|
            Ty.apply (Ty.path "*mut") [ T ],
            "cast",
            [ Ty.apply (Ty.path "array") [ T ] ]
          |),
          [ M.read (| M.use (M.alloc (| M.read (| s |) |)) |) ]
        |)))
    | _, _ => M.impossible
    end.
  
  (* StructTuple
    {
      name := "TryFromSliceError";
      ty_params := [];
      fields := [ Ty.tuple [] ];
    } *)
  
  Module Impl_core_fmt_Debug_for_core_array_TryFromSliceError.
    Definition Self : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "TryFromSliceError" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_tuple_field (|
                    M.read (| self |),
                    "core::array::TryFromSliceError",
                    0
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_core_array_TryFromSliceError.
  
  Module Impl_core_marker_Copy_for_core_array_TryFromSliceError.
    Definition Self : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_core_array_TryFromSliceError.
  
  Module Impl_core_clone_Clone_for_core_array_TryFromSliceError.
    Definition Self : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_core_array_TryFromSliceError.
  
  Module Impl_core_fmt_Display_for_core_array_TryFromSliceError.
    Definition Self : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            #[allow(deprecated)]
            self.description().fmt(f)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (| "core::fmt::Display", Ty.path "str", [], "fmt", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::error::Error",
                  Ty.path "core::array::TryFromSliceError",
                  [],
                  "description",
                  []
                |),
                [ M.read (| self |) ]
              |);
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_core_array_TryFromSliceError.
  
  Module Impl_core_error_Error_for_core_array_TryFromSliceError.
    Definition Self : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (*
        fn description(&self) -> &str {
            "could not convert slice to array"
        }
    *)
    Definition description (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| Value.String "could not convert slice to array" |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("description", InstanceField.Method description) ].
  End Impl_core_error_Error_for_core_array_TryFromSliceError.
  
  Module Impl_core_convert_From_core_convert_Infallible_for_core_array_TryFromSliceError.
    Definition Self : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (*
        fn from(x: Infallible) -> TryFromSliceError {
            match x {}
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          M.never_to_any (| M.read (| M.match_operator (| x, [] |) |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "core::convert::Infallible" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_core_convert_Infallible_for_core_array_TryFromSliceError.
  
  Module Impl_core_convert_AsRef_slice_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn as_ref(&self) -> &[T] {
            &self[..]
        }
    *)
    Definition as_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::Index",
              Ty.apply (Ty.path "array") [ T ],
              [ Ty.path "core::ops::range::RangeFull" ],
              "index",
              []
            |),
            [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::AsRef"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "slice") [ T ] ]
        (* Instance *) [ ("as_ref", InstanceField.Method (as_ref T)) ].
  End Impl_core_convert_AsRef_slice_T_for_array_T.
  
  Module Impl_core_convert_AsMut_slice_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn as_mut(&mut self) -> &mut [T] {
            &mut self[..]
        }
    *)
    Definition as_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::IndexMut",
              Ty.apply (Ty.path "array") [ T ],
              [ Ty.path "core::ops::range::RangeFull" ],
              "index_mut",
              []
            |),
            [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::AsMut"
        (Self T)
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "slice") [ T ] ]
        (* Instance *) [ ("as_mut", InstanceField.Method (as_mut T)) ].
  End Impl_core_convert_AsMut_slice_T_for_array_T.
  
  Module Impl_core_borrow_Borrow_slice_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn borrow(&self) -> &[T] {
            self
        }
    *)
    Definition borrow (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          (* Unsize *) M.pointer_coercion (M.read (| self |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::borrow::Borrow"
        (Self T)
        (* Trait polymorphic types *) [ (* Borrowed *) Ty.apply (Ty.path "slice") [ T ] ]
        (* Instance *) [ ("borrow", InstanceField.Method (borrow T)) ].
  End Impl_core_borrow_Borrow_slice_T_for_array_T.
  
  Module Impl_core_borrow_BorrowMut_slice_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn borrow_mut(&mut self) -> &mut [T] {
            self
        }
    *)
    Definition borrow_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          (* Unsize *) M.pointer_coercion (M.read (| self |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::borrow::BorrowMut"
        (Self T)
        (* Trait polymorphic types *) [ (* Borrowed *) Ty.apply (Ty.path "slice") [ T ] ]
        (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T)) ].
  End Impl_core_borrow_BorrowMut_slice_T_for_array_T.
  
  Module Impl_core_convert_TryFrom_where_core_marker_Copy_T_ref__slice_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*     type Error = TryFromSliceError; *)
    Definition _Error (T : Ty.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (*
        fn try_from(slice: &[T]) -> Result<[T; N], TryFromSliceError> {
            <&Self>::try_from(slice).copied()
        }
    *)
    Definition try_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [
                  Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ];
                  Ty.path "core::array::TryFromSliceError"
                ],
              "copied",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::TryFrom",
                  Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ],
                  [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
                  "try_from",
                  []
                |),
                [ M.read (| slice |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *)
        [ ("Error", InstanceField.Ty (_Error T)); ("try_from", InstanceField.Method (try_from T)) ].
  End Impl_core_convert_TryFrom_where_core_marker_Copy_T_ref__slice_T_for_array_T.
  
  Module Impl_core_convert_TryFrom_where_core_marker_Copy_T_ref_mut_slice_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*     type Error = TryFromSliceError; *)
    Definition _Error (T : Ty.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (*
        fn try_from(slice: &mut [T]) -> Result<[T; N], TryFromSliceError> {
            <Self>::try_from(&*slice)
        }
    *)
    Definition try_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::TryFrom",
              Ty.apply (Ty.path "array") [ T ],
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
              "try_from",
              []
            |),
            [ M.read (| slice |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *)
        [ ("Error", InstanceField.Ty (_Error T)); ("try_from", InstanceField.Method (try_from T)) ].
  End Impl_core_convert_TryFrom_where_core_marker_Copy_T_ref_mut_slice_T_for_array_T.
  
  Module Impl_core_convert_TryFrom_ref__slice_T_for_ref__array_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ].
    
    (*     type Error = TryFromSliceError; *)
    Definition _Error (T : Ty.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (*
        fn try_from(slice: &'a [T]) -> Result<&'a [T; N], TryFromSliceError> {
            if slice.len() == N {
                let ptr = slice.as_ptr() as *const [T; N];
                // SAFETY: ok because we just checked that the length fits
                unsafe { Ok(&*ptr) }
            } else {
                Err(TryFromSliceError(()))
            }
        }
    *)
    Definition try_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| slice |) ]
                            |))
                            (M.read (| M.get_constant (| "core::array::N" |) |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let ptr :=
                      M.alloc (|
                        M.rust_cast
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "as_ptr",
                              []
                            |),
                            [ M.read (| slice |) ]
                          |))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| ptr |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ Value.StructTuple "core::array::TryFromSliceError" [ Value.Tuple [] ] ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *)
        [ ("Error", InstanceField.Ty (_Error T)); ("try_from", InstanceField.Method (try_from T)) ].
  End Impl_core_convert_TryFrom_ref__slice_T_for_ref__array_T.
  
  Module Impl_core_convert_TryFrom_ref_mut_slice_T_for_ref_mut_array_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "array") [ T ] ].
    
    (*     type Error = TryFromSliceError; *)
    Definition _Error (T : Ty.t) : Ty.t := Ty.path "core::array::TryFromSliceError".
    
    (*
        fn try_from(slice: &'a mut [T]) -> Result<&'a mut [T; N], TryFromSliceError> {
            if slice.len() == N {
                let ptr = slice.as_mut_ptr() as *mut [T; N];
                // SAFETY: ok because we just checked that the length fits
                unsafe { Ok(&mut *ptr) }
            } else {
                Err(TryFromSliceError(()))
            }
        }
    *)
    Definition try_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.eq
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "slice") [ T ],
                                "len",
                                []
                              |),
                              [ M.read (| slice |) ]
                            |))
                            (M.read (| M.get_constant (| "core::array::N" |) |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let ptr :=
                      M.alloc (|
                        M.rust_cast
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ T ],
                              "as_mut_ptr",
                              []
                            |),
                            [ M.read (| slice |) ]
                          |))
                      |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| ptr |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ Value.StructTuple "core::array::TryFromSliceError" [ Value.Tuple [] ] ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::convert::TryFrom"
        (Self T)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "slice") [ T ] ] ]
        (* Instance *)
        [ ("Error", InstanceField.Ty (_Error T)); ("try_from", InstanceField.Method (try_from T)) ].
  End Impl_core_convert_TryFrom_ref_mut_slice_T_for_ref_mut_array_T.
  
  Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn hash<H: hash::Hasher>(&self, state: &mut H) {
            Hash::hash(&self[..], state)
        }
    *)
    Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.apply (Ty.path "slice") [ T ],
              [],
              "hash",
              [ H ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::Index",
                  Ty.apply (Ty.path "array") [ T ],
                  [ Ty.path "core::ops::range::RangeFull" ],
                  "index",
                  []
                |),
                [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
              |);
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
  End Impl_core_hash_Hash_where_core_hash_Hash_T_for_array_T.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::Debug::fmt(&&self[..], f)
        }
    *)
    Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::fmt::Debug",
              Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ],
              [],
              "fmt",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |);
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_array_T.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_ref__array_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ T ] ].
    
    (*     type Item = &'a T; *)
    Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
    
    (*     type IntoIter = Iter<'a, T>; *)
    Definition _IntoIter (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::Iter") [ T ].
    
    (*
        fn into_iter(self) -> Iter<'a, T> {
            self.iter()
        }
    *)
    Definition into_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter", [] |),
            [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item T));
          ("IntoIter", InstanceField.Ty (_IntoIter T));
          ("into_iter", InstanceField.Method (into_iter T))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_ref__array_T.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_array_T.
    Definition Self (T : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "&mut") [ Ty.apply (Ty.path "array") [ T ] ].
    
    (*     type Item = &'a mut T; *)
    Definition _Item (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
    
    (*     type IntoIter = IterMut<'a, T>; *)
    Definition _IntoIter (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ].
    
    (*
        fn into_iter(self) -> IterMut<'a, T> {
            self.iter_mut()
        }
    *)
    Definition into_iter (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter_mut", [] |),
            [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Item", InstanceField.Ty (_Item T));
          ("IntoIter", InstanceField.Ty (_IntoIter T));
          ("into_iter", InstanceField.Method (into_iter T))
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_ref_mut_array_T.
  
  Module Impl_core_ops_index_Index_where_core_ops_index_Index_slice_T_I_I_for_array_T.
    Definition Self (T I : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*     type Output = <[T] as Index<I>>::Output; *)
    Definition _Output (T I : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn index(&self, index: I) -> &Self::Output {
            Index::index(self as &[T], index)
        }
    *)
    Definition index (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::Index",
              Ty.apply (Ty.path "slice") [ T ],
              [ I ],
              "index",
              []
            |),
            [
              M.read (|
                M.use (M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| self |)) |))
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "core::ops::index::Index"
        (Self T I)
        (* Trait polymorphic types *) [ (* Idx *) I ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output T I)); ("index", InstanceField.Method (index T I)) ].
  End Impl_core_ops_index_Index_where_core_ops_index_Index_slice_T_I_I_for_array_T.
  
  Module Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_slice_T_I_I_for_array_T.
    Definition Self (T I : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn index_mut(&mut self, index: I) -> &mut Self::Output {
            IndexMut::index_mut(self as &mut [T], index)
        }
    *)
    Definition index_mut (T I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T I in
      match τ, α with
      | [], [ self; index ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::IndexMut",
              Ty.apply (Ty.path "slice") [ T ],
              [ I ],
              "index_mut",
              []
            |),
            [
              M.read (|
                M.use (M.alloc (| (* Unsize *) M.pointer_coercion (M.read (| self |)) |))
              |);
              M.read (| index |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T I : Ty.t),
      M.IsTraitInstance
        "core::ops::index::IndexMut"
        (Self T I)
        (* Trait polymorphic types *) [ (* Idx *) I ]
        (* Instance *) [ ("index_mut", InstanceField.Method (index_mut T I)) ].
  End Impl_core_ops_index_IndexMut_where_core_ops_index_IndexMut_slice_T_I_I_for_array_T.
  
  Module Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn partial_cmp(&self, other: &[T; N]) -> Option<Ordering> {
            PartialOrd::partial_cmp(&&self[..], &&other[..])
        }
    *)
    Definition partial_cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ],
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
              "partial_cmp",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |);
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| other |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn lt(&self, other: &[T; N]) -> bool {
            PartialOrd::lt(&&self[..], &&other[..])
        }
    *)
    Definition lt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ],
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
              "lt",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |);
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| other |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn le(&self, other: &[T; N]) -> bool {
            PartialOrd::le(&&self[..], &&other[..])
        }
    *)
    Definition le (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ],
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
              "le",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |);
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| other |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn ge(&self, other: &[T; N]) -> bool {
            PartialOrd::ge(&&self[..], &&other[..])
        }
    *)
    Definition ge (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ],
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
              "ge",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |);
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| other |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn gt(&self, other: &[T; N]) -> bool {
            PartialOrd::gt(&&self[..], &&other[..])
        }
    *)
    Definition gt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ],
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ] ],
              "gt",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |);
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| other |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("partial_cmp", InstanceField.Method (partial_cmp T));
          ("lt", InstanceField.Method (lt T));
          ("le", InstanceField.Method (le T));
          ("ge", InstanceField.Method (ge T));
          ("gt", InstanceField.Method (gt T))
        ].
  End Impl_core_cmp_PartialOrd_where_core_cmp_PartialOrd_T_for_array_T.
  
  Module Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn cmp(&self, other: &[T; N]) -> Ordering {
            Ord::cmp(&&self[..], &&other[..])
        }
    *)
    Definition cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ T ] ],
              [],
              "cmp",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |);
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply (Ty.path "array") [ T ],
                    [ Ty.path "core::ops::range::RangeFull" ],
                    "index",
                    []
                  |),
                  [ M.read (| other |); Value.StructTuple "core::ops::range::RangeFull" [] ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
  End Impl_core_cmp_Ord_where_core_cmp_Ord_T_for_array_T.
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_T_for_array_T.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        fn clone(&self) -> Self {
            SpecArrayClone::clone(self)
        }
    *)
    Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::array::SpecArrayClone", T, [], "clone", [] |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn clone_from(&mut self, other: &Self) {
            self.clone_from_slice(other);
        }
    *)
    Definition clone_from (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ T ],
                    "clone_from_slice",
                    []
                  |),
                  [
                    (* Unsize *) M.pointer_coercion (M.read (| self |));
                    (* Unsize *) M.pointer_coercion (M.read (| other |))
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("clone", InstanceField.Method (clone T));
          ("clone_from", InstanceField.Method (clone_from T))
        ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_for_array_T.
  
  (* Trait *)
  (* Empty module 'SpecArrayClone' *)
  
  Module Impl_core_array_SpecArrayClone_where_core_clone_Clone_T_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    (*
        default fn clone<const N: usize>(array: &[T; N]) -> [T; N] {
            from_trusted_iterator(array.iter().cloned())
        }
    *)
    Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ array ] =>
        ltac:(M.monadic
          (let array := M.alloc (| array |) in
          M.call_closure (|
            M.get_function (|
              "core::array::from_trusted_iterator",
              [
                T;
                Ty.apply
                  (Ty.path "core::iter::adapters::cloned::Cloned")
                  [ Ty.apply (Ty.path "core::slice::iter::Iter") [ T ] ]
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::slice::iter::Iter") [ T ],
                  [],
                  "cloned",
                  [ T ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter", [] |),
                    [ (* Unsize *) M.pointer_coercion (M.read (| array |)) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::array::SpecArrayClone"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_array_SpecArrayClone_where_core_clone_Clone_T_for_T.
  
  Module Impl_core_array_SpecArrayClone_where_core_marker_Copy_T_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    (*
        fn clone<const N: usize>(array: &[T; N]) -> [T; N] {
            *array
        }
    *)
    Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ array ] =>
        ltac:(M.monadic
          (let array := M.alloc (| array |) in
          M.read (| M.read (| array |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::array::SpecArrayClone"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_array_SpecArrayClone_where_core_marker_Copy_T_for_T.
  
  Module Impl_core_default_Default_where_core_default_Default_T_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |);
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    (*
                fn default() -> [T; $n] {
                    [$t::default(), $($ts::default()),*]
                }
    *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.Array
            [
              M.call_closure (|
                M.get_trait_method (| "core::default::Default", T, [], "default", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_where_core_default_Default_T_for_array_T.
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  Module Impl_core_default_Default_for_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*             fn default() -> [T; $n] { [] } *)
    Definition default (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with | [], [] => ltac:(M.monadic (Value.Array [])) | _, _ => M.impossible end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default T)) ].
  End Impl_core_default_Default_for_array_T.
  
  Module Impl_array_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "array") [ T ].
    
    (*
        pub fn map<F, U>(self, f: F) -> [U; N]
        where
            F: FnMut(T) -> U,
        {
            self.try_map(NeverShortCircuit::wrap_mut_1(f)).0
        }
    *)
    Definition map (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ F; U ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.SubPointer.get_struct_tuple_field (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ T ],
                    "try_map",
                    [
                      Ty.associated;
                      Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ U ]
                    ]
                  |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ U ],
                        "wrap_mut_1",
                        [ T; F ]
                      |),
                      [ M.read (| f |) ]
                    |)
                  ]
                |)
              |),
              "core::ops::try_trait::NeverShortCircuit",
              0
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_map : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "map" (map T).
    
    (*
        pub fn try_map<F, R>(self, f: F) -> ChangeOutputType<R, [R::Output; N]>
        where
            F: FnMut(T) -> R,
            R: Try,
            R::Residual: Residual<[R::Output; N]>,
        {
            drain_array_with(self, |iter| try_from_trusted_iterator(iter.map(f)))
        }
    *)
    Definition try_map (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ F; R ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_function (|
              "core::array::drain::drain_array_with",
              [
                T;
                Ty.associated;
                Ty.function
                  [ Ty.tuple [ Ty.apply (Ty.path "core::array::drain::Drain") [ T ] ] ]
                  Ty.associated
              ]
            |),
            [
              M.read (| self |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_function (|
                                  "core::array::try_from_trusted_iterator",
                                  [
                                    Ty.associated;
                                    R;
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      [ Ty.apply (Ty.path "core::array::drain::Drain") [ T ]; F ]
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply (Ty.path "core::array::drain::Drain") [ T ],
                                      [],
                                      "map",
                                      [ R; F ]
                                    |),
                                    [ M.read (| iter |); M.read (| f |) ]
                                  |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_try_map :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "try_map" (try_map T).
    
    (*
        pub const fn as_slice(&self) -> &[T] {
            self
        }
    *)
    Definition as_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          (* Unsize *) M.pointer_coercion (M.read (| self |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "as_slice" (as_slice T).
    
    (*
        pub fn as_mut_slice(&mut self) -> &mut [T] {
            self
        }
    *)
    Definition as_mut_slice (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          (* Unsize *) M.pointer_coercion (M.read (| self |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_mut_slice :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "as_mut_slice" (as_mut_slice T).
    
    (*
        pub fn each_ref(&self) -> [&T; N] {
            from_trusted_iterator(self.iter())
        }
    *)
    Definition each_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::array::from_trusted_iterator",
              [ Ty.apply (Ty.path "&") [ T ]; Ty.apply (Ty.path "core::slice::iter::Iter") [ T ] ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter", [] |),
                [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_each_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "each_ref" (each_ref T).
    
    (*
        pub fn each_mut(&mut self) -> [&mut T; N] {
            from_trusted_iterator(self.iter_mut())
        }
    *)
    Definition each_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (|
              "core::array::from_trusted_iterator",
              [
                Ty.apply (Ty.path "&mut") [ T ];
                Ty.apply (Ty.path "core::slice::iter::IterMut") [ T ]
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "iter_mut", [] |),
                [ (* Unsize *) M.pointer_coercion (M.read (| self |)) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_each_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "each_mut" (each_mut T).
    
    (*
        pub fn split_array_ref<const M: usize>(&self) -> (&[T; M], &[T]) {
            (&self[..]).split_array_ref::<M>()
        }
    *)
    Definition split_array_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "split_array_ref", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::Index",
                  Ty.apply (Ty.path "array") [ T ],
                  [ Ty.path "core::ops::range::RangeFull" ],
                  "index",
                  []
                |),
                [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_split_array_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "split_array_ref" (split_array_ref T).
    
    (*
        pub fn split_array_mut<const M: usize>(&mut self) -> (&mut [T; M], &mut [T]) {
            (&mut self[..]).split_array_mut::<M>()
        }
    *)
    Definition split_array_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "split_array_mut", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::IndexMut",
                  Ty.apply (Ty.path "array") [ T ],
                  [ Ty.path "core::ops::range::RangeFull" ],
                  "index_mut",
                  []
                |),
                [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_split_array_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "split_array_mut" (split_array_mut T).
    
    (*
        pub fn rsplit_array_ref<const M: usize>(&self) -> (&[T], &[T; M]) {
            (&self[..]).rsplit_array_ref::<M>()
        }
    *)
    Definition rsplit_array_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [ T ],
              "rsplit_array_ref",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::Index",
                  Ty.apply (Ty.path "array") [ T ],
                  [ Ty.path "core::ops::range::RangeFull" ],
                  "index",
                  []
                |),
                [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rsplit_array_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "rsplit_array_ref" (rsplit_array_ref T).
    
    (*
        pub fn rsplit_array_mut<const M: usize>(&mut self) -> (&mut [T], &mut [T; M]) {
            (&mut self[..]).rsplit_array_mut::<M>()
        }
    *)
    Definition rsplit_array_mut (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [ T ],
              "rsplit_array_mut",
              []
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::index::IndexMut",
                  Ty.apply (Ty.path "array") [ T ],
                  [ Ty.path "core::ops::range::RangeFull" ],
                  "index_mut",
                  []
                |),
                [ M.read (| self |); Value.StructTuple "core::ops::range::RangeFull" [] ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_rsplit_array_mut :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "rsplit_array_mut" (rsplit_array_mut T).
  End Impl_array_T.
  
  (*
  fn from_trusted_iterator<T, const N: usize>(iter: impl UncheckedIterator<Item = T>) -> [T; N] {
      try_from_trusted_iterator(iter.map(NeverShortCircuit)).0
  }
  *)
  Definition from_trusted_iterator (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; impl_UncheckedIterator_Item___T_ ], [ iter ] =>
      ltac:(M.monadic
        (let iter := M.alloc (| iter |) in
        M.read (|
          M.SubPointer.get_struct_tuple_field (|
            M.alloc (|
              M.call_closure (|
                M.get_function (|
                  "core::array::try_from_trusted_iterator",
                  [
                    T;
                    Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ T ];
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      [
                        impl_UncheckedIterator_Item___T_;
                        Ty.function
                          [ T ]
                          (Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ T ])
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      impl_UncheckedIterator_Item___T_,
                      [],
                      "map",
                      [
                        Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ T ];
                        Ty.function
                          [ T ]
                          (Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ T ])
                      ]
                    |),
                    [
                      M.read (| iter |);
                      M.constructor_as_closure "core::ops::try_trait::NeverShortCircuit"
                    ]
                  |)
                ]
              |)
            |),
            "core::ops::try_trait::NeverShortCircuit",
            0
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn try_from_trusted_iterator<T, R, const N: usize>(
      iter: impl UncheckedIterator<Item = R>,
  ) -> ChangeOutputType<R, [T; N]>
  where
      R: Try<Output = T>,
      R::Residual: Residual<[T; N]>,
  {
      assert!(iter.size_hint().0 >= N);
      fn next<T>(mut iter: impl UncheckedIterator<Item = T>) -> impl FnMut(usize) -> T {
          move |_| {
              // SAFETY: We know that `from_fn` will call this at most N times,
              // and we checked to ensure that we have at least that many items.
              unsafe { iter.next_unchecked() }
          }
      }
  
      try_from_fn(next(iter))
  }
  *)
  Definition try_from_trusted_iterator (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; R; impl_UncheckedIterator_Item___R_ ], [ iter ] =>
      ltac:(M.monadic
        (let iter := M.alloc (| iter |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (BinOp.Pure.ge
                              (M.read (|
                                M.SubPointer.get_tuple_field (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        impl_UncheckedIterator_Item___R_,
                                        [],
                                        "size_hint",
                                        []
                                      |),
                                      [ iter ]
                                    |)
                                  |),
                                  0
                                |)
                              |))
                              (M.read (|
                                M.get_constant (| "core::array::try_from_trusted_iterator::N" |)
                              |)))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic", [] |),
                          [ M.read (| Value.String "assertion failed: iter.size_hint().0 >= N" |) ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (| "core::array::try_from_fn", [ R; Ty.associated ] |),
              [
                M.call_closure (|
                  M.get_function (| "core::array::try_from_trusted_iterator.next", [] |),
                  [ M.read (| iter |) ]
                |)
              ]
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module try_from_trusted_iterator.
    (*
        fn next<T>(mut iter: impl UncheckedIterator<Item = T>) -> impl FnMut(usize) -> T {
            move |_| {
                // SAFETY: We know that `from_fn` will call this at most N times,
                // and we checked to ensure that we have at least that many items.
                unsafe { iter.next_unchecked() }
            }
        }
    *)
    Definition next (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T; impl_UncheckedIterator_Item___T_ ], [ iter ] =>
        ltac:(M.monadic
          (let iter := M.alloc (| iter |) in
          M.closure
            (fun γ =>
              ltac:(M.monadic
                match γ with
                | [ α0 ] =>
                  M.match_operator (|
                    M.alloc (| α0 |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::unchecked_iterator::UncheckedIterator",
                              impl_UncheckedIterator_Item___T_,
                              [],
                              "next_unchecked",
                              []
                            |),
                            [ iter ]
                          |)))
                    ]
                  |)
                | _ => M.impossible (||)
                end))))
      | _, _ => M.impossible
      end.
    
    Module next.
      (* Error OpaqueTy *)
    End next.
  End try_from_trusted_iterator.
  
  (*
  fn try_from_fn_erased<T, R>(
      buffer: &mut [MaybeUninit<T>],
      mut generator: impl FnMut(usize) -> R,
  ) -> ControlFlow<R::Residual>
  where
      R: Try<Output = T>,
  {
      let mut guard = Guard { array_mut: buffer, initialized: 0 };
  
      while guard.initialized < guard.array_mut.len() {
          let item = generator(guard.initialized).branch()?;
  
          // SAFETY: The loop condition ensures we have space to push the item
          unsafe { guard.push_unchecked(item) };
      }
  
      mem::forget(guard);
      ControlFlow::Continue(())
  }
  *)
  Definition try_from_fn_erased (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; R; impl_FnMut_usize__arrow_R ], [ buffer; generator ] =>
      ltac:(M.monadic
        (let buffer := M.alloc (| buffer |) in
        let generator := M.alloc (| generator |) in
        M.catch_return (|
          ltac:(M.monadic
            (M.read (|
              let guard :=
                M.alloc (|
                  Value.StructRecord
                    "core::array::Guard"
                    [ ("array_mut", M.read (| buffer |)); ("initialized", Value.Integer 0) ]
                |) in
              let _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.lt
                                    (M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        guard,
                                        "core::array::Guard",
                                        "initialized"
                                      |)
                                    |))
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ T ]
                                          ],
                                        "len",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            guard,
                                            "core::array::Guard",
                                            "array_mut"
                                          |)
                                        |)
                                      ]
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let item :=
                              M.copy (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::ops::control_flow::ControlFlow")
                                          [ Ty.associated; T ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            R,
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                impl_FnMut_usize__arrow_R,
                                                [ Ty.tuple [ Ty.path "usize" ] ],
                                                "call_mut",
                                                []
                                              |),
                                              [
                                                generator;
                                                Value.Tuple
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        guard,
                                                        "core::array::Guard",
                                                        "initialized"
                                                      |)
                                                    |)
                                                  ]
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::ops::control_flow::ControlFlow")
                                                      [ Ty.associated; Ty.tuple [] ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::ops::control_flow::ControlFlow")
                                                        [
                                                          Ty.associated;
                                                          Ty.path "core::convert::Infallible"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "core::array::Guard") [ T ],
                                    "push_unchecked",
                                    []
                                  |),
                                  [ guard; M.read (| item |) ]
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::forget",
                      [ Ty.apply (Ty.path "core::array::Guard") [ T ] ]
                    |),
                    [ M.read (| guard |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "core::ops::control_flow::ControlFlow::Continue"
                  [ Value.Tuple [] ]
              |)
            |)))
        |)))
    | _, _ => M.impossible
    end.
  
  (* StructRecord
    {
      name := "Guard";
      ty_params := [ "T" ];
      fields :=
        [
          ("array_mut",
            Ty.apply
              (Ty.path "&mut")
              [
                Ty.apply
                  (Ty.path "slice")
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ]
              ]);
          ("initialized", Ty.path "usize")
        ];
    } *)
  
  Module Impl_core_array_Guard_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::array::Guard") [ T ].
    
    (*
        pub unsafe fn push_unchecked(&mut self, item: T) {
            // SAFETY: If `initialized` was correct before and the caller does not
            // invoke this method more than N times then writes will be in-bounds
            // and slots will not be initialized more than once.
            unsafe {
                self.array_mut.get_unchecked_mut(self.initialized).write(item);
                self.initialized = self.initialized.unchecked_add(1);
            }
        }
    *)
    Definition push_unchecked (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; item ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let item := M.alloc (| item |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                    "write",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                        "get_unchecked_mut",
                        [ Ty.path "usize" ]
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::array::Guard",
                            "array_mut"
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::array::Guard",
                            "initialized"
                          |)
                        |)
                      ]
                    |);
                    M.read (| item |)
                  ]
                |)
              |) in
            let _ :=
              M.write (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::array::Guard",
                  "initialized"
                |),
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "unchecked_add", [] |),
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::array::Guard",
                        "initialized"
                      |)
                    |);
                    Value.Integer 1
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_push_unchecked :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "push_unchecked" (push_unchecked T).
  End Impl_core_array_Guard_T.
  
  Module Impl_core_ops_drop_Drop_for_core_array_Guard_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::array::Guard") [ T ].
    
    (*
        fn drop(&mut self) {
            debug_assert!(self.initialized <= self.array_mut.len());
    
            // SAFETY: this slice will contain only initialized objects.
            unsafe {
                crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(
                    self.array_mut.get_unchecked_mut(..self.initialized),
                ));
            }
        }
    *)
    Definition drop (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (BinOp.Pure.le
                                          (M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::array::Guard",
                                              "initialized"
                                            |)
                                          |))
                                          (M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "slice")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    [ T ]
                                                ],
                                              "len",
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "core::array::Guard",
                                                  "array_mut"
                                                |)
                                              |)
                                            ]
                                          |)))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic", [] |),
                                      [
                                        M.read (|
                                          Value.String
                                            "assertion failed: self.initialized <= self.array_mut.len()"
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::ptr::drop_in_place",
                    [ Ty.apply (Ty.path "slice") [ T ] ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                        "slice_assume_init_mut",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ] ],
                            "get_unchecked_mut",
                            [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::array::Guard",
                                "array_mut"
                              |)
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeTo"
                              [
                                ("end_",
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::array::Guard",
                                      "initialized"
                                    |)
                                  |))
                              ]
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::ops::drop::Drop"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("drop", InstanceField.Method (drop T)) ].
  End Impl_core_ops_drop_Drop_for_core_array_Guard_T.
  
  (*
  pub(crate) fn iter_next_chunk<T, const N: usize>(
      iter: &mut impl Iterator<Item = T>,
  ) -> Result<[T; N], IntoIter<T, N>> {
      let mut array = MaybeUninit::uninit_array::<N>();
      let r = iter_next_chunk_erased(&mut array, iter);
      match r {
          Ok(()) => {
              // SAFETY: All elements of `array` were populated.
              Ok(unsafe { MaybeUninit::array_assume_init(array) })
          }
          Err(initialized) => {
              // SAFETY: Only the first `initialized` elements were populated
              Err(unsafe { IntoIter::new_unchecked(array, 0..initialized) })
          }
      }
  }
  *)
  Definition iter_next_chunk (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; impl_Iterator_Item___T_ ], [ iter ] =>
      ltac:(M.monadic
        (let iter := M.alloc (| iter |) in
        M.read (|
          let array :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                  "uninit_array",
                  []
                |),
                []
              |)
            |) in
          let r :=
            M.alloc (|
              M.call_closure (|
                M.get_function (|
                  "core::array::iter_next_chunk_erased",
                  [ T; impl_Iterator_Item___T_ ]
                |),
                [ (* Unsize *) M.pointer_coercion array; M.read (| iter |) ]
              |)
            |) in
          M.match_operator (|
            r,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ T ],
                            "array_assume_init",
                            []
                          |),
                          [ M.read (| array |) ]
                        |)
                      ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                  let initialized := M.copy (| γ0_0 |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Err"
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ T ],
                            "new_unchecked",
                            []
                          |),
                          [
                            M.read (| array |);
                            Value.StructRecord
                              "core::ops::range::Range"
                              [ ("start", Value.Integer 0); ("end_", M.read (| initialized |)) ]
                          ]
                        |)
                      ]
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn iter_next_chunk_erased<T>(
      buffer: &mut [MaybeUninit<T>],
      iter: &mut impl Iterator<Item = T>,
  ) -> Result<(), usize> {
      let mut guard = Guard { array_mut: buffer, initialized: 0 };
      while guard.initialized < guard.array_mut.len() {
          let Some(item) = iter.next() else {
              // Unlike `try_from_fn_erased`, we want to keep the partial results,
              // so we need to defuse the guard instead of using `?`.
              let initialized = guard.initialized;
              mem::forget(guard);
              return Err(initialized);
          };
  
          // SAFETY: The loop condition ensures we have space to push the item
          unsafe { guard.push_unchecked(item) };
      }
  
      mem::forget(guard);
      Ok(())
  }
  *)
  Definition iter_next_chunk_erased (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; impl_Iterator_Item___T_ ], [ buffer; iter ] =>
      ltac:(M.monadic
        (let buffer := M.alloc (| buffer |) in
        let iter := M.alloc (| iter |) in
        M.read (|
          let guard :=
            M.alloc (|
              Value.StructRecord
                "core::array::Guard"
                [ ("array_mut", M.read (| buffer |)); ("initialized", Value.Integer 0) ]
            |) in
          let _ :=
            M.loop (|
              ltac:(M.monadic
                (M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.lt
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    guard,
                                    "core::array::Guard",
                                    "initialized"
                                  |)
                                |))
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ T ]
                                      ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        guard,
                                        "core::array::Guard",
                                        "array_mut"
                                      |)
                                    |)
                                  ]
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                impl_Iterator_Item___T_,
                                [],
                                "next",
                                []
                              |),
                              [ M.read (| iter |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "core::option::Option::Some",
                                    0
                                  |) in
                                let item := M.copy (| γ0_0 |) in
                                let _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::array::Guard") [ T ],
                                        "push_unchecked",
                                        []
                                      |),
                                      [ guard; M.read (| item |) ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              let _ :=
                                M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                              M.alloc (| Value.Tuple [] |)
                            |)
                          |)
                        |)))
                  ]
                |)))
            |) in
          let _ :=
            M.alloc (|
              M.call_closure (|
                M.get_function (|
                  "core::mem::forget",
                  [ Ty.apply (Ty.path "core::array::Guard") [ T ] ]
                |),
                [ M.read (| guard |) ]
              |)
            |) in
          M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
        |)))
    | _, _ => M.impossible
    end.
End array.
