(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bool.
  Module Impl_bool.
    Definition Self : Ty.t := Ty.path "bool".
    
    (*
        pub fn then_some<T>(self, t: T) -> Option<T> {
            if self { Some(t) } else { None }
        }
    *)
    Definition then_some (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self; t ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "bool", self |) in
          let t := M.alloc (| T, t |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use self in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      Value.StructTuple "core::option::Option::Some" [] [ T ] [ M.read (| t |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      Value.StructTuple "core::option::Option::None" [] [ T ] []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_then_some :
      M.IsAssociatedFunction.C Self "then_some" then_some.
    Admitted.
    Global Typeclasses Opaque then_some.
    
    (*
        pub fn then<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {
            if self { Some(f()) } else { None }
        }
    *)
    Definition then_ (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T; F ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "bool", self |) in
          let f := M.alloc (| F, f |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "core::option::Option") [] [ T ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use self in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ T ]
                        [
                          M.call_closure (|
                            T,
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [],
                              [ Ty.tuple [] ],
                              "call_once",
                              [],
                              []
                            |),
                            [ M.read (| f |); Value.Tuple [] ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      Value.StructTuple "core::option::Option::None" [] [ T ] []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_then_ : M.IsAssociatedFunction.C Self "then" then_.
    Admitted.
    Global Typeclasses Opaque then_.
  End Impl_bool.
End bool.
