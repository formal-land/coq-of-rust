(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module char.
  Module methods.
    Module Impl_char.
      Definition Self : Ty.t := Ty.path "char".
      
      (*     pub const MIN: char = '\0'; *)
      (* Ty.path "char" *)
      Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (M.alloc (| Value.UnicodeChar 0 |))).
      
      Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
      Admitted.
      Global Typeclasses Opaque value_MIN.
      
      (*     pub const MAX: char = '\u{10FFFF}'; *)
      (* Ty.path "char" *)
      Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic (M.alloc (| Value.UnicodeChar 1114111 |))).
      
      Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
      Admitted.
      Global Typeclasses Opaque value_MAX.
      
      (*     pub const REPLACEMENT_CHARACTER: char = '\u{FFFD}'; *)
      (* Ty.path "char" *)
      Definition value_REPLACEMENT_CHARACTER
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.UnicodeChar 65533 |))).
      
      Global Instance AssociatedConstant_value_REPLACEMENT_CHARACTER :
        M.IsAssociatedFunction.C Self "REPLACEMENT_CHARACTER" value_REPLACEMENT_CHARACTER.
      Admitted.
      Global Typeclasses Opaque value_REPLACEMENT_CHARACTER.
      
      (*     pub const UNICODE_VERSION: (u8, u8, u8) = crate::unicode::UNICODE_VERSION; *)
      (* Ty.tuple [ Ty.path "u8"; Ty.path "u8"; Ty.path "u8" ] *)
      Definition value_UNICODE_VERSION (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (get_constant (|
            "core::unicode::UNICODE_VERSION",
            Ty.tuple [ Ty.path "u8"; Ty.path "u8"; Ty.path "u8" ]
          |))).
      
      Global Instance AssociatedConstant_value_UNICODE_VERSION :
        M.IsAssociatedFunction.C Self "UNICODE_VERSION" value_UNICODE_VERSION.
      Admitted.
      Global Typeclasses Opaque value_UNICODE_VERSION.
      
      (*
          pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {
              super::decode::decode_utf16(iter)
          }
      *)
      Definition decode_utf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| iter |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::char::decode::DecodeUtf16")
                []
                [
                  Ty.associated_in_trait
                    "core::iter::traits::collect::IntoIterator"
                    []
                    []
                    I
                    "IntoIter"
                ],
              M.get_function (| "core::char::decode::decode_utf16", [], [ I ] |),
              [ M.read (| iter |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_decode_utf16 :
        M.IsAssociatedFunction.C Self "decode_utf16" decode_utf16.
      Admitted.
      Global Typeclasses Opaque decode_utf16.
      
      (*
          pub const fn from_u32(i: u32) -> Option<char> {
              super::convert::from_u32(i)
          }
      *)
      Definition from_u32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ i ] =>
          ltac:(M.monadic
            (let i := M.alloc (| i |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "char" ],
              M.get_function (| "core::char::convert::from_u32", [], [] |),
              [ M.read (| i |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_u32 :
        M.IsAssociatedFunction.C Self "from_u32" from_u32.
      Admitted.
      Global Typeclasses Opaque from_u32.
      
      (*
          pub const unsafe fn from_u32_unchecked(i: u32) -> char {
              // SAFETY: the safety contract must be upheld by the caller.
              unsafe { super::convert::from_u32_unchecked(i) }
          }
      *)
      Definition from_u32_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ i ] =>
          ltac:(M.monadic
            (let i := M.alloc (| i |) in
            M.call_closure (|
              Ty.path "char",
              M.get_function (| "core::char::convert::from_u32_unchecked", [], [] |),
              [ M.read (| i |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_u32_unchecked :
        M.IsAssociatedFunction.C Self "from_u32_unchecked" from_u32_unchecked.
      Admitted.
      Global Typeclasses Opaque from_u32_unchecked.
      
      (*
          pub const fn from_digit(num: u32, radix: u32) -> Option<char> {
              super::convert::from_digit(num, radix)
          }
      *)
      Definition from_digit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ num; radix ] =>
          ltac:(M.monadic
            (let num := M.alloc (| num |) in
            let radix := M.alloc (| radix |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "char" ],
              M.get_function (| "core::char::convert::from_digit", [], [] |),
              [ M.read (| num |); M.read (| radix |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_digit :
        M.IsAssociatedFunction.C Self "from_digit" from_digit.
      Admitted.
      Global Typeclasses Opaque from_digit.
      
      (*
          pub const fn is_digit(self, radix: u32) -> bool {
              self.to_digit(radix).is_some()
          }
      *)
      Definition is_digit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; radix ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let radix := M.alloc (| radix |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                "is_some",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                      M.get_associated_function (| Ty.path "char", "to_digit", [], [] |),
                      [ M.read (| self |); M.read (| radix |) ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_digit :
        M.IsAssociatedFunction.C Self "is_digit" is_digit.
      Admitted.
      Global Typeclasses Opaque is_digit.
      
      (*
          pub const fn to_digit(self, radix: u32) -> Option<u32> {
              assert!(
                  radix >= 2 && radix <= 36,
                  "to_digit: invalid radix -- radix must be in the range 2 to 36 inclusive"
              );
              // check radix to remove letter handling code when radix is a known constant
              let value = if self > '9' && radix > 10 {
                  // convert ASCII letters to lowercase
                  let lower = self as u32 | 0x20;
                  // convert an ASCII letter to the corresponding value,
                  // non-letters convert to values > 36
                  lower.wrapping_sub('a' as u32) as u64 + 10
              } else {
                  // convert digit to value, non-digits wrap to values > 36
                  (self as u32).wrapping_sub('0' as u32) as u64
              };
              // FIXME(const-hack): once then_some is const fn, use it here
              if value < radix as u64 { Some(value as u32) } else { None }
          }
      *)
      Definition to_digit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; radix ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let radix := M.alloc (| radix |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [ M.read (| radix |); Value.Integer IntegerKind.U32 2 ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| radix |); Value.Integer IntegerKind.U32 36 ]
                                    |)))
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic_fmt", [], [] |),
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Value.Array
                                              [
                                                mk_str (|
                                                  "to_digit: invalid radix -- radix must be in the range 2 to 36 inclusive"
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ value : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
                M.copy (|
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                LogicalOp.and (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| self |); Value.UnicodeChar 57 ]
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.gt,
                                      [ M.read (| radix |); Value.Integer IntegerKind.U32 10 ]
                                    |)))
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ lower : Ty.apply (Ty.path "*") [] [ Ty.path "u32" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "u32",
                                BinOp.Wrap.bit_or,
                                [
                                  M.cast (Ty.path "u32") (M.read (| self |));
                                  Value.Integer IntegerKind.U32 32
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.add,
                              [
                                M.cast
                                  (Ty.path "u64")
                                  (M.call_closure (|
                                    Ty.path "u32",
                                    M.get_associated_function (|
                                      Ty.path "u32",
                                      "wrapping_sub",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (| lower |);
                                      M.cast (Ty.path "u32") (Value.UnicodeChar 97)
                                    ]
                                  |));
                                Value.Integer IntegerKind.U64 10
                              ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.cast
                              (Ty.path "u64")
                              (M.call_closure (|
                                Ty.path "u32",
                                M.get_associated_function (|
                                  Ty.path "u32",
                                  "wrapping_sub",
                                  [],
                                  []
                                |),
                                [
                                  M.cast (Ty.path "u32") (M.read (| self |));
                                  M.cast (Ty.path "u32") (Value.UnicodeChar 48)
                                ]
                              |))
                          |)))
                    ]
                  |)
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.lt,
                              [ M.read (| value |); M.cast (Ty.path "u64") (M.read (| radix |)) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [ M.cast (Ty.path "u32") (M.read (| value |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_digit :
        M.IsAssociatedFunction.C Self "to_digit" to_digit.
      Admitted.
      Global Typeclasses Opaque to_digit.
      
      (*
          pub fn escape_unicode(self) -> EscapeUnicode {
              EscapeUnicode::new(self)
          }
      *)
      Definition escape_unicode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "core::char::EscapeUnicode",
              M.get_associated_function (| Ty.path "core::char::EscapeUnicode", "new", [], [] |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_escape_unicode :
        M.IsAssociatedFunction.C Self "escape_unicode" escape_unicode.
      Admitted.
      Global Typeclasses Opaque escape_unicode.
      
      (*
          pub(crate) fn escape_debug_ext(self, args: EscapeDebugExtArgs) -> EscapeDebug {
              match self {
                  '\0' => EscapeDebug::backslash(ascii::Char::Digit0),
                  '\t' => EscapeDebug::backslash(ascii::Char::SmallT),
                  '\r' => EscapeDebug::backslash(ascii::Char::SmallR),
                  '\n' => EscapeDebug::backslash(ascii::Char::SmallN),
                  '\\' => EscapeDebug::backslash(ascii::Char::ReverseSolidus),
                  '\"' if args.escape_double_quote => EscapeDebug::backslash(ascii::Char::QuotationMark),
                  '\'' if args.escape_single_quote => EscapeDebug::backslash(ascii::Char::Apostrophe),
                  _ if args.escape_grapheme_extended && self.is_grapheme_extended() => {
                      EscapeDebug::unicode(self)
                  }
                  _ if is_printable(self) => EscapeDebug::printable(self),
                  _ => EscapeDebug::unicode(self),
              }
          }
      "
      *)
      Definition escape_debug_ext (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; args ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let args := M.alloc (| args |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "core::char::EscapeDebug" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::Digit0" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 9 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallT" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 13 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallR" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 10 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallN" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 92 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "backslash",
                            [],
                            []
                          |),
                          [
                            Value.StructTuple
                              "core::ascii::ascii_char::AsciiChar::ReverseSolidus"
                              []
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 34 |) in
                      let γ :=
                        M.SubPointer.get_struct_record_field (|
                          args,
                          "core::char::methods::EscapeDebugExtArgs",
                          "escape_double_quote"
                        |) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::QuotationMark" []
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 39 |) in
                      let γ :=
                        M.SubPointer.get_struct_record_field (|
                          args,
                          "core::char::methods::EscapeDebugExtArgs",
                          "escape_single_quote"
                        |) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::Apostrophe" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.SubPointer.get_struct_record_field (|
                          args,
                          "core::char::methods::EscapeDebugExtArgs",
                          "escape_grapheme_extended"
                        |) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let γ :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.path "char",
                              "is_grapheme_extended",
                              [],
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        |) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "unicode",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (| "core::unicode::printable::is_printable", [], [] |),
                            [ M.read (| self |) ]
                          |)
                        |) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "printable",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDebug",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDebug",
                            "unicode",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_escape_debug_ext :
        M.IsAssociatedFunction.C Self "escape_debug_ext" escape_debug_ext.
      Admitted.
      Global Typeclasses Opaque escape_debug_ext.
      
      (*
          pub fn escape_debug(self) -> EscapeDebug {
              self.escape_debug_ext(EscapeDebugExtArgs::ESCAPE_ALL)
          }
      *)
      Definition escape_debug (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "core::char::EscapeDebug",
              M.get_associated_function (| Ty.path "char", "escape_debug_ext", [], [] |),
              [
                M.read (| self |);
                M.read (|
                  get_associated_constant (|
                    Ty.path "core::char::methods::EscapeDebugExtArgs",
                    "ESCAPE_ALL",
                    Ty.path "core::char::methods::EscapeDebugExtArgs"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_escape_debug :
        M.IsAssociatedFunction.C Self "escape_debug" escape_debug.
      Admitted.
      Global Typeclasses Opaque escape_debug.
      
      (*
          pub fn escape_default(self) -> EscapeDefault {
              match self {
                  '\t' => EscapeDefault::backslash(ascii::Char::SmallT),
                  '\r' => EscapeDefault::backslash(ascii::Char::SmallR),
                  '\n' => EscapeDefault::backslash(ascii::Char::SmallN),
                  '\\' | '\'' | '\"' => EscapeDefault::backslash(self.as_ascii().unwrap()),
                  '\x20'..='\x7e' => EscapeDefault::printable(self.as_ascii().unwrap()),
                  _ => EscapeDefault::unicode(self),
              }
          }
      "
      *)
      Definition escape_default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "core::char::EscapeDefault" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 9 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDefault",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDefault",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallT" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 13 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDefault",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDefault",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallR" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        is_constant_or_break_match (| M.read (| γ |), Value.UnicodeChar 10 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDefault",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDefault",
                            "backslash",
                            [],
                            []
                          |),
                          [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallN" [] ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (Ty.tuple []) (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 92
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 39
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 34
                                |) in
                              Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "core::char::EscapeDefault",
                                    M.get_associated_function (|
                                      Ty.path "core::char::EscapeDefault",
                                      "backslash",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "core::ascii::ascii_char::AsciiChar",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                          "unwrap",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                            M.get_associated_function (|
                                              Ty.path "char",
                                              "as_ascii",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDefault",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDefault",
                            "printable",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.path "core::ascii::ascii_char::AsciiChar",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                "unwrap",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                  M.get_associated_function (|
                                    Ty.path "char",
                                    "as_ascii",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "core::char::EscapeDefault",
                          M.get_associated_function (|
                            Ty.path "core::char::EscapeDefault",
                            "unicode",
                            [],
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_escape_default :
        M.IsAssociatedFunction.C Self "escape_default" escape_default.
      Admitted.
      Global Typeclasses Opaque escape_default.
      
      (*
          pub const fn len_utf8(self) -> usize {
              len_utf8(self as u32)
          }
      *)
      Definition len_utf8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::char::methods::len_utf8", [], [] |),
              [ M.cast (Ty.path "u32") (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len_utf8 :
        M.IsAssociatedFunction.C Self "len_utf8" len_utf8.
      Admitted.
      Global Typeclasses Opaque len_utf8.
      
      (*
          pub const fn len_utf16(self) -> usize {
              len_utf16(self as u32)
          }
      *)
      Definition len_utf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::char::methods::len_utf16", [], [] |),
              [ M.cast (Ty.path "u32") (M.read (| self |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_len_utf16 :
        M.IsAssociatedFunction.C Self "len_utf16" len_utf16.
      Admitted.
      Global Typeclasses Opaque len_utf16.
      
      (*
          pub const fn encode_utf8(self, dst: &mut [u8]) -> &mut str {
              // SAFETY: `char` is not a surrogate, so this is valid UTF-8.
              unsafe { from_utf8_unchecked_mut(encode_utf8_raw(self as u32, dst)) }
          }
      *)
      Definition encode_utf8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; dst ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dst := M.alloc (| dst |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&mut") [] [ Ty.path "str" ],
                          M.get_function (|
                            "core::str::converts::from_utf8_unchecked_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_function (|
                                    "core::char::methods::encode_utf8_raw",
                                    [],
                                    []
                                  |),
                                  [
                                    M.cast (Ty.path "u32") (M.read (| self |));
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| dst |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_encode_utf8 :
        M.IsAssociatedFunction.C Self "encode_utf8" encode_utf8.
      Admitted.
      Global Typeclasses Opaque encode_utf8.
      
      (*
          pub const fn encode_utf16(self, dst: &mut [u16]) -> &mut [u16] {
              encode_utf16_raw(self as u32, dst)
          }
      *)
      Definition encode_utf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; dst ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let dst := M.alloc (| dst |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ] ],
                      M.get_function (| "core::char::methods::encode_utf16_raw", [], [] |),
                      [
                        M.cast (Ty.path "u32") (M.read (| self |));
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_encode_utf16 :
        M.IsAssociatedFunction.C Self "encode_utf16" encode_utf16.
      Admitted.
      Global Typeclasses Opaque encode_utf16.
      
      (*
          pub fn is_alphabetic(self) -> bool {
              match self {
                  'a'..='z' | 'A'..='Z' => true,
                  c => c > '\x7f' && unicode::Alphabetic(c),
              }
          }
      *)
      Definition is_alphabetic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (Ty.tuple []) (|
                        γ,
                        [
                          fun γ => ltac:(M.monadic (Value.Tuple []));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let c := M.copy (| γ |) in
                      M.alloc (|
                        LogicalOp.and (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [ M.read (| c |); Value.UnicodeChar 127 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::unicode::unicode_data::alphabetic::lookup",
                                [],
                                []
                              |),
                              [ M.read (| c |) ]
                            |)))
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_alphabetic :
        M.IsAssociatedFunction.C Self "is_alphabetic" is_alphabetic.
      Admitted.
      Global Typeclasses Opaque is_alphabetic.
      
      (*
          pub const fn is_lowercase(self) -> bool {
              match self {
                  'a'..='z' => true,
                  c => c > '\x7f' && unicode::Lowercase(c),
              }
          }
      *)
      Definition is_lowercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                self,
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let c := M.copy (| γ |) in
                      M.alloc (|
                        LogicalOp.and (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [ M.read (| c |); Value.UnicodeChar 127 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::unicode::unicode_data::lowercase::lookup",
                                [],
                                []
                              |),
                              [ M.read (| c |) ]
                            |)))
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_lowercase :
        M.IsAssociatedFunction.C Self "is_lowercase" is_lowercase.
      Admitted.
      Global Typeclasses Opaque is_lowercase.
      
      (*
          pub const fn is_uppercase(self) -> bool {
              match self {
                  'A'..='Z' => true,
                  c => c > '\x7f' && unicode::Uppercase(c),
              }
          }
      *)
      Definition is_uppercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                self,
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let c := M.copy (| γ |) in
                      M.alloc (|
                        LogicalOp.and (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [ M.read (| c |); Value.UnicodeChar 127 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::unicode::unicode_data::uppercase::lookup",
                                [],
                                []
                              |),
                              [ M.read (| c |) ]
                            |)))
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_uppercase :
        M.IsAssociatedFunction.C Self "is_uppercase" is_uppercase.
      Admitted.
      Global Typeclasses Opaque is_uppercase.
      
      (*
          pub const fn is_whitespace(self) -> bool {
              match self {
                  ' ' | '\x09'..='\x0d' => true,
                  c => c > '\x7f' && unicode::White_Space(c),
              }
          }
      *)
      Definition is_whitespace (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (Ty.tuple []) (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 32
                                |) in
                              Value.Tuple []));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let c := M.copy (| γ |) in
                      M.alloc (|
                        LogicalOp.and (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [ M.read (| c |); Value.UnicodeChar 127 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              M.get_function (|
                                "core::unicode::unicode_data::white_space::lookup",
                                [],
                                []
                              |),
                              [ M.read (| c |) ]
                            |)))
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_whitespace :
        M.IsAssociatedFunction.C Self "is_whitespace" is_whitespace.
      Admitted.
      Global Typeclasses Opaque is_whitespace.
      
      (*
          pub fn is_alphanumeric(self) -> bool {
              self.is_alphabetic() || self.is_numeric()
          }
      *)
      Definition is_alphanumeric (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            LogicalOp.or (|
              M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (| Ty.path "char", "is_alphabetic", [], [] |),
                [ M.read (| self |) ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_associated_function (| Ty.path "char", "is_numeric", [], [] |),
                  [ M.read (| self |) ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_alphanumeric :
        M.IsAssociatedFunction.C Self "is_alphanumeric" is_alphanumeric.
      Admitted.
      Global Typeclasses Opaque is_alphanumeric.
      
      (*
          pub fn is_control(self) -> bool {
              unicode::Cc(self)
          }
      *)
      Definition is_control (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_function (| "core::unicode::unicode_data::cc::lookup", [], [] |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_control :
        M.IsAssociatedFunction.C Self "is_control" is_control.
      Admitted.
      Global Typeclasses Opaque is_control.
      
      (*
          pub(crate) fn is_grapheme_extended(self) -> bool {
              unicode::Grapheme_Extend(self)
          }
      *)
      Definition is_grapheme_extended (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              M.get_function (| "core::unicode::unicode_data::grapheme_extend::lookup", [], [] |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_grapheme_extended :
        M.IsAssociatedFunction.C Self "is_grapheme_extended" is_grapheme_extended.
      Admitted.
      Global Typeclasses Opaque is_grapheme_extended.
      
      (*
          pub fn is_numeric(self) -> bool {
              match self {
                  '0'..='9' => true,
                  c => c > '\x7f' && unicode::N(c),
              }
          }
      *)
      Definition is_numeric (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                self,
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let c := M.copy (| γ |) in
                      M.alloc (|
                        LogicalOp.and (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [ M.read (| c |); Value.UnicodeChar 127 ]
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              M.get_function (| "core::unicode::unicode_data::n::lookup", [], [] |),
                              [ M.read (| c |) ]
                            |)))
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_numeric :
        M.IsAssociatedFunction.C Self "is_numeric" is_numeric.
      Admitted.
      Global Typeclasses Opaque is_numeric.
      
      (*
          pub fn to_lowercase(self) -> ToLowercase {
              ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))
          }
      *)
      Definition to_lowercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::char::ToLowercase"
              [
                M.call_closure (|
                  Ty.path "core::char::CaseMappingIter",
                  M.get_associated_function (|
                    Ty.path "core::char::CaseMappingIter",
                    "new",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 3 ]
                        [ Ty.path "char" ],
                      M.get_function (|
                        "core::unicode::unicode_data::conversions::to_lower",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_lowercase :
        M.IsAssociatedFunction.C Self "to_lowercase" to_lowercase.
      Admitted.
      Global Typeclasses Opaque to_lowercase.
      
      (*
          pub fn to_uppercase(self) -> ToUppercase {
              ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))
          }
      *)
      Definition to_uppercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple
              "core::char::ToUppercase"
              [
                M.call_closure (|
                  Ty.path "core::char::CaseMappingIter",
                  M.get_associated_function (|
                    Ty.path "core::char::CaseMappingIter",
                    "new",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 3 ]
                        [ Ty.path "char" ],
                      M.get_function (|
                        "core::unicode::unicode_data::conversions::to_upper",
                        [],
                        []
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_uppercase :
        M.IsAssociatedFunction.C Self "to_uppercase" to_uppercase.
      Admitted.
      Global Typeclasses Opaque to_uppercase.
      
      (*
          pub const fn is_ascii(&self) -> bool {
              *self as u32 <= 0x7F
          }
      *)
      Definition is_ascii (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.le,
              [
                M.cast (Ty.path "u32") (M.read (| M.deref (| M.read (| self |) |) |));
                Value.Integer IntegerKind.U32 127
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii :
        M.IsAssociatedFunction.C Self "is_ascii" is_ascii.
      Admitted.
      Global Typeclasses Opaque is_ascii.
      
      (*
          pub const fn as_ascii(&self) -> Option<ascii::Char> {
              if self.is_ascii() {
                  // SAFETY: Just checked that this is ASCII.
                  Some(unsafe { ascii::Char::from_u8_unchecked( *self as u8) })
              } else {
                  None
              }
          }
      *)
      Definition as_ascii (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (| Ty.path "char", "is_ascii", [], [] |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              Ty.path "core::ascii::ascii_char::AsciiChar",
                              M.get_associated_function (|
                                Ty.path "core::ascii::ascii_char::AsciiChar",
                                "from_u8_unchecked",
                                [],
                                []
                              |),
                              [ M.cast (Ty.path "u8") (M.read (| M.deref (| M.read (| self |) |) |))
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_as_ascii :
        M.IsAssociatedFunction.C Self "as_ascii" as_ascii.
      Admitted.
      Global Typeclasses Opaque as_ascii.
      
      (*
          pub const fn to_ascii_uppercase(&self) -> char {
              if self.is_ascii_lowercase() {
                  ( *self as u8).ascii_change_case_unchecked() as char
              } else {
                  *self
              }
          }
      *)
      Definition to_ascii_uppercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "char" ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.path "char",
                                "is_ascii_lowercase",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.cast
                          (Ty.path "char")
                          (M.call_closure (|
                            Ty.path "u8",
                            M.get_associated_function (|
                              Ty.path "u8",
                              "ascii_change_case_unchecked",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.cast
                                    (Ty.path "u8")
                                    (M.read (| M.deref (| M.read (| self |) |) |))
                                |)
                              |)
                            ]
                          |))
                      |)));
                  fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_ascii_uppercase :
        M.IsAssociatedFunction.C Self "to_ascii_uppercase" to_ascii_uppercase.
      Admitted.
      Global Typeclasses Opaque to_ascii_uppercase.
      
      (*
          pub const fn to_ascii_lowercase(&self) -> char {
              if self.is_ascii_uppercase() {
                  ( *self as u8).ascii_change_case_unchecked() as char
              } else {
                  *self
              }
          }
      *)
      Definition to_ascii_lowercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "char" ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.path "char",
                                "is_ascii_uppercase",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.cast
                          (Ty.path "char")
                          (M.call_closure (|
                            Ty.path "u8",
                            M.get_associated_function (|
                              Ty.path "u8",
                              "ascii_change_case_unchecked",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.cast
                                    (Ty.path "u8")
                                    (M.read (| M.deref (| M.read (| self |) |) |))
                                |)
                              |)
                            ]
                          |))
                      |)));
                  fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_ascii_lowercase :
        M.IsAssociatedFunction.C Self "to_ascii_lowercase" to_ascii_lowercase.
      Admitted.
      Global Typeclasses Opaque to_ascii_lowercase.
      
      (*
          pub const fn eq_ignore_ascii_case(&self, other: &char) -> bool {
              self.to_ascii_lowercase() == other.to_ascii_lowercase()
          }
      *)
      Definition eq_ignore_ascii_case (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [
                M.call_closure (|
                  Ty.path "char",
                  M.get_associated_function (| Ty.path "char", "to_ascii_lowercase", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |);
                M.call_closure (|
                  Ty.path "char",
                  M.get_associated_function (| Ty.path "char", "to_ascii_lowercase", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_eq_ignore_ascii_case :
        M.IsAssociatedFunction.C Self "eq_ignore_ascii_case" eq_ignore_ascii_case.
      Admitted.
      Global Typeclasses Opaque eq_ignore_ascii_case.
      
      (*
          pub const fn make_ascii_uppercase(&mut self) {
              *self = self.to_ascii_uppercase();
          }
      *)
      Definition make_ascii_uppercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.path "char",
                      M.get_associated_function (| Ty.path "char", "to_ascii_uppercase", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_make_ascii_uppercase :
        M.IsAssociatedFunction.C Self "make_ascii_uppercase" make_ascii_uppercase.
      Admitted.
      Global Typeclasses Opaque make_ascii_uppercase.
      
      (*
          pub const fn make_ascii_lowercase(&mut self) {
              *self = self.to_ascii_lowercase();
          }
      *)
      Definition make_ascii_lowercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                M.alloc (|
                  M.write (|
                    M.deref (| M.read (| self |) |),
                    M.call_closure (|
                      Ty.path "char",
                      M.get_associated_function (| Ty.path "char", "to_ascii_lowercase", [], [] |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_make_ascii_lowercase :
        M.IsAssociatedFunction.C Self "make_ascii_lowercase" make_ascii_lowercase.
      Admitted.
      Global Typeclasses Opaque make_ascii_lowercase.
      
      (*
          pub const fn is_ascii_alphabetic(&self) -> bool {
              matches!( *self, 'A'..='Z' | 'a'..='z')
          }
      *)
      Definition is_ascii_alphabetic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (Ty.tuple []) (|
                        γ,
                        [
                          fun γ => ltac:(M.monadic (Value.Tuple []));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_alphabetic :
        M.IsAssociatedFunction.C Self "is_ascii_alphabetic" is_ascii_alphabetic.
      Admitted.
      Global Typeclasses Opaque is_ascii_alphabetic.
      
      (*
          pub const fn is_ascii_uppercase(&self) -> bool {
              matches!( *self, 'A'..='Z')
          }
      *)
      Definition is_ascii_uppercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_uppercase :
        M.IsAssociatedFunction.C Self "is_ascii_uppercase" is_ascii_uppercase.
      Admitted.
      Global Typeclasses Opaque is_ascii_uppercase.
      
      (*
          pub const fn is_ascii_lowercase(&self) -> bool {
              matches!( *self, 'a'..='z')
          }
      *)
      Definition is_ascii_lowercase (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_lowercase :
        M.IsAssociatedFunction.C Self "is_ascii_lowercase" is_ascii_lowercase.
      Admitted.
      Global Typeclasses Opaque is_ascii_lowercase.
      
      (*
          pub const fn is_ascii_alphanumeric(&self) -> bool {
              matches!( *self, '0'..='9') | matches!( *self, 'A'..='Z') | matches!( *self, 'a'..='z')
          }
      *)
      Definition is_ascii_alphanumeric (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.Wrap.bit_or,
              [
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                        M.deref (| M.read (| self |) |),
                        [
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                        ]
                      |)
                    |);
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                        M.deref (| M.read (| self |) |),
                        [
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                        ]
                      |)
                    |)
                  ]
                |);
                M.read (|
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                    M.deref (| M.read (| self |) |),
                    [
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_alphanumeric :
        M.IsAssociatedFunction.C Self "is_ascii_alphanumeric" is_ascii_alphanumeric.
      Admitted.
      Global Typeclasses Opaque is_ascii_alphanumeric.
      
      (*
          pub const fn is_ascii_digit(&self) -> bool {
              matches!( *self, '0'..='9')
          }
      *)
      Definition is_ascii_digit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_digit :
        M.IsAssociatedFunction.C Self "is_ascii_digit" is_ascii_digit.
      Admitted.
      Global Typeclasses Opaque is_ascii_digit.
      
      (*
          pub const fn is_ascii_octdigit(&self) -> bool {
              matches!( *self, '0'..='7')
          }
      *)
      Definition is_ascii_octdigit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_octdigit :
        M.IsAssociatedFunction.C Self "is_ascii_octdigit" is_ascii_octdigit.
      Admitted.
      Global Typeclasses Opaque is_ascii_octdigit.
      
      (*
          pub const fn is_ascii_hexdigit(&self) -> bool {
              matches!( *self, '0'..='9') | matches!( *self, 'A'..='F') | matches!( *self, 'a'..='f')
          }
      *)
      Definition is_ascii_hexdigit (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.Wrap.bit_or,
              [
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.Wrap.bit_or,
                  [
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                        M.deref (| M.read (| self |) |),
                        [
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                        ]
                      |)
                    |);
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                        M.deref (| M.read (| self |) |),
                        [
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                        ]
                      |)
                    |)
                  ]
                |);
                M.read (|
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                    M.deref (| M.read (| self |) |),
                    [
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_hexdigit :
        M.IsAssociatedFunction.C Self "is_ascii_hexdigit" is_ascii_hexdigit.
      Admitted.
      Global Typeclasses Opaque is_ascii_hexdigit.
      
      (*
          pub const fn is_ascii_punctuation(&self) -> bool {
              matches!( *self, '!'..='/')
                  | matches!( *self, ':'..='@')
                  | matches!( *self, '['..='`')
                  | matches!( *self, '{'..='~')
          }
      *)
      Definition is_ascii_punctuation (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.Wrap.bit_or,
              [
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.Wrap.bit_or,
                  [
                    M.call_closure (|
                      Ty.path "bool",
                      BinOp.Wrap.bit_or,
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                            M.deref (| M.read (| self |) |),
                            [
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                            ]
                          |)
                        |);
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                            M.deref (| M.read (| self |) |),
                            [
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                            ]
                          |)
                        |)
                      ]
                    |);
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                        M.deref (| M.read (| self |) |),
                        [
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                        ]
                      |)
                    |)
                  ]
                |);
                M.read (|
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                    M.deref (| M.read (| self |) |),
                    [
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                    ]
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_punctuation :
        M.IsAssociatedFunction.C Self "is_ascii_punctuation" is_ascii_punctuation.
      Admitted.
      Global Typeclasses Opaque is_ascii_punctuation.
      
      (*
          pub const fn is_ascii_graphic(&self) -> bool {
              matches!( *self, '!'..='~')
          }
      *)
      Definition is_ascii_graphic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_graphic :
        M.IsAssociatedFunction.C Self "is_ascii_graphic" is_ascii_graphic.
      Admitted.
      Global Typeclasses Opaque is_ascii_graphic.
      
      (*
          pub const fn is_ascii_whitespace(&self) -> bool {
              matches!( *self, '\t' | '\n' | '\x0C' | '\r' | ' ')
          }
      *)
      Definition is_ascii_whitespace (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (Ty.tuple []) (|
                        γ,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 9
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 10
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 12
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 13
                                |) in
                              Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 32
                                |) in
                              Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_whitespace :
        M.IsAssociatedFunction.C Self "is_ascii_whitespace" is_ascii_whitespace.
      Admitted.
      Global Typeclasses Opaque is_ascii_whitespace.
      
      (*
          pub const fn is_ascii_control(&self) -> bool {
              matches!( *self, '\0'..='\x1F' | '\x7F')
          }
      *)
      Definition is_ascii_control (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.find_or_pattern (Ty.tuple []) (|
                        γ,
                        [
                          fun γ => ltac:(M.monadic (Value.Tuple []));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ :=
                                is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.UnicodeChar 127
                                |) in
                              Value.Tuple []))
                        ],
                        fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                            | _ => M.impossible "wrong number of arguments"
                            end)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_ascii_control :
        M.IsAssociatedFunction.C Self "is_ascii_control" is_ascii_control.
      Admitted.
      Global Typeclasses Opaque is_ascii_control.
    End Impl_char.
    
    (* StructRecord
      {
        name := "EscapeDebugExtArgs";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("escape_grapheme_extended", Ty.path "bool");
            ("escape_single_quote", Ty.path "bool");
            ("escape_double_quote", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_char_methods_EscapeDebugExtArgs.
      Definition Self : Ty.t := Ty.path "core::char::methods::EscapeDebugExtArgs".
      
      (*
          pub(crate) const ESCAPE_ALL: Self = Self {
              escape_grapheme_extended: true,
              escape_single_quote: true,
              escape_double_quote: true,
          };
      *)
      (* Ty.path "core::char::methods::EscapeDebugExtArgs" *)
      Definition value_ESCAPE_ALL (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructRecord
              "core::char::methods::EscapeDebugExtArgs"
              [
                ("escape_grapheme_extended", Value.Bool true);
                ("escape_single_quote", Value.Bool true);
                ("escape_double_quote", Value.Bool true)
              ]
          |))).
      
      Global Instance AssociatedConstant_value_ESCAPE_ALL :
        M.IsAssociatedFunction.C Self "ESCAPE_ALL" value_ESCAPE_ALL.
      Admitted.
      Global Typeclasses Opaque value_ESCAPE_ALL.
    End Impl_core_char_methods_EscapeDebugExtArgs.
    
    (*
    const fn len_utf8(code: u32) -> usize {
        match code {
            ..MAX_ONE_B => 1,
            ..MAX_TWO_B => 2,
            ..MAX_THREE_B => 3,
            _ => 4,
        }
    }
    *)
    Definition len_utf8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ code ] =>
        ltac:(M.monadic
          (let code := M.alloc (| code |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
              code,
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 1 |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 2 |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 3 |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 4 |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_len_utf8 :
      M.IsFunction.C "core::char::methods::len_utf8" len_utf8.
    Admitted.
    Global Typeclasses Opaque len_utf8.
    
    (*
    const fn len_utf16(code: u32) -> usize {
        if (code & 0xFFFF) == code { 1 } else { 2 }
    }
    *)
    Definition len_utf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ code ] =>
        ltac:(M.monadic
          (let code := M.alloc (| code |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.eq,
                            [
                              M.call_closure (|
                                Ty.path "u32",
                                BinOp.Wrap.bit_and,
                                [ M.read (| code |); Value.Integer IntegerKind.U32 65535 ]
                              |);
                              M.read (| code |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (| Value.Integer IntegerKind.Usize 1 |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 2 |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_len_utf16 :
      M.IsFunction.C "core::char::methods::len_utf16" len_utf16.
    Admitted.
    Global Typeclasses Opaque len_utf16.
    
    (*
    pub const fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> &mut [u8] {
        let len = len_utf8(code);
        match (len, &mut *dst) {
            (1, [a, ..]) => {
                *a = code as u8;
            }
            (2, [a, b, ..]) => {
                *a = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;
                *b = (code & 0x3F) as u8 | TAG_CONT;
            }
            (3, [a, b, c, ..]) => {
                *a = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;
                *b = (code >> 6 & 0x3F) as u8 | TAG_CONT;
                *c = (code & 0x3F) as u8 | TAG_CONT;
            }
            (4, [a, b, c, d, ..]) => {
                *a = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;
                *b = (code >> 12 & 0x3F) as u8 | TAG_CONT;
                *c = (code >> 6 & 0x3F) as u8 | TAG_CONT;
                *d = (code & 0x3F) as u8 | TAG_CONT;
            }
            _ => {
                const_panic!(
                    "encode_utf8: buffer does not have enough bytes to encode code point",
                    "encode_utf8: need {len} bytes to encode U+{code:04X} but buffer has just {dst_len}",
                    code: u32 = code,
                    len: usize = len,
                    dst_len: usize = dst.len(),
                )
            }
        };
        // SAFETY: `<&mut [u8]>::as_mut_ptr` is guaranteed to return a valid pointer and `len` has been tested to be within bounds.
        unsafe { slice::from_raw_parts_mut(dst.as_mut_ptr(), len) }
    }
    *)
    Definition encode_utf8_raw (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ code; dst ] =>
        ltac:(M.monadic
          (let code := M.alloc (| code |) in
          let dst := M.alloc (| dst |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_function (| "core::char::methods::len_utf8", [], [] |),
                      [ M.read (| code |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| len |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Integer IntegerKind.Usize 1
                            |) in
                          let γ0_1 := M.read (| γ0_1 |) in
                          let γ2_0 := M.SubPointer.get_slice_index (| γ0_1, 0 |) in
                          let γ2_rest := M.SubPointer.get_slice_rest (| γ0_1, 1, 0 |) in
                          let a := M.alloc (| γ2_0 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| a |) |),
                                M.cast (Ty.path "u8") (M.read (| code |))
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Integer IntegerKind.Usize 2
                            |) in
                          let γ0_1 := M.read (| γ0_1 |) in
                          let γ2_0 := M.SubPointer.get_slice_index (| γ0_1, 0 |) in
                          let γ2_1 := M.SubPointer.get_slice_index (| γ0_1, 1 |) in
                          let γ2_rest := M.SubPointer.get_slice_rest (| γ0_1, 2, 0 |) in
                          let a := M.alloc (| γ2_0 |) in
                          let b := M.alloc (| γ2_1 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| a |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.call_closure (|
                                            Ty.path "u32",
                                            BinOp.Wrap.shr,
                                            [ M.read (| code |); Value.Integer IntegerKind.I32 6 ]
                                          |);
                                          Value.Integer IntegerKind.U32 31
                                        ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_TWO_B", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| b |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [ M.read (| code |); Value.Integer IntegerKind.U32 63 ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_CONT", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Integer IntegerKind.Usize 3
                            |) in
                          let γ0_1 := M.read (| γ0_1 |) in
                          let γ2_0 := M.SubPointer.get_slice_index (| γ0_1, 0 |) in
                          let γ2_1 := M.SubPointer.get_slice_index (| γ0_1, 1 |) in
                          let γ2_2 := M.SubPointer.get_slice_index (| γ0_1, 2 |) in
                          let γ2_rest := M.SubPointer.get_slice_rest (| γ0_1, 3, 0 |) in
                          let a := M.alloc (| γ2_0 |) in
                          let b := M.alloc (| γ2_1 |) in
                          let c := M.alloc (| γ2_2 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| a |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.call_closure (|
                                            Ty.path "u32",
                                            BinOp.Wrap.shr,
                                            [ M.read (| code |); Value.Integer IntegerKind.I32 12 ]
                                          |);
                                          Value.Integer IntegerKind.U32 15
                                        ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_THREE_B", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| b |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.call_closure (|
                                            Ty.path "u32",
                                            BinOp.Wrap.shr,
                                            [ M.read (| code |); Value.Integer IntegerKind.I32 6 ]
                                          |);
                                          Value.Integer IntegerKind.U32 63
                                        ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_CONT", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| c |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [ M.read (| code |); Value.Integer IntegerKind.U32 63 ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_CONT", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Integer IntegerKind.Usize 4
                            |) in
                          let γ0_1 := M.read (| γ0_1 |) in
                          let γ2_0 := M.SubPointer.get_slice_index (| γ0_1, 0 |) in
                          let γ2_1 := M.SubPointer.get_slice_index (| γ0_1, 1 |) in
                          let γ2_2 := M.SubPointer.get_slice_index (| γ0_1, 2 |) in
                          let γ2_3 := M.SubPointer.get_slice_index (| γ0_1, 3 |) in
                          let γ2_rest := M.SubPointer.get_slice_rest (| γ0_1, 4, 0 |) in
                          let a := M.alloc (| γ2_0 |) in
                          let b := M.alloc (| γ2_1 |) in
                          let c := M.alloc (| γ2_2 |) in
                          let d := M.alloc (| γ2_3 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| a |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.call_closure (|
                                            Ty.path "u32",
                                            BinOp.Wrap.shr,
                                            [ M.read (| code |); Value.Integer IntegerKind.I32 18 ]
                                          |);
                                          Value.Integer IntegerKind.U32 7
                                        ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_FOUR_B", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| b |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.call_closure (|
                                            Ty.path "u32",
                                            BinOp.Wrap.shr,
                                            [ M.read (| code |); Value.Integer IntegerKind.I32 12 ]
                                          |);
                                          Value.Integer IntegerKind.U32 63
                                        ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_CONT", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| c |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.call_closure (|
                                            Ty.path "u32",
                                            BinOp.Wrap.shr,
                                            [ M.read (| code |); Value.Integer IntegerKind.I32 6 ]
                                          |);
                                          Value.Integer IntegerKind.U32 63
                                        ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_CONT", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| d |) |),
                                M.call_closure (|
                                  Ty.path "u8",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u8")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [ M.read (| code |); Value.Integer IntegerKind.U32 63 ]
                                      |));
                                    M.read (|
                                      get_constant (| "core::char::TAG_CONT", Ty.path "u8" |)
                                    |)
                                  ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (|
                                  "core::char::methods::encode_utf8_raw.do_panic",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| code |);
                                  M.read (| len |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| dst |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)))
                    ]
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            M.get_function (|
                              "core::slice::raw::from_raw_parts_mut",
                              [],
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "as_mut_ptr",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |)
                                ]
                              |);
                              M.read (| len |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_encode_utf8_raw :
      M.IsFunction.C "core::char::methods::encode_utf8_raw" encode_utf8_raw.
    Admitted.
    Global Typeclasses Opaque encode_utf8_raw.
    
    (*
    pub const fn encode_utf16_raw(mut code: u32, dst: &mut [u16]) -> &mut [u16] {
        let len = len_utf16(code);
        match (len, &mut *dst) {
            (1, [a, ..]) => {
                *a = code as u16;
            }
            (2, [a, b, ..]) => {
                code -= 0x1_0000;
                *a = (code >> 10) as u16 | 0xD800;
                *b = (code & 0x3FF) as u16 | 0xDC00;
            }
            _ => {
                const_panic!(
                    "encode_utf16: buffer does not have enough bytes to encode code point",
                    "encode_utf16: need {len} bytes to encode U+{code:04X} but buffer has just {dst_len}",
                    code: u32 = code,
                    len: usize = len,
                    dst_len: usize = dst.len(),
                )
            }
        };
        // SAFETY: `<&mut [u16]>::as_mut_ptr` is guaranteed to return a valid pointer and `len` has been tested to be within bounds.
        unsafe { slice::from_raw_parts_mut(dst.as_mut_ptr(), len) }
    }
    *)
    Definition encode_utf16_raw (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ code; dst ] =>
        ltac:(M.monadic
          (let code := M.alloc (| code |) in
          let dst := M.alloc (| dst |) in
          M.borrow (|
            Pointer.Kind.MutRef,
            M.deref (|
              M.read (|
                let~ len : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_function (| "core::char::methods::len_utf16", [], [] |),
                      [ M.read (| code |) ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (|
                      Value.Tuple
                        [
                          M.read (| len |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Integer IntegerKind.Usize 1
                            |) in
                          let γ0_1 := M.read (| γ0_1 |) in
                          let γ2_0 := M.SubPointer.get_slice_index (| γ0_1, 0 |) in
                          let γ2_rest := M.SubPointer.get_slice_rest (| γ0_1, 1, 0 |) in
                          let a := M.alloc (| γ2_0 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| a |) |),
                                M.cast (Ty.path "u16") (M.read (| code |))
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let _ :=
                            is_constant_or_break_match (|
                              M.read (| γ0_0 |),
                              Value.Integer IntegerKind.Usize 2
                            |) in
                          let γ0_1 := M.read (| γ0_1 |) in
                          let γ2_0 := M.SubPointer.get_slice_index (| γ0_1, 0 |) in
                          let γ2_1 := M.SubPointer.get_slice_index (| γ0_1, 1 |) in
                          let γ2_rest := M.SubPointer.get_slice_rest (| γ0_1, 2, 0 |) in
                          let a := M.alloc (| γ2_0 |) in
                          let b := M.alloc (| γ2_1 |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              let β := code in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "u32",
                                  BinOp.Wrap.sub,
                                  [ M.read (| β |); Value.Integer IntegerKind.U32 65536 ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| a |) |),
                                M.call_closure (|
                                  Ty.path "u16",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u16")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.shr,
                                        [ M.read (| code |); Value.Integer IntegerKind.I32 10 ]
                                      |));
                                    Value.Integer IntegerKind.U16 55296
                                  ]
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                M.deref (| M.read (| b |) |),
                                M.call_closure (|
                                  Ty.path "u16",
                                  BinOp.Wrap.bit_or,
                                  [
                                    M.cast
                                      (Ty.path "u16")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [ M.read (| code |); Value.Integer IntegerKind.U32 1023 ]
                                      |));
                                    Value.Integer IntegerKind.U16 56320
                                  ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (|
                                  "core::char::methods::encode_utf16_raw.do_panic",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| code |);
                                  M.read (| len |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| dst |) |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)))
                    ]
                  |) in
                M.alloc (|
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ] ],
                            M.get_function (|
                              "core::slice::raw::from_raw_parts_mut",
                              [],
                              [ Ty.path "u16" ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*mut") [] [ Ty.path "u16" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ],
                                  "as_mut_ptr",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dst |) |) |)
                                ]
                              |);
                              M.read (| len |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_encode_utf16_raw :
      M.IsFunction.C "core::char::methods::encode_utf16_raw" encode_utf16_raw.
    Admitted.
    Global Typeclasses Opaque encode_utf16_raw.
  End methods.
End char.
