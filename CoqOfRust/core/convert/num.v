(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module convert.
  Module num.
    Module private.
      (* Trait *)
      (* Empty module 'Sealed' *)
    End private.
    
    (* Trait *)
    (* Empty module 'FloatToInt' *)
    
    Module Impl_core_convert_num_private_Sealed_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::private::Sealed"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_convert_num_private_Sealed_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_u8_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "u8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u8_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_u16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "u16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u16_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_u32_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "u32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u32_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_u64_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "u64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u64_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_u128_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "u128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u128_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_usize_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "usize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_usize_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_i8_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "i8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i8_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_i16_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "i16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i16_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_i32_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "i32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i32_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_i64_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "i64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i64_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_i128_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "i128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i128_for_f16.
    
    Module Impl_core_convert_num_FloatToInt_isize_for_f16.
      Definition Self : Ty.t := Ty.path "f16".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f16"; Ty.path "isize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_isize_for_f16.
    
    Module Impl_core_convert_num_private_Sealed_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::private::Sealed"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_convert_num_private_Sealed_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_u8_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "u8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u8_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_u16_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "u16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u16_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_u32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "u32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u32_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_u64_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "u64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u64_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_u128_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "u128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u128_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_usize_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "usize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_usize_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_i8_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "i8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i8_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_i16_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "i16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i16_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_i32_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "i32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i32_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_i64_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "i64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i64_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_i128_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "i128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i128_for_f32.
    
    Module Impl_core_convert_num_FloatToInt_isize_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f32"; Ty.path "isize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_isize_for_f32.
    
    Module Impl_core_convert_num_private_Sealed_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::private::Sealed"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_convert_num_private_Sealed_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_u8_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "u8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u8_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_u16_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "u16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u16_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_u32_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "u32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u32_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_u64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "u64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u64_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_u128_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "u128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u128_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_usize_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "usize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_usize_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_i8_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "i8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i8_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_i16_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "i16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i16_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_i32_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "i32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i32_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_i64_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "i64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i64_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_i128_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "i128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i128_for_f64.
    
    Module Impl_core_convert_num_FloatToInt_isize_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f64"; Ty.path "isize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_isize_for_f64.
    
    Module Impl_core_convert_num_private_Sealed_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::private::Sealed"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_convert_num_private_Sealed_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_u8_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "u8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u8_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_u16_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "u16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u16_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_u32_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "u32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u32_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_u64_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "u64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u64_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_u128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "u128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "u128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_u128_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_usize_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "usize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_usize_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_i8_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "i8" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i8_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_i16_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "i16" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i16_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_i32_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "i32" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i32_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_i64_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "i64" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i64_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_i128_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "i128",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "i128" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_i128_for_f128.
    
    Module Impl_core_convert_num_FloatToInt_isize_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                      unsafe fn to_int_unchecked(self) -> $Int {
                          // SAFETY: the safety contract must be upheld by the caller.
                          unsafe { crate::intrinsics::float_to_int_unchecked(self) }
                      }
      *)
      Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_function (|
                "core::intrinsics::float_to_int_unchecked",
                [],
                [ Ty.path "f128"; Ty.path "isize" ]
              |),
              [ M.read (| self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::num::FloatToInt"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *) [ ("to_int_unchecked", InstanceField.Method to_int_unchecked) ].
    End Impl_core_convert_num_FloatToInt_isize_for_f128.
    
    Module Impl_core_convert_From_bool_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u8") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_u8.
    
    Module Impl_core_convert_From_bool_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u16") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_u16.
    
    Module Impl_core_convert_From_bool_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_u32.
    
    Module Impl_core_convert_From_bool_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_u64.
    
    Module Impl_core_convert_From_bool_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_u128.
    
    Module Impl_core_convert_From_bool_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "usize") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_usize.
    
    Module Impl_core_convert_From_bool_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i8") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_i8.
    
    Module Impl_core_convert_From_bool_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i16") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_i16.
    
    Module Impl_core_convert_From_bool_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_i32.
    
    Module Impl_core_convert_From_bool_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_i64.
    
    Module Impl_core_convert_From_bool_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_i128.
    
    Module Impl_core_convert_From_bool_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "isize") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_isize.
    
    Module Impl_core_convert_From_u8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u16") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_u16.
    
    Module Impl_core_convert_From_u8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_u32.
    
    Module Impl_core_convert_From_u8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_u64.
    
    Module Impl_core_convert_From_u8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_u128.
    
    Module Impl_core_convert_From_u8_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "usize") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_usize.
    
    Module Impl_core_convert_From_u16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_u32.
    
    Module Impl_core_convert_From_u16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_u64.
    
    Module Impl_core_convert_From_u16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_u128.
    
    Module Impl_core_convert_From_u32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_u64.
    
    Module Impl_core_convert_From_u32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_u128.
    
    Module Impl_core_convert_From_u64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "u128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u64_for_u128.
    
    Module Impl_core_convert_From_i8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i16") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_i16.
    
    Module Impl_core_convert_From_i8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_i32.
    
    Module Impl_core_convert_From_i8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_i64.
    
    Module Impl_core_convert_From_i8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_i128.
    
    Module Impl_core_convert_From_i8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "isize") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_isize.
    
    Module Impl_core_convert_From_i16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_i32.
    
    Module Impl_core_convert_From_i16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_i64.
    
    Module Impl_core_convert_From_i16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_i128.
    
    Module Impl_core_convert_From_i32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i32_for_i64.
    
    Module Impl_core_convert_From_i32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i32_for_i128.
    
    Module Impl_core_convert_From_i64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i64_for_i128.
    
    Module Impl_core_convert_From_u8_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i16") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_i16.
    
    Module Impl_core_convert_From_u8_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_i32.
    
    Module Impl_core_convert_From_u8_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_i64.
    
    Module Impl_core_convert_From_u8_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_i128.
    
    Module Impl_core_convert_From_u16_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_i32.
    
    Module Impl_core_convert_From_u16_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_i64.
    
    Module Impl_core_convert_From_u16_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_i128.
    
    Module Impl_core_convert_From_u32_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_i64.
    
    Module Impl_core_convert_From_u32_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_i128.
    
    Module Impl_core_convert_From_u64_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "i128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u64_for_i128.
    
    Module Impl_core_convert_From_u16_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "usize") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_usize.
    
    Module Impl_core_convert_From_u8_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "isize") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_isize.
    
    Module Impl_core_convert_From_i16_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "isize") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_isize.
    
    Module Impl_core_convert_From_i8_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_f32.
    
    Module Impl_core_convert_From_i8_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i8_for_f64.
    
    Module Impl_core_convert_From_i16_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_f32.
    
    Module Impl_core_convert_From_i16_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i16_for_f64.
    
    Module Impl_core_convert_From_i32_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_i32_for_f64.
    
    Module Impl_core_convert_From_u8_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_f32.
    
    Module Impl_core_convert_From_u8_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u8_for_f64.
    
    Module Impl_core_convert_From_u16_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f32") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_f32.
    
    Module Impl_core_convert_From_u16_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u16_for_f64.
    
    Module Impl_core_convert_From_u32_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_u32_for_f64.
    
    Module Impl_core_convert_From_f16_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_f16_for_f64.
    
    Module Impl_core_convert_From_f16_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f16" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_f16_for_f128.
    
    Module Impl_core_convert_From_f32_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_f32_for_f64.
    
    Module Impl_core_convert_From_f32_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f32" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_f32_for_f128.
    
    Module Impl_core_convert_From_f64_for_f128.
      Definition Self : Ty.t := Ty.path "f128".
      
      (*
                  fn from(small: $Small) -> Self {
                      small as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f128") (M.read (| small |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "f64" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_f64_for_f128.
    
    Module Impl_core_convert_From_bool_for_f32.
      Definition Self : Ty.t := Ty.path "f32".
      
      (*
                  fn from(small: bool) -> Self {
                      small as u8 as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f32") (M.cast (Ty.path "u8") (M.read (| small |)))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_f32.
    
    Module Impl_core_convert_From_bool_for_f64.
      Definition Self : Ty.t := Ty.path "f64".
      
      (*
                  fn from(small: bool) -> Self {
                      small as u8 as Self
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.cast (Ty.path "f64") (M.cast (Ty.path "u8") (M.read (| small |)))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "bool" ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_bool_for_f64.
    
    Module Impl_core_convert_TryFrom_u16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u16")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u16_for_u8.
    
    Module Impl_core_convert_TryFrom_u32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u32")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u32_for_u8.
    
    Module Impl_core_convert_TryFrom_u32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u32")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "u16",
                                      "MAX",
                                      Ty.path "u16"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u32_for_u16.
    
    Module Impl_core_convert_TryFrom_u64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u64")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_u8.
    
    Module Impl_core_convert_TryFrom_u64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u64")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "u16",
                                      "MAX",
                                      Ty.path "u16"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_u16.
    
    Module Impl_core_convert_TryFrom_u64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u64")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "u32",
                                      "MAX",
                                      Ty.path "u32"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_u32.
    
    Module Impl_core_convert_TryFrom_u128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_u8.
    
    Module Impl_core_convert_TryFrom_u128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "u16",
                                      "MAX",
                                      Ty.path "u16"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_u16.
    
    Module Impl_core_convert_TryFrom_u128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "u32",
                                      "MAX",
                                      Ty.path "u32"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_u32.
    
    Module Impl_core_convert_TryFrom_u128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "u64",
                                      "MAX",
                                      Ty.path "u64"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u64") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_u64.
    
    Module Impl_core_convert_TryFrom_i16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i16" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i16")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MIN", Ty.path "i8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i16" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i16")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i16_for_i8.
    
    Module Impl_core_convert_TryFrom_i32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MIN", Ty.path "i8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_i8.
    
    Module Impl_core_convert_TryFrom_i32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "i16", "MIN", Ty.path "i16" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "i16", "MAX", Ty.path "i16" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_i16.
    
    Module Impl_core_convert_TryFrom_i64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MIN", Ty.path "i8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_i8.
    
    Module Impl_core_convert_TryFrom_i64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "i16", "MIN", Ty.path "i16" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "i16", "MAX", Ty.path "i16" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_i16.
    
    Module Impl_core_convert_TryFrom_i64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "i32", "MIN", Ty.path "i32" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "i32", "MAX", Ty.path "i32" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_i32.
    
    Module Impl_core_convert_TryFrom_i128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MIN", Ty.path "i8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_i8.
    
    Module Impl_core_convert_TryFrom_i128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i16", "MIN", Ty.path "i16" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i16", "MAX", Ty.path "i16" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_i16.
    
    Module Impl_core_convert_TryFrom_i128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i32", "MIN", Ty.path "i32" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i32", "MAX", Ty.path "i32" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_i32.
    
    Module Impl_core_convert_TryFrom_i128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i64", "MIN", Ty.path "i64" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "i64", "MAX", Ty.path "i64" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i64") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_i64.
    
    Module Impl_core_convert_TryFrom_u8_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u8")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u8_for_i8.
    
    Module Impl_core_convert_TryFrom_u16_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u16")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u16_for_i8.
    
    Module Impl_core_convert_TryFrom_u16_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u16")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i16",
                                      "MAX",
                                      Ty.path "i16"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u16_for_i16.
    
    Module Impl_core_convert_TryFrom_u32_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u32")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u32_for_i8.
    
    Module Impl_core_convert_TryFrom_u32_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u32")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i16",
                                      "MAX",
                                      Ty.path "i16"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u32_for_i16.
    
    Module Impl_core_convert_TryFrom_u32_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u32")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i32",
                                      "MAX",
                                      Ty.path "i32"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u32_for_i32.
    
    Module Impl_core_convert_TryFrom_u64_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u64")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_i8.
    
    Module Impl_core_convert_TryFrom_u64_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u64")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i16",
                                      "MAX",
                                      Ty.path "i16"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_i16.
    
    Module Impl_core_convert_TryFrom_u64_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u64")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i32",
                                      "MAX",
                                      Ty.path "i32"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_i32.
    
    Module Impl_core_convert_TryFrom_u64_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u64")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i64",
                                      "MAX",
                                      Ty.path "i64"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i64") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_i64.
    
    Module Impl_core_convert_TryFrom_u128_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_i8.
    
    Module Impl_core_convert_TryFrom_u128_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i16",
                                      "MAX",
                                      Ty.path "i16"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_i16.
    
    Module Impl_core_convert_TryFrom_u128_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i32",
                                      "MAX",
                                      Ty.path "i32"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_i32.
    
    Module Impl_core_convert_TryFrom_u128_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i64",
                                      "MAX",
                                      Ty.path "i64"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i64") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_i64.
    
    Module Impl_core_convert_TryFrom_u128_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "i128"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "u128")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "i128",
                                      "MAX",
                                      Ty.path "i128"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "i128") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_i128.
    
    Module Impl_core_convert_TryFrom_i8_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I8 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i8_for_u8.
    
    Module Impl_core_convert_TryFrom_i8_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I8 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i8_for_u16.
    
    Module Impl_core_convert_TryFrom_i8_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I8 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i8_for_u32.
    
    Module Impl_core_convert_TryFrom_i8_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I8 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u64") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i8_for_u64.
    
    Module Impl_core_convert_TryFrom_i8_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I8 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u128") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i8_for_u128.
    
    Module Impl_core_convert_TryFrom_i16_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i16" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i16")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MIN", Ty.path "u8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i16" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i16")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i16_for_u8.
    
    Module Impl_core_convert_TryFrom_i16_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I16 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i16_for_u16.
    
    Module Impl_core_convert_TryFrom_i16_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I16 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i16_for_u32.
    
    Module Impl_core_convert_TryFrom_i16_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I16 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u64") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i16_for_u64.
    
    Module Impl_core_convert_TryFrom_i16_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I16 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u128") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i16_for_u128.
    
    Module Impl_core_convert_TryFrom_i32_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MIN", Ty.path "u8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_u8.
    
    Module Impl_core_convert_TryFrom_i32_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "u16", "MIN", Ty.path "u16" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i32" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i32")
                    (M.read (| get_associated_constant (| Ty.path "u16", "MAX", Ty.path "u16" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_u16.
    
    Module Impl_core_convert_TryFrom_i32_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I32 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_u32.
    
    Module Impl_core_convert_TryFrom_i32_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I32 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u64") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_u64.
    
    Module Impl_core_convert_TryFrom_i32_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I32 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u128") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_u128.
    
    Module Impl_core_convert_TryFrom_i64_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MIN", Ty.path "u8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_u8.
    
    Module Impl_core_convert_TryFrom_i64_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "u16", "MIN", Ty.path "u16" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "u16", "MAX", Ty.path "u16" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_u16.
    
    Module Impl_core_convert_TryFrom_i64_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "u32", "MIN", Ty.path "u32" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i64" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i64")
                    (M.read (| get_associated_constant (| Ty.path "u32", "MAX", Ty.path "u32" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_u32.
    
    Module Impl_core_convert_TryFrom_i64_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I64 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u64") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_u64.
    
    Module Impl_core_convert_TryFrom_i64_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I64 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u128") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_u128.
    
    Module Impl_core_convert_TryFrom_i128_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MIN", Ty.path "u8" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_u8.
    
    Module Impl_core_convert_TryFrom_i128_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u16", "MIN", Ty.path "u16" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u16", "MAX", Ty.path "u16" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_u16.
    
    Module Impl_core_convert_TryFrom_i128_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u32", "MIN", Ty.path "u32" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u32", "MAX", Ty.path "u32" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_u32.
    
    Module Impl_core_convert_TryFrom_i128_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      let min = Self::MIN as $source;
                      let max = Self::MAX as $source;
                      if u < min || u > max {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u64", "MIN", Ty.path "u64" |) |))
                |) in
              let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                M.alloc (|
                  M.cast
                    (Ty.path "i128")
                    (M.read (| get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |) |))
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.or (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| u |); M.read (| min |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.gt,
                                  [ M.read (| u |); M.read (| max |) ]
                                |)))
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u64") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_u64.
    
    Module Impl_core_convert_TryFrom_i128_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.I128 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "u128") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_u128.
    
    Module Impl_core_convert_TryFrom_usize_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u > (Self::MAX as $source) {
                          Err(TryFromIntError(()))
                      } else {
                          Ok(u as Self)
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.gt,
                              [
                                M.read (| u |);
                                M.cast
                                  (Ty.path "usize")
                                  (M.read (|
                                    get_associated_constant (|
                                      Ty.path "isize",
                                      "MAX",
                                      Ty.path "isize"
                                    |)
                                  |))
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "isize") (M.read (| u |)) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_usize_for_isize.
    
    Module Impl_core_convert_TryFrom_isize_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(u: $source) -> Result<Self, Self::Error> {
                      if u >= 0 {
                          Ok(u as Self)
                      } else {
                          Err(TryFromIntError(()))
                      }
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                  ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.ge,
                              [ M.read (| u |); Value.Integer IntegerKind.Isize 0 ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Ok"
                          [ M.cast (Ty.path "usize") (M.read (| u |)) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.StructTuple
                          "core::result::Result::Err"
                          [ Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_isize_for_usize.
    
    Module ptr_try_from_impls.
      Module Impl_core_convert_TryFrom_usize_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "u8",
                                        "MAX",
                                        Ty.path "u8"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_u8.
      
      Module Impl_core_convert_TryFrom_usize_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "u16",
                                        "MAX",
                                        Ty.path "u16"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_u16.
      
      Module Impl_core_convert_TryFrom_usize_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "u32",
                                        "MAX",
                                        Ty.path "u32"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_u32.
      
      Module Impl_core_convert_TryFrom_usize_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "u64") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_u64.
      
      Module Impl_core_convert_TryFrom_usize_for_u128.
        Definition Self : Ty.t := Ty.path "u128".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "u128") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_u128.
      
      Module Impl_core_convert_TryFrom_usize_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "i8",
                                        "MAX",
                                        Ty.path "i8"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_i8.
      
      Module Impl_core_convert_TryFrom_usize_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "i16",
                                        "MAX",
                                        Ty.path "i16"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_i16.
      
      Module Impl_core_convert_TryFrom_usize_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "i32",
                                        "MAX",
                                        Ty.path "i32"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "i32") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_i32.
      
      Module Impl_core_convert_TryFrom_usize_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "i64",
                                        "MAX",
                                        Ty.path "i64"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "i64") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_i64.
      
      Module Impl_core_convert_TryFrom_usize_for_i128.
        Definition Self : Ty.t := Ty.path "i128".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "i128") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "usize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_usize_for_i128.
      
      Module Impl_core_convert_TryFrom_isize_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (| get_associated_constant (| Ty.path "u8", "MIN", Ty.path "u8" |) |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (| get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |) |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u8") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_u8.
      
      Module Impl_core_convert_TryFrom_isize_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "u16", "MIN", Ty.path "u16" |)
                      |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "u16", "MAX", Ty.path "u16" |)
                      |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u16") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_u16.
      
      Module Impl_core_convert_TryFrom_isize_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "u32", "MIN", Ty.path "u32" |)
                      |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "u32", "MAX", Ty.path "u32" |)
                      |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u32") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_u32.
      
      Module Impl_core_convert_TryFrom_isize_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u >= 0 {
                            Ok(u as Self)
                        } else {
                            Err(TryFromIntError(()))
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ge,
                                [ M.read (| u |); Value.Integer IntegerKind.Isize 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u64") (M.read (| u |)) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_u64.
      
      Module Impl_core_convert_TryFrom_isize_for_u128.
        Definition Self : Ty.t := Ty.path "u128".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u >= 0 {
                            Ok(u as Self)
                        } else {
                            Err(TryFromIntError(()))
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ge,
                                [ M.read (| u |); Value.Integer IntegerKind.Isize 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "u128") (M.read (| u |)) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_u128.
      
      Module Impl_core_convert_TryFrom_isize_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (| get_associated_constant (| Ty.path "i8", "MIN", Ty.path "i8" |) |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (| get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |) |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "i8") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_i8.
      
      Module Impl_core_convert_TryFrom_isize_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "i16", "MIN", Ty.path "i16" |)
                      |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "i16", "MAX", Ty.path "i16" |)
                      |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "i16") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_i16.
      
      Module Impl_core_convert_TryFrom_isize_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "i32", "MIN", Ty.path "i32" |)
                      |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "isize")
                      (M.read (|
                        get_associated_constant (| Ty.path "i32", "MAX", Ty.path "i32" |)
                      |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "i32") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_i32.
      
      Module Impl_core_convert_TryFrom_isize_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "i64") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_i64.
      
      Module Impl_core_convert_TryFrom_isize_for_i128.
        Definition Self : Ty.t := Ty.path "i128".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "i128") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "isize" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_isize_for_i128.
      
      Module Impl_core_convert_TryFrom_u32_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "usize") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "u32" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_u32_for_usize.
      
      Module Impl_core_convert_TryFrom_u64_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "usize") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "u64" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_u64_for_usize.
      
      Module Impl_core_convert_TryFrom_u128_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "u128")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "usize",
                                        "MAX",
                                        Ty.path "usize"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "usize") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "u128" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_u128_for_usize.
      
      Module Impl_core_convert_TryFrom_i8_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u >= 0 {
                            Ok(u as Self)
                        } else {
                            Err(TryFromIntError(()))
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ge,
                                [ M.read (| u |); Value.Integer IntegerKind.I8 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "usize") (M.read (| u |)) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i8" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i8_for_usize.
      
      Module Impl_core_convert_TryFrom_i16_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u >= 0 {
                            Ok(u as Self)
                        } else {
                            Err(TryFromIntError(()))
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ge,
                                [ M.read (| u |); Value.Integer IntegerKind.I16 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "usize") (M.read (| u |)) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i16" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i16_for_usize.
      
      Module Impl_core_convert_TryFrom_i32_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u >= 0 {
                            Ok(u as Self)
                        } else {
                            Err(TryFromIntError(()))
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ge,
                                [ M.read (| u |); Value.Integer IntegerKind.I32 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "usize") (M.read (| u |)) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i32" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i32_for_usize.
      
      Module Impl_core_convert_TryFrom_i64_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u >= 0 {
                            Ok(u as Self)
                        } else {
                            Err(TryFromIntError(()))
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ge,
                                [ M.read (| u |); Value.Integer IntegerKind.I64 0 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "usize") (M.read (| u |)) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i64" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i64_for_usize.
      
      Module Impl_core_convert_TryFrom_i128_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "i128")
                      (M.read (|
                        get_associated_constant (| Ty.path "usize", "MIN", Ty.path "usize" |)
                      |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "i128")
                      (M.read (|
                        get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)
                      |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "usize") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i128" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i128_for_usize.
      
      Module Impl_core_convert_TryFrom_u16_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "isize") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "u16" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_u16_for_isize.
      
      Module Impl_core_convert_TryFrom_u32_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "isize") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "u32" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_u32_for_isize.
      
      Module Impl_core_convert_TryFrom_u64_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "u64")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "isize",
                                        "MAX",
                                        Ty.path "isize"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "isize") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "u64" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_u64_for_isize.
      
      Module Impl_core_convert_TryFrom_u128_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        if u > (Self::MAX as $source) {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [
                                  M.read (| u |);
                                  M.cast
                                    (Ty.path "u128")
                                    (M.read (|
                                      get_associated_constant (|
                                        Ty.path "isize",
                                        "MAX",
                                        Ty.path "isize"
                                      |)
                                    |))
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "isize") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "u128" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_u128_for_isize.
      
      Module Impl_core_convert_TryFrom_i32_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "isize") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i32" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i32_for_isize.
      
      Module Impl_core_convert_TryFrom_i64_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(value: $source) -> Result<Self, Self::Error> {
                        Ok(value as Self)
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ value ] =>
            ltac:(M.monadic
              (let value := M.alloc (| value |) in
              Value.StructTuple
                "core::result::Result::Ok"
                [ M.cast (Ty.path "isize") (M.read (| value |)) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i64" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i64_for_isize.
      
      Module Impl_core_convert_TryFrom_i128_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*             type Error = TryFromIntError; *)
        Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
        
        (*
                    fn try_from(u: $source) -> Result<Self, Self::Error> {
                        let min = Self::MIN as $source;
                        let max = Self::MAX as $source;
                        if u < min || u > max {
                            Err(TryFromIntError(()))
                        } else {
                            Ok(u as Self)
                        }
                    }
        *)
        Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ u ] =>
            ltac:(M.monadic
              (let u := M.alloc (| u |) in
              M.read (|
                let~ min : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "i128")
                      (M.read (|
                        get_associated_constant (| Ty.path "isize", "MIN", Ty.path "isize" |)
                      |))
                  |) in
                let~ max : Ty.apply (Ty.path "*") [] [ Ty.path "i128" ] :=
                  M.alloc (|
                    M.cast
                      (Ty.path "i128")
                      (M.read (|
                        get_associated_constant (| Ty.path "isize", "MAX", Ty.path "isize" |)
                      |))
                  |) in
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError" ]
                    ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.or (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| u |); M.read (| min |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| u |); M.read (| max |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              Value.StructTuple
                                "core::num::error::TryFromIntError"
                                [ Value.Tuple [] ]
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            [ M.cast (Ty.path "isize") (M.read (| u |)) ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::convert::TryFrom"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) [ Ty.path "i128" ]
            Self
            (* Instance *)
            [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
      End Impl_core_convert_TryFrom_i128_for_isize.
    End ptr_try_from_impls.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u16",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u16",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u32",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u64",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u128",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "usize",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u32",
                    [],
                    [ Ty.path "u16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u64",
                    [],
                    [ Ty.path "u16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u128",
                    [],
                    [ Ty.path "u16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "usize",
                    [],
                    [ Ty.path "u16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u64",
                    [],
                    [ Ty.path "u32" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u128",
                    [],
                    [ Ty.path "u32" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "u128",
                    [],
                    [ Ty.path "u64" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i16",
                    [],
                    [ Ty.path "i8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i32",
                    [],
                    [ Ty.path "i8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i64",
                    [],
                    [ Ty.path "i8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "i8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "isize",
                    [],
                    [ Ty.path "i8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i32",
                    [],
                    [ Ty.path "i16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i64",
                    [],
                    [ Ty.path "i16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "i16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "isize",
                    [],
                    [ Ty.path "i16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i64",
                    [],
                    [ Ty.path "i32" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i32",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "i32" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i32",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "i64" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "i64",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i16",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i16",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i32",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i64",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "isize",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "isize",
                    [],
                    [ Ty.path "u8" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u8",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i32",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i32",
                    [],
                    [ Ty.path "u16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i64",
                    [],
                    [ Ty.path "u16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "u16" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u16",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i64",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i64",
                    [],
                    [ Ty.path "u32" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "u32" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_From_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*
                  fn from(small: NonZero<$Small>) -> Self {
                      // SAFETY: input type guarantees the value is non-zero
                      unsafe { Self::new_unchecked(From::from(small.get())) }
                  }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ small ] =>
          ltac:(M.monadic
            (let small := M.alloc (| small |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                "new_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "i128",
                  M.get_trait_method (|
                    "core::convert::From",
                    Ty.path "i128",
                    [],
                    [ Ty.path "u64" ],
                    "from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "get",
                        [],
                        []
                      |),
                      [ M.read (| small |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_TryFrom_u8_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u8_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_u16_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u16_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_u32_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u32_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_u64_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u64_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_u128_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "u128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_u128_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_usize_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_usize_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_i8_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i8" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i8_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_i16_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i16" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i16_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_i32_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i32" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i32_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_i64_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i64" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i64_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_TryFrom_i128_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "i128" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_i128_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_TryFrom_isize_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: $Int) -> Result<Self, Self::Error> {
                      Self::new(value).ok_or(TryFromIntError(()))
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.path "core::num::error::TryFromIntError"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ],
                "ok_or",
                [],
                [ Ty.path "core::num::error::TryFromIntError" ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| value |) ]
                |);
                Value.StructTuple "core::num::error::TryFromIntError" [ Value.Tuple [] ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "isize" ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_isize_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "u16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "i16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i32",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i32",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i64",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i32",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i64",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "u8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u8",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u8" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u8_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "u16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "u16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "u16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u16_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i32",
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "u32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u32_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i32",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i64",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "u64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u64_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i32",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i64",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "u128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_u128_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i8",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i16",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i32",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i64",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "i128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "i128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "i128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "i128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "i128",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "i128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "i128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_i128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_isize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "isize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "isize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "isize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "isize",
                                      [],
                                      [ Ty.path "usize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "usize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "isize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "isize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_usize_for_core_num_nonzero_NonZero_isize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "i8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i8",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i8" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "i8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i8",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i8" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "i8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i8",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i8" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "i8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i8",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i8" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [ Ty.path "i8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i8",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i8" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "i8" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i8",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i8" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i8" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i8_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "i16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "i16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "i16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "i16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [ Ty.path "i16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "i16" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i16",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i16" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i16" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i16_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "i32" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i32",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i32" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i32" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i32_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "i64" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i64",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i64" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i64" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i64_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "i128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "i128",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "i128" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "i128" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_i128_for_core_num_nonzero_NonZero_usize.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u8" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u8" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u8"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u8",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u8" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u8" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u8.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u16" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u16" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u16"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u16",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u16" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u16" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u16.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u32.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u32" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u32" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u32"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u32",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u32.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u64.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u64" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u64" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u64"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u64",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u64" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u64" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u64.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u128.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "u128" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "u128"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError" ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "u128"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "u128",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "u128" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "u128" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_u128.
    
    Module Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_usize.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ].
      
      (*             type Error = TryFromIntError; *)
      Definition _Error : Ty.t := Ty.path "core::num::error::TryFromIntError".
      
      (*
                  fn try_from(value: NonZero<$source>) -> Result<Self, Self::Error> {
                      // SAFETY: Input is guaranteed to be non-zero.
                      Ok(unsafe { Self::new_unchecked(<$target>::try_from(value.get())?) })
                  }
      *)
      Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ value ] =>
          ltac:(M.monadic
            (let value := M.alloc (| value |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ];
                  Ty.associated_in_trait
                    "core::convert::TryFrom"
                    []
                    [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
                    (Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ])
                    "Error"
                ]) (|
              ltac:(M.monadic
                (Value.StructTuple
                  "core::result::Result::Ok"
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::num::error::TryFromIntError"
                                      ];
                                    Ty.path "usize"
                                  ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                    ],
                                  [],
                                  [],
                                  "branch",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "isize" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "isize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::num::nonzero::NonZero")
                                            []
                                            [ Ty.path "isize" ],
                                          "get",
                                          [],
                                          []
                                        |),
                                        [ M.read (| value |) ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::nonzero::NonZero")
                                                  []
                                                  [ Ty.path "usize" ];
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::num::nonzero::NonZero")
                                                    []
                                                    [ Ty.path "usize" ];
                                                  Ty.path "core::num::error::TryFromIntError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "core::num::error::TryFromIntError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |)
                        |)
                      ]
                    |)
                  ]))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::TryFrom"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "isize" ] ]
          Self
          (* Instance *)
          [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
    End Impl_core_convert_TryFrom_core_num_nonzero_NonZero_isize_for_core_num_nonzero_NonZero_usize.
  End num.
End convert.
