(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module escape.
  Definition value_HEX_DIGITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.deref (|
        M.call_closure (|
          Ty.apply
            (Ty.path "&")
            []
            [
              Ty.apply
                (Ty.path "array")
                [ Value.Integer IntegerKind.Usize 16 ]
                [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
            ],
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  ]
              ],
            "unwrap",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 16 ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                    ]
                ],
              M.get_associated_function (|
                Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 16 ] [ Ty.path "u8" ],
                "as_ascii",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| UnsupportedLiteral |) |) |) ]
            |)
          ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_HEX_DIGITS :
    M.IsFunction.C "core::escape::HEX_DIGITS" value_HEX_DIGITS.
  Admitted.
  Global Typeclasses Opaque value_HEX_DIGITS.
  
  (*
  const fn backslash<const N: usize>(a: ascii::Char) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 2) };
  
      let mut output = [ascii::Char::Null; N];
  
      output[0] = ascii::Char::ReverseSolidus;
      output[1] = a;
  
      (output, 0..2)
  }
  *)
  Definition backslash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ a ] =>
      ltac:(M.monadic
        (let a := M.alloc (| Ty.path "core::ascii::ascii_char::AsciiChar", a |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.read (| get_constant (| "core::escape::backslash_discriminant", Ty.tuple [] |) |) in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            lib.repeat (|
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [] [] [],
              N
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 0 |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" [] [] []
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 1 |),
              M.read (| a |)
            |) in
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
              ],
            Value.Tuple
              [
                M.read (| output |);
                Value.mkStructRecord
                  "core::ops::range::Range"
                  []
                  [ Ty.path "u8" ]
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 2)
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_backslash :
    M.IsFunction.C "core::escape::backslash" backslash.
  Admitted.
  Global Typeclasses Opaque backslash.
  
  (*
  const fn hex_escape<const N: usize>(byte: u8) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 4) };
  
      let mut output = [ascii::Char::Null; N];
  
      let hi = HEX_DIGITS[(byte >> 4) as usize];
      let lo = HEX_DIGITS[(byte & 0xf) as usize];
  
      output[0] = ascii::Char::ReverseSolidus;
      output[1] = ascii::Char::SmallX;
      output[2] = hi;
      output[3] = lo;
  
      (output, 0..4)
  }
  *)
  Definition hex_escape (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ byte ] =>
      ltac:(M.monadic
        (let byte := M.alloc (| Ty.path "u8", byte |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.read (| get_constant (| "core::escape::hex_escape_discriminant", Ty.tuple [] |) |) in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            lib.repeat (|
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [] [] [],
              N
            |) in
          let~ hi : Ty.path "core::ascii::ascii_char::AsciiChar" :=
            M.read (|
              M.SubPointer.get_array_field (|
                get_constant (|
                  "core::escape::HEX_DIGITS",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                |),
                M.cast
                  (Ty.path "usize")
                  (M.call_closure (|
                    Ty.path "u8",
                    BinOp.Wrap.shr,
                    [ M.read (| byte |); Value.Integer IntegerKind.I32 4 ]
                  |))
              |)
            |) in
          let~ lo : Ty.path "core::ascii::ascii_char::AsciiChar" :=
            M.read (|
              M.SubPointer.get_array_field (|
                get_constant (|
                  "core::escape::HEX_DIGITS",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                |),
                M.cast
                  (Ty.path "usize")
                  (M.call_closure (|
                    Ty.path "u8",
                    BinOp.Wrap.bit_and,
                    [ M.read (| byte |); Value.Integer IntegerKind.U8 15 ]
                  |))
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 0 |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" [] [] []
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 1 |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallX" [] [] []
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 2 |),
              M.read (| hi |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 3 |),
              M.read (| lo |)
            |) in
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
              ],
            Value.Tuple
              [
                M.read (| output |);
                Value.mkStructRecord
                  "core::ops::range::Range"
                  []
                  [ Ty.path "u8" ]
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 4)
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_hex_escape :
    M.IsFunction.C "core::escape::hex_escape" hex_escape.
  Admitted.
  Global Typeclasses Opaque hex_escape.
  
  (*
  const fn verbatim<const N: usize>(a: ascii::Char) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 1) };
  
      let mut output = [ascii::Char::Null; N];
  
      output[0] = a;
  
      (output, 0..1)
  }
  *)
  Definition verbatim (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ a ] =>
      ltac:(M.monadic
        (let a := M.alloc (| Ty.path "core::ascii::ascii_char::AsciiChar", a |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.read (| get_constant (| "core::escape::verbatim_discriminant", Ty.tuple [] |) |) in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            lib.repeat (|
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [] [] [],
              N
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 0 |),
              M.read (| a |)
            |) in
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
              ],
            Value.Tuple
              [
                M.read (| output |);
                Value.mkStructRecord
                  "core::ops::range::Range"
                  []
                  [ Ty.path "u8" ]
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 1)
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_verbatim : M.IsFunction.C "core::escape::verbatim" verbatim.
  Admitted.
  Global Typeclasses Opaque verbatim.
  
  (*
  const fn escape_ascii<const N: usize>(byte: u8) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 4) };
  
      #[cfg(feature = "optimize_for_size")]
      {
          match byte {
              b'\t' => backslash(ascii::Char::SmallT),
              b'\r' => backslash(ascii::Char::SmallR),
              b'\n' => backslash(ascii::Char::SmallN),
              b'\\' => backslash(ascii::Char::ReverseSolidus),
              b'\'' => backslash(ascii::Char::Apostrophe),
              b'"' => backslash(ascii::Char::QuotationMark),
              0x00..=0x1F | 0x7F => hex_escape(byte),
              _ => match ascii::Char::from_u8(byte) {
                  Some(a) => verbatim(a),
                  None => hex_escape(byte),
              },
          }
      }
  
      #[cfg(not(feature = "optimize_for_size"))]
      {
          /// Lookup table helps us determine how to display character.
          ///
          /// Since ASCII characters will always be 7 bits, we can exploit this to store the 8th bit to
          /// indicate whether the result is escaped or unescaped.
          ///
          /// We additionally use 0x80 (escaped NUL character) to indicate hex-escaped bytes, since
          /// escaped NUL will not occur.
          const LOOKUP: [u8; 256] = {
              let mut arr = [0; 256];
              let mut idx = 0;
              while idx <= 255 {
                  arr[idx] = match idx as u8 {
                      // use 8th bit to indicate escaped
                      b'\t' => 0x80 | b't',
                      b'\r' => 0x80 | b'r',
                      b'\n' => 0x80 | b'n',
                      b'\\' => 0x80 | b'\\',
                      b'\'' => 0x80 | b'\'',
                      b'"' => 0x80 | b'"',
  
                      // use NUL to indicate hex-escaped
                      0x00..=0x1F | 0x7F..=0xFF => 0x80 | b'\0',
  
                      idx => idx,
                  };
                  idx += 1;
              }
              arr
          };
  
          let lookup = LOOKUP[byte as usize];
  
          // 8th bit indicates escape
          let lookup_escaped = lookup & 0x80 != 0;
  
          // SAFETY: We explicitly mask out the eighth bit to get a 7-bit ASCII character.
          let lookup_ascii = unsafe { ascii::Char::from_u8_unchecked(lookup & 0x7F) };
  
          if lookup_escaped {
              // NUL indicates hex-escaped
              if matches!(lookup_ascii, ascii::Char::Null) {
                  hex_escape(byte)
              } else {
                  backslash(lookup_ascii)
              }
          } else {
              verbatim(lookup_ascii)
          }
      }
  }
  "
  *)
  Definition escape_ascii (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ byte ] =>
      ltac:(M.monadic
        (let byte := M.alloc (| Ty.path "u8", byte |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.read (|
              get_constant (| "core::escape::escape_ascii_discriminant", Ty.tuple [] |)
            |) in
          let~ lookup : Ty.path "u8" :=
            M.read (|
              M.SubPointer.get_array_field (|
                get_constant (|
                  "core::escape::escape_ascii::LOOKUP",
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 256 ]
                    [ Ty.path "u8" ]
                |),
                M.cast (Ty.path "usize") (M.read (| byte |))
              |)
            |) in
          let~ lookup_escaped : Ty.path "bool" :=
            M.call_closure (|
              Ty.path "bool",
              BinOp.ne,
              [
                M.call_closure (|
                  Ty.path "u8",
                  BinOp.Wrap.bit_and,
                  [ M.read (| lookup |); Value.Integer IntegerKind.U8 128 ]
                |);
                Value.Integer IntegerKind.U8 0
              ]
            |) in
          let~ lookup_ascii : Ty.path "core::ascii::ascii_char::AsciiChar" :=
            M.call_closure (|
              Ty.path "core::ascii::ascii_char::AsciiChar",
              M.get_associated_function (|
                Ty.path "core::ascii::ascii_char::AsciiChar",
                "from_u8_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u8",
                  BinOp.Wrap.bit_and,
                  [ M.read (| lookup |); Value.Integer IntegerKind.U8 127 ]
                |)
              ]
            |) in
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
              ],
            M.match_operator (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                ],
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use lookup_escaped in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.match_operator (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ N ]
                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                        ],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.match_operator (|
                                    Ty.path "bool",
                                    lookup_ascii,
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::ascii::ascii_char::AsciiChar::Null"
                                            |) in
                                          Value.Bool true));
                                      fun γ => ltac:(M.monadic (Value.Bool false))
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ N ]
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                                ],
                              M.get_function (| "core::escape::hex_escape", [ N ], [] |),
                              [ M.read (| byte |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ N ]
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                                ],
                              M.get_function (| "core::escape::backslash", [ N ], [] |),
                              [ M.read (| lookup_ascii |) ]
                            |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ N ]
                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                        ],
                      M.get_function (| "core::escape::verbatim", [ N ], [] |),
                      [ M.read (| lookup_ascii |) ]
                    |)))
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_escape_ascii :
    M.IsFunction.C "core::escape::escape_ascii" escape_ascii.
  Admitted.
  Global Typeclasses Opaque escape_ascii.
  
  Module escape_ascii.
    Definition value_LOOKUP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (let~ arr :
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] :=
          lib.repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 256 |) in
        let~ idx : Ty.path "usize" := Value.Integer IntegerKind.Usize 0 in
        let~ _ : Ty.tuple [] :=
          M.read (|
            M.loop (|
              Ty.tuple [],
              ltac:(M.monadic
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [ M.read (| idx |); Value.Integer IntegerKind.Usize 255 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.write (|
                                M.SubPointer.get_array_field (| arr, M.read (| idx |) |),
                                M.match_operator (|
                                  Ty.path "u8",
                                  M.alloc (|
                                    Ty.path "u8",
                                    M.cast (Ty.path "u8") (M.read (| idx |))
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 9
                                          |) in
                                        M.call_closure (|
                                          Ty.path "u8",
                                          BinOp.Wrap.bit_or,
                                          [
                                            Value.Integer IntegerKind.U8 128;
                                            M.read (| UnsupportedLiteral |)
                                          ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 13
                                          |) in
                                        M.call_closure (|
                                          Ty.path "u8",
                                          BinOp.Wrap.bit_or,
                                          [
                                            Value.Integer IntegerKind.U8 128;
                                            M.read (| UnsupportedLiteral |)
                                          ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 10
                                          |) in
                                        M.call_closure (|
                                          Ty.path "u8",
                                          BinOp.Wrap.bit_or,
                                          [
                                            Value.Integer IntegerKind.U8 128;
                                            M.read (| UnsupportedLiteral |)
                                          ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 92
                                          |) in
                                        M.call_closure (|
                                          Ty.path "u8",
                                          BinOp.Wrap.bit_or,
                                          [
                                            Value.Integer IntegerKind.U8 128;
                                            M.read (| UnsupportedLiteral |)
                                          ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 39
                                          |) in
                                        M.call_closure (|
                                          Ty.path "u8",
                                          BinOp.Wrap.bit_or,
                                          [
                                            Value.Integer IntegerKind.U8 128;
                                            M.read (| UnsupportedLiteral |)
                                          ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 34
                                          |) in
                                        M.call_closure (|
                                          Ty.path "u8",
                                          BinOp.Wrap.bit_or,
                                          [
                                            Value.Integer IntegerKind.U8 128;
                                            M.read (| UnsupportedLiteral |)
                                          ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.find_or_pattern (Ty.tuple []) (|
                                          γ,
                                          [
                                            fun γ => ltac:(M.monadic (Value.Tuple []));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ],
                                          fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [] =>
                                                ltac:(M.monadic
                                                  (M.call_closure (|
                                                    Ty.path "u8",
                                                    BinOp.Wrap.bit_or,
                                                    [
                                                      Value.Integer IntegerKind.U8 128;
                                                      M.read (| UnsupportedLiteral |)
                                                    ]
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let idx := M.copy (| Ty.path "u8", γ |) in
                                        M.read (| idx |)))
                                  ]
                                |)
                              |) in
                            let~ _ : Ty.tuple [] :=
                              let β := idx in
                              M.write (|
                                β,
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                |)
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.never_to_any (|
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.never_to_any (| M.read (| M.break (||) |) |) in
                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                            |)
                          |)))
                    ]
                  |)
                |)))
            |)
          |) in
        arr)).
    
    Global Instance Instance_IsConstant_value_LOOKUP :
      M.IsFunction.C "core::escape::escape_ascii::LOOKUP" value_LOOKUP.
    Admitted.
    Global Typeclasses Opaque value_LOOKUP.
  End escape_ascii.
  
  (*
  const fn escape_unicode<const N: usize>(c: char) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 10 && N < u8::MAX as usize) };
  
      let c = c as u32;
  
      // OR-ing `1` ensures that for `c == 0` the code computes that
      // one digit should be printed.
      let start = (c | 1).leading_zeros() as usize / 4 - 2;
  
      let mut output = [ascii::Char::Null; N];
      output[3] = HEX_DIGITS[((c >> 20) & 15) as usize];
      output[4] = HEX_DIGITS[((c >> 16) & 15) as usize];
      output[5] = HEX_DIGITS[((c >> 12) & 15) as usize];
      output[6] = HEX_DIGITS[((c >> 8) & 15) as usize];
      output[7] = HEX_DIGITS[((c >> 4) & 15) as usize];
      output[8] = HEX_DIGITS[((c >> 0) & 15) as usize];
      output[9] = ascii::Char::RightCurlyBracket;
      output[start + 0] = ascii::Char::ReverseSolidus;
      output[start + 1] = ascii::Char::SmallU;
      output[start + 2] = ascii::Char::LeftCurlyBracket;
  
      (output, (start as u8)..(N as u8))
  }
  *)
  Definition escape_unicode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ c ] =>
      ltac:(M.monadic
        (let c := M.alloc (| Ty.path "char", c |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.read (|
              get_constant (| "core::escape::escape_unicode_discriminant", Ty.tuple [] |)
            |) in
          let~ c : Ty.path "u32" := M.cast (Ty.path "u32") (M.read (| c |)) in
          let~ start : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.sub,
              [
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.div,
                  [
                    M.cast
                      (Ty.path "usize")
                      (M.call_closure (|
                        Ty.path "u32",
                        M.get_associated_function (| Ty.path "u32", "leading_zeros", [], [] |),
                        [
                          M.call_closure (|
                            Ty.path "u32",
                            BinOp.Wrap.bit_or,
                            [ M.read (| c |); Value.Integer IntegerKind.U32 1 ]
                          |)
                        ]
                      |));
                    Value.Integer IntegerKind.Usize 4
                  ]
                |);
                Value.Integer IntegerKind.Usize 2
              ]
            |) in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            lib.repeat (|
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [] [] [],
              N
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 3 |),
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::escape::HEX_DIGITS",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  |),
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.shr,
                          [ M.read (| c |); Value.Integer IntegerKind.I32 20 ]
                        |);
                        Value.Integer IntegerKind.U32 15
                      ]
                    |))
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 4 |),
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::escape::HEX_DIGITS",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  |),
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.shr,
                          [ M.read (| c |); Value.Integer IntegerKind.I32 16 ]
                        |);
                        Value.Integer IntegerKind.U32 15
                      ]
                    |))
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 5 |),
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::escape::HEX_DIGITS",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  |),
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.shr,
                          [ M.read (| c |); Value.Integer IntegerKind.I32 12 ]
                        |);
                        Value.Integer IntegerKind.U32 15
                      ]
                    |))
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 6 |),
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::escape::HEX_DIGITS",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  |),
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.shr,
                          [ M.read (| c |); Value.Integer IntegerKind.I32 8 ]
                        |);
                        Value.Integer IntegerKind.U32 15
                      ]
                    |))
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 7 |),
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::escape::HEX_DIGITS",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  |),
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.shr,
                          [ M.read (| c |); Value.Integer IntegerKind.I32 4 ]
                        |);
                        Value.Integer IntegerKind.U32 15
                      ]
                    |))
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 8 |),
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::escape::HEX_DIGITS",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  |),
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.shr,
                          [ M.read (| c |); Value.Integer IntegerKind.I32 0 ]
                        |);
                        Value.Integer IntegerKind.U32 15
                      ]
                    |))
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 9 |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::RightCurlyBracket" [] [] []
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (|
                output,
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.add,
                  [ M.read (| start |); Value.Integer IntegerKind.Usize 0 ]
                |)
              |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" [] [] []
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (|
                output,
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.add,
                  [ M.read (| start |); Value.Integer IntegerKind.Usize 1 ]
                |)
              |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallU" [] [] []
            |) in
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.SubPointer.get_array_field (|
                output,
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.add,
                  [ M.read (| start |); Value.Integer IntegerKind.Usize 2 ]
                |)
              |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::LeftCurlyBracket" [] [] []
            |) in
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
              ],
            Value.Tuple
              [
                M.read (| output |);
                Value.mkStructRecord
                  "core::ops::range::Range"
                  []
                  [ Ty.path "u8" ]
                  [
                    ("start", M.cast (Ty.path "u8") (M.read (| start |)));
                    ("end_", M.cast (Ty.path "u8") N)
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_escape_unicode :
    M.IsFunction.C "core::escape::escape_unicode" escape_unicode.
  Admitted.
  Global Typeclasses Opaque escape_unicode.
  
  (* StructRecord
    {
      name := "EscapeIterInner";
      const_params := [ "N" ];
      ty_params := [];
      fields :=
        [
          ("data",
            Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ]);
          ("alive", Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_core_escape_EscapeIterInner_N.
    Definition Self (N : Value.t) : Ty.t :=
      Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [].
    
    (* Clone *)
    Definition clone (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          Value.mkStructRecord
            "core::escape::EscapeIterInner"
            [ N ]
            []
            [
              ("data",
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "array")
                      [ N ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::escape::EscapeIterInner",
                            "data"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("alive",
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::escape::EscapeIterInner",
                            "alive"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N)
        (* Instance *) [ ("clone", InstanceField.Method (clone N)) ].
  End Impl_core_clone_Clone_for_core_escape_EscapeIterInner_N.
  
  Module Impl_core_fmt_Debug_for_core_escape_EscapeIterInner_N.
    Definition Self (N : Value.t) : Ty.t :=
      Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [].
    
    (* Debug *)
    Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "EscapeIterInner" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "data" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::escape::EscapeIterInner",
                        "data"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "alive" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ] ],
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::escape::EscapeIterInner",
                            "alive"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
  End Impl_core_fmt_Debug_for_core_escape_EscapeIterInner_N.
  
  Module Impl_core_escape_EscapeIterInner_N.
    Definition Self (N : Value.t) : Ty.t :=
      Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [].
    
    (*
        pub const fn backslash(c: ascii::Char) -> Self {
            let (data, range) = backslash(c);
            Self { data, alive: range }
        }
    *)
    Definition backslash (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ c ] =>
        ltac:(M.monadic
          (let c := M.alloc (| Ty.path "core::ascii::ascii_char::AsciiChar", c |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                ],
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ N ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                  ],
                M.get_function (| "core::escape::backslash", [ N ], [] |),
                [ M.read (| c |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let data :=
                    M.copy (|
                      Ty.apply
                        (Ty.path "array")
                        [ N ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                      γ0_0
                    |) in
                  let range :=
                    M.copy (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                      γ0_1
                    |) in
                  Value.mkStructRecord
                    "core::escape::EscapeIterInner"
                    [ N ]
                    []
                    [ ("data", M.read (| data |)); ("alive", M.read (| range |)) ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_backslash :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "backslash" (backslash N).
    Admitted.
    Global Typeclasses Opaque backslash.
    
    (*
        pub const fn ascii(c: u8) -> Self {
            let (data, range) = escape_ascii(c);
            Self { data, alive: range }
        }
    *)
    Definition ascii (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ c ] =>
        ltac:(M.monadic
          (let c := M.alloc (| Ty.path "u8", c |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                ],
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ N ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                  ],
                M.get_function (| "core::escape::escape_ascii", [ N ], [] |),
                [ M.read (| c |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let data :=
                    M.copy (|
                      Ty.apply
                        (Ty.path "array")
                        [ N ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                      γ0_0
                    |) in
                  let range :=
                    M.copy (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                      γ0_1
                    |) in
                  Value.mkStructRecord
                    "core::escape::EscapeIterInner"
                    [ N ]
                    []
                    [ ("data", M.read (| data |)); ("alive", M.read (| range |)) ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ascii :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "ascii" (ascii N).
    Admitted.
    Global Typeclasses Opaque ascii.
    
    (*
        pub const fn unicode(c: char) -> Self {
            let (data, range) = escape_unicode(c);
            Self { data, alive: range }
        }
    *)
    Definition unicode (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ c ] =>
        ltac:(M.monadic
          (let c := M.alloc (| Ty.path "char", c |) in
          M.match_operator (|
            Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [],
            M.alloc (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                ],
              M.call_closure (|
                Ty.tuple
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ N ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                  ],
                M.get_function (| "core::escape::escape_unicode", [ N ], [] |),
                [ M.read (| c |) ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let data :=
                    M.copy (|
                      Ty.apply
                        (Ty.path "array")
                        [ N ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                      γ0_0
                    |) in
                  let range :=
                    M.copy (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                      γ0_1
                    |) in
                  Value.mkStructRecord
                    "core::escape::EscapeIterInner"
                    [ N ]
                    []
                    [ ("data", M.read (| data |)); ("alive", M.read (| range |)) ]))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unicode :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "unicode" (unicode N).
    Admitted.
    Global Typeclasses Opaque unicode.
    
    (*
        pub const fn empty() -> Self {
            Self { data: [ascii::Char::Null; N], alive: 0..0 }
        }
    *)
    Definition empty (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.mkStructRecord
            "core::escape::EscapeIterInner"
            [ N ]
            []
            [
              ("data",
                lib.repeat (|
                  Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [] [] [],
                  N
                |));
              ("alive",
                Value.mkStructRecord
                  "core::ops::range::Range"
                  []
                  [ Ty.path "u8" ]
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 0)
                  ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_empty :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "empty" (empty N).
    Admitted.
    Global Typeclasses Opaque empty.
    
    (*
        pub fn as_ascii(&self) -> &[ascii::Char] {
            // SAFETY: `self.alive` is guaranteed to be a valid range for indexing `self.data`.
            unsafe {
                self.data.get_unchecked(usize::from(self.alive.start)..usize::from(self.alive.end))
            }
        }
    *)
    Definition as_ascii (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                  "get_unchecked",
                  [],
                  [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ]
                |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::escape::EscapeIterInner",
                        "data"
                      |)
                    |));
                  Value.mkStructRecord
                    "core::ops::range::Range"
                    []
                    [ Ty.path "usize" ]
                    [
                      ("start",
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.path "usize",
                            [],
                            [ Ty.path "u8" ],
                            "from",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::escape::EscapeIterInner",
                                  "alive"
                                |),
                                "core::ops::range::Range",
                                "start"
                              |)
                            |)
                          ]
                        |));
                      ("end_",
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.path "usize",
                            [],
                            [ Ty.path "u8" ],
                            "from",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::escape::EscapeIterInner",
                                  "alive"
                                |),
                                "core::ops::range::Range",
                                "end"
                              |)
                            |)
                          ]
                        |))
                    ]
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ascii :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "as_ascii" (as_ascii N).
    Admitted.
    Global Typeclasses Opaque as_ascii.
    
    (*
        pub fn as_str(&self) -> &str {
            self.as_ascii().as_str()
        }
    *)
    Definition as_str (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                  "as_str",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [],
                          "as_ascii",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_str :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "as_str" (as_str N).
    Admitted.
    Global Typeclasses Opaque as_str.
    
    (*
        pub fn len(&self) -> usize {
            usize::from(self.alive.end - self.alive.start)
        }
    *)
    Definition len (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "usize",
              [],
              [ Ty.path "u8" ],
              "from",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.sub,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::escape::EscapeIterInner",
                        "alive"
                      |),
                      "core::ops::range::Range",
                      "end"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::escape::EscapeIterInner",
                        "alive"
                      |),
                      "core::ops::range::Range",
                      "start"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_len :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "len" (len N).
    Admitted.
    Global Typeclasses Opaque len.
    
    (*
        pub fn next(&mut self) -> Option<u8> {
            let i = self.alive.next()?;
    
            // SAFETY: `i` is guaranteed to be a valid index for `self.data`.
            unsafe { Some(self.data.get_unchecked(usize::from(i)).to_u8()) }
        }
    *)
    Definition next (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ i : Ty.path "u8" :=
                  M.match_operator (|
                    Ty.path "u8",
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::ops::control_flow::ControlFlow")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::convert::Infallible" ];
                          Ty.path "u8"
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ops::control_flow::ControlFlow")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "core::convert::Infallible" ];
                            Ty.path "u8"
                          ],
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                          [],
                          [],
                          "branch",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                              [],
                              [],
                              "next",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::escape::EscapeIterInner",
                                  "alive"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual :=
                            M.copy (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::convert::Infallible" ],
                              γ0_0
                            |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "core::convert::Infallible" ]
                                    ],
                                    "from_residual",
                                    [],
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| Ty.path "u8", γ0_0 |) in
                          M.read (| val |)))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "u8" ]
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                  "get_unchecked",
                                  [],
                                  [ Ty.path "usize" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::escape::EscapeIterInner",
                                        "data"
                                      |)
                                    |));
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "core::convert::From",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u8" ],
                                      "from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| i |) ]
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_next :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "next" (next N).
    Admitted.
    Global Typeclasses Opaque next.
    
    (*
        pub fn next_back(&mut self) -> Option<u8> {
            let i = self.alive.next_back()?;
    
            // SAFETY: `i` is guaranteed to be a valid index for `self.data`.
            unsafe { Some(self.data.get_unchecked(usize::from(i)).to_u8()) }
        }
    *)
    Definition next_back (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          M.catch_return (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ i : Ty.path "u8" :=
                  M.match_operator (|
                    Ty.path "u8",
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::ops::control_flow::ControlFlow")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::convert::Infallible" ];
                          Ty.path "u8"
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ops::control_flow::ControlFlow")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [ Ty.path "core::convert::Infallible" ];
                            Ty.path "u8"
                          ],
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                          [],
                          [],
                          "branch",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                            M.get_trait_method (|
                              "core::iter::traits::double_ended::DoubleEndedIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                              [],
                              [],
                              "next_back",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::escape::EscapeIterInner",
                                  "alive"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual :=
                            M.copy (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::convert::Infallible" ],
                              γ0_0
                            |) in
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "core::convert::Infallible" ]
                                    ],
                                    "from_residual",
                                    [],
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| Ty.path "u8", γ0_0 |) in
                          M.read (| val |)))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                  Value.StructTuple
                    "core::option::Option::Some"
                    []
                    [ Ty.path "u8" ]
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                  "get_unchecked",
                                  [],
                                  [ Ty.path "usize" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::escape::EscapeIterInner",
                                        "data"
                                      |)
                                    |));
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "core::convert::From",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u8" ],
                                      "from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| i |) ]
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_next_back :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "next_back" (next_back N).
    Admitted.
    Global Typeclasses Opaque next_back.
    
    (*
        pub fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
            self.alive.advance_by(n)
        }
    *)
    Definition advance_by (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self; n ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          let n := M.alloc (| Ty.path "usize", n |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
              [],
              [],
              "advance_by",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::escape::EscapeIterInner",
                  "alive"
                |)
              |);
              M.read (| n |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_advance_by :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "advance_by" (advance_by N).
    Admitted.
    Global Typeclasses Opaque advance_by.
    
    (*
        pub fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
            self.alive.advance_back_by(n)
        }
    *)
    Definition advance_back_by
        (N : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self; n ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&mut")
                []
                [ Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [] ],
              self
            |) in
          let n := M.alloc (| Ty.path "usize", n |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
              ],
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
              [],
              [],
              "advance_back_by",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::escape::EscapeIterInner",
                  "alive"
                |)
              |);
              M.read (| n |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_advance_back_by :
      forall (N : Value.t),
      M.IsAssociatedFunction.C (Self N) "advance_back_by" (advance_back_by N).
    Admitted.
    Global Typeclasses Opaque advance_back_by.
  End Impl_core_escape_EscapeIterInner_N.
End escape.
