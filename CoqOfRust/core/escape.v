(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module escape.
  Definition value_HEX_DIGITS : Value.t :=
    M.run
      ltac:(M.monadic
        (M.call_closure (|
          M.get_associated_function (|
            Ty.apply
              (Ty.path "core::option::Option")
              [
                Ty.apply
                  (Ty.path "&")
                  [ Ty.apply (Ty.path "array") [ Ty.path "core::ascii::ascii_char::AsciiChar" ] ]
              ],
            "unwrap",
            []
          |),
          [
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "array") [ Ty.path "u8" ],
                "as_ascii",
                []
              |),
              [ M.read (| UnsupportedLiteral |) ]
            |)
          ]
        |))).
  
  (*
  pub(crate) fn escape_ascii_into(output: &mut [ascii::Char; 4], byte: u8) -> Range<u8> {
      #[inline]
      fn backslash(a: ascii::Char) -> ([ascii::Char; 4], u8) {
          ([ascii::Char::ReverseSolidus, a, ascii::Char::Null, ascii::Char::Null], 2)
      }
  
      let (data, len) = match byte {
          b'\t' => backslash(ascii::Char::SmallT),
          b'\r' => backslash(ascii::Char::SmallR),
          b'\n' => backslash(ascii::Char::SmallN),
          b'\\' => backslash(ascii::Char::ReverseSolidus),
          b'\'' => backslash(ascii::Char::Apostrophe),
          b'\"' => backslash(ascii::Char::QuotationMark),
          _ => {
              if let Some(a) = byte.as_ascii()
                  && !byte.is_ascii_control()
              {
                  ([a, ascii::Char::Null, ascii::Char::Null, ascii::Char::Null], 1)
              } else {
                  let hi = HEX_DIGITS[usize::from(byte >> 4)];
                  let lo = HEX_DIGITS[usize::from(byte & 0xf)];
                  ([ascii::Char::ReverseSolidus, ascii::Char::SmallX, hi, lo], 4)
              }
          }
      };
      *output = data;
      0..len
  }
  "
  *)
  Definition escape_ascii_into (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ output; byte ] =>
      ltac:(M.monadic
        (let output := M.alloc (| output |) in
        let byte := M.alloc (| byte |) in
        M.read (|
          M.match_operator (|
            M.match_operator (|
              byte,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 9 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::escape::escape_ascii_into.backslash", [] |),
                        [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallT" [] ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 13 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::escape::escape_ascii_into.backslash", [] |),
                        [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallR" [] ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 10 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::escape::escape_ascii_into.backslash", [] |),
                        [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallN" [] ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 92 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::escape::escape_ascii_into.backslash", [] |),
                        [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" []
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 39 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::escape::escape_ascii_into.backslash", [] |),
                        [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::Apostrophe" [] ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Integer 34 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (| "core::escape::escape_ascii_into.backslash", [] |),
                        [ Value.StructTuple "core::ascii::ascii_char::AsciiChar::QuotationMark" [] ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (| Ty.path "u8", "as_ascii", [] |),
                                  [ byte ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let a := M.copy (| γ0_0 |) in
                            let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.Pure.not
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "u8",
                                        "is_ascii_control",
                                        []
                                      |),
                                      [ byte ]
                                    |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  Value.Array
                                    [
                                      M.read (| a |);
                                      Value.StructTuple
                                        "core::ascii::ascii_char::AsciiChar::Null"
                                        [];
                                      Value.StructTuple
                                        "core::ascii::ascii_char::AsciiChar::Null"
                                        [];
                                      Value.StructTuple
                                        "core::ascii::ascii_char::AsciiChar::Null"
                                        []
                                    ];
                                  Value.Integer 1
                                ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let hi :=
                              M.copy (|
                                M.SubPointer.get_array_field (|
                                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::convert::From",
                                        Ty.path "usize",
                                        [ Ty.path "u8" ],
                                        "from",
                                        []
                                      |),
                                      [ BinOp.Panic.shr (| M.read (| byte |), Value.Integer 4 |) ]
                                    |)
                                  |)
                                |)
                              |) in
                            let lo :=
                              M.copy (|
                                M.SubPointer.get_array_field (|
                                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::convert::From",
                                        Ty.path "usize",
                                        [ Ty.path "u8" ],
                                        "from",
                                        []
                                      |),
                                      [ BinOp.Pure.bit_and (M.read (| byte |)) (Value.Integer 15) ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.alloc (|
                              Value.Tuple
                                [
                                  Value.Array
                                    [
                                      Value.StructTuple
                                        "core::ascii::ascii_char::AsciiChar::ReverseSolidus"
                                        [];
                                      Value.StructTuple
                                        "core::ascii::ascii_char::AsciiChar::SmallX"
                                        [];
                                      M.read (| hi |);
                                      M.read (| lo |)
                                    ];
                                  Value.Integer 4
                                ]
                            |)))
                      ]
                    |)))
              ]
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                  let data := M.copy (| γ0_0 |) in
                  let len := M.copy (| γ0_1 |) in
                  let _ := M.write (| M.read (| output |), M.read (| data |) |) in
                  M.alloc (|
                    Value.StructRecord
                      "core::ops::range::Range"
                      [ ("start", Value.Integer 0); ("end_", M.read (| len |)) ]
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_escape_ascii_into :
    M.IsFunction "core::escape::escape_ascii_into" escape_ascii_into.
  
  Module escape_ascii_into.
    (*
        fn backslash(a: ascii::Char) -> ([ascii::Char; 4], u8) {
            ([ascii::Char::ReverseSolidus, a, ascii::Char::Null, ascii::Char::Null], 2)
        }
    *)
    Definition backslash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ a ] =>
        ltac:(M.monadic
          (let a := M.alloc (| a |) in
          Value.Tuple
            [
              Value.Array
                [
                  Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" [];
                  M.read (| a |);
                  Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [];
                  Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" []
                ];
              Value.Integer 2
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Function_backslash : M.IsFunction "core::escape::escape_ascii_into::backslash" backslash.
  End escape_ascii_into.
  
  (*
  pub(crate) fn escape_unicode_into(output: &mut [ascii::Char; 10], ch: char) -> Range<u8> {
      output[9] = ascii::Char::RightCurlyBracket;
  
      let ch = ch as u32;
      output[3] = HEX_DIGITS[((ch >> 20) & 15) as usize];
      output[4] = HEX_DIGITS[((ch >> 16) & 15) as usize];
      output[5] = HEX_DIGITS[((ch >> 12) & 15) as usize];
      output[6] = HEX_DIGITS[((ch >> 8) & 15) as usize];
      output[7] = HEX_DIGITS[((ch >> 4) & 15) as usize];
      output[8] = HEX_DIGITS[((ch >> 0) & 15) as usize];
  
      // or-ing 1 ensures that for ch==0 the code computes that one digit should
      // be printed.
      let start = (ch | 1).leading_zeros() as usize / 4 - 2;
      const UNICODE_ESCAPE_PREFIX: &[ascii::Char; 3] = b"\\u{".as_ascii().unwrap();
      output[start..][..3].copy_from_slice(UNICODE_ESCAPE_PREFIX);
  
      (start as u8)..10
  }
  *)
  Definition escape_unicode_into (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ output; ch ] =>
      ltac:(M.monadic
        (let output := M.alloc (| output |) in
        let ch := M.alloc (| ch |) in
        M.read (|
          let _ :=
            M.write (|
              M.SubPointer.get_array_field (| M.read (| output |), M.alloc (| Value.Integer 9 |) |),
              Value.StructTuple "core::ascii::ascii_char::AsciiChar::RightCurlyBracket" []
            |) in
          let ch := M.alloc (| M.rust_cast (M.read (| ch |)) |) in
          let _ :=
            M.write (|
              M.SubPointer.get_array_field (| M.read (| output |), M.alloc (| Value.Integer 3 |) |),
              M.read (|
                M.SubPointer.get_array_field (|
                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                  M.alloc (|
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (BinOp.Panic.shr (| M.read (| ch |), Value.Integer 20 |))
                        (Value.Integer 15))
                  |)
                |)
              |)
            |) in
          let _ :=
            M.write (|
              M.SubPointer.get_array_field (| M.read (| output |), M.alloc (| Value.Integer 4 |) |),
              M.read (|
                M.SubPointer.get_array_field (|
                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                  M.alloc (|
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (BinOp.Panic.shr (| M.read (| ch |), Value.Integer 16 |))
                        (Value.Integer 15))
                  |)
                |)
              |)
            |) in
          let _ :=
            M.write (|
              M.SubPointer.get_array_field (| M.read (| output |), M.alloc (| Value.Integer 5 |) |),
              M.read (|
                M.SubPointer.get_array_field (|
                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                  M.alloc (|
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (BinOp.Panic.shr (| M.read (| ch |), Value.Integer 12 |))
                        (Value.Integer 15))
                  |)
                |)
              |)
            |) in
          let _ :=
            M.write (|
              M.SubPointer.get_array_field (| M.read (| output |), M.alloc (| Value.Integer 6 |) |),
              M.read (|
                M.SubPointer.get_array_field (|
                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                  M.alloc (|
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (BinOp.Panic.shr (| M.read (| ch |), Value.Integer 8 |))
                        (Value.Integer 15))
                  |)
                |)
              |)
            |) in
          let _ :=
            M.write (|
              M.SubPointer.get_array_field (| M.read (| output |), M.alloc (| Value.Integer 7 |) |),
              M.read (|
                M.SubPointer.get_array_field (|
                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                  M.alloc (|
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (BinOp.Panic.shr (| M.read (| ch |), Value.Integer 4 |))
                        (Value.Integer 15))
                  |)
                |)
              |)
            |) in
          let _ :=
            M.write (|
              M.SubPointer.get_array_field (| M.read (| output |), M.alloc (| Value.Integer 8 |) |),
              M.read (|
                M.SubPointer.get_array_field (|
                  M.get_constant (| "core::escape::HEX_DIGITS" |),
                  M.alloc (|
                    M.rust_cast
                      (BinOp.Pure.bit_and
                        (BinOp.Panic.shr (| M.read (| ch |), Value.Integer 0 |))
                        (Value.Integer 15))
                  |)
                |)
              |)
            |) in
          let start :=
            M.alloc (|
              BinOp.Panic.sub (|
                Integer.Usize,
                BinOp.Panic.div (|
                  Integer.Usize,
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (| Ty.path "u32", "leading_zeros", [] |),
                      [ BinOp.Pure.bit_or (M.read (| ch |)) (Value.Integer 1) ]
                    |)),
                  Value.Integer 4
                |),
                Value.Integer 2
              |)
            |) in
          let _ :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                  "copy_from_slice",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::index::IndexMut",
                      Ty.apply (Ty.path "slice") [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                      [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ],
                      "index_mut",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::index::IndexMut",
                          Ty.apply
                            (Ty.path "array")
                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                          [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ] ],
                          "index_mut",
                          []
                        |),
                        [
                          M.read (| output |);
                          Value.StructRecord
                            "core::ops::range::RangeFrom"
                            [ ("start", M.read (| start |)) ]
                        ]
                      |);
                      Value.StructRecord "core::ops::range::RangeTo" [ ("end_", Value.Integer 3) ]
                    ]
                  |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.read (|
                      M.get_constant (|
                        "core::escape::escape_unicode_into::UNICODE_ESCAPE_PREFIX"
                      |)
                    |))
                ]
              |)
            |) in
          M.alloc (|
            Value.StructRecord
              "core::ops::range::Range"
              [ ("start", M.rust_cast (M.read (| start |))); ("end_", Value.Integer 10) ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Axiom Function_escape_unicode_into :
    M.IsFunction "core::escape::escape_unicode_into" escape_unicode_into.
  
  Module escape_unicode_into.
    Definition value_UNICODE_ESCAPE_PREFIX : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  [
                    Ty.apply
                      (Ty.path "&")
                      [ Ty.apply (Ty.path "array") [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                      ]
                  ],
                "unwrap",
                []
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "array") [ Ty.path "u8" ],
                    "as_ascii",
                    []
                  |),
                  [ M.read (| UnsupportedLiteral |) ]
                |)
              ]
            |)
          |))).
  End escape_unicode_into.
  
  (* StructRecord
    {
      name := "EscapeIterInner";
      ty_params := [];
      fields :=
        [
          ("data", Ty.apply (Ty.path "array") [ Ty.path "core::ascii::ascii_char::AsciiChar" ]);
          ("alive", Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_core_escape_EscapeIterInner.
    Definition Self : Ty.t := Ty.path "core::escape::EscapeIterInner".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "core::escape::EscapeIterInner"
            [
              ("data",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "array") [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::escape::EscapeIterInner",
                      "data"
                    |)
                  ]
                |));
              ("alive",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::escape::EscapeIterInner",
                      "alive"
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_core_escape_EscapeIterInner.
  
  Module Impl_core_fmt_Debug_for_core_escape_EscapeIterInner.
    Definition Self : Ty.t := Ty.path "core::escape::EscapeIterInner".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| Value.String "EscapeIterInner" |);
              M.read (| Value.String "data" |);
              (* Unsize *)
              M.pointer_coercion
                (M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::escape::EscapeIterInner",
                  "data"
                |));
              M.read (| Value.String "alive" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::escape::EscapeIterInner",
                    "alive"
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_core_escape_EscapeIterInner.
  
  Module Impl_core_escape_EscapeIterInner.
    Definition Self : Ty.t := Ty.path "core::escape::EscapeIterInner".
    
    (*
        pub fn new(data: [ascii::Char; N], alive: Range<u8>) -> Self {
            const { assert!(N < 256) };
            debug_assert!(alive.start <= alive.end && usize::from(alive.end) <= N, "{alive:?}");
            Self { data, alive }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ data; alive ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let alive := M.alloc (| alive |) in
          M.read (|
            let _ := M.get_constant (| "core::escape::new_discriminant" |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool true |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      UnOp.Pure.not
                                        (LogicalOp.and (|
                                          BinOp.Pure.le
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                alive,
                                                "core::ops::range::Range",
                                                "start"
                                              |)
                                            |))
                                            (M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                alive,
                                                "core::ops::range::Range",
                                                "end"
                                              |)
                                            |)),
                                          ltac:(M.monadic
                                            (BinOp.Pure.le
                                              (M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::convert::From",
                                                  Ty.path "usize",
                                                  [ Ty.path "u8" ],
                                                  "from",
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      alive,
                                                      "core::ops::range::Range",
                                                      "end"
                                                    |)
                                                  |)
                                                ]
                                              |))
                                              (M.read (|
                                                M.get_constant (| "core::escape::N" |)
                                              |))))
                                        |))
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.call_closure (|
                                      M.get_function (| "core::panicking::panic_fmt", [] |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Arguments",
                                            "new_v1",
                                            []
                                          |),
                                          [
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array [ M.read (| Value.String "" |) ]
                                              |));
                                            (* Unsize *)
                                            M.pointer_coercion
                                              (M.alloc (|
                                                Value.Array
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        "new_debug",
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::ops::range::Range")
                                                            [ Ty.path "u8" ]
                                                        ]
                                                      |),
                                                      [ alive ]
                                                    |)
                                                  ]
                                              |))
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructRecord
                "core::escape::EscapeIterInner"
                [ ("data", M.read (| data |)); ("alive", M.read (| alive |)) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn from_array<const M: usize>(array: [ascii::Char; M]) -> Self {
            const { assert!(M <= N) };
    
            let mut data = [ascii::Char::Null; N];
            data[..M].copy_from_slice(&array);
            Self::new(data, 0..M as u8)
        }
    *)
    Definition from_array (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ array ] =>
        ltac:(M.monadic
          (let array := M.alloc (| array |) in
          M.read (|
            let _ := M.get_constant (| "core::escape::from_array_discriminant" |) in
            let data :=
              M.alloc (|
                repeat (Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" []) N
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                    "copy_from_slice",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::index::IndexMut",
                        Ty.apply (Ty.path "array") [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                        [ Ty.apply (Ty.path "core::ops::range::RangeTo") [ Ty.path "usize" ] ],
                        "index_mut",
                        []
                      |),
                      [
                        data;
                        Value.StructRecord
                          "core::ops::range::RangeTo"
                          [
                            ("end_",
                              M.read (| M.get_constant (| "core::escape::from_array::M" |) |))
                          ]
                      ]
                    |);
                    (* Unsize *) M.pointer_coercion array
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::escape::EscapeIterInner", "new", [] |),
                [
                  M.read (| data |);
                  Value.StructRecord
                    "core::ops::range::Range"
                    [
                      ("start", Value.Integer 0);
                      ("end_",
                        M.rust_cast
                          (M.read (| M.get_constant (| "core::escape::from_array::M" |) |)))
                    ]
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_array : M.IsAssociatedFunction Self "from_array" from_array.
    
    (*
        pub fn as_ascii(&self) -> &[ascii::Char] {
            &self.data[usize::from(self.alive.start)..usize::from(self.alive.end)]
        }
    *)
    Definition as_ascii (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::index::Index",
              Ty.apply (Ty.path "array") [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
              [ Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ] ],
              "index",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::escape::EscapeIterInner",
                "data"
              |);
              Value.StructRecord
                "core::ops::range::Range"
                [
                  ("start",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.path "usize",
                        [ Ty.path "u8" ],
                        "from",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::escape::EscapeIterInner",
                              "alive"
                            |),
                            "core::ops::range::Range",
                            "start"
                          |)
                        |)
                      ]
                    |));
                  ("end_",
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::convert::From",
                        Ty.path "usize",
                        [ Ty.path "u8" ],
                        "from",
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              M.read (| self |),
                              "core::escape::EscapeIterInner",
                              "alive"
                            |),
                            "core::ops::range::Range",
                            "end"
                          |)
                        |)
                      ]
                    |))
                ]
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ascii : M.IsAssociatedFunction Self "as_ascii" as_ascii.
    
    (*
        pub fn as_str(&self) -> &str {
            self.as_ascii().as_str()
        }
    *)
    Definition as_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
              "as_str",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "core::escape::EscapeIterInner",
                  "as_ascii",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_str : M.IsAssociatedFunction Self "as_str" as_str.
    
    (*
        pub fn len(&self) -> usize {
            usize::from(self.alive.end - self.alive.start)
        }
    *)
    Definition len (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "usize",
              [ Ty.path "u8" ],
              "from",
              []
            |),
            [
              BinOp.Panic.sub (|
                Integer.U8,
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::escape::EscapeIterInner",
                      "alive"
                    |),
                    "core::ops::range::Range",
                    "end"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::escape::EscapeIterInner",
                      "alive"
                    |),
                    "core::ops::range::Range",
                    "start"
                  |)
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_len : M.IsAssociatedFunction Self "len" len.
    
    (*
        pub fn next(&mut self) -> Option<u8> {
            self.alive.next().map(|i| self.data[usize::from(i)].to_u8())
        }
    *)
    Definition next (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "u8" ],
              "map",
              [ Ty.path "u8"; Ty.function [ Ty.tuple [ Ty.path "u8" ] ] (Ty.path "u8") ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ],
                  [],
                  "next",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::escape::EscapeIterInner",
                    "alive"
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let i := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::ascii::ascii_char::AsciiChar",
                                  "to_u8",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_array_field (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::escape::EscapeIterInner",
                                        "data"
                                      |),
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::convert::From",
                                            Ty.path "usize",
                                            [ Ty.path "u8" ],
                                            "from",
                                            []
                                          |),
                                          [ M.read (| i |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next : M.IsAssociatedFunction Self "next" next.
    
    (*
        pub fn next_back(&mut self) -> Option<u8> {
            self.alive.next_back().map(|i| self.data[usize::from(i)].to_u8())
        }
    *)
    Definition next_back (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "u8" ],
              "map",
              [ Ty.path "u8"; Ty.function [ Ty.tuple [ Ty.path "u8" ] ] (Ty.path "u8") ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::double_ended::DoubleEndedIterator",
                  Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ],
                  [],
                  "next_back",
                  []
                |),
                [
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::escape::EscapeIterInner",
                    "alive"
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let i := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::ascii::ascii_char::AsciiChar",
                                  "to_u8",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_array_field (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::escape::EscapeIterInner",
                                        "data"
                                      |),
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::convert::From",
                                            Ty.path "usize",
                                            [ Ty.path "u8" ],
                                            "from",
                                            []
                                          |),
                                          [ M.read (| i |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next_back : M.IsAssociatedFunction Self "next_back" next_back.
    
    (*
        pub fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
            self.alive.advance_by(n)
        }
    *)
    Definition advance_by (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ],
              [],
              "advance_by",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::escape::EscapeIterInner",
                "alive"
              |);
              M.read (| n |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_advance_by : M.IsAssociatedFunction Self "advance_by" advance_by.
    
    (*
        pub fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
            self.alive.advance_back_by(n)
        }
    *)
    Definition advance_back_by (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ],
              [],
              "advance_back_by",
              []
            |),
            [
              M.SubPointer.get_struct_record_field (|
                M.read (| self |),
                "core::escape::EscapeIterInner",
                "alive"
              |);
              M.read (| n |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_advance_back_by :
      M.IsAssociatedFunction Self "advance_back_by" advance_back_by.
  End Impl_core_escape_EscapeIterInner.
End escape.
