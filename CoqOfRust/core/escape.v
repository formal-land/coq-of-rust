(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module escape.
  Definition value_HEX_DIGITS : Value.t :=
    M.run_constant
      ltac:(M.monadic
        (M.deref (|
          M.call_closure (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "array")
                  [ Value.Integer IntegerKind.Usize 16 ]
                  [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 16 ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                    ]
                ],
              "unwrap",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 16 ]
                          [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                      ]
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 16 ]
                    [ Ty.path "u8" ],
                  "as_ascii",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| UnsupportedLiteral |) |) |) ]
              |)
            ]
          |)
        |))).
  
  Axiom Constant_value_HEX_DIGITS : (M.get_constant "core::escape::HEX_DIGITS") = value_HEX_DIGITS.
  Global Hint Rewrite Constant_value_HEX_DIGITS : constant_rewrites.
  
  (*
  const fn backslash<const N: usize>(a: ascii::Char) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 2) };
  
      let mut output = [ascii::Char::Null; N];
  
      output[0] = ascii::Char::ReverseSolidus;
      output[1] = a;
  
      (output, 0..2)
  }
  *)
  Definition backslash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ a ] =>
      ltac:(M.monadic
        (let a := M.alloc (| a |) in
        M.read (|
          let~ _ : Ty.tuple [] := M.get_constant "core::escape::backslash_discriminant" in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            M.alloc (|
              repeat (| Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [], N |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 0 |),
                Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" []
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 1 |),
                M.read (| a |)
              |)
            |) in
          M.alloc (|
            Value.Tuple
              [
                M.read (| output |);
                Value.StructRecord
                  "core::ops::range::Range"
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 2)
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_backslash :
    M.IsFunction.Trait "core::escape::backslash" backslash.
  Admitted.
  Global Typeclasses Opaque backslash.
  
  (*
  const fn hex_escape<const N: usize>(byte: u8) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 4) };
  
      let mut output = [ascii::Char::Null; N];
  
      let hi = HEX_DIGITS[(byte >> 4) as usize];
      let lo = HEX_DIGITS[(byte & 0xf) as usize];
  
      output[0] = ascii::Char::ReverseSolidus;
      output[1] = ascii::Char::SmallX;
      output[2] = hi;
      output[3] = lo;
  
      (output, 0..4)
  }
  *)
  Definition hex_escape (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ byte ] =>
      ltac:(M.monadic
        (let byte := M.alloc (| byte |) in
        M.read (|
          let~ _ : Ty.tuple [] := M.get_constant "core::escape::hex_escape_discriminant" in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            M.alloc (|
              repeat (| Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [], N |)
            |) in
          let~ hi : Ty.path "core::ascii::ascii_char::AsciiChar" :=
            M.copy (|
              M.SubPointer.get_array_field (|
                M.get_constant "core::escape::HEX_DIGITS",
                M.cast
                  (Ty.path "usize")
                  (BinOp.Wrap.shr (| M.read (| byte |), Value.Integer IntegerKind.I32 4 |))
              |)
            |) in
          let~ lo : Ty.path "core::ascii::ascii_char::AsciiChar" :=
            M.copy (|
              M.SubPointer.get_array_field (|
                M.get_constant "core::escape::HEX_DIGITS",
                M.cast
                  (Ty.path "usize")
                  (BinOp.bit_and (M.read (| byte |)) (Value.Integer IntegerKind.U8 15))
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 0 |),
                Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" []
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 1 |),
                Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallX" []
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 2 |),
                M.read (| hi |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 3 |),
                M.read (| lo |)
              |)
            |) in
          M.alloc (|
            Value.Tuple
              [
                M.read (| output |);
                Value.StructRecord
                  "core::ops::range::Range"
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 4)
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_hex_escape :
    M.IsFunction.Trait "core::escape::hex_escape" hex_escape.
  Admitted.
  Global Typeclasses Opaque hex_escape.
  
  (*
  const fn verbatim<const N: usize>(a: ascii::Char) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 1) };
  
      let mut output = [ascii::Char::Null; N];
  
      output[0] = a;
  
      (output, 0..1)
  }
  *)
  Definition verbatim (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ a ] =>
      ltac:(M.monadic
        (let a := M.alloc (| a |) in
        M.read (|
          let~ _ : Ty.tuple [] := M.get_constant "core::escape::verbatim_discriminant" in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            M.alloc (|
              repeat (| Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [], N |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 0 |),
                M.read (| a |)
              |)
            |) in
          M.alloc (|
            Value.Tuple
              [
                M.read (| output |);
                Value.StructRecord
                  "core::ops::range::Range"
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 1)
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_verbatim :
    M.IsFunction.Trait "core::escape::verbatim" verbatim.
  Admitted.
  Global Typeclasses Opaque verbatim.
  
  (*
  const fn escape_ascii<const N: usize>(byte: u8) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 4) };
  
      #[cfg(feature = "optimize_for_size")]
      {
          match byte {
              b'\t' => backslash(ascii::Char::SmallT),
              b'\r' => backslash(ascii::Char::SmallR),
              b'\n' => backslash(ascii::Char::SmallN),
              b'\\' => backslash(ascii::Char::ReverseSolidus),
              b'\'' => backslash(ascii::Char::Apostrophe),
              b'"' => backslash(ascii::Char::QuotationMark),
              0x00..=0x1F | 0x7F => hex_escape(byte),
              _ => match ascii::Char::from_u8(byte) {
                  Some(a) => verbatim(a),
                  None => hex_escape(byte),
              },
          }
      }
  
      #[cfg(not(feature = "optimize_for_size"))]
      {
          /// Lookup table helps us determine how to display character.
          ///
          /// Since ASCII characters will always be 7 bits, we can exploit this to store the 8th bit to
          /// indicate whether the result is escaped or unescaped.
          ///
          /// We additionally use 0x80 (escaped NUL character) to indicate hex-escaped bytes, since
          /// escaped NUL will not occur.
          const LOOKUP: [u8; 256] = {
              let mut arr = [0; 256];
              let mut idx = 0;
              while idx <= 255 {
                  arr[idx] = match idx as u8 {
                      // use 8th bit to indicate escaped
                      b'\t' => 0x80 | b't',
                      b'\r' => 0x80 | b'r',
                      b'\n' => 0x80 | b'n',
                      b'\\' => 0x80 | b'\\',
                      b'\'' => 0x80 | b'\'',
                      b'"' => 0x80 | b'"',
  
                      // use NUL to indicate hex-escaped
                      0x00..=0x1F | 0x7F..=0xFF => 0x80 | b'\0',
  
                      idx => idx,
                  };
                  idx += 1;
              }
              arr
          };
  
          let lookup = LOOKUP[byte as usize];
  
          // 8th bit indicates escape
          let lookup_escaped = lookup & 0x80 != 0;
  
          // SAFETY: We explicitly mask out the eighth bit to get a 7-bit ASCII character.
          let lookup_ascii = unsafe { ascii::Char::from_u8_unchecked(lookup & 0x7F) };
  
          if lookup_escaped {
              // NUL indicates hex-escaped
              if matches!(lookup_ascii, ascii::Char::Null) {
                  hex_escape(byte)
              } else {
                  backslash(lookup_ascii)
              }
          } else {
              verbatim(lookup_ascii)
          }
      }
  }
  "
  *)
  Definition escape_ascii (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ byte ] =>
      ltac:(M.monadic
        (let byte := M.alloc (| byte |) in
        M.read (|
          let~ _ : Ty.tuple [] := M.get_constant "core::escape::escape_ascii_discriminant" in
          let~ lookup : Ty.path "u8" :=
            M.copy (|
              M.SubPointer.get_array_field (|
                M.get_constant "core::escape::escape_ascii::LOOKUP",
                M.cast (Ty.path "usize") (M.read (| byte |))
              |)
            |) in
          let~ lookup_escaped : Ty.path "bool" :=
            M.alloc (|
              BinOp.ne (|
                BinOp.bit_and (M.read (| lookup |)) (Value.Integer IntegerKind.U8 128),
                Value.Integer IntegerKind.U8 0
              |)
            |) in
          let~ lookup_ascii : Ty.path "core::ascii::ascii_char::AsciiChar" :=
            M.alloc (|
              M.call_closure (|
                Ty.path "core::ascii::ascii_char::AsciiChar",
                M.get_associated_function (|
                  Ty.path "core::ascii::ascii_char::AsciiChar",
                  "from_u8_unchecked",
                  [],
                  []
                |),
                [ BinOp.bit_and (M.read (| lookup |)) (Value.Integer IntegerKind.U8 127) ]
              |)
            |) in
          M.match_operator (|
            Some
              (Ty.tuple
                [
                  Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                ]),
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use lookup_escaped in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.match_operator (|
                    Some
                      (Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ N ]
                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                        ]),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.match_operator (|
                                Some (Ty.path "bool"),
                                lookup_ascii,
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (|
                                          γ,
                                          "core::ascii::ascii_char::AsciiChar::Null"
                                        |) in
                                      M.alloc (| Value.Bool true |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                                ]
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ N ]
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                                ],
                              M.get_function (| "core::escape::hex_escape", [ N ], [] |),
                              [ M.read (| byte |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ N ]
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                                ],
                              M.get_function (| "core::escape::backslash", [ N ], [] |),
                              [ M.read (| lookup_ascii |) ]
                            |)
                          |)))
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ N ]
                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                        ],
                      M.get_function (| "core::escape::verbatim", [ N ], [] |),
                      [ M.read (| lookup_ascii |) ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_escape_ascii :
    M.IsFunction.Trait "core::escape::escape_ascii" escape_ascii.
  Admitted.
  Global Typeclasses Opaque escape_ascii.
  
  Module escape_ascii.
    Definition value_LOOKUP : Value.t :=
      M.run_constant
        ltac:(M.monadic
          (let~ arr :
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 256 ] [ Ty.path "u8" ] :=
            M.alloc (|
              repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 256 |)
            |) in
          let~ idx : Ty.path "usize" := M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
          let~ _ : Ty.tuple [] :=
            M.loop (|
              Ty.tuple [],
              ltac:(M.monadic
                (M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.le (| M.read (| idx |), Value.Integer IntegerKind.Usize 255 |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              M.SubPointer.get_array_field (| arr, M.read (| idx |) |),
                              M.read (|
                                M.match_operator (|
                                  Some (Ty.path "u8"),
                                  M.alloc (| M.cast (Ty.path "u8") (M.read (| idx |)) |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 9
                                          |) in
                                        M.alloc (|
                                          BinOp.bit_or
                                            (Value.Integer IntegerKind.U8 128)
                                            (M.read (| UnsupportedLiteral |))
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 13
                                          |) in
                                        M.alloc (|
                                          BinOp.bit_or
                                            (Value.Integer IntegerKind.U8 128)
                                            (M.read (| UnsupportedLiteral |))
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 10
                                          |) in
                                        M.alloc (|
                                          BinOp.bit_or
                                            (Value.Integer IntegerKind.U8 128)
                                            (M.read (| UnsupportedLiteral |))
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 92
                                          |) in
                                        M.alloc (|
                                          BinOp.bit_or
                                            (Value.Integer IntegerKind.U8 128)
                                            (M.read (| UnsupportedLiteral |))
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 39
                                          |) in
                                        M.alloc (|
                                          BinOp.bit_or
                                            (Value.Integer IntegerKind.U8 128)
                                            (M.read (| UnsupportedLiteral |))
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Integer IntegerKind.U8 34
                                          |) in
                                        M.alloc (|
                                          BinOp.bit_or
                                            (Value.Integer IntegerKind.U8 128)
                                            (M.read (| UnsupportedLiteral |))
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.find_or_pattern (|
                                          γ,
                                          [
                                            fun γ => ltac:(M.monadic (Value.Tuple []));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ],
                                          fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [] =>
                                                ltac:(M.monadic
                                                  (M.alloc (|
                                                    BinOp.bit_or
                                                      (Value.Integer IntegerKind.U8 128)
                                                      (M.read (| UnsupportedLiteral |))
                                                  |)))
                                              | _ => M.impossible "wrong number of arguments"
                                              end)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let idx := M.copy (| γ |) in
                                        idx))
                                  ]
                                |)
                              |)
                            |)
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            let β := idx in
                            M.write (|
                              β,
                              BinOp.Wrap.add (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                              M.alloc (| Value.Tuple [] |)
                            |)
                          |)
                        |)))
                  ]
                |)))
            |) in
          arr)).
    
    Axiom Constant_value_LOOKUP :
      (M.get_constant "core::escape::escape_ascii::LOOKUP") = value_LOOKUP.
    Global Hint Rewrite Constant_value_LOOKUP : constant_rewrites.
  End escape_ascii.
  
  (*
  const fn escape_unicode<const N: usize>(c: char) -> ([ascii::Char; N], Range<u8>) {
      const { assert!(N >= 10 && N < u8::MAX as usize) };
  
      let c = c as u32;
  
      // OR-ing `1` ensures that for `c == 0` the code computes that
      // one digit should be printed.
      let start = (c | 1).leading_zeros() as usize / 4 - 2;
  
      let mut output = [ascii::Char::Null; N];
      output[3] = HEX_DIGITS[((c >> 20) & 15) as usize];
      output[4] = HEX_DIGITS[((c >> 16) & 15) as usize];
      output[5] = HEX_DIGITS[((c >> 12) & 15) as usize];
      output[6] = HEX_DIGITS[((c >> 8) & 15) as usize];
      output[7] = HEX_DIGITS[((c >> 4) & 15) as usize];
      output[8] = HEX_DIGITS[((c >> 0) & 15) as usize];
      output[9] = ascii::Char::RightCurlyBracket;
      output[start + 0] = ascii::Char::ReverseSolidus;
      output[start + 1] = ascii::Char::SmallU;
      output[start + 2] = ascii::Char::LeftCurlyBracket;
  
      (output, (start as u8)..(N as u8))
  }
  *)
  Definition escape_unicode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ N ], [], [ c ] =>
      ltac:(M.monadic
        (let c := M.alloc (| c |) in
        M.read (|
          let~ _ : Ty.tuple [] := M.get_constant "core::escape::escape_unicode_discriminant" in
          let~ c : Ty.path "u32" := M.alloc (| M.cast (Ty.path "u32") (M.read (| c |)) |) in
          let~ start : Ty.path "usize" :=
            M.alloc (|
              BinOp.Wrap.sub (|
                BinOp.Wrap.div (|
                  M.cast
                    (Ty.path "usize")
                    (M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (| Ty.path "u32", "leading_zeros", [], [] |),
                      [ BinOp.bit_or (M.read (| c |)) (Value.Integer IntegerKind.U32 1) ]
                    |)),
                  Value.Integer IntegerKind.Usize 4
                |),
                Value.Integer IntegerKind.Usize 2
              |)
            |) in
          let~ output :
              Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ] :=
            M.alloc (|
              repeat (| Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [], N |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 3 |),
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.get_constant "core::escape::HEX_DIGITS",
                    M.cast
                      (Ty.path "usize")
                      (BinOp.bit_and
                        (BinOp.Wrap.shr (| M.read (| c |), Value.Integer IntegerKind.I32 20 |))
                        (Value.Integer IntegerKind.U32 15))
                  |)
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 4 |),
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.get_constant "core::escape::HEX_DIGITS",
                    M.cast
                      (Ty.path "usize")
                      (BinOp.bit_and
                        (BinOp.Wrap.shr (| M.read (| c |), Value.Integer IntegerKind.I32 16 |))
                        (Value.Integer IntegerKind.U32 15))
                  |)
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 5 |),
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.get_constant "core::escape::HEX_DIGITS",
                    M.cast
                      (Ty.path "usize")
                      (BinOp.bit_and
                        (BinOp.Wrap.shr (| M.read (| c |), Value.Integer IntegerKind.I32 12 |))
                        (Value.Integer IntegerKind.U32 15))
                  |)
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 6 |),
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.get_constant "core::escape::HEX_DIGITS",
                    M.cast
                      (Ty.path "usize")
                      (BinOp.bit_and
                        (BinOp.Wrap.shr (| M.read (| c |), Value.Integer IntegerKind.I32 8 |))
                        (Value.Integer IntegerKind.U32 15))
                  |)
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 7 |),
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.get_constant "core::escape::HEX_DIGITS",
                    M.cast
                      (Ty.path "usize")
                      (BinOp.bit_and
                        (BinOp.Wrap.shr (| M.read (| c |), Value.Integer IntegerKind.I32 4 |))
                        (Value.Integer IntegerKind.U32 15))
                  |)
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 8 |),
                M.read (|
                  M.SubPointer.get_array_field (|
                    M.get_constant "core::escape::HEX_DIGITS",
                    M.cast
                      (Ty.path "usize")
                      (BinOp.bit_and
                        (BinOp.Wrap.shr (| M.read (| c |), Value.Integer IntegerKind.I32 0 |))
                        (Value.Integer IntegerKind.U32 15))
                  |)
                |)
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (| output, Value.Integer IntegerKind.Usize 9 |),
                Value.StructTuple "core::ascii::ascii_char::AsciiChar::RightCurlyBracket" []
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (|
                  output,
                  BinOp.Wrap.add (| M.read (| start |), Value.Integer IntegerKind.Usize 0 |)
                |),
                Value.StructTuple "core::ascii::ascii_char::AsciiChar::ReverseSolidus" []
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (|
                  output,
                  BinOp.Wrap.add (| M.read (| start |), Value.Integer IntegerKind.Usize 1 |)
                |),
                Value.StructTuple "core::ascii::ascii_char::AsciiChar::SmallU" []
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.write (|
                M.SubPointer.get_array_field (|
                  output,
                  BinOp.Wrap.add (| M.read (| start |), Value.Integer IntegerKind.Usize 2 |)
                |),
                Value.StructTuple "core::ascii::ascii_char::AsciiChar::LeftCurlyBracket" []
              |)
            |) in
          M.alloc (|
            Value.Tuple
              [
                M.read (| output |);
                Value.StructRecord
                  "core::ops::range::Range"
                  [
                    ("start", M.cast (Ty.path "u8") (M.read (| start |)));
                    ("end_",
                      M.cast
                        (Ty.path "u8")
                        (M.read (| M.get_constant "core::escape::escape_unicode::N" |)))
                  ]
              ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_escape_unicode :
    M.IsFunction.Trait "core::escape::escape_unicode" escape_unicode.
  Admitted.
  Global Typeclasses Opaque escape_unicode.
  
  (* StructRecord
    {
      name := "EscapeIterInner";
      const_params := [ "N" ];
      ty_params := [];
      fields :=
        [
          ("data",
            Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ]);
          ("alive", Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_core_escape_EscapeIterInner_N.
    Definition Self (N : Value.t) : Ty.t :=
      Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [].
    
    (* Clone *)
    Definition clone (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "core::escape::EscapeIterInner"
            [
              ("data",
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ N ] [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "array")
                      [ N ]
                      [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::escape::EscapeIterInner",
                            "data"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("alive",
                M.call_closure (|
                  Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::escape::EscapeIterInner",
                            "alive"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N)
        (* Instance *) [ ("clone", InstanceField.Method (clone N)) ].
  End Impl_core_clone_Clone_for_core_escape_EscapeIterInner_N.
  
  Module Impl_core_fmt_Debug_for_core_escape_EscapeIterInner_N.
    Definition Self (N : Value.t) : Ty.t :=
      Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [].
    
    (* Debug *)
    Definition fmt (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| Value.String "EscapeIterInner" |) |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "data" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::escape::EscapeIterInner",
                      "data"
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "alive" |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::escape::EscapeIterInner",
                          "alive"
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N : Value.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self N)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt N)) ].
  End Impl_core_fmt_Debug_for_core_escape_EscapeIterInner_N.
  
  Module Impl_core_escape_EscapeIterInner_N.
    Definition Self (N : Value.t) : Ty.t :=
      Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [].
    
    (*
        pub const fn backslash(c: ascii::Char) -> Self {
            let (data, range) = backslash(c);
            Self { data, alive: range }
        }
    *)
    Definition backslash (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ c ] =>
        ltac:(M.monadic
          (let c := M.alloc (| c |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ N ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                    ],
                  M.get_function (| "core::escape::backslash", [ N ], [] |),
                  [ M.read (| c |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let data := M.copy (| γ0_0 |) in
                    let range := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "core::escape::EscapeIterInner"
                        [ ("data", M.read (| data |)); ("alive", M.read (| range |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_backslash :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "backslash" (backslash N).
    Admitted.
    Global Typeclasses Opaque backslash.
    
    (*
        pub const fn ascii(c: u8) -> Self {
            let (data, range) = escape_ascii(c);
            Self { data, alive: range }
        }
    *)
    Definition ascii (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ c ] =>
        ltac:(M.monadic
          (let c := M.alloc (| c |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ N ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                    ],
                  M.get_function (| "core::escape::escape_ascii", [ N ], [] |),
                  [ M.read (| c |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let data := M.copy (| γ0_0 |) in
                    let range := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "core::escape::EscapeIterInner"
                        [ ("data", M.read (| data |)); ("alive", M.read (| range |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_ascii :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "ascii" (ascii N).
    Admitted.
    Global Typeclasses Opaque ascii.
    
    (*
        pub const fn unicode(c: char) -> Self {
            let (data, range) = escape_unicode(c);
            Self { data, alive: range }
        }
    *)
    Definition unicode (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ c ] =>
        ltac:(M.monadic
          (let c := M.alloc (| c |) in
          M.read (|
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "array")
                        [ N ]
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ];
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ]
                    ],
                  M.get_function (| "core::escape::escape_unicode", [ N ], [] |),
                  [ M.read (| c |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let data := M.copy (| γ0_0 |) in
                    let range := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "core::escape::EscapeIterInner"
                        [ ("data", M.read (| data |)); ("alive", M.read (| range |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unicode :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "unicode" (unicode N).
    Admitted.
    Global Typeclasses Opaque unicode.
    
    (*
        pub const fn empty() -> Self {
            Self { data: [ascii::Char::Null; N], alive: 0..0 }
        }
    *)
    Definition empty (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "core::escape::EscapeIterInner"
            [
              ("data",
                repeat (| Value.StructTuple "core::ascii::ascii_char::AsciiChar::Null" [], N |));
              ("alive",
                Value.StructRecord
                  "core::ops::range::Range"
                  [
                    ("start", Value.Integer IntegerKind.U8 0);
                    ("end_", Value.Integer IntegerKind.U8 0)
                  ])
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_empty :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "empty" (empty N).
    Admitted.
    Global Typeclasses Opaque empty.
    
    (*
        pub fn as_ascii(&self) -> &[ascii::Char] {
            // SAFETY: `self.alive` is guaranteed to be a valid range for indexing `self.data`.
            unsafe {
                self.data.get_unchecked(usize::from(self.alive.start)..usize::from(self.alive.end))
            }
        }
    *)
    Definition as_ascii (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                  ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                  "get_unchecked",
                  [],
                  [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::escape::EscapeIterInner",
                      "data"
                    |)
                  |);
                  Value.StructRecord
                    "core::ops::range::Range"
                    [
                      ("start",
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.path "usize",
                            [],
                            [ Ty.path "u8" ],
                            "from",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::escape::EscapeIterInner",
                                  "alive"
                                |),
                                "core::ops::range::Range",
                                "start"
                              |)
                            |)
                          ]
                        |));
                      ("end_",
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.path "usize",
                            [],
                            [ Ty.path "u8" ],
                            "from",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::escape::EscapeIterInner",
                                  "alive"
                                |),
                                "core::ops::range::Range",
                                "end"
                              |)
                            |)
                          ]
                        |))
                    ]
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_ascii :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "as_ascii" (as_ascii N).
    Admitted.
    Global Typeclasses Opaque as_ascii.
    
    (*
        pub fn as_str(&self) -> &str {
            self.as_ascii().as_str()
        }
    *)
    Definition as_str (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "slice") [] [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                  "as_str",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.path "core::ascii::ascii_char::AsciiChar" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::escape::EscapeIterInner") [ N ] [],
                          "as_ascii",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_str :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "as_str" (as_str N).
    Admitted.
    Global Typeclasses Opaque as_str.
    
    (*
        pub fn len(&self) -> usize {
            usize::from(self.alive.end - self.alive.start)
        }
    *)
    Definition len (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "core::convert::From",
              Ty.path "usize",
              [],
              [ Ty.path "u8" ],
              "from",
              [],
              []
            |),
            [
              BinOp.Wrap.sub (|
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::escape::EscapeIterInner",
                      "alive"
                    |),
                    "core::ops::range::Range",
                    "end"
                  |)
                |),
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::escape::EscapeIterInner",
                      "alive"
                    |),
                    "core::ops::range::Range",
                    "start"
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_len :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "len" (len N).
    Admitted.
    Global Typeclasses Opaque len.
    
    (*
        pub fn next(&mut self) -> Option<u8> {
            let i = self.alive.next()?;
    
            // SAFETY: `i` is guaranteed to be a valid index for `self.data`.
            unsafe { Some(self.data.get_unchecked(usize::from(i)).to_u8()) }
        }
    *)
    Definition next (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ i : Ty.path "u8" :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.path "u8"),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::convert::Infallible" ];
                              Ty.path "u8"
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                                [],
                                [],
                                "next",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::escape::EscapeIterInner",
                                    "alive"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u8" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                  "get_unchecked",
                                  [],
                                  [ Ty.path "usize" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::escape::EscapeIterInner",
                                      "data"
                                    |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "core::convert::From",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u8" ],
                                      "from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| i |) ]
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_next :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "next" (next N).
    Admitted.
    Global Typeclasses Opaque next.
    
    (*
        pub fn next_back(&mut self) -> Option<u8> {
            let i = self.alive.next_back()?;
    
            // SAFETY: `i` is guaranteed to be a valid index for `self.data`.
            unsafe { Some(self.data.get_unchecked(usize::from(i)).to_u8()) }
        }
    *)
    Definition next_back (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return (|
            ltac:(M.monadic
              (M.read (|
                let~ i : Ty.path "u8" :=
                  M.copy (|
                    M.match_operator (|
                      Some (Ty.path "u8"),
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.path "core::convert::Infallible" ];
                              Ty.path "u8"
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                              M.get_trait_method (|
                                "core::iter::traits::double_ended::DoubleEndedIterator",
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
                                [],
                                [],
                                "next_back",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::escape::EscapeIterInner",
                                    "alive"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u8" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                  "get_unchecked",
                                  [],
                                  [ Ty.path "usize" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::escape::EscapeIterInner",
                                      "data"
                                    |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "core::convert::From",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u8" ],
                                      "from",
                                      [],
                                      []
                                    |),
                                    [ M.read (| i |) ]
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_next_back :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "next_back" (next_back N).
    Admitted.
    Global Typeclasses Opaque next_back.
    
    (*
        pub fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
            self.alive.advance_by(n)
        }
    *)
    Definition advance_by (N : Value.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
              [],
              [],
              "advance_by",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::escape::EscapeIterInner",
                  "alive"
                |)
              |);
              M.read (| n |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_advance_by :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "advance_by" (advance_by N).
    Admitted.
    Global Typeclasses Opaque advance_by.
    
    (*
        pub fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
            self.alive.advance_back_by(n)
        }
    *)
    Definition advance_back_by
        (N : Value.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N in
      match ε, τ, α with
      | [], [], [ self; n ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let n := M.alloc (| n |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
              ],
            M.get_trait_method (|
              "core::iter::traits::double_ended::DoubleEndedIterator",
              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ],
              [],
              [],
              "advance_back_by",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::escape::EscapeIterInner",
                  "alive"
                |)
              |);
              M.read (| n |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_advance_back_by :
      forall (N : Value.t),
      M.IsAssociatedFunction.Trait (Self N) "advance_back_by" (advance_back_by N).
    Admitted.
    Global Typeclasses Opaque advance_back_by.
  End Impl_core_escape_EscapeIterInner_N.
End escape.
