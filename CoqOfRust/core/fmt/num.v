(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module fmt.
  Module num.
    (* Trait *)
    (* Empty module 'DisplayInt' *)
    
    Module Impl_core_fmt_num_DisplayInt_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.I8 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_i8.
    
    Module Impl_core_fmt_num_DisplayInt_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.I16 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_i16.
    
    Module Impl_core_fmt_num_DisplayInt_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.I32 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_i32.
    
    Module Impl_core_fmt_num_DisplayInt_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.I64 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_i64.
    
    Module Impl_core_fmt_num_DisplayInt_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.I128 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_i128.
    
    Module Impl_core_fmt_num_DisplayInt_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.Isize 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_isize.
    
    Module Impl_core_fmt_num_DisplayInt_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.U8 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.read (| M.use u |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.use (M.read (| self |)) |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_u8.
    
    Module Impl_core_fmt_num_DisplayInt_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.U16 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_u16.
    
    Module Impl_core_fmt_num_DisplayInt_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.U32 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_u32.
    
    Module Impl_core_fmt_num_DisplayInt_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.U64 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.use (M.read (| self |)) |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_u64.
    
    Module Impl_core_fmt_num_DisplayInt_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.U128 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.use (M.read (| self |)) |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_u128.
    
    Module Impl_core_fmt_num_DisplayInt_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*           fn zero() -> Self { 0 } *)
      Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] => ltac:(M.monadic (Value.Integer IntegerKind.Usize 0))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn from_u8(u: u8) -> Self { u as Self } *)
      Definition from_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ u ] =>
          ltac:(M.monadic
            (let u := M.alloc (| u |) in
            M.rust_cast (M.read (| u |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u8(&self) -> u8 { *self as u8 } *)
      Definition to_u8 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u64(&self) -> u64 { *self as u64 } *)
      Definition to_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*           fn to_u128(&self) -> u128 { *self as u128 } *)
      Definition to_u128 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.rust_cast (M.read (| M.read (| self |) |))))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::DisplayInt"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("zero", InstanceField.Method zero);
            ("from_u8", InstanceField.Method from_u8);
            ("to_u8", InstanceField.Method to_u8);
            ("to_u64", InstanceField.Method to_u64);
            ("to_u128", InstanceField.Method to_u128)
          ].
    End Impl_core_fmt_num_DisplayInt_for_usize.
    
    (* Trait *)
    Module GenericRadix.
      Definition fmt_int (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ self; x; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let x := M.alloc (| x |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ zero :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::fmt::num::DisplayInt", T, [], "zero", [] |),
                    []
                  |)
                |) in
              let~ is_nonnegative :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "ge", [] |),
                    [ x; zero ]
                  |)
                |) in
              let~ buf :=
                M.alloc (|
                  repeat
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ],
                        "uninit",
                        []
                      |),
                      []
                    |))
                    128
                |) in
              let~ curr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ]
                        ],
                      "len",
                      []
                    |),
                    [ (* Unsize *) M.pointer_coercion buf ]
                  |)
                |) in
              let~ base :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::fmt::num::DisplayInt", T, [], "from_u8", [] |),
                    [ M.read (| M.get_constant (| "core::fmt::num::GenericRadix::BASE" |) |) ]
                  |)
                |) in
              let~ _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use is_nonnegative in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::rev::Rev")
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ Ty.path "u8" ]
                                        ]
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ Ty.path "u8" ]
                                        ],
                                      [],
                                      "rev",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "slice")
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                [ Ty.path "u8" ]
                                            ],
                                          "iter_mut",
                                          []
                                        |),
                                        [ (* Unsize *) M.pointer_coercion buf ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let~ _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::rev::Rev")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::IterMut")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::mem::maybe_uninit::MaybeUninit")
                                                          [ Ty.path "u8" ]
                                                      ]
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let byte := M.copy (| γ0_0 |) in
                                                let~ n :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Rem",
                                                        T,
                                                        [ T ],
                                                        "rem",
                                                        []
                                                      |),
                                                      [ M.read (| x |); M.read (| base |) ]
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  M.write (|
                                                    x,
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Div",
                                                        T,
                                                        [ T ],
                                                        "div",
                                                        []
                                                      |),
                                                      [ M.read (| x |); M.read (| base |) ]
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::mem::maybe_uninit::MaybeUninit")
                                                          [ Ty.path "u8" ],
                                                        "write",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| byte |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::fmt::num::GenericRadix",
                                                            Self,
                                                            [],
                                                            "digit",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::fmt::num::DisplayInt",
                                                                T,
                                                                [],
                                                                "to_u8",
                                                                []
                                                              |),
                                                              [ n ]
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  let β := curr in
                                                  M.write (|
                                                    β,
                                                    BinOp.Wrap.sub (|
                                                      M.read (| β |),
                                                      Value.Integer IntegerKind.Usize 1
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  M.match_operator (|
                                                    M.alloc (| Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::cmp::PartialEq",
                                                                    T,
                                                                    [ T ],
                                                                    "eq",
                                                                    []
                                                                  |),
                                                                  [ x; zero ]
                                                                |)
                                                              |)) in
                                                          let _ :=
                                                            M.is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |))));
                    fun γ =>
                      ltac:(M.monadic
                        (M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::rev::Rev")
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ Ty.path "u8" ]
                                        ]
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ Ty.path "u8" ]
                                        ],
                                      [],
                                      "rev",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "slice")
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                [ Ty.path "u8" ]
                                            ],
                                          "iter_mut",
                                          []
                                        |),
                                        [ (* Unsize *) M.pointer_coercion buf ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let~ _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::rev::Rev")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::IterMut")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::mem::maybe_uninit::MaybeUninit")
                                                          [ Ty.path "u8" ]
                                                      ]
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let byte := M.copy (| γ0_0 |) in
                                                let~ n :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Sub",
                                                        T,
                                                        [ T ],
                                                        "sub",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| zero |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::arith::Rem",
                                                            T,
                                                            [ T ],
                                                            "rem",
                                                            []
                                                          |),
                                                          [ M.read (| x |); M.read (| base |) ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  M.write (|
                                                    x,
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Div",
                                                        T,
                                                        [ T ],
                                                        "div",
                                                        []
                                                      |),
                                                      [ M.read (| x |); M.read (| base |) ]
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::mem::maybe_uninit::MaybeUninit")
                                                          [ Ty.path "u8" ],
                                                        "write",
                                                        []
                                                      |),
                                                      [
                                                        M.read (| byte |);
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::fmt::num::GenericRadix",
                                                            Self,
                                                            [],
                                                            "digit",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::fmt::num::DisplayInt",
                                                                T,
                                                                [],
                                                                "to_u8",
                                                                []
                                                              |),
                                                              [ n ]
                                                            |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  let β := curr in
                                                  M.write (|
                                                    β,
                                                    BinOp.Wrap.sub (|
                                                      M.read (| β |),
                                                      Value.Integer IntegerKind.Usize 1
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  M.match_operator (|
                                                    M.alloc (| Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::cmp::PartialEq",
                                                                    T,
                                                                    [ T ],
                                                                    "eq",
                                                                    []
                                                                  |),
                                                                  [ x; zero ]
                                                                |)
                                                              |)) in
                                                          let _ :=
                                                            M.is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (| M.break (||) |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |))))
                  ]
                |) in
              let~ buf :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "array")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ]
                        ],
                      [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ] ],
                      "index",
                      []
                    |),
                    [
                      buf;
                      Value.StructRecord
                        "core::ops::range::RangeFrom"
                        [ ("start", M.read (| curr |)) ]
                    ]
                  |)
                |) in
              let~ buf :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::str::converts::from_utf8_unchecked", [] |),
                    [
                      M.call_closure (|
                        M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                [ Ty.path "u8" ],
                              "slice_as_ptr",
                              []
                            |),
                            [ M.read (| buf |) ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    [ Ty.path "u8" ]
                                ],
                              "len",
                              []
                            |),
                            [ M.read (| buf |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "pad_integral",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| is_nonnegative |);
                    M.read (| M.get_constant (| "core::fmt::num::GenericRadix::PREFIX" |) |);
                    M.read (| buf |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_fmt_int :
        M.IsProvidedMethod "core::fmt::num::GenericRadix" "fmt_int" fmt_int.
    End GenericRadix.
    
    (* StructTuple
      {
        name := "Binary";
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_core_fmt_num_Binary.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Binary".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::fmt::num::Binary" []))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_num_Binary.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_fmt_num_Binary.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Binary".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_fmt_num_Binary.
    
    Module Impl_core_cmp_PartialEq_for_core_fmt_num_Binary.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Binary".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_fmt_num_Binary.
    
    (* StructTuple
      {
        name := "Octal";
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_core_fmt_num_Octal.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Octal".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::fmt::num::Octal" []))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_num_Octal.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_fmt_num_Octal.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Octal".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_fmt_num_Octal.
    
    Module Impl_core_cmp_PartialEq_for_core_fmt_num_Octal.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Octal".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_fmt_num_Octal.
    
    (* StructTuple
      {
        name := "LowerHex";
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_core_fmt_num_LowerHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::LowerHex".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::fmt::num::LowerHex" []))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_num_LowerHex.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_fmt_num_LowerHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::LowerHex".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_fmt_num_LowerHex.
    
    Module Impl_core_cmp_PartialEq_for_core_fmt_num_LowerHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::LowerHex".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_fmt_num_LowerHex.
    
    (* StructTuple
      {
        name := "UpperHex";
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_clone_Clone_for_core_fmt_num_UpperHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::UpperHex".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructTuple "core::fmt::num::UpperHex" []))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_num_UpperHex.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_fmt_num_UpperHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::UpperHex".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_fmt_num_UpperHex.
    
    Module Impl_core_cmp_PartialEq_for_core_fmt_num_UpperHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::UpperHex".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            Value.Bool true))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_fmt_num_UpperHex.
    
    Module Impl_core_fmt_num_GenericRadix_for_core_fmt_num_Binary.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Binary".
      
      (*             const BASE: u8 = $base; *)
      (* Ty.path "u8" *)
      Definition value_BASE : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 2 |))).
      
      (*             const PREFIX: &'static str = $prefix; *)
      (* Ty.apply (Ty.path "&") [ Ty.path "str" ] *)
      Definition value_PREFIX : Value.t := M.run ltac:(M.monadic (Value.String "0b")).
      
      (*
                  fn digit(x: u8) -> u8 {
                      match x {
                          $($x => $conv,)+
                          x => panic!("number not in the range 0..={}: {}", Self::BASE - 1, x),
                      }
                  }
      *)
      Definition digit (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              M.match_operator (|
                x,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        BinOp.Wrap.add (| M.read (| UnsupportedLiteral |), M.read (| x |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "number not in the range 0..=" |);
                                          M.read (| Value.String ": " |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.alloc (|
                                                BinOp.Wrap.sub (|
                                                  M.read (|
                                                    M.get_constant (|
                                                      "core::fmt::num::GenericRadix::BASE"
                                                    |)
                                                  |),
                                                  Value.Integer IntegerKind.U8 1
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [ x ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::GenericRadix"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("value_BASE", InstanceField.Constant value_BASE);
            ("value_PREFIX", InstanceField.Constant value_PREFIX);
            ("digit", InstanceField.Method digit)
          ].
    End Impl_core_fmt_num_GenericRadix_for_core_fmt_num_Binary.
    
    Module Impl_core_fmt_num_GenericRadix_for_core_fmt_num_Octal.
      Definition Self : Ty.t := Ty.path "core::fmt::num::Octal".
      
      (*             const BASE: u8 = $base; *)
      (* Ty.path "u8" *)
      Definition value_BASE : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 8 |))).
      
      (*             const PREFIX: &'static str = $prefix; *)
      (* Ty.apply (Ty.path "&") [ Ty.path "str" ] *)
      Definition value_PREFIX : Value.t := M.run ltac:(M.monadic (Value.String "0o")).
      
      (*
                  fn digit(x: u8) -> u8 {
                      match x {
                          $($x => $conv,)+
                          x => panic!("number not in the range 0..={}: {}", Self::BASE - 1, x),
                      }
                  }
      *)
      Definition digit (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              M.match_operator (|
                x,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        BinOp.Wrap.add (| M.read (| UnsupportedLiteral |), M.read (| x |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "number not in the range 0..=" |);
                                          M.read (| Value.String ": " |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.alloc (|
                                                BinOp.Wrap.sub (|
                                                  M.read (|
                                                    M.get_constant (|
                                                      "core::fmt::num::GenericRadix::BASE"
                                                    |)
                                                  |),
                                                  Value.Integer IntegerKind.U8 1
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [ x ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::GenericRadix"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("value_BASE", InstanceField.Constant value_BASE);
            ("value_PREFIX", InstanceField.Constant value_PREFIX);
            ("digit", InstanceField.Method digit)
          ].
    End Impl_core_fmt_num_GenericRadix_for_core_fmt_num_Octal.
    
    Module Impl_core_fmt_num_GenericRadix_for_core_fmt_num_LowerHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::LowerHex".
      
      (*             const BASE: u8 = $base; *)
      (* Ty.path "u8" *)
      Definition value_BASE : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 16 |))).
      
      (*             const PREFIX: &'static str = $prefix; *)
      (* Ty.apply (Ty.path "&") [ Ty.path "str" ] *)
      Definition value_PREFIX : Value.t := M.run ltac:(M.monadic (Value.String "0x")).
      
      (*
                  fn digit(x: u8) -> u8 {
                      match x {
                          $($x => $conv,)+
                          x => panic!("number not in the range 0..={}: {}", Self::BASE - 1, x),
                      }
                  }
      *)
      Definition digit (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              M.match_operator (|
                x,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        BinOp.Wrap.add (| M.read (| UnsupportedLiteral |), M.read (| x |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        BinOp.Wrap.add (|
                          M.read (| UnsupportedLiteral |),
                          BinOp.Wrap.sub (| M.read (| x |), Value.Integer IntegerKind.U8 10 |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "number not in the range 0..=" |);
                                          M.read (| Value.String ": " |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.alloc (|
                                                BinOp.Wrap.sub (|
                                                  M.read (|
                                                    M.get_constant (|
                                                      "core::fmt::num::GenericRadix::BASE"
                                                    |)
                                                  |),
                                                  Value.Integer IntegerKind.U8 1
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [ x ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::GenericRadix"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("value_BASE", InstanceField.Constant value_BASE);
            ("value_PREFIX", InstanceField.Constant value_PREFIX);
            ("digit", InstanceField.Method digit)
          ].
    End Impl_core_fmt_num_GenericRadix_for_core_fmt_num_LowerHex.
    
    Module Impl_core_fmt_num_GenericRadix_for_core_fmt_num_UpperHex.
      Definition Self : Ty.t := Ty.path "core::fmt::num::UpperHex".
      
      (*             const BASE: u8 = $base; *)
      (* Ty.path "u8" *)
      Definition value_BASE : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 16 |))).
      
      (*             const PREFIX: &'static str = $prefix; *)
      (* Ty.apply (Ty.path "&") [ Ty.path "str" ] *)
      Definition value_PREFIX : Value.t := M.run ltac:(M.monadic (Value.String "0x")).
      
      (*
                  fn digit(x: u8) -> u8 {
                      match x {
                          $($x => $conv,)+
                          x => panic!("number not in the range 0..={}: {}", Self::BASE - 1, x),
                      }
                  }
      *)
      Definition digit (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.read (|
              M.match_operator (|
                x,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        BinOp.Wrap.add (| M.read (| UnsupportedLiteral |), M.read (| x |) |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        BinOp.Wrap.add (|
                          M.read (| UnsupportedLiteral |),
                          BinOp.Wrap.sub (| M.read (| x |), Value.Integer IntegerKind.U8 10 |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let x := M.copy (| γ |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (| Value.String "number not in the range 0..=" |);
                                          M.read (| Value.String ": " |)
                                        ]
                                    |));
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.alloc (|
                                                BinOp.Wrap.sub (|
                                                  M.read (|
                                                    M.get_constant (|
                                                      "core::fmt::num::GenericRadix::BASE"
                                                    |)
                                                  |),
                                                  Value.Integer IntegerKind.U8 1
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [ Ty.path "u8" ]
                                            |),
                                            [ x ]
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::num::GenericRadix"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("value_BASE", InstanceField.Constant value_BASE);
            ("value_PREFIX", InstanceField.Constant value_PREFIX);
            ("digit", InstanceField.Method digit)
          ].
    End Impl_core_fmt_num_GenericRadix_for_core_fmt_num_UpperHex.
    
    Module Impl_core_fmt_Binary_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_isize.
    
    Module Impl_core_fmt_Octal_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_isize.
    
    Module Impl_core_fmt_LowerHex_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_isize.
    
    Module Impl_core_fmt_UpperHex_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_isize.
    
    Module Impl_core_fmt_Binary_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_usize.
    
    Module Impl_core_fmt_Octal_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_usize.
    
    Module Impl_core_fmt_LowerHex_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_usize.
    
    Module Impl_core_fmt_UpperHex_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "usize" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_usize.
    
    Module Impl_core_fmt_Binary_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_i8.
    
    Module Impl_core_fmt_Octal_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_i8.
    
    Module Impl_core_fmt_LowerHex_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_i8.
    
    Module Impl_core_fmt_UpperHex_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_i8.
    
    Module Impl_core_fmt_Binary_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_u8.
    
    Module Impl_core_fmt_Octal_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_u8.
    
    Module Impl_core_fmt_LowerHex_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_u8.
    
    Module Impl_core_fmt_UpperHex_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u8" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_u8.
    
    Module Impl_core_fmt_Binary_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_i16.
    
    Module Impl_core_fmt_Octal_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_i16.
    
    Module Impl_core_fmt_LowerHex_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_i16.
    
    Module Impl_core_fmt_UpperHex_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_i16.
    
    Module Impl_core_fmt_Binary_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_u16.
    
    Module Impl_core_fmt_Octal_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_u16.
    
    Module Impl_core_fmt_LowerHex_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_u16.
    
    Module Impl_core_fmt_UpperHex_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u16" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_u16.
    
    Module Impl_core_fmt_Binary_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_i32.
    
    Module Impl_core_fmt_Octal_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_i32.
    
    Module Impl_core_fmt_LowerHex_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_i32.
    
    Module Impl_core_fmt_UpperHex_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_i32.
    
    Module Impl_core_fmt_Binary_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_u32.
    
    Module Impl_core_fmt_Octal_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_u32.
    
    Module Impl_core_fmt_LowerHex_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_u32.
    
    Module Impl_core_fmt_UpperHex_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u32" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_u32.
    
    Module Impl_core_fmt_Binary_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_i64.
    
    Module Impl_core_fmt_Octal_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_i64.
    
    Module Impl_core_fmt_LowerHex_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_i64.
    
    Module Impl_core_fmt_UpperHex_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_i64.
    
    Module Impl_core_fmt_Binary_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_u64.
    
    Module Impl_core_fmt_Octal_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_u64.
    
    Module Impl_core_fmt_LowerHex_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_u64.
    
    Module Impl_core_fmt_UpperHex_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u64" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_u64.
    
    Module Impl_core_fmt_Binary_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_i128.
    
    Module Impl_core_fmt_Octal_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_i128.
    
    Module Impl_core_fmt_LowerHex_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_i128.
    
    Module Impl_core_fmt_UpperHex_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.rust_cast (M.read (| M.read (| self |) |));
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_i128.
    
    Module Impl_core_fmt_Binary_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Binary",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Binary" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Binary"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Binary_for_u128.
    
    Module Impl_core_fmt_Octal_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::Octal",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::Octal" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Octal"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Octal_for_u128.
    
    Module Impl_core_fmt_LowerHex_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::LowerHex",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::LowerHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerHex_for_u128.
    
    Module Impl_core_fmt_UpperHex_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      $Radix.fmt_int( *self as $U, f)
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::fmt::num::GenericRadix",
                Ty.path "core::fmt::num::UpperHex",
                [],
                "fmt_int",
                [ Ty.path "u128" ]
              |),
              [
                M.alloc (| Value.StructTuple "core::fmt::num::UpperHex" [] |);
                M.read (| M.use (M.read (| self |)) |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperHex"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperHex_for_u128.
    
    Module Impl_core_fmt_Debug_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "i8",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "i8",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "i8",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_i8.
    
    Module Impl_core_fmt_Debug_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "i16",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "i16",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "i16",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_i16.
    
    Module Impl_core_fmt_Debug_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "i32",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "i32",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "i32",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_i32.
    
    Module Impl_core_fmt_Debug_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "i64",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "i64",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "i64",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_i64.
    
    Module Impl_core_fmt_Debug_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "i128",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "i128",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "i128",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_i128.
    
    Module Impl_core_fmt_Debug_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "isize",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "isize",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "isize",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_isize.
    
    Module Impl_core_fmt_Debug_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "u8",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "u8",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "u8",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_u8.
    
    Module Impl_core_fmt_Debug_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "u16",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "u16",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "u16",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_u16.
    
    Module Impl_core_fmt_Debug_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "u32",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "u32",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "u32",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_u32.
    
    Module Impl_core_fmt_Debug_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "u64",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "u64",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "u64",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_u64.
    
    Module Impl_core_fmt_Debug_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "u128",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "u128",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "u128",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_u128.
    
    Module Impl_core_fmt_Debug_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                  fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                      if f.debug_lower_hex() {
                          fmt::LowerHex::fmt(self, f)
                      } else if f.debug_upper_hex() {
                          fmt::UpperHex::fmt(self, f)
                      } else {
                          fmt::Display::fmt(self, f)
                      }
                  }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "debug_lower_hex",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::fmt::LowerHex",
                            Ty.path "usize",
                            [],
                            "fmt",
                            []
                          |),
                          [ M.read (| self |); M.read (| f |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_upper_hex",
                                        []
                                      |),
                                      [ M.read (| f |) ]
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::UpperHex",
                                    Ty.path "usize",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::fmt::Display",
                                    Ty.path "usize",
                                    [],
                                    "fmt",
                                    []
                                  |),
                                  [ M.read (| self |); M.read (| f |) ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_usize.
    
    Definition value_DEC_DIGITS_LUT : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| UnsupportedLiteral |))).
    
    Module imp.
      (*
              fn $name(mut n: $u, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                  // 2^128 is about 3*10^38, so 39 gives an extra byte of space
                  let mut buf = [MaybeUninit::<u8>::uninit(); 39];
                  let mut curr = buf.len();
                  let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);
                  let lut_ptr = DEC_DIGITS_LUT.as_ptr();
      
                  // SAFETY: Since `d1` and `d2` are always less than or equal to `198`, we
                  // can copy from `lut_ptr[d1..d1 + 1]` and `lut_ptr[d2..d2 + 1]`. To show
                  // that it's OK to copy into `buf_ptr`, notice that at the beginning
                  // `curr == buf.len() == 39 > log(n)` since `n < 2^128 < 10^39`, and at
                  // each step this is kept the same as `n` is divided. Since `n` is always
                  // non-negative, this means that `curr > 0` so `buf_ptr[curr..curr + 1]`
                  // is safe to access.
                  unsafe {
                      // need at least 16 bits for the 4-characters-at-a-time to work.
                      assert!(crate::mem::size_of::<$u>() >= 2);
      
                      // eagerly decode 4 characters at a time
                      while n >= 10000 {
                          let rem = (n % 10000) as usize;
                          n /= 10000;
      
                          let d1 = (rem / 100) << 1;
                          let d2 = (rem % 100) << 1;
                          curr -= 4;
      
                          // We are allowed to copy to `buf_ptr[curr..curr + 3]` here since
                          // otherwise `curr < 0`. But then `n` was originally at least `10000^10`
                          // which is `10^40 > 2^128 > n`.
                          ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);
                          ptr::copy_nonoverlapping(lut_ptr.add(d2), buf_ptr.add(curr + 2), 2);
                      }
      
                      // if we reach here numbers are <= 9999, so at most 4 chars long
                      let mut n = n as usize; // possibly reduce 64bit math
      
                      // decode 2 more chars, if > 2 chars
                      if n >= 100 {
                          let d1 = (n % 100) << 1;
                          n /= 100;
                          curr -= 2;
                          ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);
                      }
      
                      // decode last 1 or 2 chars
                      if n < 10 {
                          curr -= 1;
                          *buf_ptr.add(curr) = (n as u8) + b'0';
                      } else {
                          let d1 = n << 1;
                          curr -= 2;
                          ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);
                      }
                  }
      
                  // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid
                  // UTF-8 since `DEC_DIGITS_LUT` is
                  let buf_slice = unsafe {
                      str::from_utf8_unchecked(
                          slice::from_raw_parts(buf_ptr.add(curr), buf.len() - curr))
                  };
                  f.pad_integral(is_nonnegative, "", buf_slice)
              }
      *)
      Definition fmt_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n; is_nonnegative; f ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            let is_nonnegative := M.alloc (| is_nonnegative |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ buf :=
                M.alloc (|
                  repeat
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ],
                        "uninit",
                        []
                      |),
                      []
                    |))
                    39
                |) in
              let~ curr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ]
                        ],
                      "len",
                      []
                    |),
                    [ (* Unsize *) M.pointer_coercion buf ]
                  |)
                |) in
              let~ buf_ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ],
                      "slice_as_mut_ptr",
                      []
                    |),
                    [ (* Unsize *) M.pointer_coercion buf ]
                  |)
                |) in
              let~ lut_ptr :=
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                      "as_ptr",
                      []
                    |),
                    [
                      (* Unsize *)
                      M.pointer_coercion
                        (M.read (|
                          M.read (| M.get_constant (| "core::fmt::num::DEC_DIGITS_LUT" |) |)
                        |))
                    ]
                  |)
                |) in
              let~ _ :=
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  BinOp.ge (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::size_of", [ Ty.path "u64" ] |),
                                      []
                                    |),
                                    Value.Integer IntegerKind.Usize 2
                                  |)
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                M.get_function (| "core::panicking::panic", [] |),
                                [
                                  M.read (|
                                    Value.String
                                      "assertion failed: crate::mem::size_of::<u64>() >= 2"
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.ge (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.U64 10000
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ rem :=
                                M.alloc (|
                                  M.rust_cast
                                    (BinOp.Wrap.rem (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.U64 10000
                                    |))
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.U64 10000
                                  |)
                                |) in
                              let~ d1 :=
                                M.alloc (|
                                  BinOp.Wrap.shl (|
                                    BinOp.Wrap.div (|
                                      M.read (| rem |),
                                      Value.Integer IntegerKind.Usize 100
                                    |),
                                    Value.Integer IntegerKind.I32 1
                                  |)
                                |) in
                              let~ d2 :=
                                M.alloc (|
                                  BinOp.Wrap.shl (|
                                    BinOp.Wrap.rem (|
                                      M.read (| rem |),
                                      Value.Integer IntegerKind.Usize 100
                                    |),
                                    Value.Integer IntegerKind.I32 1
                                  |)
                                |) in
                              let~ _ :=
                                let β := curr in
                                M.write (|
                                  β,
                                  BinOp.Wrap.sub (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.Usize 4
                                  |)
                                |) in
                              let~ _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::copy_nonoverlapping",
                                      [ Ty.path "u8" ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                          "add",
                                          []
                                        |),
                                        [ M.read (| lut_ptr |); M.read (| d1 |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                          "add",
                                          []
                                        |),
                                        [ M.read (| buf_ptr |); M.read (| curr |) ]
                                      |);
                                      Value.Integer IntegerKind.Usize 2
                                    ]
                                  |)
                                |) in
                              let~ _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::copy_nonoverlapping",
                                      [ Ty.path "u8" ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                          "add",
                                          []
                                        |),
                                        [ M.read (| lut_ptr |); M.read (| d2 |) ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                          "add",
                                          []
                                        |),
                                        [
                                          M.read (| buf_ptr |);
                                          BinOp.Wrap.add (|
                                            M.read (| curr |),
                                            Value.Integer IntegerKind.Usize 2
                                          |)
                                        ]
                                      |);
                                      Value.Integer IntegerKind.Usize 2
                                    ]
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                let~ n := M.alloc (| M.rust_cast (M.read (| n |)) |) in
                let~ _ :=
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.ge (| M.read (| n |), Value.Integer IntegerKind.Usize 100 |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ d1 :=
                            M.alloc (|
                              BinOp.Wrap.shl (|
                                BinOp.Wrap.rem (|
                                  M.read (| n |),
                                  Value.Integer IntegerKind.Usize 100
                                |),
                                Value.Integer IntegerKind.I32 1
                              |)
                            |) in
                          let~ _ :=
                            let β := n in
                            M.write (|
                              β,
                              BinOp.Wrap.div (|
                                M.read (| β |),
                                Value.Integer IntegerKind.Usize 100
                              |)
                            |) in
                          let~ _ :=
                            let β := curr in
                            M.write (|
                              β,
                              BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 2 |)
                            |) in
                          let~ _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::intrinsics::copy_nonoverlapping",
                                  [ Ty.path "u8" ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                      "add",
                                      []
                                    |),
                                    [ M.read (| lut_ptr |); M.read (| d1 |) ]
                                  |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "add",
                                      []
                                    |),
                                    [ M.read (| buf_ptr |); M.read (| curr |) ]
                                  |);
                                  Value.Integer IntegerKind.Usize 2
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.lt (| M.read (| n |), Value.Integer IntegerKind.Usize 10 |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ :=
                          let β := curr in
                          M.write (|
                            β,
                            BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                          |) in
                        let~ _ :=
                          M.write (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                "add",
                                []
                              |),
                              [ M.read (| buf_ptr |); M.read (| curr |) ]
                            |),
                            BinOp.Wrap.add (|
                              M.rust_cast (M.read (| n |)),
                              M.read (| UnsupportedLiteral |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let~ d1 :=
                          M.alloc (|
                            BinOp.Wrap.shl (| M.read (| n |), Value.Integer IntegerKind.I32 1 |)
                          |) in
                        let~ _ :=
                          let β := curr in
                          M.write (|
                            β,
                            BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 2 |)
                          |) in
                        let~ _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::copy_nonoverlapping",
                                [ Ty.path "u8" ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                    "add",
                                    []
                                  |),
                                  [ M.read (| lut_ptr |); M.read (| d1 |) ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                    "add",
                                    []
                                  |),
                                  [ M.read (| buf_ptr |); M.read (| curr |) ]
                                |);
                                Value.Integer IntegerKind.Usize 2
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ buf_slice :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::str::converts::from_utf8_unchecked", [] |),
                    [
                      M.call_closure (|
                        M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                        [
                          (* MutToConstPointer *)
                          M.pointer_coercion
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                "add",
                                []
                              |),
                              [ M.read (| buf_ptr |); M.read (| curr |) ]
                            |));
                          BinOp.Wrap.sub (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      [ Ty.path "u8" ]
                                  ],
                                "len",
                                []
                              |),
                              [ (* Unsize *) M.pointer_coercion buf ]
                            |),
                            M.read (| curr |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "pad_integral",
                    []
                  |),
                  [
                    M.read (| f |);
                    M.read (| is_nonnegative |);
                    M.read (| Value.String "" |);
                    M.read (| buf_slice |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Function_fmt_u64 : M.IsFunction "core::fmt::num::imp::fmt_u64" fmt_u64.
      
      Module Impl_core_fmt_Display_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I8 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i8",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i8",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_i8.
      
      Module Impl_core_fmt_Display_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U8 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u8",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u8",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_u8.
      
      Module Impl_core_fmt_Display_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I16 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i16",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i16",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_i16.
      
      Module Impl_core_fmt_Display_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U16 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u16",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u16",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_u16.
      
      Module Impl_core_fmt_Display_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I32 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i32",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i32",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_i32.
      
      Module Impl_core_fmt_Display_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U32 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u32",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u32",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_u32.
      
      Module Impl_core_fmt_Display_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I64 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i64",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i64",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_i64.
      
      Module Impl_core_fmt_Display_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U64 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u64",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u64",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_u64.
      
      Module Impl_core_fmt_Display_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.Usize 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "usize",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "usize",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_usize.
      
      Module Impl_core_fmt_Display_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*
                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                        let is_nonnegative = *self >= 0;
                        let n = if is_nonnegative {
                            self.$conv_fn()
                        } else {
                            // convert the negative num to positive by summing 1 to it's 2 complement
                            (!self.$conv_fn()).wrapping_add(1)
                        };
                        $name(n, is_nonnegative, f)
                    }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.Isize 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "isize",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "isize",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::fmt_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Display"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Display_for_isize.
      
      (*
              fn $name(
                  mut n: $u,
                  is_nonnegative: bool,
                  upper: bool,
                  f: &mut fmt::Formatter<'_>
              ) -> fmt::Result {
                  let (mut n, mut exponent, trailing_zeros, added_precision) = {
                      let mut exponent = 0;
                      // count and remove trailing decimal zeroes
                      while n % 10 == 0 && n >= 10 {
                          n /= 10;
                          exponent += 1;
                      }
                      let (added_precision, subtracted_precision) = match f.precision() {
                          Some(fmt_prec) => {
                              // number of decimal digits minus 1
                              let mut tmp = n;
                              let mut prec = 0;
                              while tmp >= 10 {
                                  tmp /= 10;
                                  prec += 1;
                              }
                              (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))
                          }
                          None => (0, 0)
                      };
                      for _ in 1..subtracted_precision {
                          n /= 10;
                          exponent += 1;
                      }
                      if subtracted_precision != 0 {
                          let rem = n % 10;
                          n /= 10;
                          exponent += 1;
                          // round up last digit, round to even on a tie
                          if rem > 5 || (rem == 5 && (n % 2 != 0 || subtracted_precision > 1 )) {
                              n += 1;
                              // if the digit is rounded to the next power
                              // instead adjust the exponent
                              if n.ilog10() > (n - 1).ilog10() {
                                  n /= 10;
                                  exponent += 1;
                              }
                          }
                      }
                      (n, exponent, exponent, added_precision)
                  };
      
                  // 39 digits (worst case u128) + . = 40
                  // Since `curr` always decreases by the number of digits copied, this means
                  // that `curr >= 0`.
                  let mut buf = [MaybeUninit::<u8>::uninit(); 40];
                  let mut curr = buf.len(); //index for buf
                  let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);
                  let lut_ptr = DEC_DIGITS_LUT.as_ptr();
      
                  // decode 2 chars at a time
                  while n >= 100 {
                      let d1 = ((n % 100) as usize) << 1;
                      curr -= 2;
                      // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since
                      // `DEC_DIGITS_LUT` has a length of 200.
                      unsafe {
                          ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);
                      }
                      n /= 100;
                      exponent += 2;
                  }
                  // n is <= 99, so at most 2 chars long
                  let mut n = n as isize; // possibly reduce 64bit math
                  // decode second-to-last character
                  if n >= 10 {
                      curr -= 1;
                      // SAFETY: Safe since `40 > curr >= 0` (see comment)
                      unsafe {
                          *buf_ptr.add(curr) = (n as u8 % 10_u8) + b'0';
                      }
                      n /= 10;
                      exponent += 1;
                  }
                  // add decimal point iff >1 mantissa digit will be printed
                  if exponent != trailing_zeros || added_precision != 0 {
                      curr -= 1;
                      // SAFETY: Safe since `40 > curr >= 0`
                      unsafe {
                          *buf_ptr.add(curr) = b'.';
                      }
                  }
      
                  // SAFETY: Safe since `40 > curr >= 0`
                  let buf_slice = unsafe {
                      // decode last character
                      curr -= 1;
                      *buf_ptr.add(curr) = (n as u8) + b'0';
      
                      let len = buf.len() - curr as usize;
                      slice::from_raw_parts(buf_ptr.add(curr), len)
                  };
      
                  // stores 'e' (or 'E') and the up to 2-digit exponent
                  let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];
                  let exp_ptr = MaybeUninit::slice_as_mut_ptr(&mut exp_buf);
                  // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`
                  // is contained within `exp_buf` since `len <= 3`.
                  let exp_slice = unsafe {
                      *exp_ptr.add(0) = if upper { b'E' } else { b'e' };
                      let len = if exponent < 10 {
                          *exp_ptr.add(1) = (exponent as u8) + b'0';
                          2
                      } else {
                          let off = exponent << 1;
                          ptr::copy_nonoverlapping(lut_ptr.add(off), exp_ptr.add(1), 2);
                          3
                      };
                      slice::from_raw_parts(exp_ptr, len)
                  };
      
                  let parts = &[
                      numfmt::Part::Copy(buf_slice),
                      numfmt::Part::Zero(added_precision),
                      numfmt::Part::Copy(exp_slice),
                  ];
                  let sign = if !is_nonnegative {
                      "-"
                  } else if f.sign_plus() {
                      "+"
                  } else {
                      ""
                  };
                  let formatted = numfmt::Formatted { sign, parts };
                  // SAFETY: `buf_slice` and `exp_slice` contain only ASCII characters.
                  unsafe { f.pad_formatted_parts(&formatted) }
              }
      *)
      Definition exp_u64 (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ n; is_nonnegative; upper; f ] =>
          ltac:(M.monadic
            (let n := M.alloc (| n |) in
            let is_nonnegative := M.alloc (| is_nonnegative |) in
            let upper := M.alloc (| upper |) in
            let f := M.alloc (| f |) in
            M.read (|
              M.match_operator (|
                let~ exponent := M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                let~ _ :=
                  M.loop (|
                    ltac:(M.monadic
                      (M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.and (|
                                      BinOp.eq (|
                                        BinOp.Wrap.rem (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U64 10
                                        |),
                                        Value.Integer IntegerKind.U64 0
                                      |),
                                      ltac:(M.monadic
                                        (BinOp.ge (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U64 10
                                        |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.U64 10
                                  |)
                                |) in
                              let~ _ :=
                                let β := exponent in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let~ _ :=
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)
                                  |)
                                |)
                              |)))
                        ]
                      |)))
                  |) in
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "precision",
                          []
                        |),
                        [ M.read (| f |) ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let fmt_prec := M.copy (| γ0_0 |) in
                          let~ tmp := M.copy (| n |) in
                          let~ prec := M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                          let~ _ :=
                            M.loop (|
                              ltac:(M.monadic
                                (M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              BinOp.ge (|
                                                M.read (| tmp |),
                                                Value.Integer IntegerKind.U64 10
                                              |)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := tmp in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.div (|
                                              M.read (| β |),
                                              Value.Integer IntegerKind.U64 10
                                            |)
                                          |) in
                                        let~ _ :=
                                          let β := prec in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.add (|
                                              M.read (| β |),
                                              Value.Integer IntegerKind.Usize 1
                                            |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              let~ _ :=
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)))
                            |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "saturating_sub",
                                    []
                                  |),
                                  [ M.read (| fmt_prec |); M.read (| prec |) ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "saturating_sub",
                                    []
                                  |),
                                  [ M.read (| prec |); M.read (| fmt_prec |) ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                          M.alloc (|
                            Value.Tuple
                              [ Value.Integer IntegerKind.Usize 0; Value.Integer IntegerKind.Usize 0
                              ]
                          |)))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let added_precision := M.copy (| γ0_0 |) in
                        let subtracted_precision := M.copy (| γ0_1 |) in
                        let~ _ :=
                          M.use
                            (M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::collect::IntoIterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      [ Ty.path "usize" ],
                                    [],
                                    "into_iter",
                                    []
                                  |),
                                  [
                                    Value.StructRecord
                                      "core::ops::range::Range"
                                      [
                                        ("start", Value.Integer IntegerKind.Usize 1);
                                        ("end_", M.read (| subtracted_precision |))
                                      ]
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let iter := M.copy (| γ |) in
                                    M.loop (|
                                      ltac:(M.monadic
                                        (let~ _ :=
                                          M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::ops::range::Range")
                                                    [ Ty.path "usize" ],
                                                  [],
                                                  "next",
                                                  []
                                                |),
                                                [ iter ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let _ :=
                                                    M.is_struct_tuple (|
                                                      γ,
                                                      "core::option::Option::None"
                                                    |) in
                                                  M.alloc (|
                                                    M.never_to_any (| M.read (| M.break (||) |) |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 :=
                                                    M.SubPointer.get_struct_tuple_field (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let~ _ :=
                                                    let β := n in
                                                    M.write (|
                                                      β,
                                                      BinOp.Wrap.div (|
                                                        M.read (| β |),
                                                        Value.Integer IntegerKind.U64 10
                                                      |)
                                                    |) in
                                                  let~ _ :=
                                                    let β := exponent in
                                                    M.write (|
                                                      β,
                                                      BinOp.Wrap.add (|
                                                        M.read (| β |),
                                                        Value.Integer IntegerKind.Usize 1
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |) in
                                        M.alloc (| Value.Tuple [] |)))
                                    |)))
                              ]
                            |)) in
                        let~ _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.ne (|
                                          M.read (| subtracted_precision |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ rem :=
                                    M.alloc (|
                                      BinOp.Wrap.rem (|
                                        M.read (| n |),
                                        Value.Integer IntegerKind.U64 10
                                      |)
                                    |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div (|
                                        M.read (| β |),
                                        Value.Integer IntegerKind.U64 10
                                      |)
                                    |) in
                                  let~ _ :=
                                    let β := exponent in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add (|
                                        M.read (| β |),
                                        Value.Integer IntegerKind.Usize 1
                                      |)
                                    |) in
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                LogicalOp.or (|
                                                  BinOp.gt (|
                                                    M.read (| rem |),
                                                    Value.Integer IntegerKind.U64 5
                                                  |),
                                                  ltac:(M.monadic
                                                    (LogicalOp.and (|
                                                      BinOp.eq (|
                                                        M.read (| rem |),
                                                        Value.Integer IntegerKind.U64 5
                                                      |),
                                                      ltac:(M.monadic
                                                        (LogicalOp.or (|
                                                          BinOp.ne (|
                                                            BinOp.Wrap.rem (|
                                                              M.read (| n |),
                                                              Value.Integer IntegerKind.U64 2
                                                            |),
                                                            Value.Integer IntegerKind.U64 0
                                                          |),
                                                          ltac:(M.monadic
                                                            (BinOp.gt (|
                                                              M.read (| subtracted_precision |),
                                                              Value.Integer IntegerKind.Usize 1
                                                            |)))
                                                        |)))
                                                    |)))
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ :=
                                            let β := n in
                                            M.write (|
                                              β,
                                              BinOp.Wrap.add (|
                                                M.read (| β |),
                                                Value.Integer IntegerKind.U64 1
                                              |)
                                            |) in
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        BinOp.gt (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "u64",
                                                              "ilog10",
                                                              []
                                                            |),
                                                            [ M.read (| n |) ]
                                                          |),
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "u64",
                                                              "ilog10",
                                                              []
                                                            |),
                                                            [
                                                              BinOp.Wrap.sub (|
                                                                M.read (| n |),
                                                                Value.Integer IntegerKind.U64 1
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)) in
                                                  let _ :=
                                                    M.is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  let~ _ :=
                                                    let β := n in
                                                    M.write (|
                                                      β,
                                                      BinOp.Wrap.div (|
                                                        M.read (| β |),
                                                        Value.Integer IntegerKind.U64 10
                                                      |)
                                                    |) in
                                                  let~ _ :=
                                                    let β := exponent in
                                                    M.write (|
                                                      β,
                                                      BinOp.Wrap.add (|
                                                        M.read (| β |),
                                                        Value.Integer IntegerKind.Usize 1
                                                      |)
                                                    |) in
                                                  M.alloc (| Value.Tuple [] |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              M.read (| n |);
                              M.read (| exponent |);
                              M.read (| exponent |);
                              M.read (| added_precision |)
                            ]
                        |)))
                  ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let n := M.copy (| γ0_0 |) in
                      let exponent := M.copy (| γ0_1 |) in
                      let trailing_zeros := M.copy (| γ0_2 |) in
                      let added_precision := M.copy (| γ0_3 |) in
                      let~ buf :=
                        M.alloc (|
                          repeat
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  [ Ty.path "u8" ],
                                "uninit",
                                []
                              |),
                              []
                            |))
                            40
                        |) in
                      let~ curr :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    [ Ty.path "u8" ]
                                ],
                              "len",
                              []
                            |),
                            [ (* Unsize *) M.pointer_coercion buf ]
                          |)
                        |) in
                      let~ buf_ptr :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                [ Ty.path "u8" ],
                              "slice_as_mut_ptr",
                              []
                            |),
                            [ (* Unsize *) M.pointer_coercion buf ]
                          |)
                        |) in
                      let~ lut_ptr :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                              "as_ptr",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.read (|
                                  M.read (| M.get_constant (| "core::fmt::num::DEC_DIGITS_LUT" |) |)
                                |))
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.loop (|
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.ge (|
                                            M.read (| n |),
                                            Value.Integer IntegerKind.U64 100
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ d1 :=
                                      M.alloc (|
                                        BinOp.Wrap.shl (|
                                          M.rust_cast
                                            (BinOp.Wrap.rem (|
                                              M.read (| n |),
                                              Value.Integer IntegerKind.U64 100
                                            |)),
                                          Value.Integer IntegerKind.I32 1
                                        |)
                                      |) in
                                    let~ _ :=
                                      let β := curr in
                                      M.write (|
                                        β,
                                        BinOp.Wrap.sub (|
                                          M.read (| β |),
                                          Value.Integer IntegerKind.Usize 2
                                        |)
                                      |) in
                                    let~ _ :=
                                      let~ _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (|
                                              "core::intrinsics::copy_nonoverlapping",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                                  "add",
                                                  []
                                                |),
                                                [ M.read (| lut_ptr |); M.read (| d1 |) ]
                                              |);
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                                  "add",
                                                  []
                                                |),
                                                [ M.read (| buf_ptr |); M.read (| curr |) ]
                                              |);
                                              Value.Integer IntegerKind.Usize 2
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |) in
                                    let~ _ :=
                                      let β := n in
                                      M.write (|
                                        β,
                                        BinOp.Wrap.div (|
                                          M.read (| β |),
                                          Value.Integer IntegerKind.U64 100
                                        |)
                                      |) in
                                    let~ _ :=
                                      let β := exponent in
                                      M.write (|
                                        β,
                                        BinOp.Wrap.add (|
                                          M.read (| β |),
                                          Value.Integer IntegerKind.Usize 2
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      let~ n := M.alloc (| M.rust_cast (M.read (| n |)) |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.ge (|
                                        M.read (| n |),
                                        Value.Integer IntegerKind.Isize 10
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ :=
                                  let β := curr in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.sub (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |) in
                                let~ _ :=
                                  let~ _ :=
                                    M.write (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                          "add",
                                          []
                                        |),
                                        [ M.read (| buf_ptr |); M.read (| curr |) ]
                                      |),
                                      BinOp.Wrap.add (|
                                        BinOp.Wrap.rem (|
                                          M.rust_cast (M.read (| n |)),
                                          Value.Integer IntegerKind.U8 10
                                        |),
                                        M.read (| UnsupportedLiteral |)
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |) in
                                let~ _ :=
                                  let β := n in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.div (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.Isize 10
                                    |)
                                  |) in
                                let~ _ :=
                                  let β := exponent in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.add (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      LogicalOp.or (|
                                        BinOp.ne (|
                                          M.read (| exponent |),
                                          M.read (| trailing_zeros |)
                                        |),
                                        ltac:(M.monadic
                                          (BinOp.ne (|
                                            M.read (| added_precision |),
                                            Value.Integer IntegerKind.Usize 0
                                          |)))
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ :=
                                  let β := curr in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.sub (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |) in
                                let~ _ :=
                                  M.write (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                        "add",
                                        []
                                      |),
                                      [ M.read (| buf_ptr |); M.read (| curr |) ]
                                    |),
                                    M.read (| UnsupportedLiteral |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      let~ buf_slice :=
                        M.copy (|
                          let~ _ :=
                            let β := curr in
                            M.write (|
                              β,
                              BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                            |) in
                          let~ _ :=
                            M.write (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| buf_ptr |); M.read (| curr |) ]
                              |),
                              BinOp.Wrap.add (|
                                M.rust_cast (M.read (| n |)),
                                M.read (| UnsupportedLiteral |)
                              |)
                            |) in
                          let~ len :=
                            M.alloc (|
                              BinOp.Wrap.sub (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          [ Ty.path "u8" ]
                                      ],
                                    "len",
                                    []
                                  |),
                                  [ (* Unsize *) M.pointer_coercion buf ]
                                |),
                                M.read (| M.use curr |)
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "core::slice::raw::from_raw_parts",
                                [ Ty.path "u8" ]
                              |),
                              [
                                (* MutToConstPointer *)
                                M.pointer_coercion
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "add",
                                      []
                                    |),
                                    [ M.read (| buf_ptr |); M.read (| curr |) ]
                                  |));
                                M.read (| len |)
                              ]
                            |)
                          |)
                        |) in
                      let~ exp_buf :=
                        M.alloc (|
                          repeat
                            (M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  [ Ty.path "u8" ],
                                "uninit",
                                []
                              |),
                              []
                            |))
                            3
                        |) in
                      let~ exp_ptr :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                [ Ty.path "u8" ],
                              "slice_as_mut_ptr",
                              []
                            |),
                            [ (* Unsize *) M.pointer_coercion exp_buf ]
                          |)
                        |) in
                      let~ exp_slice :=
                        M.copy (|
                          let~ _ :=
                            M.write (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| exp_ptr |); Value.Integer IntegerKind.Usize 0 ]
                              |),
                              M.read (|
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.use upper in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        UnsupportedLiteral));
                                    fun γ => ltac:(M.monadic UnsupportedLiteral)
                                  ]
                                |)
                              |)
                            |) in
                          let~ len :=
                            M.copy (|
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.lt (|
                                              M.read (| exponent |),
                                              Value.Integer IntegerKind.Usize 10
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        M.write (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                              "add",
                                              []
                                            |),
                                            [
                                              M.read (| exp_ptr |);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |),
                                          BinOp.Wrap.add (|
                                            M.rust_cast (M.read (| exponent |)),
                                            M.read (| UnsupportedLiteral |)
                                          |)
                                        |) in
                                      M.alloc (| Value.Integer IntegerKind.Usize 2 |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let~ off :=
                                        M.alloc (|
                                          BinOp.Wrap.shl (|
                                            M.read (| exponent |),
                                            Value.Integer IntegerKind.I32 1
                                          |)
                                        |) in
                                      let~ _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (|
                                              "core::intrinsics::copy_nonoverlapping",
                                              [ Ty.path "u8" ]
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                                  "add",
                                                  []
                                                |),
                                                [ M.read (| lut_ptr |); M.read (| off |) ]
                                              |);
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                                  "add",
                                                  []
                                                |),
                                                [
                                                  M.read (| exp_ptr |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 2
                                            ]
                                          |)
                                        |) in
                                      M.alloc (| Value.Integer IntegerKind.Usize 3 |)))
                                ]
                              |)
                            |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_function (|
                                "core::slice::raw::from_raw_parts",
                                [ Ty.path "u8" ]
                              |),
                              [
                                (* MutToConstPointer *) M.pointer_coercion (M.read (| exp_ptr |));
                                M.read (| len |)
                              ]
                            |)
                          |)
                        |) in
                      let~ parts :=
                        M.alloc (|
                          M.alloc (|
                            Value.Array
                              [
                                Value.StructTuple
                                  "core::num::fmt::Part::Copy"
                                  [ M.read (| buf_slice |) ];
                                Value.StructTuple
                                  "core::num::fmt::Part::Zero"
                                  [ M.read (| added_precision |) ];
                                Value.StructTuple
                                  "core::num::fmt::Part::Copy"
                                  [ M.read (| exp_slice |) ]
                              ]
                          |)
                        |) in
                      let~ sign :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (| UnOp.not (| M.read (| is_nonnegative |) |) |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  Value.String "-"));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.read (|
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Formatter",
                                                        "sign_plus",
                                                        []
                                                      |),
                                                      [ M.read (| f |) ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              Value.String "+"));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (| M.read (| Value.String "" |) |)))
                                        ]
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let~ formatted :=
                        M.alloc (|
                          Value.StructRecord
                            "core::num::fmt::Formatted"
                            [
                              ("sign", M.read (| sign |));
                              ("parts", (* Unsize *) M.pointer_coercion (M.read (| parts |)))
                            ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Formatter",
                            "pad_formatted_parts",
                            []
                          |),
                          [ M.read (| f |); formatted ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Function_exp_u64 : M.IsFunction "core::fmt::num::imp::exp_u64" exp_u64.
      
      Module Impl_core_fmt_LowerExp_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I8 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i8",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i8",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_i8.
      
      Module Impl_core_fmt_LowerExp_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U8 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u8",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u8",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_u8.
      
      Module Impl_core_fmt_LowerExp_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I16 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i16",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i16",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_i16.
      
      Module Impl_core_fmt_LowerExp_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U16 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u16",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u16",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_u16.
      
      Module Impl_core_fmt_LowerExp_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I32 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i32",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i32",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_i32.
      
      Module Impl_core_fmt_LowerExp_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U32 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u32",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u32",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_u32.
      
      Module Impl_core_fmt_LowerExp_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I64 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i64",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i64",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_i64.
      
      Module Impl_core_fmt_LowerExp_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U64 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u64",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u64",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_u64.
      
      Module Impl_core_fmt_LowerExp_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.Usize 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "usize",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "usize",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_usize.
      
      Module Impl_core_fmt_LowerExp_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, false, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.Isize 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "isize",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "isize",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |)
                    ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::LowerExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_LowerExp_for_isize.
      
      Module Impl_core_fmt_UpperExp_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I8 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i8",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i8",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_i8.
      
      Module Impl_core_fmt_UpperExp_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U8 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u8",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u8",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_u8.
      
      Module Impl_core_fmt_UpperExp_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I16 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i16",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i16",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_i16.
      
      Module Impl_core_fmt_UpperExp_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U16 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u16",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u16",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_u16.
      
      Module Impl_core_fmt_UpperExp_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I32 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i32",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i32",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_i32.
      
      Module Impl_core_fmt_UpperExp_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U32 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u32",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u32",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_u32.
      
      Module Impl_core_fmt_UpperExp_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I64 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "i64",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "i64",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_i64.
      
      Module Impl_core_fmt_UpperExp_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U64 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "u64",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "u64",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_u64.
      
      Module Impl_core_fmt_UpperExp_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.Usize 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "usize",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "usize",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_usize.
      
      Module Impl_core_fmt_UpperExp_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*
                        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                            let is_nonnegative = *self >= 0;
                            let n = if is_nonnegative {
                                self.$conv_fn()
                            } else {
                                // convert the negative num to positive by summing 1 to it's 2 complement
                                (!self.$conv_fn()).wrapping_add(1)
                            };
                            $name(n, is_nonnegative, true, f)
                        }
        *)
        Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; f ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let f := M.alloc (| f |) in
              M.read (|
                let~ is_nonnegative :=
                  M.alloc (|
                    BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.Isize 0 |)
                  |) in
                let~ n :=
                  M.copy (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use is_nonnegative in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::num::DisplayInt",
                                  Ty.path "isize",
                                  [],
                                  "to_u64",
                                  []
                                |),
                                [ M.read (| self |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                                [
                                  UnOp.not (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::fmt::num::DisplayInt",
                                        Ty.path "isize",
                                        [],
                                        "to_u64",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U64 1
                                ]
                              |)
                            |)))
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.call_closure (|
                    M.get_function (| "core::fmt::num::imp::exp_u64", [] |),
                    [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                  |)
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::UpperExp"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_UpperExp_for_isize.
    End imp.
    
    (*
            fn $name(
                mut n: $u,
                is_nonnegative: bool,
                upper: bool,
                f: &mut fmt::Formatter<'_>
            ) -> fmt::Result {
                let (mut n, mut exponent, trailing_zeros, added_precision) = {
                    let mut exponent = 0;
                    // count and remove trailing decimal zeroes
                    while n % 10 == 0 && n >= 10 {
                        n /= 10;
                        exponent += 1;
                    }
                    let (added_precision, subtracted_precision) = match f.precision() {
                        Some(fmt_prec) => {
                            // number of decimal digits minus 1
                            let mut tmp = n;
                            let mut prec = 0;
                            while tmp >= 10 {
                                tmp /= 10;
                                prec += 1;
                            }
                            (fmt_prec.saturating_sub(prec), prec.saturating_sub(fmt_prec))
                        }
                        None => (0, 0)
                    };
                    for _ in 1..subtracted_precision {
                        n /= 10;
                        exponent += 1;
                    }
                    if subtracted_precision != 0 {
                        let rem = n % 10;
                        n /= 10;
                        exponent += 1;
                        // round up last digit, round to even on a tie
                        if rem > 5 || (rem == 5 && (n % 2 != 0 || subtracted_precision > 1 )) {
                            n += 1;
                            // if the digit is rounded to the next power
                            // instead adjust the exponent
                            if n.ilog10() > (n - 1).ilog10() {
                                n /= 10;
                                exponent += 1;
                            }
                        }
                    }
                    (n, exponent, exponent, added_precision)
                };
    
                // 39 digits (worst case u128) + . = 40
                // Since `curr` always decreases by the number of digits copied, this means
                // that `curr >= 0`.
                let mut buf = [MaybeUninit::<u8>::uninit(); 40];
                let mut curr = buf.len(); //index for buf
                let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);
                let lut_ptr = DEC_DIGITS_LUT.as_ptr();
    
                // decode 2 chars at a time
                while n >= 100 {
                    let d1 = ((n % 100) as usize) << 1;
                    curr -= 2;
                    // SAFETY: `d1 <= 198`, so we can copy from `lut_ptr[d1..d1 + 2]` since
                    // `DEC_DIGITS_LUT` has a length of 200.
                    unsafe {
                        ptr::copy_nonoverlapping(lut_ptr.add(d1), buf_ptr.add(curr), 2);
                    }
                    n /= 100;
                    exponent += 2;
                }
                // n is <= 99, so at most 2 chars long
                let mut n = n as isize; // possibly reduce 64bit math
                // decode second-to-last character
                if n >= 10 {
                    curr -= 1;
                    // SAFETY: Safe since `40 > curr >= 0` (see comment)
                    unsafe {
                        *buf_ptr.add(curr) = (n as u8 % 10_u8) + b'0';
                    }
                    n /= 10;
                    exponent += 1;
                }
                // add decimal point iff >1 mantissa digit will be printed
                if exponent != trailing_zeros || added_precision != 0 {
                    curr -= 1;
                    // SAFETY: Safe since `40 > curr >= 0`
                    unsafe {
                        *buf_ptr.add(curr) = b'.';
                    }
                }
    
                // SAFETY: Safe since `40 > curr >= 0`
                let buf_slice = unsafe {
                    // decode last character
                    curr -= 1;
                    *buf_ptr.add(curr) = (n as u8) + b'0';
    
                    let len = buf.len() - curr as usize;
                    slice::from_raw_parts(buf_ptr.add(curr), len)
                };
    
                // stores 'e' (or 'E') and the up to 2-digit exponent
                let mut exp_buf = [MaybeUninit::<u8>::uninit(); 3];
                let exp_ptr = MaybeUninit::slice_as_mut_ptr(&mut exp_buf);
                // SAFETY: In either case, `exp_buf` is written within bounds and `exp_ptr[..len]`
                // is contained within `exp_buf` since `len <= 3`.
                let exp_slice = unsafe {
                    *exp_ptr.add(0) = if upper { b'E' } else { b'e' };
                    let len = if exponent < 10 {
                        *exp_ptr.add(1) = (exponent as u8) + b'0';
                        2
                    } else {
                        let off = exponent << 1;
                        ptr::copy_nonoverlapping(lut_ptr.add(off), exp_ptr.add(1), 2);
                        3
                    };
                    slice::from_raw_parts(exp_ptr, len)
                };
    
                let parts = &[
                    numfmt::Part::Copy(buf_slice),
                    numfmt::Part::Zero(added_precision),
                    numfmt::Part::Copy(exp_slice),
                ];
                let sign = if !is_nonnegative {
                    "-"
                } else if f.sign_plus() {
                    "+"
                } else {
                    ""
                };
                let formatted = numfmt::Formatted { sign, parts };
                // SAFETY: `buf_slice` and `exp_slice` contain only ASCII characters.
                unsafe { f.pad_formatted_parts(&formatted) }
            }
    *)
    Definition exp_u128 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n; is_nonnegative; upper; f ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          let is_nonnegative := M.alloc (| is_nonnegative |) in
          let upper := M.alloc (| upper |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              let~ exponent := M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
              let~ _ :=
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    BinOp.eq (|
                                      BinOp.Wrap.rem (|
                                        M.read (| n |),
                                        Value.Integer IntegerKind.U128 10
                                      |),
                                      Value.Integer IntegerKind.U128 0
                                    |),
                                    ltac:(M.monadic
                                      (BinOp.ge (|
                                        M.read (| n |),
                                        Value.Integer IntegerKind.U128 10
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ :=
                              let β := n in
                              M.write (|
                                β,
                                BinOp.Wrap.div (|
                                  M.read (| β |),
                                  Value.Integer IntegerKind.U128 10
                                |)
                              |) in
                            let~ _ :=
                              let β := exponent in
                              M.write (|
                                β,
                                BinOp.Wrap.add (|
                                  M.read (| β |),
                                  Value.Integer IntegerKind.Usize 1
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ _ :=
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                  M.alloc (| Value.Tuple [] |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |) in
              M.match_operator (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "precision",
                        []
                      |),
                      [ M.read (| f |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let fmt_prec := M.copy (| γ0_0 |) in
                        let~ tmp := M.copy (| n |) in
                        let~ prec := M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                        let~ _ :=
                          M.loop (|
                            ltac:(M.monadic
                              (M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.ge (|
                                              M.read (| tmp |),
                                              Value.Integer IntegerKind.U128 10
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ _ :=
                                        let β := tmp in
                                        M.write (|
                                          β,
                                          BinOp.Wrap.div (|
                                            M.read (| β |),
                                            Value.Integer IntegerKind.U128 10
                                          |)
                                        |) in
                                      let~ _ :=
                                        let β := prec in
                                        M.write (|
                                          β,
                                          BinOp.Wrap.add (|
                                            M.read (| β |),
                                            Value.Integer IntegerKind.Usize 1
                                          |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            let~ _ :=
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |)))
                          |) in
                        M.alloc (|
                          Value.Tuple
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "saturating_sub",
                                  []
                                |),
                                [ M.read (| fmt_prec |); M.read (| prec |) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "usize",
                                  "saturating_sub",
                                  []
                                |),
                                [ M.read (| prec |); M.read (| fmt_prec |) ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                        M.alloc (|
                          Value.Tuple
                            [ Value.Integer IntegerKind.Usize 0; Value.Integer IntegerKind.Usize 0 ]
                        |)))
                  ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let added_precision := M.copy (| γ0_0 |) in
                      let subtracted_precision := M.copy (| γ0_1 |) in
                      let~ _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  Value.StructRecord
                                    "core::ops::range::Range"
                                    [
                                      ("start", Value.Integer IntegerKind.Usize 1);
                                      ("end_", M.read (| subtracted_precision |))
                                    ]
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let~ _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::ops::range::Range")
                                                  [ Ty.path "usize" ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let~ _ :=
                                                  let β := n in
                                                  M.write (|
                                                    β,
                                                    BinOp.Wrap.div (|
                                                      M.read (| β |),
                                                      Value.Integer IntegerKind.U128 10
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  let β := exponent in
                                                  M.write (|
                                                    β,
                                                    BinOp.Wrap.add (|
                                                      M.read (| β |),
                                                      Value.Integer IntegerKind.Usize 1
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      let~ _ :=
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      BinOp.ne (|
                                        M.read (| subtracted_precision |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ rem :=
                                  M.alloc (|
                                    BinOp.Wrap.rem (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.U128 10
                                    |)
                                  |) in
                                let~ _ :=
                                  let β := n in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.div (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.U128 10
                                    |)
                                  |) in
                                let~ _ :=
                                  let β := exponent in
                                  M.write (|
                                    β,
                                    BinOp.Wrap.add (|
                                      M.read (| β |),
                                      Value.Integer IntegerKind.Usize 1
                                    |)
                                  |) in
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              LogicalOp.or (|
                                                BinOp.gt (|
                                                  M.read (| rem |),
                                                  Value.Integer IntegerKind.U128 5
                                                |),
                                                ltac:(M.monadic
                                                  (LogicalOp.and (|
                                                    BinOp.eq (|
                                                      M.read (| rem |),
                                                      Value.Integer IntegerKind.U128 5
                                                    |),
                                                    ltac:(M.monadic
                                                      (LogicalOp.or (|
                                                        BinOp.ne (|
                                                          BinOp.Wrap.rem (|
                                                            M.read (| n |),
                                                            Value.Integer IntegerKind.U128 2
                                                          |),
                                                          Value.Integer IntegerKind.U128 0
                                                        |),
                                                        ltac:(M.monadic
                                                          (BinOp.gt (|
                                                            M.read (| subtracted_precision |),
                                                            Value.Integer IntegerKind.Usize 1
                                                          |)))
                                                      |)))
                                                  |)))
                                              |)
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        let~ _ :=
                                          let β := n in
                                          M.write (|
                                            β,
                                            BinOp.Wrap.add (|
                                              M.read (| β |),
                                              Value.Integer IntegerKind.U128 1
                                            |)
                                          |) in
                                        M.match_operator (|
                                          M.alloc (| Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      BinOp.gt (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "u128",
                                                            "ilog10",
                                                            []
                                                          |),
                                                          [ M.read (| n |) ]
                                                        |),
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "u128",
                                                            "ilog10",
                                                            []
                                                          |),
                                                          [
                                                            BinOp.Wrap.sub (|
                                                              M.read (| n |),
                                                              Value.Integer IntegerKind.U128 1
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  M.is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                let~ _ :=
                                                  let β := n in
                                                  M.write (|
                                                    β,
                                                    BinOp.Wrap.div (|
                                                      M.read (| β |),
                                                      Value.Integer IntegerKind.U128 10
                                                    |)
                                                  |) in
                                                let~ _ :=
                                                  let β := exponent in
                                                  M.write (|
                                                    β,
                                                    BinOp.Wrap.add (|
                                                      M.read (| β |),
                                                      Value.Integer IntegerKind.Usize 1
                                                    |)
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)));
                                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                          ]
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| n |);
                            M.read (| exponent |);
                            M.read (| exponent |);
                            M.read (| added_precision |)
                          ]
                      |)))
                ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                    let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                    let n := M.copy (| γ0_0 |) in
                    let exponent := M.copy (| γ0_1 |) in
                    let trailing_zeros := M.copy (| γ0_2 |) in
                    let added_precision := M.copy (| γ0_3 |) in
                    let~ buf :=
                      M.alloc (|
                        repeat
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                [ Ty.path "u8" ],
                              "uninit",
                              []
                            |),
                            []
                          |))
                          40
                      |) in
                    let~ curr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  [ Ty.path "u8" ]
                              ],
                            "len",
                            []
                          |),
                          [ (* Unsize *) M.pointer_coercion buf ]
                        |)
                      |) in
                    let~ buf_ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              [ Ty.path "u8" ],
                            "slice_as_mut_ptr",
                            []
                          |),
                          [ (* Unsize *) M.pointer_coercion buf ]
                        |)
                      |) in
                    let~ lut_ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                            "as_ptr",
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.read (|
                                M.read (| M.get_constant (| "core::fmt::num::DEC_DIGITS_LUT" |) |)
                              |))
                          ]
                        |)
                      |) in
                    let~ _ :=
                      M.loop (|
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        BinOp.ge (|
                                          M.read (| n |),
                                          Value.Integer IntegerKind.U128 100
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ d1 :=
                                    M.alloc (|
                                      BinOp.Wrap.shl (|
                                        M.rust_cast
                                          (BinOp.Wrap.rem (|
                                            M.read (| n |),
                                            Value.Integer IntegerKind.U128 100
                                          |)),
                                        Value.Integer IntegerKind.I32 1
                                      |)
                                    |) in
                                  let~ _ :=
                                    let β := curr in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.sub (|
                                        M.read (| β |),
                                        Value.Integer IntegerKind.Usize 2
                                      |)
                                    |) in
                                  let~ _ :=
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::intrinsics::copy_nonoverlapping",
                                            [ Ty.path "u8" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                                "add",
                                                []
                                              |),
                                              [ M.read (| lut_ptr |); M.read (| d1 |) ]
                                            |);
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                                "add",
                                                []
                                              |),
                                              [ M.read (| buf_ptr |); M.read (| curr |) ]
                                            |);
                                            Value.Integer IntegerKind.Usize 2
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |) in
                                  let~ _ :=
                                    let β := n in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.div (|
                                        M.read (| β |),
                                        Value.Integer IntegerKind.U128 100
                                      |)
                                    |) in
                                  let~ _ :=
                                    let β := exponent in
                                    M.write (|
                                      β,
                                      BinOp.Wrap.add (|
                                        M.read (| β |),
                                        Value.Integer IntegerKind.Usize 2
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        let~ _ :=
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |) in
                                        M.alloc (| Value.Tuple [] |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)))
                      |) in
                    let~ n := M.alloc (| M.rust_cast (M.read (| n |)) |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.ge (|
                                      M.read (| n |),
                                      Value.Integer IntegerKind.Isize 10
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                let β := curr in
                                M.write (|
                                  β,
                                  BinOp.Wrap.sub (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                |) in
                              let~ _ :=
                                let~ _ :=
                                  M.write (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                        "add",
                                        []
                                      |),
                                      [ M.read (| buf_ptr |); M.read (| curr |) ]
                                    |),
                                    BinOp.Wrap.add (|
                                      BinOp.Wrap.rem (|
                                        M.rust_cast (M.read (| n |)),
                                        Value.Integer IntegerKind.U8 10
                                      |),
                                      M.read (| UnsupportedLiteral |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |) in
                              let~ _ :=
                                let β := n in
                                M.write (|
                                  β,
                                  BinOp.Wrap.div (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.Isize 10
                                  |)
                                |) in
                              let~ _ :=
                                let β := exponent in
                                M.write (|
                                  β,
                                  BinOp.Wrap.add (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    LogicalOp.or (|
                                      BinOp.ne (|
                                        M.read (| exponent |),
                                        M.read (| trailing_zeros |)
                                      |),
                                      ltac:(M.monadic
                                        (BinOp.ne (|
                                          M.read (| added_precision |),
                                          Value.Integer IntegerKind.Usize 0
                                        |)))
                                    |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ _ :=
                                let β := curr in
                                M.write (|
                                  β,
                                  BinOp.Wrap.sub (|
                                    M.read (| β |),
                                    Value.Integer IntegerKind.Usize 1
                                  |)
                                |) in
                              let~ _ :=
                                M.write (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "add",
                                      []
                                    |),
                                    [ M.read (| buf_ptr |); M.read (| curr |) ]
                                  |),
                                  M.read (| UnsupportedLiteral |)
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ buf_slice :=
                      M.copy (|
                        let~ _ :=
                          let β := curr in
                          M.write (|
                            β,
                            BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                          |) in
                        let~ _ :=
                          M.write (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                "add",
                                []
                              |),
                              [ M.read (| buf_ptr |); M.read (| curr |) ]
                            |),
                            BinOp.Wrap.add (|
                              M.rust_cast (M.read (| n |)),
                              M.read (| UnsupportedLiteral |)
                            |)
                          |) in
                        let~ len :=
                          M.alloc (|
                            BinOp.Wrap.sub (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    [
                                      Ty.apply
                                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                        [ Ty.path "u8" ]
                                    ],
                                  "len",
                                  []
                                |),
                                [ (* Unsize *) M.pointer_coercion buf ]
                              |),
                              M.read (| M.use curr |)
                            |)
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::slice::raw::from_raw_parts",
                              [ Ty.path "u8" ]
                            |),
                            [
                              (* MutToConstPointer *)
                              M.pointer_coercion
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                    "add",
                                    []
                                  |),
                                  [ M.read (| buf_ptr |); M.read (| curr |) ]
                                |));
                              M.read (| len |)
                            ]
                          |)
                        |)
                      |) in
                    let~ exp_buf :=
                      M.alloc (|
                        repeat
                          (M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                [ Ty.path "u8" ],
                              "uninit",
                              []
                            |),
                            []
                          |))
                          3
                      |) in
                    let~ exp_ptr :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              [ Ty.path "u8" ],
                            "slice_as_mut_ptr",
                            []
                          |),
                          [ (* Unsize *) M.pointer_coercion exp_buf ]
                        |)
                      |) in
                    let~ exp_slice :=
                      M.copy (|
                        let~ _ :=
                          M.write (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                "add",
                                []
                              |),
                              [ M.read (| exp_ptr |); Value.Integer IntegerKind.Usize 0 ]
                            |),
                            M.read (|
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.use upper in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      UnsupportedLiteral));
                                  fun γ => ltac:(M.monadic UnsupportedLiteral)
                                ]
                              |)
                            |)
                          |) in
                        let~ len :=
                          M.copy (|
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          BinOp.lt (|
                                            M.read (| exponent |),
                                            Value.Integer IntegerKind.Usize 10
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ :=
                                      M.write (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                            "add",
                                            []
                                          |),
                                          [ M.read (| exp_ptr |); Value.Integer IntegerKind.Usize 1
                                          ]
                                        |),
                                        BinOp.Wrap.add (|
                                          M.rust_cast (M.read (| exponent |)),
                                          M.read (| UnsupportedLiteral |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Integer IntegerKind.Usize 2 |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let~ off :=
                                      M.alloc (|
                                        BinOp.Wrap.shl (|
                                          M.read (| exponent |),
                                          Value.Integer IntegerKind.I32 1
                                        |)
                                      |) in
                                    let~ _ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (|
                                            "core::intrinsics::copy_nonoverlapping",
                                            [ Ty.path "u8" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                                "add",
                                                []
                                              |),
                                              [ M.read (| lut_ptr |); M.read (| off |) ]
                                            |);
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                                "add",
                                                []
                                              |),
                                              [
                                                M.read (| exp_ptr |);
                                                Value.Integer IntegerKind.Usize 1
                                              ]
                                            |);
                                            Value.Integer IntegerKind.Usize 2
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Integer IntegerKind.Usize 3 |)))
                              ]
                            |)
                          |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::slice::raw::from_raw_parts",
                              [ Ty.path "u8" ]
                            |),
                            [
                              (* MutToConstPointer *) M.pointer_coercion (M.read (| exp_ptr |));
                              M.read (| len |)
                            ]
                          |)
                        |)
                      |) in
                    let~ parts :=
                      M.alloc (|
                        M.alloc (|
                          Value.Array
                            [
                              Value.StructTuple
                                "core::num::fmt::Part::Copy"
                                [ M.read (| buf_slice |) ];
                              Value.StructTuple
                                "core::num::fmt::Part::Zero"
                                [ M.read (| added_precision |) ];
                              Value.StructTuple
                                "core::num::fmt::Part::Copy"
                                [ M.read (| exp_slice |) ]
                            ]
                        |)
                      |) in
                    let~ sign :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (| UnOp.not (| M.read (| is_nonnegative |) |) |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                Value.String "-"));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (| Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Formatter",
                                                      "sign_plus",
                                                      []
                                                    |),
                                                    [ M.read (| f |) ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              M.is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            Value.String "+"));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (| M.read (| Value.String "" |) |)))
                                      ]
                                    |)
                                  |)
                                |)))
                          ]
                        |)
                      |) in
                    let~ formatted :=
                      M.alloc (|
                        Value.StructRecord
                          "core::num::fmt::Formatted"
                          [
                            ("sign", M.read (| sign |));
                            ("parts", (* Unsize *) M.pointer_coercion (M.read (| parts |)))
                          ]
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "pad_formatted_parts",
                          []
                        |),
                        [ M.read (| f |); formatted ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_exp_u128 : M.IsFunction "core::fmt::num::exp_u128" exp_u128.
    
    Module Impl_core_fmt_LowerExp_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          let is_nonnegative = *self >= 0;
                          let n = if is_nonnegative {
                              self.$conv_fn()
                          } else {
                              // convert the negative num to positive by summing 1 to it's 2 complement
                              (!self.$conv_fn()).wrapping_add(1)
                          };
                          $name(n, is_nonnegative, false, f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ is_nonnegative :=
                M.alloc (|
                  BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I128 0 |)
                |) in
              let~ n :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use is_nonnegative in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::fmt::num::DisplayInt",
                                Ty.path "i128",
                                [],
                                "to_u128",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                              [
                                UnOp.not (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::fmt::num::DisplayInt",
                                      Ty.path "i128",
                                      [],
                                      "to_u128",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |);
                                Value.Integer IntegerKind.U128 1
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::fmt::num::exp_u128", [] |),
                  [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerExp"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerExp_for_i128.
    
    Module Impl_core_fmt_LowerExp_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          let is_nonnegative = *self >= 0;
                          let n = if is_nonnegative {
                              self.$conv_fn()
                          } else {
                              // convert the negative num to positive by summing 1 to it's 2 complement
                              (!self.$conv_fn()).wrapping_add(1)
                          };
                          $name(n, is_nonnegative, false, f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ is_nonnegative :=
                M.alloc (|
                  BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U128 0 |)
                |) in
              let~ n :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use is_nonnegative in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::fmt::num::DisplayInt",
                                Ty.path "u128",
                                [],
                                "to_u128",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                              [
                                UnOp.not (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::fmt::num::DisplayInt",
                                      Ty.path "u128",
                                      [],
                                      "to_u128",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |);
                                Value.Integer IntegerKind.U128 1
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::fmt::num::exp_u128", [] |),
                  [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool false; M.read (| f |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::LowerExp"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_LowerExp_for_u128.
    
    Module Impl_core_fmt_UpperExp_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          let is_nonnegative = *self >= 0;
                          let n = if is_nonnegative {
                              self.$conv_fn()
                          } else {
                              // convert the negative num to positive by summing 1 to it's 2 complement
                              (!self.$conv_fn()).wrapping_add(1)
                          };
                          $name(n, is_nonnegative, true, f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ is_nonnegative :=
                M.alloc (|
                  BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I128 0 |)
                |) in
              let~ n :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use is_nonnegative in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::fmt::num::DisplayInt",
                                Ty.path "i128",
                                [],
                                "to_u128",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                              [
                                UnOp.not (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::fmt::num::DisplayInt",
                                      Ty.path "i128",
                                      [],
                                      "to_u128",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |);
                                Value.Integer IntegerKind.U128 1
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::fmt::num::exp_u128", [] |),
                  [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperExp"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperExp_for_i128.
    
    Module Impl_core_fmt_UpperExp_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                      fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
                          let is_nonnegative = *self >= 0;
                          let n = if is_nonnegative {
                              self.$conv_fn()
                          } else {
                              // convert the negative num to positive by summing 1 to it's 2 complement
                              (!self.$conv_fn()).wrapping_add(1)
                          };
                          $name(n, is_nonnegative, true, f)
                      }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ is_nonnegative :=
                M.alloc (|
                  BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.U128 0 |)
                |) in
              let~ n :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use is_nonnegative in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::fmt::num::DisplayInt",
                                Ty.path "u128",
                                [],
                                "to_u128",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                              [
                                UnOp.not (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::fmt::num::DisplayInt",
                                      Ty.path "u128",
                                      [],
                                      "to_u128",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |);
                                Value.Integer IntegerKind.U128 1
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::fmt::num::exp_u128", [] |),
                  [ M.read (| n |); M.read (| is_nonnegative |); Value.Bool true; M.read (| f |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::UpperExp"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_UpperExp_for_u128.
    
    (*
    fn parse_u64_into<const N: usize>(mut n: u64, buf: &mut [MaybeUninit<u8>; N], curr: &mut usize) {
        let buf_ptr = MaybeUninit::slice_as_mut_ptr(buf);
        let lut_ptr = DEC_DIGITS_LUT.as_ptr();
        assert!( *curr > 19);
    
        // SAFETY:
        // Writes at most 19 characters into the buffer. Guaranteed that any ptr into LUT is at most
        // 198, so will never OOB. There is a check above that there are at least 19 characters
        // remaining.
        unsafe {
            if n >= 1e16 as u64 {
                let to_parse = n % 1e16 as u64;
                n /= 1e16 as u64;
    
                // Some of these are nops but it looks more elegant this way.
                let d1 = ((to_parse / 1e14 as u64) % 100) << 1;
                let d2 = ((to_parse / 1e12 as u64) % 100) << 1;
                let d3 = ((to_parse / 1e10 as u64) % 100) << 1;
                let d4 = ((to_parse / 1e8 as u64) % 100) << 1;
                let d5 = ((to_parse / 1e6 as u64) % 100) << 1;
                let d6 = ((to_parse / 1e4 as u64) % 100) << 1;
                let d7 = ((to_parse / 1e2 as u64) % 100) << 1;
                let d8 = ((to_parse / 1e0 as u64) % 100) << 1;
    
                *curr -= 16;
    
                ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add( *curr + 0), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add( *curr + 2), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add( *curr + 4), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add( *curr + 6), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d5 as usize), buf_ptr.add( *curr + 8), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d6 as usize), buf_ptr.add( *curr + 10), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d7 as usize), buf_ptr.add( *curr + 12), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d8 as usize), buf_ptr.add( *curr + 14), 2);
            }
            if n >= 1e8 as u64 {
                let to_parse = n % 1e8 as u64;
                n /= 1e8 as u64;
    
                // Some of these are nops but it looks more elegant this way.
                let d1 = ((to_parse / 1e6 as u64) % 100) << 1;
                let d2 = ((to_parse / 1e4 as u64) % 100) << 1;
                let d3 = ((to_parse / 1e2 as u64) % 100) << 1;
                let d4 = ((to_parse / 1e0 as u64) % 100) << 1;
                *curr -= 8;
    
                ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add( *curr + 0), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add( *curr + 2), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d3 as usize), buf_ptr.add( *curr + 4), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d4 as usize), buf_ptr.add( *curr + 6), 2);
            }
            // `n` < 1e8 < (1 << 32)
            let mut n = n as u32;
            if n >= 1e4 as u32 {
                let to_parse = n % 1e4 as u32;
                n /= 1e4 as u32;
    
                let d1 = (to_parse / 100) << 1;
                let d2 = (to_parse % 100) << 1;
                *curr -= 4;
    
                ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add( *curr + 0), 2);
                ptr::copy_nonoverlapping(lut_ptr.add(d2 as usize), buf_ptr.add( *curr + 2), 2);
            }
    
            // `n` < 1e4 < (1 << 16)
            let mut n = n as u16;
            if n >= 100 {
                let d1 = (n % 100) << 1;
                n /= 100;
                *curr -= 2;
                ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add( *curr), 2);
            }
    
            // decode last 1 or 2 chars
            if n < 10 {
                *curr -= 1;
                *buf_ptr.add( *curr) = (n as u8) + b'0';
            } else {
                let d1 = n << 1;
                *curr -= 2;
                ptr::copy_nonoverlapping(lut_ptr.add(d1 as usize), buf_ptr.add( *curr), 2);
            }
        }
    }
    *)
    Definition parse_u64_into (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n; buf; curr ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          let buf := M.alloc (| buf |) in
          let curr := M.alloc (| curr |) in
          M.read (|
            let~ buf_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ],
                    "slice_as_mut_ptr",
                    []
                  |),
                  [ (* Unsize *) M.pointer_coercion (M.read (| buf |)) ]
                |)
              |) in
            let~ lut_ptr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                    "as_ptr",
                    []
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.read (|
                        M.read (| M.get_constant (| "core::fmt::num::DEC_DIGITS_LUT" |) |)
                      |))
                  ]
                |)
              |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              BinOp.gt (|
                                M.read (| M.read (| curr |) |),
                                Value.Integer IntegerKind.Usize 19
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic", [] |),
                            [ M.read (| Value.String "assertion failed: *curr > 19" |) ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ge (|
                              M.read (| n |),
                              M.rust_cast (M.read (| UnsupportedLiteral |))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ to_parse :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.read (| n |),
                            M.rust_cast (M.read (| UnsupportedLiteral |))
                          |)
                        |) in
                      let~ _ :=
                        let β := n in
                        M.write (|
                          β,
                          BinOp.Wrap.div (|
                            M.read (| β |),
                            M.rust_cast (M.read (| UnsupportedLiteral |))
                          |)
                        |) in
                      let~ d1 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d2 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d3 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d4 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d5 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d6 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d7 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d8 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ _ :=
                        let β := M.read (| curr |) in
                        M.write (|
                          β,
                          BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 16 |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d1 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d2 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 2
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d3 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 4
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d4 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 6
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d5 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 8
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d6 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 10
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d7 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 12
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d8 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 14
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ge (|
                              M.read (| n |),
                              M.rust_cast (M.read (| UnsupportedLiteral |))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ to_parse :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.read (| n |),
                            M.rust_cast (M.read (| UnsupportedLiteral |))
                          |)
                        |) in
                      let~ _ :=
                        let β := n in
                        M.write (|
                          β,
                          BinOp.Wrap.div (|
                            M.read (| β |),
                            M.rust_cast (M.read (| UnsupportedLiteral |))
                          |)
                        |) in
                      let~ d1 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d2 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d3 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d4 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              BinOp.Wrap.div (|
                                M.read (| to_parse |),
                                M.rust_cast (M.read (| UnsupportedLiteral |))
                              |),
                              Value.Integer IntegerKind.U64 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ _ :=
                        let β := M.read (| curr |) in
                        M.write (|
                          β,
                          BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 8 |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d1 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d2 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 2
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d3 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 4
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d4 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 6
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ n := M.alloc (| M.rust_cast (M.read (| n |)) |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ge (|
                              M.read (| n |),
                              M.rust_cast (M.read (| UnsupportedLiteral |))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ to_parse :=
                        M.alloc (|
                          BinOp.Wrap.rem (|
                            M.read (| n |),
                            M.rust_cast (M.read (| UnsupportedLiteral |))
                          |)
                        |) in
                      let~ _ :=
                        let β := n in
                        M.write (|
                          β,
                          BinOp.Wrap.div (|
                            M.read (| β |),
                            M.rust_cast (M.read (| UnsupportedLiteral |))
                          |)
                        |) in
                      let~ d1 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.div (|
                              M.read (| to_parse |),
                              Value.Integer IntegerKind.U32 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ d2 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (|
                              M.read (| to_parse |),
                              Value.Integer IntegerKind.U32 100
                            |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ _ :=
                        let β := M.read (| curr |) in
                        M.write (|
                          β,
                          BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 4 |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d1 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d2 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [
                                  M.read (| buf_ptr |);
                                  BinOp.Wrap.add (|
                                    M.read (| M.read (| curr |) |),
                                    Value.Integer IntegerKind.Usize 2
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ n := M.alloc (| M.rust_cast (M.read (| n |)) |) in
            let~ _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.ge (| M.read (| n |), Value.Integer IntegerKind.U16 100 |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ d1 :=
                        M.alloc (|
                          BinOp.Wrap.shl (|
                            BinOp.Wrap.rem (| M.read (| n |), Value.Integer IntegerKind.U16 100 |),
                            Value.Integer IntegerKind.I32 1
                          |)
                        |) in
                      let~ _ :=
                        let β := n in
                        M.write (|
                          β,
                          BinOp.Wrap.div (| M.read (| β |), Value.Integer IntegerKind.U16 100 |)
                        |) in
                      let~ _ :=
                        let β := M.read (| curr |) in
                        M.write (|
                          β,
                          BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 2 |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping",
                              [ Ty.path "u8" ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| lut_ptr |); M.rust_cast (M.read (| d1 |)) ]
                              |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                  "add",
                                  []
                                |),
                                [ M.read (| buf_ptr |); M.read (| M.read (| curr |) |) ]
                              |);
                              Value.Integer IntegerKind.Usize 2
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.lt (| M.read (| n |), Value.Integer IntegerKind.U16 10 |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      let β := M.read (| curr |) in
                      M.write (|
                        β,
                        BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 1 |)
                      |) in
                    let~ _ :=
                      M.write (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                            "add",
                            []
                          |),
                          [ M.read (| buf_ptr |); M.read (| M.read (| curr |) |) ]
                        |),
                        BinOp.Wrap.add (|
                          M.rust_cast (M.read (| n |)),
                          M.read (| UnsupportedLiteral |)
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ =>
                  ltac:(M.monadic
                    (let~ d1 :=
                      M.alloc (|
                        BinOp.Wrap.shl (| M.read (| n |), Value.Integer IntegerKind.I32 1 |)
                      |) in
                    let~ _ :=
                      let β := M.read (| curr |) in
                      M.write (|
                        β,
                        BinOp.Wrap.sub (| M.read (| β |), Value.Integer IntegerKind.Usize 2 |)
                      |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::copy_nonoverlapping",
                            [ Ty.path "u8" ]
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*const") [ Ty.path "u8" ],
                                "add",
                                []
                              |),
                              [ M.read (| lut_ptr |); M.rust_cast (M.read (| d1 |)) ]
                            |);
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                "add",
                                []
                              |),
                              [ M.read (| buf_ptr |); M.read (| M.read (| curr |) |) ]
                            |);
                            Value.Integer IntegerKind.Usize 2
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_parse_u64_into : M.IsFunction "core::fmt::num::parse_u64_into" parse_u64_into.
    
    Module Impl_core_fmt_Display_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              fmt_u128( *self, true, f)
          }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_function (| "core::fmt::num::fmt_u128", [] |),
              [ M.read (| M.read (| self |) |); Value.Bool true; M.read (| f |) ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_u128.
    
    Module Impl_core_fmt_Display_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
          fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
              let is_nonnegative = *self >= 0;
              let n = if is_nonnegative {
                  self.to_u128()
              } else {
                  // convert the negative num to positive by summing 1 to it's 2 complement
                  (!self.to_u128()).wrapping_add(1)
              };
              fmt_u128(n, is_nonnegative, f)
          }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.read (|
              let~ is_nonnegative :=
                M.alloc (|
                  BinOp.ge (| M.read (| M.read (| self |) |), Value.Integer IntegerKind.I128 0 |)
                |) in
              let~ n :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use is_nonnegative in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::fmt::num::DisplayInt",
                                Ty.path "i128",
                                [],
                                "to_u128",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                              [
                                UnOp.not (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::fmt::num::DisplayInt",
                                      Ty.path "i128",
                                      [],
                                      "to_u128",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |);
                                Value.Integer IntegerKind.U128 1
                              ]
                            |)
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::fmt::num::fmt_u128", [] |),
                  [ M.read (| n |); M.read (| is_nonnegative |); M.read (| f |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_i128.
    
    (*
    fn fmt_u128(n: u128, is_nonnegative: bool, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // 2^128 is about 3*10^38, so 39 gives an extra byte of space
        let mut buf = [MaybeUninit::<u8>::uninit(); 39];
        let mut curr = buf.len();
    
        let (n, rem) = udiv_1e19(n);
        parse_u64_into(rem, &mut buf, &mut curr);
    
        if n != 0 {
            // 0 pad up to point
            let target = buf.len() - 19;
            // SAFETY: Guaranteed that we wrote at most 19 bytes, and there must be space
            // remaining since it has length 39
            unsafe {
                ptr::write_bytes(
                    MaybeUninit::slice_as_mut_ptr(&mut buf).add(target),
                    b'0',
                    curr - target,
                );
            }
            curr = target;
    
            let (n, rem) = udiv_1e19(n);
            parse_u64_into(rem, &mut buf, &mut curr);
            // Should this following branch be annotated with unlikely?
            if n != 0 {
                let target = buf.len() - 38;
                // The raw `buf_ptr` pointer is only valid until `buf` is used the next time,
                // buf `buf` is not used in this scope so we are good.
                let buf_ptr = MaybeUninit::slice_as_mut_ptr(&mut buf);
                // SAFETY: At this point we wrote at most 38 bytes, pad up to that point,
                // There can only be at most 1 digit remaining.
                unsafe {
                    ptr::write_bytes(buf_ptr.add(target), b'0', curr - target);
                    curr = target - 1;
                    *buf_ptr.add(curr) = (n as u8) + b'0';
                }
            }
        }
    
        // SAFETY: `curr` > 0 (since we made `buf` large enough), and all the chars are valid
        // UTF-8 since `DEC_DIGITS_LUT` is
        let buf_slice = unsafe {
            str::from_utf8_unchecked(slice::from_raw_parts(
                MaybeUninit::slice_as_mut_ptr(&mut buf).add(curr),
                buf.len() - curr,
            ))
        };
        f.pad_integral(is_nonnegative, "", buf_slice)
    }
    *)
    Definition fmt_u128 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n; is_nonnegative; f ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          let is_nonnegative := M.alloc (| is_nonnegative |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ buf :=
              M.alloc (|
                repeat
                  (M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ],
                      "uninit",
                      []
                    |),
                    []
                  |))
                  39
              |) in
            let~ curr :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "slice")
                      [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [ Ty.path "u8" ]
                      ],
                    "len",
                    []
                  |),
                  [ (* Unsize *) M.pointer_coercion buf ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "core::fmt::num::udiv_1e19", [] |),
                  [ M.read (| n |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let n := M.copy (| γ0_0 |) in
                    let rem := M.copy (| γ0_1 |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::fmt::num::parse_u64_into", [] |),
                          [ M.read (| rem |); buf; curr ]
                        |)
                      |) in
                    let~ _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.ne (| M.read (| n |), Value.Integer IntegerKind.U128 0 |)
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let~ target :=
                                M.alloc (|
                                  BinOp.Wrap.sub (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              [ Ty.path "u8" ]
                                          ],
                                        "len",
                                        []
                                      |),
                                      [ (* Unsize *) M.pointer_coercion buf ]
                                    |),
                                    Value.Integer IntegerKind.Usize 19
                                  |)
                                |) in
                              let~ _ :=
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::intrinsics::write_bytes",
                                        [ Ty.path "u8" ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                            "add",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  [ Ty.path "u8" ],
                                                "slice_as_mut_ptr",
                                                []
                                              |),
                                              [ (* Unsize *) M.pointer_coercion buf ]
                                            |);
                                            M.read (| target |)
                                          ]
                                        |);
                                        M.read (| UnsupportedLiteral |);
                                        BinOp.Wrap.sub (| M.read (| curr |), M.read (| target |) |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |) in
                              let~ _ := M.write (| curr, M.read (| target |) |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_function (| "core::fmt::num::udiv_1e19", [] |),
                                    [ M.read (| n |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let n := M.copy (| γ0_0 |) in
                                      let rem := M.copy (| γ0_1 |) in
                                      let~ _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (|
                                              "core::fmt::num::parse_u64_into",
                                              []
                                            |),
                                            [ M.read (| rem |); buf; curr ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    BinOp.ne (|
                                                      M.read (| n |),
                                                      Value.Integer IntegerKind.U128 0
                                                    |)
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              let~ target :=
                                                M.alloc (|
                                                  BinOp.Wrap.sub (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::mem::maybe_uninit::MaybeUninit")
                                                              [ Ty.path "u8" ]
                                                          ],
                                                        "len",
                                                        []
                                                      |),
                                                      [ (* Unsize *) M.pointer_coercion buf ]
                                                    |),
                                                    Value.Integer IntegerKind.Usize 38
                                                  |)
                                                |) in
                                              let~ buf_ptr :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::mem::maybe_uninit::MaybeUninit")
                                                        [ Ty.path "u8" ],
                                                      "slice_as_mut_ptr",
                                                      []
                                                    |),
                                                    [ (* Unsize *) M.pointer_coercion buf ]
                                                  |)
                                                |) in
                                              let~ _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_function (|
                                                      "core::intrinsics::write_bytes",
                                                      [ Ty.path "u8" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "*mut")
                                                            [ Ty.path "u8" ],
                                                          "add",
                                                          []
                                                        |),
                                                        [ M.read (| buf_ptr |); M.read (| target |)
                                                        ]
                                                      |);
                                                      M.read (| UnsupportedLiteral |);
                                                      BinOp.Wrap.sub (|
                                                        M.read (| curr |),
                                                        M.read (| target |)
                                                      |)
                                                    ]
                                                  |)
                                                |) in
                                              let~ _ :=
                                                M.write (|
                                                  curr,
                                                  BinOp.Wrap.sub (|
                                                    M.read (| target |),
                                                    Value.Integer IntegerKind.Usize 1
                                                  |)
                                                |) in
                                              let~ _ :=
                                                M.write (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                                      "add",
                                                      []
                                                    |),
                                                    [ M.read (| buf_ptr |); M.read (| curr |) ]
                                                  |),
                                                  BinOp.Wrap.add (|
                                                    M.rust_cast (M.read (| n |)),
                                                    M.read (| UnsupportedLiteral |)
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let~ buf_slice :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "core::str::converts::from_utf8_unchecked", [] |),
                          [
                            M.call_closure (|
                              M.get_function (|
                                "core::slice::raw::from_raw_parts",
                                [ Ty.path "u8" ]
                              |),
                              [
                                (* MutToConstPointer *)
                                M.pointer_coercion
                                  (M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "*mut") [ Ty.path "u8" ],
                                      "add",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ Ty.path "u8" ],
                                          "slice_as_mut_ptr",
                                          []
                                        |),
                                        [ (* Unsize *) M.pointer_coercion buf ]
                                      |);
                                      M.read (| curr |)
                                    ]
                                  |));
                                BinOp.Wrap.sub (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            [ Ty.path "u8" ]
                                        ],
                                      "len",
                                      []
                                    |),
                                    [ (* Unsize *) M.pointer_coercion buf ]
                                  |),
                                  M.read (| curr |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "pad_integral",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| is_nonnegative |);
                          M.read (| Value.String "" |);
                          M.read (| buf_slice |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_fmt_u128 : M.IsFunction "core::fmt::num::fmt_u128" fmt_u128.
    
    (*
    fn udiv_1e19(n: u128) -> (u128, u64) {
        const DIV: u64 = 1e19 as u64;
        const FACTOR: u128 = 156927543384667019095894735580191660403;
    
        let quot = if n < 1 << 83 {
            ((n >> 19) as u64 / (DIV >> 19)) as u128
        } else {
            u128_mulhi(n, FACTOR) >> 62
        };
    
        let rem = (n - quot * DIV as u128) as u64;
        (quot, rem)
    }
    *)
    Definition udiv_1e19 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let~ quot :=
              M.copy (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.lt (|
                                M.read (| n |),
                                BinOp.Wrap.shl (|
                                  Value.Integer IntegerKind.U128 1,
                                  Value.Integer IntegerKind.I32 83
                                |)
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.rust_cast
                            (BinOp.Wrap.div (|
                              M.rust_cast
                                (BinOp.Wrap.shr (|
                                  M.read (| n |),
                                  Value.Integer IntegerKind.I32 19
                                |)),
                              BinOp.Wrap.shr (|
                                M.read (| M.get_constant (| "core::fmt::num::udiv_1e19::DIV" |) |),
                                Value.Integer IntegerKind.I32 19
                              |)
                            |))
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          BinOp.Wrap.shr (|
                            M.call_closure (|
                              M.get_function (| "core::fmt::num::u128_mulhi", [] |),
                              [
                                M.read (| n |);
                                M.read (|
                                  M.get_constant (| "core::fmt::num::udiv_1e19::FACTOR" |)
                                |)
                              ]
                            |),
                            Value.Integer IntegerKind.I32 62
                          |)
                        |)))
                  ]
                |)
              |) in
            let~ rem :=
              M.alloc (|
                M.rust_cast
                  (BinOp.Wrap.sub (|
                    M.read (| n |),
                    BinOp.Wrap.mul (|
                      M.read (| quot |),
                      M.rust_cast
                        (M.read (| M.get_constant (| "core::fmt::num::udiv_1e19::DIV" |) |))
                    |)
                  |))
              |) in
            M.alloc (| Value.Tuple [ M.read (| quot |); M.read (| rem |) ] |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_udiv_1e19 : M.IsFunction "core::fmt::num::udiv_1e19" udiv_1e19.
    
    Module udiv_1e19.
      Definition value_DIV : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| M.rust_cast (M.read (| UnsupportedLiteral |)) |))).
      
      Definition value_FACTOR : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (| Value.Integer IntegerKind.U128 156927543384667019095894735580191660403 |))).
    End udiv_1e19.
    
    (*
    fn u128_mulhi(x: u128, y: u128) -> u128 {
        let x_lo = x as u64;
        let x_hi = (x >> 64) as u64;
        let y_lo = y as u64;
        let y_hi = (y >> 64) as u64;
    
        // handle possibility of overflow
        let carry = (x_lo as u128 * y_lo as u128) >> 64;
        let m = x_lo as u128 * y_hi as u128 + carry;
        let high1 = m >> 64;
    
        let m_lo = m as u64;
        let high2 = (x_hi as u128 * y_lo as u128 + m_lo as u128) >> 64;
    
        x_hi as u128 * y_hi as u128 + high1 + high2
    }
    *)
    Definition u128_mulhi (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ x; y ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          M.read (|
            let~ x_lo := M.alloc (| M.rust_cast (M.read (| x |)) |) in
            let~ x_hi :=
              M.alloc (|
                M.rust_cast (BinOp.Wrap.shr (| M.read (| x |), Value.Integer IntegerKind.I32 64 |))
              |) in
            let~ y_lo := M.alloc (| M.rust_cast (M.read (| y |)) |) in
            let~ y_hi :=
              M.alloc (|
                M.rust_cast (BinOp.Wrap.shr (| M.read (| y |), Value.Integer IntegerKind.I32 64 |))
              |) in
            let~ carry :=
              M.alloc (|
                BinOp.Wrap.shr (|
                  BinOp.Wrap.mul (|
                    M.rust_cast (M.read (| x_lo |)),
                    M.rust_cast (M.read (| y_lo |))
                  |),
                  Value.Integer IntegerKind.I32 64
                |)
              |) in
            let~ m :=
              M.alloc (|
                BinOp.Wrap.add (|
                  BinOp.Wrap.mul (|
                    M.rust_cast (M.read (| x_lo |)),
                    M.rust_cast (M.read (| y_hi |))
                  |),
                  M.read (| carry |)
                |)
              |) in
            let~ high1 :=
              M.alloc (| BinOp.Wrap.shr (| M.read (| m |), Value.Integer IntegerKind.I32 64 |) |) in
            let~ m_lo := M.alloc (| M.rust_cast (M.read (| m |)) |) in
            let~ high2 :=
              M.alloc (|
                BinOp.Wrap.shr (|
                  BinOp.Wrap.add (|
                    BinOp.Wrap.mul (|
                      M.rust_cast (M.read (| x_hi |)),
                      M.rust_cast (M.read (| y_lo |))
                    |),
                    M.rust_cast (M.read (| m_lo |))
                  |),
                  Value.Integer IntegerKind.I32 64
                |)
              |) in
            M.alloc (|
              BinOp.Wrap.add (|
                BinOp.Wrap.add (|
                  BinOp.Wrap.mul (|
                    M.rust_cast (M.read (| x_hi |)),
                    M.rust_cast (M.read (| y_hi |))
                  |),
                  M.read (| high1 |)
                |),
                M.read (| high2 |)
              |)
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_u128_mulhi : M.IsFunction "core::fmt::num::u128_mulhi" u128_mulhi.
  End num.
End fmt.
