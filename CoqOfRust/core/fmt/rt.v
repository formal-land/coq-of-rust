(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module fmt.
  Module rt.
    (* StructRecord
      {
        name := "Placeholder";
        ty_params := [];
        fields :=
          [
            ("position", Ty.path "usize");
            ("fill", Ty.path "char");
            ("align", Ty.path "core::fmt::rt::Alignment");
            ("flags", Ty.path "u32");
            ("precision", Ty.path "core::fmt::rt::Count");
            ("width", Ty.path "core::fmt::rt::Count")
          ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_fmt_rt_Placeholder.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Placeholder".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_fmt_rt_Placeholder.
    
    Module Impl_core_clone_Clone_for_core_fmt_rt_Placeholder.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Placeholder".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Value.DeclaredButUndefined,
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Value.DeclaredButUndefined,
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Value.DeclaredButUndefined,
                                                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_rt_Placeholder.
    
    Module Impl_core_fmt_rt_Placeholder.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Placeholder".
      
      (*
          pub const fn new(
              position: usize,
              fill: char,
              align: Alignment,
              flags: u32,
              precision: Count,
              width: Count,
          ) -> Self {
              Self { position, fill, align, flags, precision, width }
          }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ position; fill; align; flags; precision; width ] =>
          ltac:(M.monadic
            (let position := M.alloc (| position |) in
            let fill := M.alloc (| fill |) in
            let align := M.alloc (| align |) in
            let flags := M.alloc (| flags |) in
            let precision := M.alloc (| precision |) in
            let width := M.alloc (| width |) in
            Value.StructRecord
              "core::fmt::rt::Placeholder"
              [
                ("position", M.read (| position |));
                ("fill", M.read (| fill |));
                ("align", M.read (| align |));
                ("flags", M.read (| flags |));
                ("precision", M.read (| precision |));
                ("width", M.read (| width |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    End Impl_core_fmt_rt_Placeholder.
    
    (*
    Enum Alignment
    {
      ty_params := [];
      variants :=
        [
          {
            name := "Left";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Right";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Center";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Unknown";
            item := StructTuple [];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_marker_Copy_for_core_fmt_rt_Alignment.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Alignment".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_fmt_rt_Alignment.
    
    Module Impl_core_clone_Clone_for_core_fmt_rt_Alignment.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Alignment".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_rt_Alignment.
    
    Module Impl_core_marker_StructuralPartialEq_for_core_fmt_rt_Alignment.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Alignment".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_fmt_rt_Alignment.
    
    Module Impl_core_cmp_PartialEq_for_core_fmt_rt_Alignment.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Alignment".
      
      (* PartialEq *)
      Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            M.read (|
              let~ __self_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "core::fmt::rt::Alignment" ]
                    |),
                    [ M.read (| self |) ]
                  |)
                |) in
              let~ __arg1_tag :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::discriminant_value",
                      [ Ty.path "core::fmt::rt::Alignment" ]
                    |),
                    [ M.read (| other |) ]
                  |)
                |) in
              M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_fmt_rt_Alignment.
    
    Module Impl_core_marker_StructuralEq_for_core_fmt_rt_Alignment.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Alignment".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralEq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_StructuralEq_for_core_fmt_rt_Alignment.
    
    Module Impl_core_cmp_Eq_for_core_fmt_rt_Alignment.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Alignment".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_fmt_rt_Alignment.
    
    (*
    Enum Count
    {
      ty_params := [];
      variants :=
        [
          {
            name := "Is";
            item := StructTuple [ Ty.path "usize" ];
            discriminant := None;
          };
          {
            name := "Param";
            item := StructTuple [ Ty.path "usize" ];
            discriminant := None;
          };
          {
            name := "Implied";
            item := StructTuple [];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_marker_Copy_for_core_fmt_rt_Count.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Count".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_fmt_rt_Count.
    
    Module Impl_core_clone_Clone_for_core_fmt_rt_Count.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Count".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_rt_Count.
    
    (*
    Enum Flag
    {
      ty_params := [];
      variants :=
        [
          {
            name := "SignPlus";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "SignMinus";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "Alternate";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "SignAwareZeroPad";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "DebugLowerHex";
            item := StructTuple [];
            discriminant := None;
          };
          {
            name := "DebugUpperHex";
            item := StructTuple [];
            discriminant := None;
          }
        ];
    }
    *)
    
    Module Impl_core_marker_Copy_for_core_fmt_rt_Flag.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Flag".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_fmt_rt_Flag.
    
    Module Impl_core_clone_Clone_for_core_fmt_rt_Flag.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Flag".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (| M.read (| self |) |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_rt_Flag.
    
    (* StructRecord
      {
        name := "Argument";
        ty_params := [];
        fields :=
          [
            ("value", Ty.apply (Ty.path "&") [ Ty.path "core::fmt::rt::Opaque" ]);
            ("formatter",
              Ty.function
                [
                  Ty.apply (Ty.path "&") [ Ty.path "core::fmt::rt::Opaque" ];
                  Ty.apply (Ty.path "&mut") [ Ty.path "core::fmt::Formatter" ]
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ]))
          ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_fmt_rt_Argument.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Argument".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_fmt_rt_Argument.
    
    Module Impl_core_clone_Clone_for_core_fmt_rt_Argument.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Argument".
      
      (* Clone *)
      Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_fmt_rt_Argument.
    
    Module Impl_core_fmt_rt_Argument.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::Argument".
      
      (*
          fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'b> {
              // SAFETY: `mem::transmute(x)` is safe because
              //     1. `&'b T` keeps the lifetime it originated with `'b`
              //              (so as to not have an unbounded lifetime)
              //     2. `&'b T` and `&'b Opaque` have the same memory layout
              //              (when `T` is `Sized`, as it is here)
              // `mem::transmute(f)` is safe since `fn(&T, &mut Formatter<'_>) -> Result`
              // and `fn(&Opaque, &mut Formatter<'_>) -> Result` have the same ABI
              // (as long as `T` is `Sized`)
              unsafe { Argument { formatter: mem::transmute(f), value: mem::transmute(x) } }
          }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x; f ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            let f := M.alloc (| f |) in
            Value.StructRecord
              "core::fmt::rt::Argument"
              [
                ("formatter",
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::transmute",
                      [
                        Ty.function
                          [
                            Ty.apply (Ty.path "&") [ T ];
                            Ty.apply (Ty.path "&mut") [ Ty.path "core::fmt::Formatter" ]
                          ]
                          (Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ]);
                        Ty.function
                          [
                            Ty.apply (Ty.path "&") [ Ty.path "core::fmt::rt::Opaque" ];
                            Ty.apply (Ty.path "&mut") [ Ty.path "core::fmt::Formatter" ]
                          ]
                          (Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ])
                      ]
                    |),
                    [ M.read (| f |) ]
                  |));
                ("value",
                  M.call_closure (|
                    M.get_function (|
                      "core::intrinsics::transmute",
                      [
                        Ty.apply (Ty.path "&") [ T ];
                        Ty.apply (Ty.path "&") [ Ty.path "core::fmt::rt::Opaque" ]
                      ]
                    |),
                    [ M.read (| x |) ]
                  |))
              ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
      
      (*
          pub fn new_display<'b, T: Display>(x: &'b T) -> Argument<'_> {
              Self::new(x, Display::fmt)
          }
      *)
      Definition new_display (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_trait_method (| "core::fmt::Display", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_display : M.IsAssociatedFunction Self "new_display" new_display.
      
      (*
          pub fn new_debug<'b, T: Debug>(x: &'b T) -> Argument<'_> {
              Self::new(x, Debug::fmt)
          }
      *)
      Definition new_debug (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_trait_method (| "core::fmt::Debug", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_debug : M.IsAssociatedFunction Self "new_debug" new_debug.
      
      (*
          pub fn new_octal<'b, T: Octal>(x: &'b T) -> Argument<'_> {
              Self::new(x, Octal::fmt)
          }
      *)
      Definition new_octal (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_trait_method (| "core::fmt::Octal", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_octal : M.IsAssociatedFunction Self "new_octal" new_octal.
      
      (*
          pub fn new_lower_hex<'b, T: LowerHex>(x: &'b T) -> Argument<'_> {
              Self::new(x, LowerHex::fmt)
          }
      *)
      Definition new_lower_hex (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_trait_method (| "core::fmt::LowerHex", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_lower_hex :
        M.IsAssociatedFunction Self "new_lower_hex" new_lower_hex.
      
      (*
          pub fn new_upper_hex<'b, T: UpperHex>(x: &'b T) -> Argument<'_> {
              Self::new(x, UpperHex::fmt)
          }
      *)
      Definition new_upper_hex (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_trait_method (| "core::fmt::UpperHex", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_upper_hex :
        M.IsAssociatedFunction Self "new_upper_hex" new_upper_hex.
      
      (*
          pub fn new_pointer<'b, T: Pointer>(x: &'b T) -> Argument<'_> {
              Self::new(x, Pointer::fmt)
          }
      *)
      Definition new_pointer (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_trait_method (| "core::fmt::Pointer", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_pointer : M.IsAssociatedFunction Self "new_pointer" new_pointer.
      
      (*
          pub fn new_binary<'b, T: Binary>(x: &'b T) -> Argument<'_> {
              Self::new(x, Binary::fmt)
          }
      *)
      Definition new_binary (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion (M.get_trait_method (| "core::fmt::Binary", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_binary : M.IsAssociatedFunction Self "new_binary" new_binary.
      
      (*
          pub fn new_lower_exp<'b, T: LowerExp>(x: &'b T) -> Argument<'_> {
              Self::new(x, LowerExp::fmt)
          }
      *)
      Definition new_lower_exp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_trait_method (| "core::fmt::LowerExp", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_lower_exp :
        M.IsAssociatedFunction Self "new_lower_exp" new_lower_exp.
      
      (*
          pub fn new_upper_exp<'b, T: UpperExp>(x: &'b T) -> Argument<'_> {
              Self::new(x, UpperExp::fmt)
          }
      *)
      Definition new_upper_exp (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "core::fmt::rt::Argument", "new", [ T ] |),
              [
                M.read (| x |);
                (* ReifyFnPointer *)
                M.pointer_coercion
                  (M.get_trait_method (| "core::fmt::UpperExp", T, [], "fmt", [] |))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new_upper_exp :
        M.IsAssociatedFunction Self "new_upper_exp" new_upper_exp.
      
      (*
          pub fn from_usize(x: &usize) -> Argument<'_> {
              Self::new(x, USIZE_MARKER)
          }
      *)
      Definition from_usize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ x ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::fmt::rt::Argument",
                "new",
                [ Ty.path "usize" ]
              |),
              [
                M.read (| x |);
                M.read (| M.read (| M.get_constant (| "core::fmt::rt::USIZE_MARKER" |) |) |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_from_usize : M.IsAssociatedFunction Self "from_usize" from_usize.
      
      (*
          pub(super) fn fmt(&self, f: &mut Formatter<'_>) -> Result {
              (self.formatter)(self.value, f)
          }
      *)
      Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.read (| self |),
                  "core::fmt::rt::Argument",
                  "formatter"
                |)
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::fmt::rt::Argument",
                    "value"
                  |)
                |);
                M.read (| f |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_fmt : M.IsAssociatedFunction Self "fmt" fmt.
      
      (*
          pub(super) fn as_usize(&self) -> Option<usize> {
              // We are type punning a bit here: USIZE_MARKER only takes an &usize but
              // formatter takes an &Opaque. Rust understandably doesn't think we should compare
              // the function pointers if they don't have the same signature, so we cast to
              // usizes to tell it that we just want to compare addresses.
              if self.formatter as usize == USIZE_MARKER as usize {
                  // SAFETY: The `formatter` field is only set to USIZE_MARKER if
                  // the value is a usize, so this is safe
                  Some(unsafe { *(self.value as *const _ as *const usize) })
              } else {
                  None
              }
          }
      *)
      Definition as_usize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.eq
                              (M.rust_cast
                                (M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.read (| self |),
                                    "core::fmt::rt::Argument",
                                    "formatter"
                                  |)
                                |)))
                              (M.rust_cast
                                (M.read (|
                                  M.read (| M.get_constant (| "core::fmt::rt::USIZE_MARKER" |) |)
                                |)))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.rust_cast
                                (M.read (|
                                  M.use
                                    (M.alloc (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::fmt::rt::Argument",
                                          "value"
                                        |)
                                      |)
                                    |))
                                |))
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_as_usize : M.IsAssociatedFunction Self "as_usize" as_usize.
      
      (*
          pub fn none() -> [Self; 0] {
              []
          }
      *)
      Definition none (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with | [], [] => ltac:(M.monadic (Value.Array [])) | _, _ => M.impossible end.
      
      Axiom AssociatedFunction_none : M.IsAssociatedFunction Self "none" none.
    End Impl_core_fmt_rt_Argument.
    
    (* StructRecord
      {
        name := "UnsafeArg";
        ty_params := [];
        fields := [ ("_private", Ty.tuple []) ];
      } *)
    
    Module Impl_core_fmt_rt_UnsafeArg.
      Definition Self : Ty.t := Ty.path "core::fmt::rt::UnsafeArg".
      
      (*
          pub unsafe fn new() -> Self {
              Self { _private: () }
          }
      *)
      Definition new (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [] =>
          ltac:(M.monadic
            (Value.StructRecord "core::fmt::rt::UnsafeArg" [ ("_private", Value.Tuple []) ]))
        | _, _ => M.impossible
        end.
      
      Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    End Impl_core_fmt_rt_UnsafeArg.
    
    (* Foreign type 'Opaque' *)
    
    Definition value_USIZE_MARKER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.alloc (|
              (* ClosureFnPointer(Normal) *)
              M.pointer_coercion
                (M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let ptr := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.read (|
                                            let~ _v :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (|
                                                    "core::ptr::read_volatile",
                                                    [ Ty.path "usize" ]
                                                  |),
                                                  [ M.read (| ptr |) ]
                                                |)
                                              |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.loop (|
                                                    ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => ltac:(M.monadic (M.impossible (||)))
                      end)))
            |)
          |))).
  End rt.
End fmt.
