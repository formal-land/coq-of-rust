(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module hash.
  (* Trait *)
  Module Hash.
    Definition hash_slice (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ H ], [ data; state ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let state := M.alloc (| state |) in
          M.read (|
            M.use
              (M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Self ] ],
                      [],
                      "into_iter",
                      []
                    |),
                    [ M.read (| data |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        ltac:(M.monadic
                          (let~ _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [ Self ],
                                    [],
                                    "next",
                                    []
                                  |),
                                  [ iter ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let piece := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::hash::Hash",
                                          Self,
                                          [],
                                          "hash",
                                          [ H ]
                                        |),
                                        [ M.read (| piece |); M.read (| state |) ]
                                      |)
                                    |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_hash_slice : M.IsProvidedMethod "core::hash::Hash" "hash_slice" hash_slice.
  End Hash.
  
  (* Trait *)
  Module Hasher.
    Definition write_u8 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write", [] |),
            [
              M.read (| self |);
              (* Unsize *) M.pointer_coercion (M.alloc (| Value.Array [ M.read (| i |) ] |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_u8 : M.IsProvidedMethod "core::hash::Hasher" "write_u8" write_u8.
    Definition write_u16 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write", [] |),
            [
              M.read (| self |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u16", "to_ne_bytes", [] |),
                    [ M.read (| i |) ]
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_u16 : M.IsProvidedMethod "core::hash::Hasher" "write_u16" write_u16.
    Definition write_u32 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write", [] |),
            [
              M.read (| self |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u32", "to_ne_bytes", [] |),
                    [ M.read (| i |) ]
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_u32 : M.IsProvidedMethod "core::hash::Hasher" "write_u32" write_u32.
    Definition write_u64 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write", [] |),
            [
              M.read (| self |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "to_ne_bytes", [] |),
                    [ M.read (| i |) ]
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_u64 : M.IsProvidedMethod "core::hash::Hasher" "write_u64" write_u64.
    Definition write_u128 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write", [] |),
            [
              M.read (| self |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u128", "to_ne_bytes", [] |),
                    [ M.read (| i |) ]
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_u128 :
      M.IsProvidedMethod "core::hash::Hasher" "write_u128" write_u128.
    Definition write_usize (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write", [] |),
            [
              M.read (| self |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "to_ne_bytes", [] |),
                    [ M.read (| i |) ]
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_usize :
      M.IsProvidedMethod "core::hash::Hasher" "write_usize" write_usize.
    Definition write_i8 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write_u8", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| i |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_i8 : M.IsProvidedMethod "core::hash::Hasher" "write_i8" write_i8.
    Definition write_i16 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write_u16", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| i |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_i16 : M.IsProvidedMethod "core::hash::Hasher" "write_i16" write_i16.
    Definition write_i32 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write_u32", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| i |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_i32 : M.IsProvidedMethod "core::hash::Hasher" "write_i32" write_i32.
    Definition write_i64 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write_u64", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| i |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_i64 : M.IsProvidedMethod "core::hash::Hasher" "write_i64" write_i64.
    Definition write_i128 (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write_u128", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| i |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_i128 :
      M.IsProvidedMethod "core::hash::Hasher" "write_i128" write_i128.
    Definition write_isize (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", Self, [], "write_usize", [] |),
            [ M.read (| self |); M.rust_cast (M.read (| i |)) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_isize :
      M.IsProvidedMethod "core::hash::Hasher" "write_isize" write_isize.
    Definition write_length_prefix (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", Self, [], "write_usize", [] |),
                  [ M.read (| self |); M.read (| len |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_length_prefix :
      M.IsProvidedMethod "core::hash::Hasher" "write_length_prefix" write_length_prefix.
    Definition write_str (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.read (|
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", Self, [], "write", [] |),
                  [
                    M.read (| self |);
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                      [ M.read (| s |) ]
                    |)
                  ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", Self, [], "write_u8", [] |),
                  [ M.read (| self |); Value.Integer 255 ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_write_str : M.IsProvidedMethod "core::hash::Hasher" "write_str" write_str.
  End Hasher.
  
  Module Impl_core_hash_Hasher_where_core_hash_Hasher_H_where_core_marker_Sized_H_for_ref_mut_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ H ].
    
    (*
        fn finish(&self) -> u64 {
            ( **self).finish()
        }
    *)
    Definition finish (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "finish", [] |),
            [ M.read (| M.read (| self |) |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write(&mut self, bytes: &[u8]) {
            ( **self).write(bytes)
        }
    *)
    Definition write (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; bytes ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
            [ M.read (| M.read (| self |) |); M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u8(&mut self, i: u8) {
            ( **self).write_u8(i)
        }
    *)
    Definition write_u8 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_u8", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u16(&mut self, i: u16) {
            ( **self).write_u16(i)
        }
    *)
    Definition write_u16 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_u16", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u32(&mut self, i: u32) {
            ( **self).write_u32(i)
        }
    *)
    Definition write_u32 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_u32", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u64(&mut self, i: u64) {
            ( **self).write_u64(i)
        }
    *)
    Definition write_u64 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_u64", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_u128(&mut self, i: u128) {
            ( **self).write_u128(i)
        }
    *)
    Definition write_u128 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_u128", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_usize(&mut self, i: usize) {
            ( **self).write_usize(i)
        }
    *)
    Definition write_usize (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_usize", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i8(&mut self, i: i8) {
            ( **self).write_i8(i)
        }
    *)
    Definition write_i8 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_i8", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i16(&mut self, i: i16) {
            ( **self).write_i16(i)
        }
    *)
    Definition write_i16 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_i16", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i32(&mut self, i: i32) {
            ( **self).write_i32(i)
        }
    *)
    Definition write_i32 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_i32", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i64(&mut self, i: i64) {
            ( **self).write_i64(i)
        }
    *)
    Definition write_i64 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_i64", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_i128(&mut self, i: i128) {
            ( **self).write_i128(i)
        }
    *)
    Definition write_i128 (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_i128", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_isize(&mut self, i: isize) {
            ( **self).write_isize(i)
        }
    *)
    Definition write_isize (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_isize", [] |),
            [ M.read (| M.read (| self |) |); M.read (| i |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_length_prefix(&mut self, len: usize) {
            ( **self).write_length_prefix(len)
        }
    *)
    Definition write_length_prefix (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_length_prefix", [] |),
            [ M.read (| M.read (| self |) |); M.read (| len |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn write_str(&mut self, s: &str) {
            ( **self).write_str(s)
        }
    *)
    Definition write_str (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hasher", H, [], "write_str", [] |),
            [ M.read (| M.read (| self |) |); M.read (| s |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::hash::Hasher"
        (Self H)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("finish", InstanceField.Method (finish H));
          ("write", InstanceField.Method (write H));
          ("write_u8", InstanceField.Method (write_u8 H));
          ("write_u16", InstanceField.Method (write_u16 H));
          ("write_u32", InstanceField.Method (write_u32 H));
          ("write_u64", InstanceField.Method (write_u64 H));
          ("write_u128", InstanceField.Method (write_u128 H));
          ("write_usize", InstanceField.Method (write_usize H));
          ("write_i8", InstanceField.Method (write_i8 H));
          ("write_i16", InstanceField.Method (write_i16 H));
          ("write_i32", InstanceField.Method (write_i32 H));
          ("write_i64", InstanceField.Method (write_i64 H));
          ("write_i128", InstanceField.Method (write_i128 H));
          ("write_isize", InstanceField.Method (write_isize H));
          ("write_length_prefix", InstanceField.Method (write_length_prefix H));
          ("write_str", InstanceField.Method (write_str H))
        ].
  End Impl_core_hash_Hasher_where_core_hash_Hasher_H_where_core_marker_Sized_H_for_ref_mut_H.
  
  (* Trait *)
  Module BuildHasher.
    Definition hash_one (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.read (|
            let~ hasher :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::BuildHasher", Self, [], "build_hasher", [] |),
                  [ M.read (| self |) ]
                |)
              |) in
            let~ _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ Ty.associated ] |),
                  [ x; hasher ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hasher", Ty.associated, [], "finish", [] |),
                [ hasher ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_hash_one :
      M.IsProvidedMethod "core::hash::BuildHasher" "hash_one" hash_one.
  End BuildHasher.
  
  (* StructTuple
    {
      name := "BuildHasherDefault";
      ty_params := [ "H" ];
      fields := [ Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.function [] H ] ];
    } *)
  
  Module Impl_core_fmt_Debug_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "core::hash::BuildHasherDefault") [ H ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("BuildHasherDefault").finish()
        }
    *)
    Definition fmt (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugStruct",
              "finish",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::fmt::Formatter",
                    "debug_struct",
                    []
                  |),
                  [ M.read (| f |); M.read (| Value.String "BuildHasherDefault" |) ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self H)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt H)) ].
  End Impl_core_fmt_Debug_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_hash_BuildHasher_where_core_default_Default_H_where_core_hash_Hasher_H_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "core::hash::BuildHasherDefault") [ H ].
    
    (*     type Hasher = H; *)
    Definition _Hasher (H : Ty.t) : Ty.t := H.
    
    (*
        fn build_hasher(&self) -> H {
            H::default()
        }
    *)
    Definition build_hasher (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (| "core::default::Default", H, [], "default", [] |),
            []
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::hash::BuildHasher"
        (Self H)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Hasher", InstanceField.Ty (_Hasher H));
          ("build_hasher", InstanceField.Method (build_hasher H))
        ].
  End Impl_core_hash_BuildHasher_where_core_default_Default_H_where_core_hash_Hasher_H_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_clone_Clone_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "core::hash::BuildHasherDefault") [ H ].
    
    (*
        fn clone(&self) -> BuildHasherDefault<H> {
            BuildHasherDefault(marker::PhantomData)
        }
    *)
    Definition clone (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::hash::BuildHasherDefault"
            [ Value.StructTuple "core::marker::PhantomData" [] ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self H)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone H)) ].
  End Impl_core_clone_Clone_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_default_Default_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "core::hash::BuildHasherDefault") [ H ].
    
    (*
        fn default() -> BuildHasherDefault<H> {
            BuildHasherDefault(marker::PhantomData)
        }
    *)
    Definition default (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "core::hash::BuildHasherDefault"
            [ Value.StructTuple "core::marker::PhantomData" [] ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (Self H)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method (default H)) ].
  End Impl_core_default_Default_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_cmp_PartialEq_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "core::hash::BuildHasherDefault") [ H ].
    
    (*
        fn eq(&self, _other: &BuildHasherDefault<H>) -> bool {
            true
        }
    *)
    Definition eq (H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match τ, α with
      | [], [ self; _other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let _other := M.alloc (| _other |) in
          Value.Bool true))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self H)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq H)) ].
  End Impl_core_cmp_PartialEq_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_cmp_Eq_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "core::hash::BuildHasherDefault") [ H ].
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance "core::cmp::Eq" (Self H) (* Trait polymorphic types *) [] (* Instance *) [].
  End Impl_core_cmp_Eq_for_core_hash_BuildHasherDefault_H.
  
  Module impls.
    Module Impl_core_hash_Hash_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_u8", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u8.
    
    Module Impl_core_hash_Hash_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_u16", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "u16" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "u16" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u16.
    
    Module Impl_core_hash_Hash_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_u32", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "u32" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "u32" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u32.
    
    Module Impl_core_hash_Hash_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_u64", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "u64" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "u64" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u64.
    
    Module Impl_core_hash_Hash_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_usize", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "usize" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "usize" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_usize.
    
    Module Impl_core_hash_Hash_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_i8", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "i8" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "i8" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i8.
    
    Module Impl_core_hash_Hash_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_i16", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "i16" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "i16" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i16.
    
    Module Impl_core_hash_Hash_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_i32", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "i32" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "i32" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i32.
    
    Module Impl_core_hash_Hash_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_i64", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "i64" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "i64" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i64.
    
    Module Impl_core_hash_Hash_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_isize", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "isize" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "isize" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_isize.
    
    Module Impl_core_hash_Hash_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_u128", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "u128" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "u128" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u128.
    
    Module Impl_core_hash_Hash_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_i128", [] |),
              [ M.read (| state |); M.read (| M.read (| self |) |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "core::mem::size_of_val",
                      [ Ty.apply (Ty.path "slice") [ Ty.path "i128" ] ]
                    |),
                    [ M.read (| data |) ]
                  |)
                |) in
              let~ ptr :=
                M.alloc (|
                  M.rust_cast
                    (M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [ Ty.path "i128" ],
                        "as_ptr",
                        []
                      |),
                      [ M.read (| data |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hasher", H, [], "write", [] |),
                  [
                    M.read (| state |);
                    M.call_closure (|
                      M.get_function (| "core::slice::raw::from_raw_parts", [ Ty.path "u8" ] |),
                      [ M.read (| ptr |); M.read (| newlen |) ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i128.
    
    Module Impl_core_hash_Hash_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_u8( *self as u8)
              }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_u8", [] |),
              [ M.read (| state |); M.rust_cast (M.read (| M.read (| self |) |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_bool.
    
    Module Impl_core_hash_Hash_for_char.
      Definition Self : Ty.t := Ty.path "char".
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_u32( *self as u32)
              }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              M.get_trait_method (| "core::hash::Hasher", H, [], "write_u32", [] |),
              [ M.read (| state |); M.rust_cast (M.read (| M.read (| self |) |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_char.
    
    Module Impl_core_hash_Hash_for_str.
      Definition Self : Ty.t := Ty.path "str".
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_str(self);
              }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hasher", H, [], "write_str", [] |),
                    [ M.read (| state |); M.read (| self |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_str.
    
    Module Impl_core_hash_Hash_for_never.
      Definition Self : Ty.t := Ty.path "never".
      
      (*
              fn hash<H: Hasher>(&self, _: &mut H) {
                  *self
              }
      *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β1,
              [ fun γ => ltac:(M.monadic (M.never_to_any (| M.read (| M.read (| self |) |) |))) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_never.
    
    Module Impl_core_hash_Hash_for_Tuple_.
      Definition Self : Ty.t := Ty.tuple [].
      
      (*                 fn hash<H: Hasher>(&self, _state: &mut H) {} *)
      Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ H ], [ self; _state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let _state := M.alloc (| _state |) in
            Value.Tuple []))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_Tuple_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_marker_Sized_T_for_Tuple_T_.
      Definition Self (T : Ty.t) : Ty.t := Ty.tuple [ T ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_marker_Sized_T_for_Tuple_T_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_marker_Sized_B_for_Tuple_T_B_.
      Definition Self (T B : Ty.t) : Ty.t := Ty.tuple [ T; B ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_marker_Sized_B_for_Tuple_T_B_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_marker_Sized_C_for_Tuple_T_B_C_.
      Definition Self (T B C : Ty.t) : Ty.t := Ty.tuple [ T; B; C ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_marker_Sized_C_for_Tuple_T_B_C_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_marker_Sized_D_for_Tuple_T_B_C_D_.
      Definition Self (T B C D : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_marker_Sized_D_for_Tuple_T_B_C_D_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_marker_Sized_E_for_Tuple_T_B_C_D_E_.
      Definition Self (T B C D E : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_marker_Sized_E_for_Tuple_T_B_C_D_E_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_marker_Sized_F_for_Tuple_T_B_C_D_E_F_.
      Definition Self (T B C D E F : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E F : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E F in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", F, [], "hash", [ S ] |),
                            [ M.read (| value_F |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E F : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E F)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_marker_Sized_F_for_Tuple_T_B_C_D_E_F_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_marker_Sized_G_for_Tuple_T_B_C_D_E_F_G_.
      Definition Self (T B C D E F G : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F; G ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E F G : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E F G in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", F, [], "hash", [ S ] |),
                            [ M.read (| value_F |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", G, [], "hash", [ S ] |),
                            [ M.read (| value_G |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E F G : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E F G)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_marker_Sized_G_for_Tuple_T_B_C_D_E_F_G_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_marker_Sized_H_for_Tuple_T_B_C_D_E_F_G_H_.
      Definition Self (T B C D E F G H : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F; G; H ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E F G H : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E F G H in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", F, [], "hash", [ S ] |),
                            [ M.read (| value_F |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", G, [], "hash", [ S ] |),
                            [ M.read (| value_G |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", H, [], "hash", [ S ] |),
                            [ M.read (| value_H |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E F G H : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E F G H)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_marker_Sized_H_for_Tuple_T_B_C_D_E_F_G_H_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_marker_Sized_I_for_Tuple_T_B_C_D_E_F_G_H_I_.
      Definition Self (T B C D E F G H I : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F; G; H; I ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E F G H I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E F G H I in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", F, [], "hash", [ S ] |),
                            [ M.read (| value_F |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", G, [], "hash", [ S ] |),
                            [ M.read (| value_G |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", H, [], "hash", [ S ] |),
                            [ M.read (| value_H |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", I, [], "hash", [ S ] |),
                            [ M.read (| value_I |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E F G H I)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_marker_Sized_I_for_Tuple_T_B_C_D_E_F_G_H_I_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_marker_Sized_J_for_Tuple_T_B_C_D_E_F_G_H_I_J_.
      Definition Self (T B C D E F G H I J : Ty.t) : Ty.t :=
        Ty.tuple [ T; B; C; D; E; F; G; H; I; J ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E F G H I J : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E F G H I J in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let γ0_9 := M.SubPointer.get_tuple_field (| γ, 9 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let value_J := M.alloc (| γ0_9 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", F, [], "hash", [ S ] |),
                            [ M.read (| value_F |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", G, [], "hash", [ S ] |),
                            [ M.read (| value_G |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", H, [], "hash", [ S ] |),
                            [ M.read (| value_H |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", I, [], "hash", [ S ] |),
                            [ M.read (| value_I |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", J, [], "hash", [ S ] |),
                            [ M.read (| value_J |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I J : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E F G H I J)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I J)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_marker_Sized_J_for_Tuple_T_B_C_D_E_F_G_H_I_J_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_marker_Sized_K_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_.
      Definition Self (T B C D E F G H I J K : Ty.t) : Ty.t :=
        Ty.tuple [ T; B; C; D; E; F; G; H; I; J; K ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E F G H I J K : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E F G H I J K in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let γ0_9 := M.SubPointer.get_tuple_field (| γ, 9 |) in
                      let γ0_10 := M.SubPointer.get_tuple_field (| γ, 10 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let value_J := M.alloc (| γ0_9 |) in
                      let value_K := M.alloc (| γ0_10 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", F, [], "hash", [ S ] |),
                            [ M.read (| value_F |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", G, [], "hash", [ S ] |),
                            [ M.read (| value_G |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", H, [], "hash", [ S ] |),
                            [ M.read (| value_H |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", I, [], "hash", [ S ] |),
                            [ M.read (| value_I |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", J, [], "hash", [ S ] |),
                            [ M.read (| value_J |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", K, [], "hash", [ S ] |),
                            [ M.read (| value_K |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I J K : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E F G H I J K)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I J K)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_marker_Sized_K_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_hash_Hash_L_where_core_marker_Sized_L_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_L_.
      Definition Self (T B C D E F G H I J K L : Ty.t) : Ty.t :=
        Ty.tuple [ T; B; C; D; E; F; G; H; I; J; K; L ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D E F G H I J K L : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D E F G H I J K L in
        match τ, α with
        | [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let γ0_9 := M.SubPointer.get_tuple_field (| γ, 9 |) in
                      let γ0_10 := M.SubPointer.get_tuple_field (| γ, 10 |) in
                      let γ0_11 := M.SubPointer.get_tuple_field (| γ, 11 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let value_J := M.alloc (| γ0_9 |) in
                      let value_K := M.alloc (| γ0_10 |) in
                      let value_L := M.alloc (| γ0_11 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ S ] |),
                            [ M.read (| value_T |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", B, [], "hash", [ S ] |),
                            [ M.read (| value_B |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", C, [], "hash", [ S ] |),
                            [ M.read (| value_C |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", D, [], "hash", [ S ] |),
                            [ M.read (| value_D |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", E, [], "hash", [ S ] |),
                            [ M.read (| value_E |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", F, [], "hash", [ S ] |),
                            [ M.read (| value_F |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", G, [], "hash", [ S ] |),
                            [ M.read (| value_G |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", H, [], "hash", [ S ] |),
                            [ M.read (| value_H |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", I, [], "hash", [ S ] |),
                            [ M.read (| value_I |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", J, [], "hash", [ S ] |),
                            [ M.read (| value_J |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", K, [], "hash", [ S ] |),
                            [ M.read (| value_K |); M.read (| state |) ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hash", L, [], "hash", [ S ] |),
                            [ M.read (| value_L |); M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I J K L : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T B C D E F G H I J K L)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I J K L)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_hash_Hash_L_where_core_marker_Sized_L_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_L_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_length_prefix(self.len());
                  Hash::hash_slice(self, state)
              }
      *)
      Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hasher", H, [], "write_length_prefix", [] |),
                    [
                      M.read (| state |);
                      M.call_closure (|
                        M.get_associated_function (| Ty.apply (Ty.path "slice") [ T ], "len", [] |),
                        [ M.read (| self |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", T, [], "hash_slice", [ H ] |),
                  [ M.read (| self |); M.read (| state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_for_slice_T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  ( **self).hash(state);
              }
      *)
      Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ H ] |),
                    [ M.read (| M.read (| self |) |); M.read (| state |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref__T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  ( **self).hash(state);
              }
      *)
      Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::hash::Hash", T, [], "hash", [ H ] |),
                    [ M.read (| M.read (| self |) |); M.read (| state |) ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref_mut_T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_const_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*const") [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  let (address, metadata) = self.to_raw_parts();
                  state.write_usize(address.addr());
                  metadata.hash(state);
              }
      *)
      Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*const") [ T ],
                      "to_raw_parts",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let address := M.copy (| γ0_0 |) in
                      let metadata := M.copy (| γ0_1 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hasher", H, [], "write_usize", [] |),
                            [
                              M.read (| state |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [ Ty.tuple [] ],
                                  "addr",
                                  []
                                |),
                                [ M.read (| address |) ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::hash::Hash",
                              Ty.associated,
                              [],
                              "hash",
                              [ H ]
                            |),
                            [ metadata; M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_const_T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  let (address, metadata) = self.to_raw_parts();
                  state.write_usize(address.addr());
                  metadata.hash(state);
              }
      *)
      Definition hash (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [ T ],
                      "to_raw_parts",
                      []
                    |),
                    [ M.read (| M.read (| self |) |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let address := M.copy (| γ0_0 |) in
                      let metadata := M.copy (| γ0_1 |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (| "core::hash::Hasher", H, [], "write_usize", [] |),
                            [
                              M.read (| state |);
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [ Ty.tuple [] ],
                                  "addr",
                                  []
                                |),
                                [ M.read (| address |) ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::hash::Hash",
                              Ty.associated,
                              [],
                              "hash",
                              [ H ]
                            |),
                            [ metadata; M.read (| state |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_mut_T.
  End impls.
End hash.
