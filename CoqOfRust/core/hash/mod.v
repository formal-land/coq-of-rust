(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module hash.
  (* Trait *)
  Module Hash.
    Definition hash_slice (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ H ], [ data; state ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          let state := M.alloc (| state |) in
          M.read (|
            M.use
              (M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Self ] ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| data |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.tuple [],
                        ltac:(M.monadic
                          (let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.apply (Ty.path "&") [] [ Self ] ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Self ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let piece := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::hash::Hash",
                                          Self,
                                          [],
                                          [],
                                          "hash",
                                          [],
                                          [ H ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| piece |) |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |)
                                        ]
                                      |)
                                    |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_hash_slice : M.IsProvidedMethod "core::hash::Hash" "hash_slice" hash_slice.
  End Hash.
  
  (* Trait *)
  Module Hasher.
    Definition write_u8 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ M.read (| i |) ] |) |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_u8 : M.IsProvidedMethod "core::hash::Hasher" "write_u8" write_u8.
    Definition write_u16 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 2 ]
                          [ Ty.path "u8" ],
                        M.get_associated_function (| Ty.path "u16", "to_ne_bytes", [], [] |),
                        [ M.read (| i |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_u16 : M.IsProvidedMethod "core::hash::Hasher" "write_u16" write_u16.
    Definition write_u32 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 4 ]
                          [ Ty.path "u8" ],
                        M.get_associated_function (| Ty.path "u32", "to_ne_bytes", [], [] |),
                        [ M.read (| i |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_u32 : M.IsProvidedMethod "core::hash::Hasher" "write_u32" write_u32.
    Definition write_u64 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 8 ]
                          [ Ty.path "u8" ],
                        M.get_associated_function (| Ty.path "u64", "to_ne_bytes", [], [] |),
                        [ M.read (| i |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_u64 : M.IsProvidedMethod "core::hash::Hasher" "write_u64" write_u64.
    Definition write_u128 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 16 ]
                          [ Ty.path "u8" ],
                        M.get_associated_function (| Ty.path "u128", "to_ne_bytes", [], [] |),
                        [ M.read (| i |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_u128 :
      M.IsProvidedMethod "core::hash::Hasher" "write_u128" write_u128.
    Definition write_usize
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 8 ]
                          [ Ty.path "u8" ],
                        M.get_associated_function (| Ty.path "usize", "to_ne_bytes", [], [] |),
                        [ M.read (| i |) ]
                      |)
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_usize :
      M.IsProvidedMethod "core::hash::Hasher" "write_usize" write_usize.
    Definition write_i8 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write_u8", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.cast (Ty.path "u8") (M.read (| i |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_i8 : M.IsProvidedMethod "core::hash::Hasher" "write_i8" write_i8.
    Definition write_i16 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write_u16", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.cast (Ty.path "u16") (M.read (| i |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_i16 : M.IsProvidedMethod "core::hash::Hasher" "write_i16" write_i16.
    Definition write_i32 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write_u32", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.cast (Ty.path "u32") (M.read (| i |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_i32 : M.IsProvidedMethod "core::hash::Hasher" "write_i32" write_i32.
    Definition write_i64 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write_u64", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.cast (Ty.path "u64") (M.read (| i |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_i64 : M.IsProvidedMethod "core::hash::Hasher" "write_i64" write_i64.
    Definition write_i128 (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write_u128", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.cast (Ty.path "u128") (M.read (| i |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_i128 :
      M.IsProvidedMethod "core::hash::Hasher" "write_i128" write_i128.
    Definition write_isize
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write_usize", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.cast (Ty.path "usize") (M.read (| i |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_isize :
      M.IsProvidedMethod "core::hash::Hasher" "write_isize" write_isize.
    Definition write_length_prefix
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hasher",
                    Self,
                    [],
                    [],
                    "write_usize",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.read (| len |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_length_prefix :
      M.IsProvidedMethod "core::hash::Hasher" "write_length_prefix" write_length_prefix.
    Definition write_str (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_associated_function (| Ty.path "str", "as_bytes", [], [] |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", Self, [], [], "write_u8", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                    Value.Integer IntegerKind.U8 255
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_write_str : M.IsProvidedMethod "core::hash::Hasher" "write_str" write_str.
  End Hasher.
  
  Module Impl_core_hash_Hasher_where_core_hash_Hasher_H_where_core_marker_Sized_H_for_ref_mut_H.
    Definition Self (H : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ H ].
    
    (*
        fn finish(&self) -> u64 {
            ( **self).finish()
        }
    *)
    Definition finish (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u64",
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "finish", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write(&mut self, bytes: &[u8]) {
            ( **self).write(bytes)
        }
    *)
    Definition write (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; bytes ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u8(&mut self, i: u8) {
            ( **self).write_u8(i)
        }
    *)
    Definition write_u8 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u8", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u16(&mut self, i: u16) {
            ( **self).write_u16(i)
        }
    *)
    Definition write_u16 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u16", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u32(&mut self, i: u32) {
            ( **self).write_u32(i)
        }
    *)
    Definition write_u32 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u32", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u64(&mut self, i: u64) {
            ( **self).write_u64(i)
        }
    *)
    Definition write_u64 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u64", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_u128(&mut self, i: u128) {
            ( **self).write_u128(i)
        }
    *)
    Definition write_u128 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u128", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_usize(&mut self, i: usize) {
            ( **self).write_usize(i)
        }
    *)
    Definition write_usize (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_usize", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i8(&mut self, i: i8) {
            ( **self).write_i8(i)
        }
    *)
    Definition write_i8 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i8", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i16(&mut self, i: i16) {
            ( **self).write_i16(i)
        }
    *)
    Definition write_i16 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i16", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i32(&mut self, i: i32) {
            ( **self).write_i32(i)
        }
    *)
    Definition write_i32 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i32", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i64(&mut self, i: i64) {
            ( **self).write_i64(i)
        }
    *)
    Definition write_i64 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i64", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_i128(&mut self, i: i128) {
            ( **self).write_i128(i)
        }
    *)
    Definition write_i128 (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i128", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_isize(&mut self, i: isize) {
            ( **self).write_isize(i)
        }
    *)
    Definition write_isize (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; i ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let i := M.alloc (| i |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_isize", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| i |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_length_prefix(&mut self, len: usize) {
            ( **self).write_length_prefix(len)
        }
    *)
    Definition write_length_prefix
        (H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; len ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let len := M.alloc (| len |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_length_prefix", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.read (| len |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn write_str(&mut self, s: &str) {
            ( **self).write_str(s)
        }
    *)
    Definition write_str (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; s ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let s := M.alloc (| s |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_str", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
              |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::hash::Hasher"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self H)
        (* Instance *)
        [
          ("finish", InstanceField.Method (finish H));
          ("write", InstanceField.Method (write H));
          ("write_u8", InstanceField.Method (write_u8 H));
          ("write_u16", InstanceField.Method (write_u16 H));
          ("write_u32", InstanceField.Method (write_u32 H));
          ("write_u64", InstanceField.Method (write_u64 H));
          ("write_u128", InstanceField.Method (write_u128 H));
          ("write_usize", InstanceField.Method (write_usize H));
          ("write_i8", InstanceField.Method (write_i8 H));
          ("write_i16", InstanceField.Method (write_i16 H));
          ("write_i32", InstanceField.Method (write_i32 H));
          ("write_i64", InstanceField.Method (write_i64 H));
          ("write_i128", InstanceField.Method (write_i128 H));
          ("write_isize", InstanceField.Method (write_isize H));
          ("write_length_prefix", InstanceField.Method (write_length_prefix H));
          ("write_str", InstanceField.Method (write_str H))
        ].
  End Impl_core_hash_Hasher_where_core_hash_Hasher_H_where_core_marker_Sized_H_for_ref_mut_H.
  
  (* Trait *)
  Module BuildHasher.
    Definition hash_one (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.read (|
            let~ hasher : Ty.associated_in_trait "core::hash::BuildHasher" [] [] Self "Hasher" :=
              M.alloc (|
                M.call_closure (|
                  Ty.associated_in_trait "core::hash::BuildHasher" [] [] Self "Hasher",
                  M.get_trait_method (|
                    "core::hash::BuildHasher",
                    Self,
                    [],
                    [],
                    "build_hasher",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    T,
                    [],
                    [],
                    "hash",
                    [],
                    [ Ty.associated_in_trait "core::hash::BuildHasher" [] [] Self "Hasher" ]
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, x |);
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (| M.borrow (| Pointer.Kind.MutRef, hasher |) |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "u64",
                M.get_trait_method (|
                  "core::hash::Hasher",
                  Ty.associated_in_trait "core::hash::BuildHasher" [] [] Self "Hasher",
                  [],
                  [],
                  "finish",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, hasher |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_hash_one :
      M.IsProvidedMethod "core::hash::BuildHasher" "hash_one" hash_one.
  End BuildHasher.
  
  (* StructTuple
    {
      name := "BuildHasherDefault";
      const_params := [];
      ty_params := [ "H" ];
      fields := [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ Ty.function [] H ] ];
    } *)
  
  Module Impl_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ].
    
    (*
        pub const fn new() -> Self {
            BuildHasherDefault(marker::PhantomData)
        }
    *)
    Definition new (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "core::hash::BuildHasherDefault"
            [ Value.StructTuple "core::marker::PhantomData" [] ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (H : Ty.t),
      M.IsAssociatedFunction.Trait (Self H) "new" (new H).
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_fmt_Debug_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("BuildHasherDefault").finish()
        }
    *)
    Definition fmt (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugStruct",
              "finish",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.alloc (|
                  M.call_closure (|
                    Ty.path "core::fmt::builders::DebugStruct",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_struct",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| Value.String "BuildHasherDefault" |) |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self H)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt H)) ].
  End Impl_core_fmt_Debug_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_hash_BuildHasher_where_core_default_Default_H_where_core_hash_Hasher_H_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ].
    
    (*     type Hasher = H; *)
    Definition _Hasher (H : Ty.t) : Ty.t := H.
    
    (*
        fn build_hasher(&self) -> H {
            H::default()
        }
    *)
    Definition build_hasher (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            H,
            M.get_trait_method (| "core::default::Default", H, [], [], "default", [], [] |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::hash::BuildHasher"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self H)
        (* Instance *)
        [
          ("Hasher", InstanceField.Ty (_Hasher H));
          ("build_hasher", InstanceField.Method (build_hasher H))
        ].
  End Impl_core_hash_BuildHasher_where_core_default_Default_H_where_core_hash_Hasher_H_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_clone_Clone_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ].
    
    (*
        fn clone(&self) -> BuildHasherDefault<H> {
            BuildHasherDefault(marker::PhantomData)
        }
    *)
    Definition clone (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::hash::BuildHasherDefault"
            [ Value.StructTuple "core::marker::PhantomData" [] ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self H)
        (* Instance *) [ ("clone", InstanceField.Method (clone H)) ].
  End Impl_core_clone_Clone_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_default_Default_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ].
    
    (*
        fn default() -> BuildHasherDefault<H> {
            Self::new()
        }
    *)
    Definition default (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ],
              "new",
              [],
              []
            |),
            []
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self H)
        (* Instance *) [ ("default", InstanceField.Method (default H)) ].
  End Impl_core_default_Default_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_cmp_PartialEq_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ].
    
    (*
        fn eq(&self, _other: &BuildHasherDefault<H>) -> bool {
            true
        }
    *)
    Definition eq (H : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self H in
      match ε, τ, α with
      | [], [], [ self; _other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let _other := M.alloc (| _other |) in
          Value.Bool true))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self H)
        (* Instance *) [ ("eq", InstanceField.Method (eq H)) ].
  End Impl_core_cmp_PartialEq_for_core_hash_BuildHasherDefault_H.
  
  Module Impl_core_cmp_Eq_for_core_hash_BuildHasherDefault_H.
    Definition Self (H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "core::hash::BuildHasherDefault") [] [ H ].
    
    Axiom Implements :
      forall (H : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self H)
        (* Instance *) [].
  End Impl_core_cmp_Eq_for_core_hash_BuildHasherDefault_H.
  
  Module impls.
    Module Impl_core_hash_Hash_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u8", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u8.
    
    Module Impl_core_hash_Hash_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u16", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u16.
    
    Module Impl_core_hash_Hash_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u32", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u32" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u32" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u32.
    
    Module Impl_core_hash_Hash_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u64", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u64" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u64.
    
    Module Impl_core_hash_Hash_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_usize", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "usize" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "usize" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_usize.
    
    Module Impl_core_hash_Hash_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i8", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "i8" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "i8" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "i8" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i8.
    
    Module Impl_core_hash_Hash_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i16", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "i16" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "i16" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "i16" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i16.
    
    Module Impl_core_hash_Hash_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i32", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "i32" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "i32" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i32.
    
    Module Impl_core_hash_Hash_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i64", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "i64" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "i64" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i64.
    
    Module Impl_core_hash_Hash_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_isize", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "isize" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "isize" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "isize" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_isize.
    
    Module Impl_core_hash_Hash_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u128", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u128" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "u128" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_u128.
    
    Module Impl_core_hash_Hash_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
                      fn hash<H: Hasher>(&self, state: &mut H) {
                          state.$meth( *self)
                      }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_i128", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.read (| M.deref (| M.read (| self |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {
                          let newlen = mem::size_of_val(data);
                          let ptr = data.as_ptr() as *const u8;
                          // SAFETY: `ptr` is valid and aligned, as this macro is only used
                          // for numeric primitives which have no padding. The new slice only
                          // spans across `data` and is never mutated, and its total size is the
                          // same as the original `data` so it can't be over `isize::MAX`.
                          state.write(unsafe { slice::from_raw_parts(ptr, newlen) })
                      }
      *)
      Definition hash_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ data; state ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ newlen : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (|
                      "core::mem::size_of_val",
                      [],
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "i128" ] ]
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                  |)
                |) in
              let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                M.alloc (|
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*const") [] [ Ty.path "i128" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ Ty.path "i128" ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| data |) |) |) ]
                    |))
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hasher", H, [], [], "write", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                          M.get_function (|
                            "core::slice::raw::from_raw_parts",
                            [],
                            [ Ty.path "u8" ]
                          |),
                          [ M.read (| ptr |); M.read (| newlen |) ]
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("hash", InstanceField.Method hash); ("hash_slice", InstanceField.Method hash_slice) ].
    End Impl_core_hash_Hash_for_i128.
    
    Module Impl_core_hash_Hash_for_bool.
      Definition Self : Ty.t := Ty.path "bool".
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_u8( *self as u8)
              }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u8", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.cast (Ty.path "u8") (M.read (| M.deref (| M.read (| self |) |) |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_bool.
    
    Module Impl_core_hash_Hash_for_char.
      Definition Self : Ty.t := Ty.path "char".
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_u32( *self as u32)
              }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.call_closure (|
              Ty.tuple [],
              M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_u32", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                M.cast (Ty.path "u32") (M.read (| M.deref (| M.read (| self |) |) |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_char.
    
    Module Impl_core_hash_Hash_for_str.
      Definition Self : Ty.t := Ty.path "str".
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_str(self);
              }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (| "core::hash::Hasher", H, [], [], "write_str", [], [] |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_str.
    
    Module Impl_core_hash_Hash_for_never.
      Definition Self : Ty.t := Ty.path "never".
      
      (*
              fn hash<H: Hasher>(&self, _: &mut H) {
                  *self
              }
      *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; β1 ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β1,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.never_to_any (| M.read (| M.deref (| M.read (| self |) |) |) |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_never.
    
    Module Impl_core_hash_Hash_for_Tuple_.
      Definition Self : Ty.t := Ty.tuple [].
      
      (*                 fn hash<H: Hasher>(&self, _state: &mut H) {} *)
      Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ H ], [ self; _state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let _state := M.alloc (| _state |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("hash", InstanceField.Method hash) ].
    End Impl_core_hash_Hash_for_Tuple_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_marker_Sized_T_for_Tuple_T_.
      Definition Self (T : Ty.t) : Ty.t := Ty.tuple [ T ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_marker_Sized_T_for_Tuple_T_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_marker_Sized_B_for_Tuple_T_B_.
      Definition Self (T B : Ty.t) : Ty.t := Ty.tuple [ T; B ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_marker_Sized_B_for_Tuple_T_B_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_marker_Sized_C_for_Tuple_T_B_C_.
      Definition Self (T B C : Ty.t) : Ty.t := Ty.tuple [ T; B; C ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_marker_Sized_C_for_Tuple_T_B_C_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_marker_Sized_D_for_Tuple_T_B_C_D_.
      Definition Self (T B C D : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash (T B C D : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T B C D in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_marker_Sized_D_for_Tuple_T_B_C_D_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_marker_Sized_E_for_Tuple_T_B_C_D_E_.
      Definition Self (T B C D E : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_marker_Sized_E_for_Tuple_T_B_C_D_E_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_marker_Sized_F_for_Tuple_T_B_C_D_E_F_.
      Definition Self (T B C D E F : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E F in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              F,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_F |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E F : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E F)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_marker_Sized_F_for_Tuple_T_B_C_D_E_F_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_marker_Sized_G_for_Tuple_T_B_C_D_E_F_G_.
      Definition Self (T B C D E F G : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F; G ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E F G : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E F G in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              F,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_F |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              G,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_G |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E F G : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E F G)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_marker_Sized_G_for_Tuple_T_B_C_D_E_F_G_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_marker_Sized_H_for_Tuple_T_B_C_D_E_F_G_H_.
      Definition Self (T B C D E F G H : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F; G; H ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E F G H : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E F G H in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              F,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_F |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              G,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_G |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              H,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_H |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E F G H : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E F G H)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_marker_Sized_H_for_Tuple_T_B_C_D_E_F_G_H_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_marker_Sized_I_for_Tuple_T_B_C_D_E_F_G_H_I_.
      Definition Self (T B C D E F G H I : Ty.t) : Ty.t := Ty.tuple [ T; B; C; D; E; F; G; H; I ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E F G H I : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E F G H I in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              F,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_F |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              G,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_G |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              H,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_H |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              I,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_I |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E F G H I)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_marker_Sized_I_for_Tuple_T_B_C_D_E_F_G_H_I_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_marker_Sized_J_for_Tuple_T_B_C_D_E_F_G_H_I_J_.
      Definition Self (T B C D E F G H I J : Ty.t) : Ty.t :=
        Ty.tuple [ T; B; C; D; E; F; G; H; I; J ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E F G H I J : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E F G H I J in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let γ0_9 := M.SubPointer.get_tuple_field (| γ, 9 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let value_J := M.alloc (| γ0_9 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              F,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_F |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              G,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_G |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              H,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_H |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              I,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_I |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              J,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_J |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I J : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E F G H I J)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I J)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_marker_Sized_J_for_Tuple_T_B_C_D_E_F_G_H_I_J_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_marker_Sized_K_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_.
      Definition Self (T B C D E F G H I J K : Ty.t) : Ty.t :=
        Ty.tuple [ T; B; C; D; E; F; G; H; I; J; K ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E F G H I J K : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E F G H I J K in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let γ0_9 := M.SubPointer.get_tuple_field (| γ, 9 |) in
                      let γ0_10 := M.SubPointer.get_tuple_field (| γ, 10 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let value_J := M.alloc (| γ0_9 |) in
                      let value_K := M.alloc (| γ0_10 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              F,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_F |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              G,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_G |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              H,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_H |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              I,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_I |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              J,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_J |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              K,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_K |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I J K : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E F G H I J K)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I J K)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_marker_Sized_K_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_hash_Hash_L_where_core_marker_Sized_L_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_L_.
      Definition Self (T B C D E F G H I J K L : Ty.t) : Ty.t :=
        Ty.tuple [ T; B; C; D; E; F; G; H; I; J; K; L ].
      
      (*
                          fn hash<S: Hasher>(&self, state: &mut S) {
                              let ($(ref $name,)+) = *self;
                              $($name.hash(state);)+
                          }
      *)
      Definition hash
          (T B C D E F G H I J K L : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T B C D E F G H I J K L in
        match ε, τ, α with
        | [], [ _ as S ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let γ0_3 := M.SubPointer.get_tuple_field (| γ, 3 |) in
                      let γ0_4 := M.SubPointer.get_tuple_field (| γ, 4 |) in
                      let γ0_5 := M.SubPointer.get_tuple_field (| γ, 5 |) in
                      let γ0_6 := M.SubPointer.get_tuple_field (| γ, 6 |) in
                      let γ0_7 := M.SubPointer.get_tuple_field (| γ, 7 |) in
                      let γ0_8 := M.SubPointer.get_tuple_field (| γ, 8 |) in
                      let γ0_9 := M.SubPointer.get_tuple_field (| γ, 9 |) in
                      let γ0_10 := M.SubPointer.get_tuple_field (| γ, 10 |) in
                      let γ0_11 := M.SubPointer.get_tuple_field (| γ, 11 |) in
                      let value_T := M.alloc (| γ0_0 |) in
                      let value_B := M.alloc (| γ0_1 |) in
                      let value_C := M.alloc (| γ0_2 |) in
                      let value_D := M.alloc (| γ0_3 |) in
                      let value_E := M.alloc (| γ0_4 |) in
                      let value_F := M.alloc (| γ0_5 |) in
                      let value_G := M.alloc (| γ0_6 |) in
                      let value_H := M.alloc (| γ0_7 |) in
                      let value_I := M.alloc (| γ0_8 |) in
                      let value_J := M.alloc (| γ0_9 |) in
                      let value_K := M.alloc (| γ0_10 |) in
                      let value_L := M.alloc (| γ0_11 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              T,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_T |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              B,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_B |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              C,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_C |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              D,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_D |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              E,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_E |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              F,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_F |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              G,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_G |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              H,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_H |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              I,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_I |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              J,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_J |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              K,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_K |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              L,
                              [],
                              [],
                              "hash",
                              [],
                              [ S ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| value_L |) |) |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T B C D E F G H I J K L : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T B C D E F G H I J K L)
          (* Instance *) [ ("hash", InstanceField.Method (hash T B C D E F G H I J K L)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_where_core_hash_Hash_B_where_core_hash_Hash_C_where_core_hash_Hash_D_where_core_hash_Hash_E_where_core_hash_Hash_F_where_core_hash_Hash_G_where_core_hash_Hash_H_where_core_hash_Hash_I_where_core_hash_Hash_J_where_core_hash_Hash_K_where_core_hash_Hash_L_where_core_marker_Sized_L_for_Tuple_T_B_C_D_E_F_G_H_I_J_K_L_.
    
    Module Impl_core_hash_Hash_where_core_hash_Hash_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  state.write_length_prefix(self.len());
                  Hash::hash_slice(self, state)
              }
      *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (|
                      "core::hash::Hasher",
                      H,
                      [],
                      [],
                      "write_length_prefix",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ T ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "core::hash::Hash", T, [], [], "hash_slice", [], [ H ] |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_hash_Hash_T_for_slice_T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref__T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [] [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  ( **self).hash(state);
              }
      *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ H ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref__T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&mut") [] [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  ( **self).hash(state);
              }
      *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_trait_method (| "core::hash::Hash", T, [], [], "hash", [], [ H ] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (| M.read (| M.deref (| M.read (| self |) |) |) |)
                      |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_where_core_hash_Hash_T_for_ref_mut_T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_const_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*const") [] [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  let (address, metadata) = self.to_raw_parts();
                  state.write_usize(address.addr());
                  metadata.hash(state);
              }
      *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ];
                        Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] T "Metadata"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*const") [] [ T ],
                      "to_raw_parts",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let address := M.copy (| γ0_0 |) in
                      let metadata := M.copy (| γ0_1 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hasher",
                              H,
                              [],
                              [],
                              "write_usize",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                  "addr",
                                  [],
                                  []
                                |),
                                [ M.read (| address |) ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              Ty.associated_in_trait
                                "core::ptr::metadata::Pointee"
                                []
                                []
                                T
                                "Metadata",
                              [],
                              [],
                              "hash",
                              [],
                              [ H ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, metadata |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_const_T.
    
    Module Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_mut_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ T ].
      
      (*
              fn hash<H: Hasher>(&self, state: &mut H) {
                  let (address, metadata) = self.to_raw_parts();
                  state.write_usize(address.addr());
                  metadata.hash(state);
              }
      *)
      Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ H ], [ self; state ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let state := M.alloc (| state |) in
            M.read (|
              M.match_operator (|
                None,
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ];
                        Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] T "Metadata"
                      ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "*mut") [] [ T ],
                      "to_raw_parts",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let address := M.copy (| γ0_0 |) in
                      let metadata := M.copy (| γ0_1 |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hasher",
                              H,
                              [],
                              [],
                              "write_usize",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ],
                                  "addr",
                                  [],
                                  []
                                |),
                                [ M.read (| address |) ]
                              |)
                            ]
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_trait_method (|
                              "core::hash::Hash",
                              Ty.associated_in_trait
                                "core::ptr::metadata::Pointee"
                                []
                                []
                                T
                                "Metadata",
                              [],
                              [],
                              "hash",
                              [],
                              [ H ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, metadata |);
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                            ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::hash::Hash"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
    End Impl_core_hash_Hash_where_core_marker_Sized_T_for_pointer_mut_T.
  End impls.
End hash.
