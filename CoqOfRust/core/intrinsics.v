(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module hint.
  Module unreachable_unchecked.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| UnOp.not (| Value.Bool false |) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: hint::unreachable_unchecked must never be reached"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::hint::unreachable_unchecked::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] => ltac:(M.monadic (Value.Tuple []))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::hint::unreachable_unchecked::comptime" comptime.
  End unreachable_unchecked.
End hint.

Module intrinsics.
  (*
  pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {
      // SAFETY: see `ptr::drop_in_place`
      unsafe { crate::ptr::drop_in_place(to_drop) }
  }
  *)
  Definition drop_in_place (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ to_drop ] =>
      ltac:(M.monadic
        (let to_drop := M.alloc (| to_drop |) in
        M.call_closure (|
          M.get_function (| "core::ptr::drop_in_place", [ T ] |),
          [ M.read (| to_drop |) ]
        |)))
    | _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_drop_in_place : M.IsFunction "core::intrinsics::drop_in_place" drop_in_place.
  
  Parameter atomic_cxchg_relaxed_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_relaxed_relaxed :
    M.IsFunction "core::intrinsics::atomic_cxchg_relaxed_relaxed" atomic_cxchg_relaxed_relaxed.
  
  Parameter atomic_cxchg_relaxed_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_relaxed_acquire :
    M.IsFunction "core::intrinsics::atomic_cxchg_relaxed_acquire" atomic_cxchg_relaxed_acquire.
  
  Parameter atomic_cxchg_relaxed_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_relaxed_seqcst :
    M.IsFunction "core::intrinsics::atomic_cxchg_relaxed_seqcst" atomic_cxchg_relaxed_seqcst.
  
  Parameter atomic_cxchg_acquire_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_acquire_relaxed :
    M.IsFunction "core::intrinsics::atomic_cxchg_acquire_relaxed" atomic_cxchg_acquire_relaxed.
  
  Parameter atomic_cxchg_acquire_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_acquire_acquire :
    M.IsFunction "core::intrinsics::atomic_cxchg_acquire_acquire" atomic_cxchg_acquire_acquire.
  
  Parameter atomic_cxchg_acquire_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_acquire_seqcst :
    M.IsFunction "core::intrinsics::atomic_cxchg_acquire_seqcst" atomic_cxchg_acquire_seqcst.
  
  Parameter atomic_cxchg_release_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_release_relaxed :
    M.IsFunction "core::intrinsics::atomic_cxchg_release_relaxed" atomic_cxchg_release_relaxed.
  
  Parameter atomic_cxchg_release_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_release_acquire :
    M.IsFunction "core::intrinsics::atomic_cxchg_release_acquire" atomic_cxchg_release_acquire.
  
  Parameter atomic_cxchg_release_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_release_seqcst :
    M.IsFunction "core::intrinsics::atomic_cxchg_release_seqcst" atomic_cxchg_release_seqcst.
  
  Parameter atomic_cxchg_acqrel_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_acqrel_relaxed :
    M.IsFunction "core::intrinsics::atomic_cxchg_acqrel_relaxed" atomic_cxchg_acqrel_relaxed.
  
  Parameter atomic_cxchg_acqrel_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_acqrel_acquire :
    M.IsFunction "core::intrinsics::atomic_cxchg_acqrel_acquire" atomic_cxchg_acqrel_acquire.
  
  Parameter atomic_cxchg_acqrel_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_acqrel_seqcst :
    M.IsFunction "core::intrinsics::atomic_cxchg_acqrel_seqcst" atomic_cxchg_acqrel_seqcst.
  
  Parameter atomic_cxchg_seqcst_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_seqcst_relaxed :
    M.IsFunction "core::intrinsics::atomic_cxchg_seqcst_relaxed" atomic_cxchg_seqcst_relaxed.
  
  Parameter atomic_cxchg_seqcst_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_seqcst_acquire :
    M.IsFunction "core::intrinsics::atomic_cxchg_seqcst_acquire" atomic_cxchg_seqcst_acquire.
  
  Parameter atomic_cxchg_seqcst_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchg_seqcst_seqcst :
    M.IsFunction "core::intrinsics::atomic_cxchg_seqcst_seqcst" atomic_cxchg_seqcst_seqcst.
  
  Parameter atomic_cxchgweak_relaxed_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_relaxed_relaxed :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_relaxed_relaxed"
      atomic_cxchgweak_relaxed_relaxed.
  
  Parameter atomic_cxchgweak_relaxed_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_relaxed_acquire :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_relaxed_acquire"
      atomic_cxchgweak_relaxed_acquire.
  
  Parameter atomic_cxchgweak_relaxed_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_relaxed_seqcst :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_relaxed_seqcst"
      atomic_cxchgweak_relaxed_seqcst.
  
  Parameter atomic_cxchgweak_acquire_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_acquire_relaxed :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_acquire_relaxed"
      atomic_cxchgweak_acquire_relaxed.
  
  Parameter atomic_cxchgweak_acquire_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_acquire_acquire :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_acquire_acquire"
      atomic_cxchgweak_acquire_acquire.
  
  Parameter atomic_cxchgweak_acquire_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_acquire_seqcst :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_acquire_seqcst"
      atomic_cxchgweak_acquire_seqcst.
  
  Parameter atomic_cxchgweak_release_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_release_relaxed :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_release_relaxed"
      atomic_cxchgweak_release_relaxed.
  
  Parameter atomic_cxchgweak_release_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_release_acquire :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_release_acquire"
      atomic_cxchgweak_release_acquire.
  
  Parameter atomic_cxchgweak_release_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_release_seqcst :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_release_seqcst"
      atomic_cxchgweak_release_seqcst.
  
  Parameter atomic_cxchgweak_acqrel_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_acqrel_relaxed :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_acqrel_relaxed"
      atomic_cxchgweak_acqrel_relaxed.
  
  Parameter atomic_cxchgweak_acqrel_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_acqrel_acquire :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_acqrel_acquire"
      atomic_cxchgweak_acqrel_acquire.
  
  Parameter atomic_cxchgweak_acqrel_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_acqrel_seqcst :
    M.IsFunction "core::intrinsics::atomic_cxchgweak_acqrel_seqcst" atomic_cxchgweak_acqrel_seqcst.
  
  Parameter atomic_cxchgweak_seqcst_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_seqcst_relaxed :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_seqcst_relaxed"
      atomic_cxchgweak_seqcst_relaxed.
  
  Parameter atomic_cxchgweak_seqcst_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_seqcst_acquire :
    M.IsFunction
      "core::intrinsics::atomic_cxchgweak_seqcst_acquire"
      atomic_cxchgweak_seqcst_acquire.
  
  Parameter atomic_cxchgweak_seqcst_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_cxchgweak_seqcst_seqcst :
    M.IsFunction "core::intrinsics::atomic_cxchgweak_seqcst_seqcst" atomic_cxchgweak_seqcst_seqcst.
  
  Parameter atomic_load_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_load_seqcst :
    M.IsFunction "core::intrinsics::atomic_load_seqcst" atomic_load_seqcst.
  
  Parameter atomic_load_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_load_acquire :
    M.IsFunction "core::intrinsics::atomic_load_acquire" atomic_load_acquire.
  
  Parameter atomic_load_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_load_relaxed :
    M.IsFunction "core::intrinsics::atomic_load_relaxed" atomic_load_relaxed.
  
  Parameter atomic_load_unordered : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_load_unordered :
    M.IsFunction "core::intrinsics::atomic_load_unordered" atomic_load_unordered.
  
  Parameter atomic_store_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_store_seqcst :
    M.IsFunction "core::intrinsics::atomic_store_seqcst" atomic_store_seqcst.
  
  Parameter atomic_store_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_store_release :
    M.IsFunction "core::intrinsics::atomic_store_release" atomic_store_release.
  
  Parameter atomic_store_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_store_relaxed :
    M.IsFunction "core::intrinsics::atomic_store_relaxed" atomic_store_relaxed.
  
  Parameter atomic_store_unordered : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_store_unordered :
    M.IsFunction "core::intrinsics::atomic_store_unordered" atomic_store_unordered.
  
  Parameter atomic_xchg_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xchg_seqcst :
    M.IsFunction "core::intrinsics::atomic_xchg_seqcst" atomic_xchg_seqcst.
  
  Parameter atomic_xchg_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xchg_acquire :
    M.IsFunction "core::intrinsics::atomic_xchg_acquire" atomic_xchg_acquire.
  
  Parameter atomic_xchg_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xchg_release :
    M.IsFunction "core::intrinsics::atomic_xchg_release" atomic_xchg_release.
  
  Parameter atomic_xchg_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xchg_acqrel :
    M.IsFunction "core::intrinsics::atomic_xchg_acqrel" atomic_xchg_acqrel.
  
  Parameter atomic_xchg_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xchg_relaxed :
    M.IsFunction "core::intrinsics::atomic_xchg_relaxed" atomic_xchg_relaxed.
  
  Parameter atomic_xadd_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xadd_seqcst :
    M.IsFunction "core::intrinsics::atomic_xadd_seqcst" atomic_xadd_seqcst.
  
  Parameter atomic_xadd_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xadd_acquire :
    M.IsFunction "core::intrinsics::atomic_xadd_acquire" atomic_xadd_acquire.
  
  Parameter atomic_xadd_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xadd_release :
    M.IsFunction "core::intrinsics::atomic_xadd_release" atomic_xadd_release.
  
  Parameter atomic_xadd_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xadd_acqrel :
    M.IsFunction "core::intrinsics::atomic_xadd_acqrel" atomic_xadd_acqrel.
  
  Parameter atomic_xadd_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xadd_relaxed :
    M.IsFunction "core::intrinsics::atomic_xadd_relaxed" atomic_xadd_relaxed.
  
  Parameter atomic_xsub_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xsub_seqcst :
    M.IsFunction "core::intrinsics::atomic_xsub_seqcst" atomic_xsub_seqcst.
  
  Parameter atomic_xsub_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xsub_acquire :
    M.IsFunction "core::intrinsics::atomic_xsub_acquire" atomic_xsub_acquire.
  
  Parameter atomic_xsub_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xsub_release :
    M.IsFunction "core::intrinsics::atomic_xsub_release" atomic_xsub_release.
  
  Parameter atomic_xsub_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xsub_acqrel :
    M.IsFunction "core::intrinsics::atomic_xsub_acqrel" atomic_xsub_acqrel.
  
  Parameter atomic_xsub_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xsub_relaxed :
    M.IsFunction "core::intrinsics::atomic_xsub_relaxed" atomic_xsub_relaxed.
  
  Parameter atomic_and_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_and_seqcst :
    M.IsFunction "core::intrinsics::atomic_and_seqcst" atomic_and_seqcst.
  
  Parameter atomic_and_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_and_acquire :
    M.IsFunction "core::intrinsics::atomic_and_acquire" atomic_and_acquire.
  
  Parameter atomic_and_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_and_release :
    M.IsFunction "core::intrinsics::atomic_and_release" atomic_and_release.
  
  Parameter atomic_and_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_and_acqrel :
    M.IsFunction "core::intrinsics::atomic_and_acqrel" atomic_and_acqrel.
  
  Parameter atomic_and_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_and_relaxed :
    M.IsFunction "core::intrinsics::atomic_and_relaxed" atomic_and_relaxed.
  
  Parameter atomic_nand_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_nand_seqcst :
    M.IsFunction "core::intrinsics::atomic_nand_seqcst" atomic_nand_seqcst.
  
  Parameter atomic_nand_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_nand_acquire :
    M.IsFunction "core::intrinsics::atomic_nand_acquire" atomic_nand_acquire.
  
  Parameter atomic_nand_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_nand_release :
    M.IsFunction "core::intrinsics::atomic_nand_release" atomic_nand_release.
  
  Parameter atomic_nand_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_nand_acqrel :
    M.IsFunction "core::intrinsics::atomic_nand_acqrel" atomic_nand_acqrel.
  
  Parameter atomic_nand_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_nand_relaxed :
    M.IsFunction "core::intrinsics::atomic_nand_relaxed" atomic_nand_relaxed.
  
  Parameter atomic_or_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_or_seqcst :
    M.IsFunction "core::intrinsics::atomic_or_seqcst" atomic_or_seqcst.
  
  Parameter atomic_or_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_or_acquire :
    M.IsFunction "core::intrinsics::atomic_or_acquire" atomic_or_acquire.
  
  Parameter atomic_or_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_or_release :
    M.IsFunction "core::intrinsics::atomic_or_release" atomic_or_release.
  
  Parameter atomic_or_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_or_acqrel :
    M.IsFunction "core::intrinsics::atomic_or_acqrel" atomic_or_acqrel.
  
  Parameter atomic_or_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_or_relaxed :
    M.IsFunction "core::intrinsics::atomic_or_relaxed" atomic_or_relaxed.
  
  Parameter atomic_xor_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xor_seqcst :
    M.IsFunction "core::intrinsics::atomic_xor_seqcst" atomic_xor_seqcst.
  
  Parameter atomic_xor_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xor_acquire :
    M.IsFunction "core::intrinsics::atomic_xor_acquire" atomic_xor_acquire.
  
  Parameter atomic_xor_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xor_release :
    M.IsFunction "core::intrinsics::atomic_xor_release" atomic_xor_release.
  
  Parameter atomic_xor_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xor_acqrel :
    M.IsFunction "core::intrinsics::atomic_xor_acqrel" atomic_xor_acqrel.
  
  Parameter atomic_xor_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_xor_relaxed :
    M.IsFunction "core::intrinsics::atomic_xor_relaxed" atomic_xor_relaxed.
  
  Parameter atomic_max_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_max_seqcst :
    M.IsFunction "core::intrinsics::atomic_max_seqcst" atomic_max_seqcst.
  
  Parameter atomic_max_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_max_acquire :
    M.IsFunction "core::intrinsics::atomic_max_acquire" atomic_max_acquire.
  
  Parameter atomic_max_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_max_release :
    M.IsFunction "core::intrinsics::atomic_max_release" atomic_max_release.
  
  Parameter atomic_max_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_max_acqrel :
    M.IsFunction "core::intrinsics::atomic_max_acqrel" atomic_max_acqrel.
  
  Parameter atomic_max_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_max_relaxed :
    M.IsFunction "core::intrinsics::atomic_max_relaxed" atomic_max_relaxed.
  
  Parameter atomic_min_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_min_seqcst :
    M.IsFunction "core::intrinsics::atomic_min_seqcst" atomic_min_seqcst.
  
  Parameter atomic_min_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_min_acquire :
    M.IsFunction "core::intrinsics::atomic_min_acquire" atomic_min_acquire.
  
  Parameter atomic_min_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_min_release :
    M.IsFunction "core::intrinsics::atomic_min_release" atomic_min_release.
  
  Parameter atomic_min_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_min_acqrel :
    M.IsFunction "core::intrinsics::atomic_min_acqrel" atomic_min_acqrel.
  
  Parameter atomic_min_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_min_relaxed :
    M.IsFunction "core::intrinsics::atomic_min_relaxed" atomic_min_relaxed.
  
  Parameter atomic_umin_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umin_seqcst :
    M.IsFunction "core::intrinsics::atomic_umin_seqcst" atomic_umin_seqcst.
  
  Parameter atomic_umin_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umin_acquire :
    M.IsFunction "core::intrinsics::atomic_umin_acquire" atomic_umin_acquire.
  
  Parameter atomic_umin_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umin_release :
    M.IsFunction "core::intrinsics::atomic_umin_release" atomic_umin_release.
  
  Parameter atomic_umin_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umin_acqrel :
    M.IsFunction "core::intrinsics::atomic_umin_acqrel" atomic_umin_acqrel.
  
  Parameter atomic_umin_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umin_relaxed :
    M.IsFunction "core::intrinsics::atomic_umin_relaxed" atomic_umin_relaxed.
  
  Parameter atomic_umax_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umax_seqcst :
    M.IsFunction "core::intrinsics::atomic_umax_seqcst" atomic_umax_seqcst.
  
  Parameter atomic_umax_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umax_acquire :
    M.IsFunction "core::intrinsics::atomic_umax_acquire" atomic_umax_acquire.
  
  Parameter atomic_umax_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umax_release :
    M.IsFunction "core::intrinsics::atomic_umax_release" atomic_umax_release.
  
  Parameter atomic_umax_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umax_acqrel :
    M.IsFunction "core::intrinsics::atomic_umax_acqrel" atomic_umax_acqrel.
  
  Parameter atomic_umax_relaxed : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_umax_relaxed :
    M.IsFunction "core::intrinsics::atomic_umax_relaxed" atomic_umax_relaxed.
  
  Parameter atomic_fence_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_fence_seqcst :
    M.IsFunction "core::intrinsics::atomic_fence_seqcst" atomic_fence_seqcst.
  
  Parameter atomic_fence_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_fence_acquire :
    M.IsFunction "core::intrinsics::atomic_fence_acquire" atomic_fence_acquire.
  
  Parameter atomic_fence_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_fence_release :
    M.IsFunction "core::intrinsics::atomic_fence_release" atomic_fence_release.
  
  Parameter atomic_fence_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_fence_acqrel :
    M.IsFunction "core::intrinsics::atomic_fence_acqrel" atomic_fence_acqrel.
  
  Parameter atomic_singlethreadfence_seqcst : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_singlethreadfence_seqcst :
    M.IsFunction
      "core::intrinsics::atomic_singlethreadfence_seqcst"
      atomic_singlethreadfence_seqcst.
  
  Parameter atomic_singlethreadfence_acquire : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_singlethreadfence_acquire :
    M.IsFunction
      "core::intrinsics::atomic_singlethreadfence_acquire"
      atomic_singlethreadfence_acquire.
  
  Parameter atomic_singlethreadfence_release : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_singlethreadfence_release :
    M.IsFunction
      "core::intrinsics::atomic_singlethreadfence_release"
      atomic_singlethreadfence_release.
  
  Parameter atomic_singlethreadfence_acqrel : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_atomic_singlethreadfence_acqrel :
    M.IsFunction
      "core::intrinsics::atomic_singlethreadfence_acqrel"
      atomic_singlethreadfence_acqrel.
  
  Parameter prefetch_read_data : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_prefetch_read_data :
    M.IsFunction "core::intrinsics::prefetch_read_data" prefetch_read_data.
  
  Parameter prefetch_write_data : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_prefetch_write_data :
    M.IsFunction "core::intrinsics::prefetch_write_data" prefetch_write_data.
  
  Parameter prefetch_read_instruction : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_prefetch_read_instruction :
    M.IsFunction "core::intrinsics::prefetch_read_instruction" prefetch_read_instruction.
  
  Parameter prefetch_write_instruction : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_prefetch_write_instruction :
    M.IsFunction "core::intrinsics::prefetch_write_instruction" prefetch_write_instruction.
  
  Parameter rustc_peek : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_rustc_peek : M.IsFunction "core::intrinsics::rustc_peek" rustc_peek.
  
  Parameter abort : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_abort : M.IsFunction "core::intrinsics::abort" abort.
  
  Parameter unreachable : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unreachable : M.IsFunction "core::intrinsics::unreachable" unreachable.
  
  Parameter assume : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_assume : M.IsFunction "core::intrinsics::assume" assume.
  
  Parameter likely : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_likely : M.IsFunction "core::intrinsics::likely" likely.
  
  Parameter unlikely : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unlikely : M.IsFunction "core::intrinsics::unlikely" unlikely.
  
  Parameter breakpoint : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_breakpoint : M.IsFunction "core::intrinsics::breakpoint" breakpoint.
  
  Parameter size_of : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_size_of : M.IsFunction "core::intrinsics::size_of" size_of.
  
  Parameter min_align_of : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_min_align_of : M.IsFunction "core::intrinsics::min_align_of" min_align_of.
  
  Parameter pref_align_of : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_pref_align_of : M.IsFunction "core::intrinsics::pref_align_of" pref_align_of.
  
  Parameter size_of_val : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_size_of_val : M.IsFunction "core::intrinsics::size_of_val" size_of_val.
  
  Parameter min_align_of_val : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_min_align_of_val :
    M.IsFunction "core::intrinsics::min_align_of_val" min_align_of_val.
  
  Parameter type_name : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_type_name : M.IsFunction "core::intrinsics::type_name" type_name.
  
  Parameter type_id : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_type_id : M.IsFunction "core::intrinsics::type_id" type_id.
  
  Parameter assert_inhabited : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_assert_inhabited :
    M.IsFunction "core::intrinsics::assert_inhabited" assert_inhabited.
  
  Parameter assert_zero_valid : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_assert_zero_valid :
    M.IsFunction "core::intrinsics::assert_zero_valid" assert_zero_valid.
  
  Parameter assert_mem_uninitialized_valid : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_assert_mem_uninitialized_valid :
    M.IsFunction "core::intrinsics::assert_mem_uninitialized_valid" assert_mem_uninitialized_valid.
  
  Parameter caller_location : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_caller_location : M.IsFunction "core::intrinsics::caller_location" caller_location.
  
  Parameter forget : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_forget : M.IsFunction "core::intrinsics::forget" forget.
  
  Parameter transmute : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_transmute : M.IsFunction "core::intrinsics::transmute" transmute.
  
  Parameter transmute_unchecked : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_transmute_unchecked :
    M.IsFunction "core::intrinsics::transmute_unchecked" transmute_unchecked.
  
  Parameter needs_drop : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_needs_drop : M.IsFunction "core::intrinsics::needs_drop" needs_drop.
  
  Parameter offset : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_offset : M.IsFunction "core::intrinsics::offset" offset.
  
  Parameter arith_offset : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_arith_offset : M.IsFunction "core::intrinsics::arith_offset" arith_offset.
  
  Parameter ptr_mask : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ptr_mask : M.IsFunction "core::intrinsics::ptr_mask" ptr_mask.
  
  Parameter volatile_copy_nonoverlapping_memory : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_volatile_copy_nonoverlapping_memory :
    M.IsFunction
      "core::intrinsics::volatile_copy_nonoverlapping_memory"
      volatile_copy_nonoverlapping_memory.
  
  Parameter volatile_copy_memory : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_volatile_copy_memory :
    M.IsFunction "core::intrinsics::volatile_copy_memory" volatile_copy_memory.
  
  Parameter volatile_set_memory : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_volatile_set_memory :
    M.IsFunction "core::intrinsics::volatile_set_memory" volatile_set_memory.
  
  Parameter volatile_load : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_volatile_load : M.IsFunction "core::intrinsics::volatile_load" volatile_load.
  
  Parameter volatile_store : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_volatile_store : M.IsFunction "core::intrinsics::volatile_store" volatile_store.
  
  Parameter unaligned_volatile_load : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unaligned_volatile_load :
    M.IsFunction "core::intrinsics::unaligned_volatile_load" unaligned_volatile_load.
  
  Parameter unaligned_volatile_store : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unaligned_volatile_store :
    M.IsFunction "core::intrinsics::unaligned_volatile_store" unaligned_volatile_store.
  
  Parameter sqrtf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_sqrtf32 : M.IsFunction "core::intrinsics::sqrtf32" sqrtf32.
  
  Parameter sqrtf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_sqrtf64 : M.IsFunction "core::intrinsics::sqrtf64" sqrtf64.
  
  Parameter powif32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_powif32 : M.IsFunction "core::intrinsics::powif32" powif32.
  
  Parameter powif64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_powif64 : M.IsFunction "core::intrinsics::powif64" powif64.
  
  Parameter sinf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_sinf32 : M.IsFunction "core::intrinsics::sinf32" sinf32.
  
  Parameter sinf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_sinf64 : M.IsFunction "core::intrinsics::sinf64" sinf64.
  
  Parameter cosf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_cosf32 : M.IsFunction "core::intrinsics::cosf32" cosf32.
  
  Parameter cosf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_cosf64 : M.IsFunction "core::intrinsics::cosf64" cosf64.
  
  Parameter powf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_powf32 : M.IsFunction "core::intrinsics::powf32" powf32.
  
  Parameter powf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_powf64 : M.IsFunction "core::intrinsics::powf64" powf64.
  
  Parameter expf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_expf32 : M.IsFunction "core::intrinsics::expf32" expf32.
  
  Parameter expf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_expf64 : M.IsFunction "core::intrinsics::expf64" expf64.
  
  Parameter exp2f32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_exp2f32 : M.IsFunction "core::intrinsics::exp2f32" exp2f32.
  
  Parameter exp2f64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_exp2f64 : M.IsFunction "core::intrinsics::exp2f64" exp2f64.
  
  Parameter logf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_logf32 : M.IsFunction "core::intrinsics::logf32" logf32.
  
  Parameter logf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_logf64 : M.IsFunction "core::intrinsics::logf64" logf64.
  
  Parameter log10f32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_log10f32 : M.IsFunction "core::intrinsics::log10f32" log10f32.
  
  Parameter log10f64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_log10f64 : M.IsFunction "core::intrinsics::log10f64" log10f64.
  
  Parameter log2f32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_log2f32 : M.IsFunction "core::intrinsics::log2f32" log2f32.
  
  Parameter log2f64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_log2f64 : M.IsFunction "core::intrinsics::log2f64" log2f64.
  
  Parameter fmaf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fmaf32 : M.IsFunction "core::intrinsics::fmaf32" fmaf32.
  
  Parameter fmaf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fmaf64 : M.IsFunction "core::intrinsics::fmaf64" fmaf64.
  
  Parameter fabsf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fabsf32 : M.IsFunction "core::intrinsics::fabsf32" fabsf32.
  
  Parameter fabsf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fabsf64 : M.IsFunction "core::intrinsics::fabsf64" fabsf64.
  
  Parameter minnumf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_minnumf32 : M.IsFunction "core::intrinsics::minnumf32" minnumf32.
  
  Parameter minnumf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_minnumf64 : M.IsFunction "core::intrinsics::minnumf64" minnumf64.
  
  Parameter maxnumf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_maxnumf32 : M.IsFunction "core::intrinsics::maxnumf32" maxnumf32.
  
  Parameter maxnumf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_maxnumf64 : M.IsFunction "core::intrinsics::maxnumf64" maxnumf64.
  
  Parameter copysignf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_copysignf32 : M.IsFunction "core::intrinsics::copysignf32" copysignf32.
  
  Parameter copysignf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_copysignf64 : M.IsFunction "core::intrinsics::copysignf64" copysignf64.
  
  Parameter floorf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_floorf32 : M.IsFunction "core::intrinsics::floorf32" floorf32.
  
  Parameter floorf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_floorf64 : M.IsFunction "core::intrinsics::floorf64" floorf64.
  
  Parameter ceilf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ceilf32 : M.IsFunction "core::intrinsics::ceilf32" ceilf32.
  
  Parameter ceilf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ceilf64 : M.IsFunction "core::intrinsics::ceilf64" ceilf64.
  
  Parameter truncf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_truncf32 : M.IsFunction "core::intrinsics::truncf32" truncf32.
  
  Parameter truncf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_truncf64 : M.IsFunction "core::intrinsics::truncf64" truncf64.
  
  Parameter rintf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_rintf32 : M.IsFunction "core::intrinsics::rintf32" rintf32.
  
  Parameter rintf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_rintf64 : M.IsFunction "core::intrinsics::rintf64" rintf64.
  
  Parameter nearbyintf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_nearbyintf32 : M.IsFunction "core::intrinsics::nearbyintf32" nearbyintf32.
  
  Parameter nearbyintf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_nearbyintf64 : M.IsFunction "core::intrinsics::nearbyintf64" nearbyintf64.
  
  Parameter roundf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_roundf32 : M.IsFunction "core::intrinsics::roundf32" roundf32.
  
  Parameter roundf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_roundf64 : M.IsFunction "core::intrinsics::roundf64" roundf64.
  
  Parameter roundevenf32 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_roundevenf32 : M.IsFunction "core::intrinsics::roundevenf32" roundevenf32.
  
  Parameter roundevenf64 : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_roundevenf64 : M.IsFunction "core::intrinsics::roundevenf64" roundevenf64.
  
  Parameter fadd_fast : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fadd_fast : M.IsFunction "core::intrinsics::fadd_fast" fadd_fast.
  
  Parameter fsub_fast : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fsub_fast : M.IsFunction "core::intrinsics::fsub_fast" fsub_fast.
  
  Parameter fmul_fast : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fmul_fast : M.IsFunction "core::intrinsics::fmul_fast" fmul_fast.
  
  Parameter fdiv_fast : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_fdiv_fast : M.IsFunction "core::intrinsics::fdiv_fast" fdiv_fast.
  
  Parameter frem_fast : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_frem_fast : M.IsFunction "core::intrinsics::frem_fast" frem_fast.
  
  Parameter float_to_int_unchecked : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_float_to_int_unchecked :
    M.IsFunction "core::intrinsics::float_to_int_unchecked" float_to_int_unchecked.
  
  Parameter ctpop : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ctpop : M.IsFunction "core::intrinsics::ctpop" ctpop.
  
  Parameter ctlz : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ctlz : M.IsFunction "core::intrinsics::ctlz" ctlz.
  
  Parameter ctlz_nonzero : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ctlz_nonzero : M.IsFunction "core::intrinsics::ctlz_nonzero" ctlz_nonzero.
  
  Parameter cttz : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_cttz : M.IsFunction "core::intrinsics::cttz" cttz.
  
  Parameter cttz_nonzero : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_cttz_nonzero : M.IsFunction "core::intrinsics::cttz_nonzero" cttz_nonzero.
  
  Parameter bswap : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_bswap : M.IsFunction "core::intrinsics::bswap" bswap.
  
  Parameter bitreverse : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_bitreverse : M.IsFunction "core::intrinsics::bitreverse" bitreverse.
  
  Parameter add_with_overflow : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_add_with_overflow :
    M.IsFunction "core::intrinsics::add_with_overflow" add_with_overflow.
  
  Parameter sub_with_overflow : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_sub_with_overflow :
    M.IsFunction "core::intrinsics::sub_with_overflow" sub_with_overflow.
  
  Parameter mul_with_overflow : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_mul_with_overflow :
    M.IsFunction "core::intrinsics::mul_with_overflow" mul_with_overflow.
  
  Parameter exact_div : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_exact_div : M.IsFunction "core::intrinsics::exact_div" exact_div.
  
  Parameter unchecked_div : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unchecked_div : M.IsFunction "core::intrinsics::unchecked_div" unchecked_div.
  
  Parameter unchecked_rem : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unchecked_rem : M.IsFunction "core::intrinsics::unchecked_rem" unchecked_rem.
  
  Parameter unchecked_shl : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unchecked_shl : M.IsFunction "core::intrinsics::unchecked_shl" unchecked_shl.
  
  Parameter unchecked_shr : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unchecked_shr : M.IsFunction "core::intrinsics::unchecked_shr" unchecked_shr.
  
  Parameter unchecked_add : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unchecked_add : M.IsFunction "core::intrinsics::unchecked_add" unchecked_add.
  
  Parameter unchecked_sub : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unchecked_sub : M.IsFunction "core::intrinsics::unchecked_sub" unchecked_sub.
  
  Parameter unchecked_mul : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_unchecked_mul : M.IsFunction "core::intrinsics::unchecked_mul" unchecked_mul.
  
  Parameter rotate_left : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_rotate_left : M.IsFunction "core::intrinsics::rotate_left" rotate_left.
  
  Parameter rotate_right : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_rotate_right : M.IsFunction "core::intrinsics::rotate_right" rotate_right.
  
  Parameter wrapping_add : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_wrapping_add : M.IsFunction "core::intrinsics::wrapping_add" wrapping_add.
  
  Parameter wrapping_sub : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_wrapping_sub : M.IsFunction "core::intrinsics::wrapping_sub" wrapping_sub.
  
  Parameter wrapping_mul : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_wrapping_mul : M.IsFunction "core::intrinsics::wrapping_mul" wrapping_mul.
  
  Parameter saturating_add : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_saturating_add : M.IsFunction "core::intrinsics::saturating_add" saturating_add.
  
  Parameter saturating_sub : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_saturating_sub : M.IsFunction "core::intrinsics::saturating_sub" saturating_sub.
  
  Parameter read_via_copy : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_read_via_copy : M.IsFunction "core::intrinsics::read_via_copy" read_via_copy.
  
  Parameter write_via_move : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_write_via_move : M.IsFunction "core::intrinsics::write_via_move" write_via_move.
  
  Parameter discriminant_value : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_discriminant_value :
    M.IsFunction "core::intrinsics::discriminant_value" discriminant_value.
  
  Parameter variant_count : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_variant_count : M.IsFunction "core::intrinsics::variant_count" variant_count.
  
  Parameter try : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_try : M.IsFunction "core::intrinsics::try" try.
  
  Parameter nontemporal_store : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_nontemporal_store :
    M.IsFunction "core::intrinsics::nontemporal_store" nontemporal_store.
  
  Parameter ptr_offset_from : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ptr_offset_from : M.IsFunction "core::intrinsics::ptr_offset_from" ptr_offset_from.
  
  Parameter ptr_offset_from_unsigned : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ptr_offset_from_unsigned :
    M.IsFunction "core::intrinsics::ptr_offset_from_unsigned" ptr_offset_from_unsigned.
  
  Parameter ptr_guaranteed_cmp : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_ptr_guaranteed_cmp :
    M.IsFunction "core::intrinsics::ptr_guaranteed_cmp" ptr_guaranteed_cmp.
  
  Parameter const_allocate : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_const_allocate : M.IsFunction "core::intrinsics::const_allocate" const_allocate.
  
  Parameter const_deallocate : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_const_deallocate :
    M.IsFunction "core::intrinsics::const_deallocate" const_deallocate.
  
  Parameter raw_eq : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_raw_eq : M.IsFunction "core::intrinsics::raw_eq" raw_eq.
  
  Parameter compare_bytes : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_compare_bytes : M.IsFunction "core::intrinsics::compare_bytes" compare_bytes.
  
  Parameter black_box : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_black_box : M.IsFunction "core::intrinsics::black_box" black_box.
  
  Parameter vtable_size : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_vtable_size : M.IsFunction "core::intrinsics::vtable_size" vtable_size.
  
  Parameter vtable_align : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_vtable_align : M.IsFunction "core::intrinsics::vtable_align" vtable_align.
  
  Parameter const_eval_select : (list Ty.t) -> (list Value.t) -> M.
  
  Axiom Function_const_eval_select :
    M.IsFunction "core::intrinsics::const_eval_select" const_eval_select.
  
  (*
  pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {
      !ptr.is_null() && ptr.is_aligned()
  }
  *)
  Definition is_aligned_and_not_null (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        LogicalOp.and (|
          UnOp.not (|
            M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "is_null", [] |),
              [ M.read (| ptr |) ]
            |)
          |),
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "is_aligned", [] |),
              [ M.read (| ptr |) ]
            |)))
        |)))
    | _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_is_aligned_and_not_null :
    M.IsFunction "core::intrinsics::is_aligned_and_not_null" is_aligned_and_not_null.
  
  (*
  pub(crate) fn is_valid_allocation_size<T>(len: usize) -> bool {
      let max_len = const {
          let size = crate::mem::size_of::<T>();
          if size == 0 { usize::MAX } else { isize::MAX as usize / size }
      };
      len <= max_len
  }
  *)
  Definition is_valid_allocation_size (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ len ] =>
      ltac:(M.monadic
        (let len := M.alloc (| len |) in
        M.read (|
          let~ max_len :=
            M.copy (|
              M.get_constant (| "core::intrinsics::is_valid_allocation_size_discriminant" |)
            |) in
          M.alloc (| BinOp.le (| M.read (| len |), M.read (| max_len |) |) |)
        |)))
    | _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_is_valid_allocation_size :
    M.IsFunction "core::intrinsics::is_valid_allocation_size" is_valid_allocation_size.
  
  (*
  pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {
      let src_usize = src.addr();
      let dst_usize = dst.addr();
      let size = mem::size_of::<T>()
          .checked_mul(count)
          .expect("is_nonoverlapping: `size_of::<T>() * count` overflows a usize");
      let diff = src_usize.abs_diff(dst_usize);
      // If the absolute distance between the ptrs is at least as big as the size of the buffer,
      // they do not overlap.
      diff >= size
  }
  *)
  Definition is_nonoverlapping (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let~ src_usize :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "addr", [] |),
                [ M.read (| src |) ]
              |)
            |) in
          let~ dst_usize :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "addr", [] |),
                [ M.read (| dst |) ]
              |)
            |) in
          let~ size :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                  "expect",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "checked_mul", [] |),
                    [
                      M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |);
                      M.read (| count |)
                    ]
                  |);
                  M.read (|
                    Value.String "is_nonoverlapping: `size_of::<T>() * count` overflows a usize"
                  |)
                ]
              |)
            |) in
          let~ diff :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "abs_diff", [] |),
                [ M.read (| src_usize |); M.read (| dst_usize |) ]
              |)
            |) in
          M.alloc (| BinOp.ge (| M.read (| diff |), M.read (| size |) |) |)
        |)))
    | _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_is_nonoverlapping :
    M.IsFunction "core::intrinsics::is_nonoverlapping" is_nonoverlapping.
  
  (*
  pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {
      extern "rust-intrinsic" {
          #[rustc_const_stable(feature = "const_intrinsic_copy", since = "1.63.0")]
          #[rustc_nounwind]
          pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);
      }
  
      // SAFETY: the safety contract for `copy_nonoverlapping` must be
      // upheld by the caller.
      unsafe {
          assert_unsafe_precondition!(
              "ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \
              and the specified memory ranges do not overlap",
              [T](src: *const T, dst: *mut T, count: usize) =>
              is_aligned_and_not_null(src)
                  && is_aligned_and_not_null(dst)
                  && is_nonoverlapping(src, dst, count)
          );
          copy_nonoverlapping(src, dst, count)
      }
  }
  *)
  Definition copy_nonoverlapping (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let~ _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::const_eval_select",
                            [
                              Ty.tuple
                                [
                                  Ty.apply (Ty.path "*const") [ T ];
                                  Ty.apply (Ty.path "*mut") [ T ];
                                  Ty.path "usize"
                                ];
                              Ty.function
                                [
                                  Ty.apply (Ty.path "*const") [ T ];
                                  Ty.apply (Ty.path "*mut") [ T ];
                                  Ty.path "usize"
                                ]
                                (Ty.tuple []);
                              Ty.function
                                [
                                  Ty.apply (Ty.path "*const") [ T ];
                                  Ty.apply (Ty.path "*mut") [ T ];
                                  Ty.path "usize"
                                ]
                                (Ty.tuple []);
                              Ty.tuple []
                            ]
                          |),
                          [
                            Value.Tuple [ M.read (| src |); M.read (| dst |); M.read (| count |) ];
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping.comptime",
                              []
                            |);
                            M.get_function (| "core::intrinsics::copy_nonoverlapping.runtime", [] |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::copy_nonoverlapping::copy_nonoverlapping",
                [ T ]
              |),
              [ M.read (| src |); M.read (| dst |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_copy_nonoverlapping :
    M.IsFunction "core::intrinsics::copy_nonoverlapping" copy_nonoverlapping.
  
  Module copy_nonoverlapping.
    Parameter copy_nonoverlapping : (list Ty.t) -> (list Value.t) -> M.
    
    Axiom Function_copy_nonoverlapping :
      M.IsFunction "core::intrinsics::copy_nonoverlapping::copy_nonoverlapping" copy_nonoverlapping.
    
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src; dst; count ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          let count := M.alloc (| count |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            LogicalOp.and (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ M.read (| src |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_aligned_and_not_null",
                                      [ T ]
                                    |),
                                    [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |))
                                    ]
                                  |)))
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_function (| "core::intrinsics::is_nonoverlapping", [ T ] |),
                                  [
                                    M.read (| src |);
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |));
                                    M.read (| count |)
                                  ]
                                |)))
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::intrinsics::copy_nonoverlapping::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0; β1; β2 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          let β1 := M.alloc (| β1 |) in
          let β2 := M.alloc (| β2 |) in
          M.match_operator (|
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    β1,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            β2,
                            [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                          |)))
                    ]
                  |)))
            ]
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime :
      M.IsFunction "core::intrinsics::copy_nonoverlapping::comptime" comptime.
  End copy_nonoverlapping.
  
  (*
  pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {
      extern "rust-intrinsic" {
          #[rustc_const_stable(feature = "const_intrinsic_copy", since = "1.63.0")]
          #[rustc_nounwind]
          fn copy<T>(src: *const T, dst: *mut T, count: usize);
      }
  
      // SAFETY: the safety contract for `copy` must be upheld by the caller.
      unsafe {
          assert_unsafe_precondition!(
              "ptr::copy requires that both pointer arguments are aligned and non-null",
              [T](src: *const T, dst: *mut T) =>
              is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)
          );
          copy(src, dst, count)
      }
  }
  *)
  Definition copy (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let~ _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::const_eval_select",
                            [
                              Ty.tuple
                                [ Ty.apply (Ty.path "*const") [ T ]; Ty.apply (Ty.path "*mut") [ T ]
                                ];
                              Ty.function
                                [ Ty.apply (Ty.path "*const") [ T ]; Ty.apply (Ty.path "*mut") [ T ]
                                ]
                                (Ty.tuple []);
                              Ty.function
                                [ Ty.apply (Ty.path "*const") [ T ]; Ty.apply (Ty.path "*mut") [ T ]
                                ]
                                (Ty.tuple []);
                              Ty.tuple []
                            ]
                          |),
                          [
                            Value.Tuple [ M.read (| src |); M.read (| dst |) ];
                            M.get_function (| "core::intrinsics::copy.comptime", [] |);
                            M.get_function (| "core::intrinsics::copy.runtime", [] |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (| "core::intrinsics::copy::copy", [ T ] |),
              [ M.read (| src |); M.read (| dst |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_copy : M.IsFunction "core::intrinsics::copy" copy.
  
  Module copy.
    Parameter copy : (list Ty.t) -> (list Value.t) -> M.
    
    Axiom Function_copy : M.IsFunction "core::intrinsics::copy::copy" copy.
    
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src; dst ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            LogicalOp.and (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::intrinsics::is_aligned_and_not_null",
                                  [ T ]
                                |),
                                [ M.read (| src |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                                |)))
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::copy requires that both pointer arguments are aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::intrinsics::copy::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0; β1 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          let β1 := M.alloc (| β1 |) in
          M.match_operator (|
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
            ]
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::intrinsics::copy::comptime" comptime.
  End copy.
  
  (*
  pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {
      extern "rust-intrinsic" {
          #[rustc_const_unstable(feature = "const_ptr_write", issue = "86302")]
          #[rustc_nounwind]
          fn write_bytes<T>(dst: *mut T, val: u8, count: usize);
      }
  
      // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.
      unsafe {
          assert_unsafe_precondition!(
              "ptr::write_bytes requires that the destination pointer is aligned and non-null",
              [T](dst: *mut T) => is_aligned_and_not_null(dst)
          );
          write_bytes(dst, val, count)
      }
  }
  *)
  Definition write_bytes (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ dst; val; count ] =>
      ltac:(M.monadic
        (let dst := M.alloc (| dst |) in
        let val := M.alloc (| val |) in
        let count := M.alloc (| count |) in
        M.read (|
          let~ _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::const_eval_select",
                            [
                              Ty.tuple [ Ty.apply (Ty.path "*mut") [ T ] ];
                              Ty.function [ Ty.apply (Ty.path "*mut") [ T ] ] (Ty.tuple []);
                              Ty.function [ Ty.apply (Ty.path "*mut") [ T ] ] (Ty.tuple []);
                              Ty.tuple []
                            ]
                          |),
                          [
                            Value.Tuple [ M.read (| dst |) ];
                            M.get_function (| "core::intrinsics::write_bytes.comptime", [] |);
                            M.get_function (| "core::intrinsics::write_bytes.runtime", [] |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (| "core::intrinsics::write_bytes::write_bytes", [ T ] |),
              [ M.read (| dst |); M.read (| val |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_write_bytes : M.IsFunction "core::intrinsics::write_bytes" write_bytes.
  
  Module write_bytes.
    Parameter write_bytes : (list Ty.t) -> (list Value.t) -> M.
    
    Axiom Function_write_bytes :
      M.IsFunction "core::intrinsics::write_bytes::write_bytes" write_bytes.
    
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::intrinsics::write_bytes::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::intrinsics::write_bytes::comptime" comptime.
  End write_bytes.
End intrinsics.

Module ptr.
  Module swap_nonoverlapping.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ x; y; count ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          let count := M.alloc (| count |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            LogicalOp.and (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| x |)) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_aligned_and_not_null",
                                      [ T ]
                                    |),
                                    [ (* MutToConstPointer *) M.pointer_coercion (M.read (| y |)) ]
                                  |)))
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_function (| "core::intrinsics::is_nonoverlapping", [ T ] |),
                                  [
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| x |));
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| y |));
                                    M.read (| count |)
                                  ]
                                |)))
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::ptr::swap_nonoverlapping::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0; β1; β2 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          let β1 := M.alloc (| β1 |) in
          let β2 := M.alloc (| β2 |) in
          M.match_operator (|
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    β1,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            β2,
                            [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                          |)))
                    ]
                  |)))
            ]
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::ptr::swap_nonoverlapping::comptime" comptime.
  End swap_nonoverlapping.
  
  Module replace.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::replace requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::ptr::replace::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::ptr::replace::comptime" comptime.
  End replace.
  
  Module read.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ M.read (| src |) ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::read requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::ptr::read::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::ptr::read::comptime" comptime.
  End read.
  
  Module write.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::write requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::ptr::write::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::ptr::write::comptime" comptime.
  End write.
  
  Module read_volatile.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ M.read (| src |) ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::read_volatile requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::ptr::read_volatile::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::ptr::read_volatile::comptime" comptime.
  End read_volatile.
  
  Module write_volatile.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::write_volatile requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_runtime : M.IsFunction "core::ptr::write_volatile::runtime" runtime.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Function_comptime : M.IsFunction "core::ptr::write_volatile::comptime" comptime.
  End write_volatile.
End ptr.

Module slice.
  Module raw.
    Module from_raw_parts.
      (*
                  fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                      if !$e {
                          // don't unwind to reduce impact on code size
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $name)
                          );
                      }
                  }
      *)
      Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ data; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let len := M.alloc (| len |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ M.read (| data |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_valid_allocation_size",
                                      [ T ]
                                    |),
                                    [ M.read (| len |) ]
                                  |)))
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_nounwind", [] |),
                            [
                              M.read (|
                                Value.String
                                  "unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Function_runtime : M.IsFunction "core::slice::raw::from_raw_parts::runtime" runtime.
      
      (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
      Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Function_comptime : M.IsFunction "core::slice::raw::from_raw_parts::comptime" comptime.
    End from_raw_parts.
    
    Module from_raw_parts_mut.
      (*
                  fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                      if !$e {
                          // don't unwind to reduce impact on code size
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $name)
                          );
                      }
                  }
      *)
      Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ data; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let len := M.alloc (| len |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| data |)) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_valid_allocation_size",
                                      [ T ]
                                    |),
                                    [ M.read (| len |) ]
                                  |)))
                              |)
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_nounwind", [] |),
                            [
                              M.read (|
                                Value.String
                                  "unsafe precondition(s) violated: slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Function_runtime : M.IsFunction "core::slice::raw::from_raw_parts_mut::runtime" runtime.
      
      (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
      Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
              ]
            |)))
        | _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Function_comptime :
        M.IsFunction "core::slice::raw::from_raw_parts_mut::comptime" comptime.
    End from_raw_parts_mut.
  End raw.
End slice.
