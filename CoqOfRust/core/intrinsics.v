(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module hint.
  Module unreachable_unchecked.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| UnOp.Pure.not (Value.Bool false) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: hint::unreachable_unchecked must never be reached"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with | [], [] => ltac:(M.monadic (Value.Tuple [])) | _, _ => M.impossible end.
  End unreachable_unchecked.
End hint.

Module intrinsics.
  (*
  pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {
      // SAFETY: see `ptr::drop_in_place`
      unsafe { crate::ptr::drop_in_place(to_drop) }
  }
  *)
  Definition drop_in_place (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ to_drop ] =>
      ltac:(M.monadic
        (let to_drop := M.alloc (| to_drop |) in
        M.call_closure (|
          M.get_function (| "core::ptr::drop_in_place", [ T ] |),
          [ M.read (| to_drop |) ]
        |)))
    | _, _ => M.impossible
    end.
  
  (* Unhandled foreign module here *)
  
  (*
  pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {
      !ptr.is_null() && ptr.is_aligned()
  }
  *)
  Definition is_aligned_and_not_null (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ ptr ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        LogicalOp.and (|
          UnOp.Pure.not
            (M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "is_null", [] |),
              [ M.read (| ptr |) ]
            |)),
          ltac:(M.monadic
            (M.call_closure (|
              M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "is_aligned", [] |),
              [ M.read (| ptr |) ]
            |)))
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub(crate) fn is_valid_allocation_size<T>(len: usize) -> bool {
      let max_len = const {
          let size = crate::mem::size_of::<T>();
          if size == 0 { usize::MAX } else { isize::MAX as usize / size }
      };
      len <= max_len
  }
  *)
  Definition is_valid_allocation_size (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ len ] =>
      ltac:(M.monadic
        (let len := M.alloc (| len |) in
        M.read (|
          let max_len :=
            M.copy (|
              M.get_constant (| "core::intrinsics::is_valid_allocation_size_discriminant" |)
            |) in
          M.alloc (| BinOp.Pure.le (M.read (| len |)) (M.read (| max_len |)) |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {
      let src_usize = src.addr();
      let dst_usize = dst.addr();
      let size = mem::size_of::<T>()
          .checked_mul(count)
          .expect("is_nonoverlapping: `size_of::<T>() * count` overflows a usize");
      let diff = src_usize.abs_diff(dst_usize);
      // If the absolute distance between the ptrs is at least as big as the size of the buffer,
      // they do not overlap.
      diff >= size
  }
  *)
  Definition is_nonoverlapping (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let src_usize :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "addr", [] |),
                [ M.read (| src |) ]
              |)
            |) in
          let dst_usize :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.apply (Ty.path "*const") [ T ], "addr", [] |),
                [ M.read (| dst |) ]
              |)
            |) in
          let size :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                  "expect",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "usize", "checked_mul", [] |),
                    [
                      M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |);
                      M.read (| count |)
                    ]
                  |);
                  M.read (|
                    Value.String "is_nonoverlapping: `size_of::<T>() * count` overflows a usize"
                  |)
                ]
              |)
            |) in
          let diff :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "usize", "abs_diff", [] |),
                [ M.read (| src_usize |); M.read (| dst_usize |) ]
              |)
            |) in
          M.alloc (| BinOp.Pure.ge (M.read (| diff |)) (M.read (| size |)) |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {
      extern "rust-intrinsic" {
          #[rustc_const_stable(feature = "const_intrinsic_copy", since = "1.63.0")]
          #[rustc_nounwind]
          pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);
      }
  
      // SAFETY: the safety contract for `copy_nonoverlapping` must be
      // upheld by the caller.
      unsafe {
          assert_unsafe_precondition!(
              "ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \
              and the specified memory ranges do not overlap",
              [T](src: *const T, dst: *mut T, count: usize) =>
              is_aligned_and_not_null(src)
                  && is_aligned_and_not_null(dst)
                  && is_nonoverlapping(src, dst, count)
          );
          copy_nonoverlapping(src, dst, count)
      }
  }
  *)
  Definition copy_nonoverlapping (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::const_eval_select",
                            [
                              Ty.tuple
                                [
                                  Ty.apply (Ty.path "*const") [ T ];
                                  Ty.apply (Ty.path "*mut") [ T ];
                                  Ty.path "usize"
                                ];
                              Ty.function
                                [
                                  Ty.apply (Ty.path "*const") [ T ];
                                  Ty.apply (Ty.path "*mut") [ T ];
                                  Ty.path "usize"
                                ]
                                (Ty.tuple []);
                              Ty.function
                                [
                                  Ty.apply (Ty.path "*const") [ T ];
                                  Ty.apply (Ty.path "*mut") [ T ];
                                  Ty.path "usize"
                                ]
                                (Ty.tuple []);
                              Ty.tuple []
                            ]
                          |),
                          [
                            Value.Tuple [ M.read (| src |); M.read (| dst |); M.read (| count |) ];
                            M.get_function (|
                              "core::intrinsics::copy_nonoverlapping.comptime",
                              []
                            |);
                            M.get_function (| "core::intrinsics::copy_nonoverlapping.runtime", [] |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::copy_nonoverlapping::copy_nonoverlapping",
                [ T ]
              |),
              [ M.read (| src |); M.read (| dst |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module copy_nonoverlapping.
    (* Unhandled foreign module here *)
    
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src; dst; count ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          let count := M.alloc (| count |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (LogicalOp.and (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ M.read (| src |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_aligned_and_not_null",
                                      [ T ]
                                    |),
                                    [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |))
                                    ]
                                  |)))
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_function (| "core::intrinsics::is_nonoverlapping", [ T ] |),
                                  [
                                    M.read (| src |);
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |));
                                    M.read (| count |)
                                  ]
                                |)))
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0; β1; β2 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          let β1 := M.alloc (| β1 |) in
          let β2 := M.alloc (| β2 |) in
          M.match_operator (|
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    β1,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            β2,
                            [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                          |)))
                    ]
                  |)))
            ]
          |)))
      | _, _ => M.impossible
      end.
  End copy_nonoverlapping.
  
  (*
  pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {
      extern "rust-intrinsic" {
          #[rustc_const_stable(feature = "const_intrinsic_copy", since = "1.63.0")]
          #[rustc_nounwind]
          fn copy<T>(src: *const T, dst: *mut T, count: usize);
      }
  
      // SAFETY: the safety contract for `copy` must be upheld by the caller.
      unsafe {
          assert_unsafe_precondition!(
              "ptr::copy requires that both pointer arguments are aligned and non-null",
              [T](src: *const T, dst: *mut T) =>
              is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)
          );
          copy(src, dst, count)
      }
  }
  *)
  Definition copy (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::const_eval_select",
                            [
                              Ty.tuple
                                [ Ty.apply (Ty.path "*const") [ T ]; Ty.apply (Ty.path "*mut") [ T ]
                                ];
                              Ty.function
                                [ Ty.apply (Ty.path "*const") [ T ]; Ty.apply (Ty.path "*mut") [ T ]
                                ]
                                (Ty.tuple []);
                              Ty.function
                                [ Ty.apply (Ty.path "*const") [ T ]; Ty.apply (Ty.path "*mut") [ T ]
                                ]
                                (Ty.tuple []);
                              Ty.tuple []
                            ]
                          |),
                          [
                            Value.Tuple [ M.read (| src |); M.read (| dst |) ];
                            M.get_function (| "core::intrinsics::copy.comptime", [] |);
                            M.get_function (| "core::intrinsics::copy.runtime", [] |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (| "core::intrinsics::copy::copy", [ T ] |),
              [ M.read (| src |); M.read (| dst |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module copy.
    (* Unhandled foreign module here *)
    
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src; dst ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (LogicalOp.and (|
                              M.call_closure (|
                                M.get_function (|
                                  "core::intrinsics::is_aligned_and_not_null",
                                  [ T ]
                                |),
                                [ M.read (| src |) ]
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                                |)))
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::copy requires that both pointer arguments are aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0; β1 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          let β1 := M.alloc (| β1 |) in
          M.match_operator (|
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
            ]
          |)))
      | _, _ => M.impossible
      end.
  End copy.
  
  (*
  pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {
      extern "rust-intrinsic" {
          #[rustc_const_unstable(feature = "const_ptr_write", issue = "86302")]
          #[rustc_nounwind]
          fn write_bytes<T>(dst: *mut T, val: u8, count: usize);
      }
  
      // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.
      unsafe {
          assert_unsafe_precondition!(
              "ptr::write_bytes requires that the destination pointer is aligned and non-null",
              [T](dst: *mut T) => is_aligned_and_not_null(dst)
          );
          write_bytes(dst, val, count)
      }
  }
  *)
  Definition write_bytes (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T ], [ dst; val; count ] =>
      ltac:(M.monadic
        (let dst := M.alloc (| dst |) in
        let val := M.alloc (| val |) in
        let count := M.alloc (| count |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| Value.Bool true |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (|
                            "core::intrinsics::const_eval_select",
                            [
                              Ty.tuple [ Ty.apply (Ty.path "*mut") [ T ] ];
                              Ty.function [ Ty.apply (Ty.path "*mut") [ T ] ] (Ty.tuple []);
                              Ty.function [ Ty.apply (Ty.path "*mut") [ T ] ] (Ty.tuple []);
                              Ty.tuple []
                            ]
                          |),
                          [
                            Value.Tuple [ M.read (| dst |) ];
                            M.get_function (| "core::intrinsics::write_bytes.comptime", [] |);
                            M.get_function (| "core::intrinsics::write_bytes.runtime", [] |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (| "core::intrinsics::write_bytes::write_bytes", [ T ] |),
              [ M.read (| dst |); M.read (| val |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module write_bytes.
    (* Unhandled foreign module here *)
    
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::write_bytes requires that the destination pointer is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible
      end.
  End write_bytes.
End intrinsics.

Module ptr.
  Module swap_nonoverlapping.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ x; y; count ] =>
        ltac:(M.monadic
          (let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          let count := M.alloc (| count |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (LogicalOp.and (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| x |)) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_aligned_and_not_null",
                                      [ T ]
                                    |),
                                    [ (* MutToConstPointer *) M.pointer_coercion (M.read (| y |)) ]
                                  |)))
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  M.get_function (| "core::intrinsics::is_nonoverlapping", [ T ] |),
                                  [
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| x |));
                                    (* MutToConstPointer *) M.pointer_coercion (M.read (| y |));
                                    M.read (| count |)
                                  ]
                                |)))
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::swap_nonoverlapping requires that both pointer arguments are aligned and non-null and the specified memory ranges do not overlap"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0; β1; β2 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          let β1 := M.alloc (| β1 |) in
          let β2 := M.alloc (| β2 |) in
          M.match_operator (|
            β0,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    β1,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            β2,
                            [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                          |)))
                    ]
                  |)))
            ]
          |)))
      | _, _ => M.impossible
      end.
  End swap_nonoverlapping.
  
  Module replace.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::replace requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible
      end.
  End replace.
  
  Module read.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ M.read (| src |) ]
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::read requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible
      end.
  End read.
  
  Module write.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::write requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible
      end.
  End write.
  
  Module read_volatile.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ src ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ M.read (| src |) ]
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::read_volatile requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible
      end.
  End read_volatile.
  
  Module write_volatile.
    (*
                fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                    if !$e {
                        // don't unwind to reduce impact on code size
                        ::core::panicking::panic_nounwind(
                            concat!("unsafe precondition(s) violated: ", $name)
                        );
                    }
                }
    *)
    Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ dst ] =>
        ltac:(M.monadic
          (let dst := M.alloc (| dst |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.Pure.not
                            (M.call_closure (|
                              M.get_function (|
                                "core::intrinsics::is_aligned_and_not_null",
                                [ T ]
                              |),
                              [ (* MutToConstPointer *) M.pointer_coercion (M.read (| dst |)) ]
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_nounwind", [] |),
                          [
                            M.read (|
                              Value.String
                                "unsafe precondition(s) violated: ptr::write_volatile requires that the pointer argument is aligned and non-null"
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
    Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ β0 ] =>
        ltac:(M.monadic
          (let β0 := M.alloc (| β0 |) in
          M.match_operator (| β0, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
      | _, _ => M.impossible
      end.
  End write_volatile.
End ptr.

Module slice.
  Module raw.
    Module from_raw_parts.
      (*
                  fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                      if !$e {
                          // don't unwind to reduce impact on code size
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $name)
                          );
                      }
                  }
      *)
      Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ data; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let len := M.alloc (| len |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ M.read (| data |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_valid_allocation_size",
                                      [ T ]
                                    |),
                                    [ M.read (| len |) ]
                                  |)))
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_nounwind", [] |),
                            [
                              M.read (|
                                Value.String
                                  "unsafe precondition(s) violated: slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
      Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
    End from_raw_parts.
    
    Module from_raw_parts_mut.
      (*
                  fn runtime$(<$($tt)*>)?($($i:$ty),* ) {
                      if !$e {
                          // don't unwind to reduce impact on code size
                          ::core::panicking::panic_nounwind(
                              concat!("unsafe precondition(s) violated: ", $name)
                          );
                      }
                  }
      *)
      Definition runtime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ data; len ] =>
          ltac:(M.monadic
            (let data := M.alloc (| data |) in
            let len := M.alloc (| len |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (LogicalOp.and (|
                                M.call_closure (|
                                  M.get_function (|
                                    "core::intrinsics::is_aligned_and_not_null",
                                    [ T ]
                                  |),
                                  [ (* MutToConstPointer *) M.pointer_coercion (M.read (| data |)) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_function (|
                                      "core::intrinsics::is_valid_allocation_size",
                                      [ T ]
                                    |),
                                    [ M.read (| len |) ]
                                  |)))
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_nounwind", [] |),
                            [
                              M.read (|
                                Value.String
                                  "unsafe precondition(s) violated: slice::from_raw_parts_mut requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*             const fn comptime$(<$($tt)*>)?($(_:$ty),* ) {} *)
      Definition comptime (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ T ], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (| β1, [ fun γ => ltac:(M.monadic (Value.Tuple [])) ] |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
    End from_raw_parts_mut.
  End raw.
End slice.
