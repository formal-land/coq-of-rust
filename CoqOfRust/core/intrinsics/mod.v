(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module from_str_radix_panic.
    Module do_panic.
      (*
              fn runtime($($arg: $ty),* ) $( -> $ret )? {
                  $runtime
              }
      *)
      Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ radix ] =>
          ltac:(M.monadic
            (let radix := M.alloc (| radix |) in
            M.call_closure (|
              Ty.path "never",
              M.get_function (| "core::panicking::panic_fmt", [], [] |),
              [
                M.call_closure (|
                  Ty.path "core::fmt::Arguments",
                  M.get_associated_function (|
                    Ty.path "core::fmt::Arguments",
                    "new_v1",
                    [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Value.Array
                              [
                                mk_str (|
                                  "from_str_radix_int: must lie in the range `[2, 36]` - found "
                                |)
                              ]
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  Ty.path "core::fmt::rt::Argument",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [],
                                    [ Ty.path "u32" ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.borrow (| Pointer.Kind.Ref, radix |) |)
                                    |)
                                  ]
                                |)
                              ]
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_runtime :
        M.IsFunction.C "core::num::from_str_radix_panic::do_panic::runtime" runtime.
      Admitted.
      Global Typeclasses Opaque runtime.
      
      (*
              const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                  // Don't warn if one of the arguments is unused.
                  $(let _ = $arg;)*
      
                  $compiletime
              }
      *)
      Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ radix ] =>
          ltac:(M.monadic
            (let radix := M.alloc (| radix |) in
            M.read (|
              M.match_operator (|
                None,
                radix,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [ Value.Integer IntegerKind.Usize 1 ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            mk_str (|
                                              "from_str_radix_int: must lie in the range `[2, 36]`"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_compiletime :
        M.IsFunction.C "core::num::from_str_radix_panic::do_panic::compiletime" compiletime.
      Admitted.
      Global Typeclasses Opaque compiletime.
    End do_panic.
  End from_str_radix_panic.
End num.

Module intrinsics.
  (*
  pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {
      // SAFETY: see `ptr::drop_in_place`
      unsafe { crate::ptr::drop_in_place(to_drop) }
  }
  *)
  Definition drop_in_place (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ to_drop ] =>
      ltac:(M.monadic
        (let to_drop := M.alloc (| to_drop |) in
        M.call_closure (|
          Ty.tuple [],
          M.get_function (| "core::ptr::drop_in_place", [], [ T ] |),
          [ M.read (| to_drop |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_drop_in_place :
    M.IsFunction.C "core::intrinsics::drop_in_place" drop_in_place.
  Admitted.
  Global Typeclasses Opaque drop_in_place.
  
  (*
  pub unsafe fn atomic_cxchg_relaxed_relaxed<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_relaxed_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_relaxed_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_relaxed_relaxed" atomic_cxchg_relaxed_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_relaxed_relaxed.
  
  (*
  pub unsafe fn atomic_cxchg_relaxed_acquire<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_relaxed_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_relaxed_acquire :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_relaxed_acquire" atomic_cxchg_relaxed_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_relaxed_acquire.
  
  (*
  pub unsafe fn atomic_cxchg_relaxed_seqcst<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_relaxed_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_relaxed_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_relaxed_seqcst" atomic_cxchg_relaxed_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_relaxed_seqcst.
  
  (*
  pub unsafe fn atomic_cxchg_acquire_relaxed<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_acquire_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_acquire_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_acquire_relaxed" atomic_cxchg_acquire_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_acquire_relaxed.
  
  (*
  pub unsafe fn atomic_cxchg_acquire_acquire<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_acquire_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_acquire_acquire :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_acquire_acquire" atomic_cxchg_acquire_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_acquire_acquire.
  
  (*
  pub unsafe fn atomic_cxchg_acquire_seqcst<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_acquire_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_acquire_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_acquire_seqcst" atomic_cxchg_acquire_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_acquire_seqcst.
  
  (*
  pub unsafe fn atomic_cxchg_release_relaxed<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_release_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_release_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_release_relaxed" atomic_cxchg_release_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_release_relaxed.
  
  (*
  pub unsafe fn atomic_cxchg_release_acquire<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_release_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_release_acquire :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_release_acquire" atomic_cxchg_release_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_release_acquire.
  
  (*
  pub unsafe fn atomic_cxchg_release_seqcst<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_release_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_release_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_release_seqcst" atomic_cxchg_release_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_release_seqcst.
  
  (*
  pub unsafe fn atomic_cxchg_acqrel_relaxed<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_acqrel_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_acqrel_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_acqrel_relaxed" atomic_cxchg_acqrel_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_acqrel_relaxed.
  
  (*
  pub unsafe fn atomic_cxchg_acqrel_acquire<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_acqrel_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_acqrel_acquire :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_acqrel_acquire" atomic_cxchg_acqrel_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_acqrel_acquire.
  
  (*
  pub unsafe fn atomic_cxchg_acqrel_seqcst<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_acqrel_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_acqrel_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_acqrel_seqcst" atomic_cxchg_acqrel_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_acqrel_seqcst.
  
  (*
  pub unsafe fn atomic_cxchg_seqcst_relaxed<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_seqcst_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_seqcst_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_seqcst_relaxed" atomic_cxchg_seqcst_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_seqcst_relaxed.
  
  (*
  pub unsafe fn atomic_cxchg_seqcst_acquire<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_seqcst_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_seqcst_acquire :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_seqcst_acquire" atomic_cxchg_seqcst_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_seqcst_acquire.
  
  (*
  pub unsafe fn atomic_cxchg_seqcst_seqcst<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchg_seqcst_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchg_seqcst_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_cxchg_seqcst_seqcst" atomic_cxchg_seqcst_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchg_seqcst_seqcst.
  
  (*
  pub unsafe fn atomic_cxchgweak_relaxed_relaxed<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_relaxed_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_relaxed_relaxed :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_relaxed_relaxed"
      atomic_cxchgweak_relaxed_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_relaxed_relaxed.
  
  (*
  pub unsafe fn atomic_cxchgweak_relaxed_acquire<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_relaxed_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_relaxed_acquire :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_relaxed_acquire"
      atomic_cxchgweak_relaxed_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_relaxed_acquire.
  
  (*
  pub unsafe fn atomic_cxchgweak_relaxed_seqcst<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_relaxed_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_relaxed_seqcst :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_relaxed_seqcst"
      atomic_cxchgweak_relaxed_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_relaxed_seqcst.
  
  (*
  pub unsafe fn atomic_cxchgweak_acquire_relaxed<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_acquire_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_acquire_relaxed :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_acquire_relaxed"
      atomic_cxchgweak_acquire_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_acquire_relaxed.
  
  (*
  pub unsafe fn atomic_cxchgweak_acquire_acquire<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_acquire_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_acquire_acquire :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_acquire_acquire"
      atomic_cxchgweak_acquire_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_acquire_acquire.
  
  (*
  pub unsafe fn atomic_cxchgweak_acquire_seqcst<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_acquire_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_acquire_seqcst :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_acquire_seqcst"
      atomic_cxchgweak_acquire_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_acquire_seqcst.
  
  (*
  pub unsafe fn atomic_cxchgweak_release_relaxed<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_release_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_release_relaxed :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_release_relaxed"
      atomic_cxchgweak_release_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_release_relaxed.
  
  (*
  pub unsafe fn atomic_cxchgweak_release_acquire<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_release_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_release_acquire :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_release_acquire"
      atomic_cxchgweak_release_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_release_acquire.
  
  (*
  pub unsafe fn atomic_cxchgweak_release_seqcst<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_release_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_release_seqcst :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_release_seqcst"
      atomic_cxchgweak_release_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_release_seqcst.
  
  (*
  pub unsafe fn atomic_cxchgweak_acqrel_relaxed<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_acqrel_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_acqrel_relaxed :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_acqrel_relaxed"
      atomic_cxchgweak_acqrel_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_acqrel_relaxed.
  
  (*
  pub unsafe fn atomic_cxchgweak_acqrel_acquire<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_acqrel_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_acqrel_acquire :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_acqrel_acquire"
      atomic_cxchgweak_acqrel_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_acqrel_acquire.
  
  (*
  pub unsafe fn atomic_cxchgweak_acqrel_seqcst<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_acqrel_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_acqrel_seqcst :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_acqrel_seqcst"
      atomic_cxchgweak_acqrel_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_acqrel_seqcst.
  
  (*
  pub unsafe fn atomic_cxchgweak_seqcst_relaxed<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_seqcst_relaxed
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_seqcst_relaxed :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_seqcst_relaxed"
      atomic_cxchgweak_seqcst_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_seqcst_relaxed.
  
  (*
  pub unsafe fn atomic_cxchgweak_seqcst_acquire<T: Copy>(
      _dst: *mut T,
      _old: T,
      _src: T,
  ) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_seqcst_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_seqcst_acquire :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_seqcst_acquire"
      atomic_cxchgweak_seqcst_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_seqcst_acquire.
  
  (*
  pub unsafe fn atomic_cxchgweak_seqcst_seqcst<T: Copy>(_dst: *mut T, _old: T, _src: T) -> (T, bool) {
      unreachable!()
  }
  *)
  Definition atomic_cxchgweak_seqcst_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _old; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _old := M.alloc (| _old |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_cxchgweak_seqcst_seqcst :
    M.IsFunction.C
      "core::intrinsics::atomic_cxchgweak_seqcst_seqcst"
      atomic_cxchgweak_seqcst_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_cxchgweak_seqcst_seqcst.
  
  (*
  pub unsafe fn atomic_load_seqcst<T: Copy>(_src: *const T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_load_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_load_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_load_seqcst" atomic_load_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_load_seqcst.
  
  (*
  pub unsafe fn atomic_load_acquire<T: Copy>(_src: *const T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_load_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_load_acquire :
    M.IsFunction.C "core::intrinsics::atomic_load_acquire" atomic_load_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_load_acquire.
  
  (*
  pub unsafe fn atomic_load_relaxed<T: Copy>(_src: *const T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_load_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_load_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_load_relaxed" atomic_load_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_load_relaxed.
  
  (*
  pub unsafe fn atomic_load_unordered<T: Copy>(_src: *const T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_load_unordered (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_load_unordered :
    M.IsFunction.C "core::intrinsics::atomic_load_unordered" atomic_load_unordered.
  Admitted.
  Global Typeclasses Opaque atomic_load_unordered.
  
  (*
  pub unsafe fn atomic_store_seqcst<T: Copy>(_dst: *mut T, _val: T) {
      unreachable!()
  }
  *)
  Definition atomic_store_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _val ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _val := M.alloc (| _val |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_store_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_store_seqcst" atomic_store_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_store_seqcst.
  
  (*
  pub unsafe fn atomic_store_release<T: Copy>(_dst: *mut T, _val: T) {
      unreachable!()
  }
  *)
  Definition atomic_store_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _val ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _val := M.alloc (| _val |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_store_release :
    M.IsFunction.C "core::intrinsics::atomic_store_release" atomic_store_release.
  Admitted.
  Global Typeclasses Opaque atomic_store_release.
  
  (*
  pub unsafe fn atomic_store_relaxed<T: Copy>(_dst: *mut T, _val: T) {
      unreachable!()
  }
  *)
  Definition atomic_store_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _val ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _val := M.alloc (| _val |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_store_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_store_relaxed" atomic_store_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_store_relaxed.
  
  (*
  pub unsafe fn atomic_store_unordered<T: Copy>(_dst: *mut T, _val: T) {
      unreachable!()
  }
  *)
  Definition atomic_store_unordered (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _val ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _val := M.alloc (| _val |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_store_unordered :
    M.IsFunction.C "core::intrinsics::atomic_store_unordered" atomic_store_unordered.
  Admitted.
  Global Typeclasses Opaque atomic_store_unordered.
  
  (*
  pub unsafe fn atomic_xchg_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xchg_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xchg_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_xchg_seqcst" atomic_xchg_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_xchg_seqcst.
  
  (*
  pub unsafe fn atomic_xchg_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xchg_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xchg_acquire :
    M.IsFunction.C "core::intrinsics::atomic_xchg_acquire" atomic_xchg_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_xchg_acquire.
  
  (*
  pub unsafe fn atomic_xchg_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xchg_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xchg_release :
    M.IsFunction.C "core::intrinsics::atomic_xchg_release" atomic_xchg_release.
  Admitted.
  Global Typeclasses Opaque atomic_xchg_release.
  
  (*
  pub unsafe fn atomic_xchg_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xchg_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xchg_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_xchg_acqrel" atomic_xchg_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_xchg_acqrel.
  
  (*
  pub unsafe fn atomic_xchg_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xchg_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xchg_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_xchg_relaxed" atomic_xchg_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_xchg_relaxed.
  
  (*
  pub unsafe fn atomic_xadd_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xadd_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xadd_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_xadd_seqcst" atomic_xadd_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_xadd_seqcst.
  
  (*
  pub unsafe fn atomic_xadd_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xadd_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xadd_acquire :
    M.IsFunction.C "core::intrinsics::atomic_xadd_acquire" atomic_xadd_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_xadd_acquire.
  
  (*
  pub unsafe fn atomic_xadd_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xadd_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xadd_release :
    M.IsFunction.C "core::intrinsics::atomic_xadd_release" atomic_xadd_release.
  Admitted.
  Global Typeclasses Opaque atomic_xadd_release.
  
  (*
  pub unsafe fn atomic_xadd_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xadd_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xadd_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_xadd_acqrel" atomic_xadd_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_xadd_acqrel.
  
  (*
  pub unsafe fn atomic_xadd_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xadd_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xadd_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_xadd_relaxed" atomic_xadd_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_xadd_relaxed.
  
  (*
  pub unsafe fn atomic_xsub_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xsub_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xsub_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_xsub_seqcst" atomic_xsub_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_xsub_seqcst.
  
  (*
  pub unsafe fn atomic_xsub_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xsub_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xsub_acquire :
    M.IsFunction.C "core::intrinsics::atomic_xsub_acquire" atomic_xsub_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_xsub_acquire.
  
  (*
  pub unsafe fn atomic_xsub_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xsub_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xsub_release :
    M.IsFunction.C "core::intrinsics::atomic_xsub_release" atomic_xsub_release.
  Admitted.
  Global Typeclasses Opaque atomic_xsub_release.
  
  (*
  pub unsafe fn atomic_xsub_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xsub_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xsub_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_xsub_acqrel" atomic_xsub_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_xsub_acqrel.
  
  (*
  pub unsafe fn atomic_xsub_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xsub_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xsub_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_xsub_relaxed" atomic_xsub_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_xsub_relaxed.
  
  (*
  pub unsafe fn atomic_and_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_and_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_and_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_and_seqcst" atomic_and_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_and_seqcst.
  
  (*
  pub unsafe fn atomic_and_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_and_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_and_acquire :
    M.IsFunction.C "core::intrinsics::atomic_and_acquire" atomic_and_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_and_acquire.
  
  (*
  pub unsafe fn atomic_and_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_and_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_and_release :
    M.IsFunction.C "core::intrinsics::atomic_and_release" atomic_and_release.
  Admitted.
  Global Typeclasses Opaque atomic_and_release.
  
  (*
  pub unsafe fn atomic_and_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_and_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_and_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_and_acqrel" atomic_and_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_and_acqrel.
  
  (*
  pub unsafe fn atomic_and_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_and_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_and_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_and_relaxed" atomic_and_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_and_relaxed.
  
  (*
  pub unsafe fn atomic_nand_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_nand_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_nand_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_nand_seqcst" atomic_nand_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_nand_seqcst.
  
  (*
  pub unsafe fn atomic_nand_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_nand_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_nand_acquire :
    M.IsFunction.C "core::intrinsics::atomic_nand_acquire" atomic_nand_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_nand_acquire.
  
  (*
  pub unsafe fn atomic_nand_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_nand_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_nand_release :
    M.IsFunction.C "core::intrinsics::atomic_nand_release" atomic_nand_release.
  Admitted.
  Global Typeclasses Opaque atomic_nand_release.
  
  (*
  pub unsafe fn atomic_nand_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_nand_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_nand_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_nand_acqrel" atomic_nand_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_nand_acqrel.
  
  (*
  pub unsafe fn atomic_nand_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_nand_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_nand_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_nand_relaxed" atomic_nand_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_nand_relaxed.
  
  (*
  pub unsafe fn atomic_or_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_or_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_or_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_or_seqcst" atomic_or_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_or_seqcst.
  
  (*
  pub unsafe fn atomic_or_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_or_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_or_acquire :
    M.IsFunction.C "core::intrinsics::atomic_or_acquire" atomic_or_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_or_acquire.
  
  (*
  pub unsafe fn atomic_or_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_or_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_or_release :
    M.IsFunction.C "core::intrinsics::atomic_or_release" atomic_or_release.
  Admitted.
  Global Typeclasses Opaque atomic_or_release.
  
  (*
  pub unsafe fn atomic_or_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_or_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_or_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_or_acqrel" atomic_or_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_or_acqrel.
  
  (*
  pub unsafe fn atomic_or_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_or_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_or_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_or_relaxed" atomic_or_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_or_relaxed.
  
  (*
  pub unsafe fn atomic_xor_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xor_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xor_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_xor_seqcst" atomic_xor_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_xor_seqcst.
  
  (*
  pub unsafe fn atomic_xor_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xor_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xor_acquire :
    M.IsFunction.C "core::intrinsics::atomic_xor_acquire" atomic_xor_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_xor_acquire.
  
  (*
  pub unsafe fn atomic_xor_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xor_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xor_release :
    M.IsFunction.C "core::intrinsics::atomic_xor_release" atomic_xor_release.
  Admitted.
  Global Typeclasses Opaque atomic_xor_release.
  
  (*
  pub unsafe fn atomic_xor_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xor_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xor_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_xor_acqrel" atomic_xor_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_xor_acqrel.
  
  (*
  pub unsafe fn atomic_xor_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_xor_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_xor_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_xor_relaxed" atomic_xor_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_xor_relaxed.
  
  (*
  pub unsafe fn atomic_max_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_max_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_max_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_max_seqcst" atomic_max_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_max_seqcst.
  
  (*
  pub unsafe fn atomic_max_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_max_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_max_acquire :
    M.IsFunction.C "core::intrinsics::atomic_max_acquire" atomic_max_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_max_acquire.
  
  (*
  pub unsafe fn atomic_max_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_max_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_max_release :
    M.IsFunction.C "core::intrinsics::atomic_max_release" atomic_max_release.
  Admitted.
  Global Typeclasses Opaque atomic_max_release.
  
  (*
  pub unsafe fn atomic_max_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_max_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_max_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_max_acqrel" atomic_max_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_max_acqrel.
  
  (*
  pub unsafe fn atomic_max_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_max_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_max_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_max_relaxed" atomic_max_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_max_relaxed.
  
  (*
  pub unsafe fn atomic_min_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_min_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_min_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_min_seqcst" atomic_min_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_min_seqcst.
  
  (*
  pub unsafe fn atomic_min_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_min_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_min_acquire :
    M.IsFunction.C "core::intrinsics::atomic_min_acquire" atomic_min_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_min_acquire.
  
  (*
  pub unsafe fn atomic_min_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_min_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_min_release :
    M.IsFunction.C "core::intrinsics::atomic_min_release" atomic_min_release.
  Admitted.
  Global Typeclasses Opaque atomic_min_release.
  
  (*
  pub unsafe fn atomic_min_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_min_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_min_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_min_acqrel" atomic_min_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_min_acqrel.
  
  (*
  pub unsafe fn atomic_min_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_min_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_min_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_min_relaxed" atomic_min_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_min_relaxed.
  
  (*
  pub unsafe fn atomic_umin_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umin_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umin_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_umin_seqcst" atomic_umin_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_umin_seqcst.
  
  (*
  pub unsafe fn atomic_umin_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umin_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umin_acquire :
    M.IsFunction.C "core::intrinsics::atomic_umin_acquire" atomic_umin_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_umin_acquire.
  
  (*
  pub unsafe fn atomic_umin_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umin_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umin_release :
    M.IsFunction.C "core::intrinsics::atomic_umin_release" atomic_umin_release.
  Admitted.
  Global Typeclasses Opaque atomic_umin_release.
  
  (*
  pub unsafe fn atomic_umin_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umin_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umin_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_umin_acqrel" atomic_umin_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_umin_acqrel.
  
  (*
  pub unsafe fn atomic_umin_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umin_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umin_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_umin_relaxed" atomic_umin_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_umin_relaxed.
  
  (*
  pub unsafe fn atomic_umax_seqcst<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umax_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umax_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_umax_seqcst" atomic_umax_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_umax_seqcst.
  
  (*
  pub unsafe fn atomic_umax_acquire<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umax_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umax_acquire :
    M.IsFunction.C "core::intrinsics::atomic_umax_acquire" atomic_umax_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_umax_acquire.
  
  (*
  pub unsafe fn atomic_umax_release<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umax_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umax_release :
    M.IsFunction.C "core::intrinsics::atomic_umax_release" atomic_umax_release.
  Admitted.
  Global Typeclasses Opaque atomic_umax_release.
  
  (*
  pub unsafe fn atomic_umax_acqrel<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umax_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umax_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_umax_acqrel" atomic_umax_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_umax_acqrel.
  
  (*
  pub unsafe fn atomic_umax_relaxed<T: Copy>(_dst: *mut T, _src: T) -> T {
      unreachable!()
  }
  *)
  Definition atomic_umax_relaxed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_umax_relaxed :
    M.IsFunction.C "core::intrinsics::atomic_umax_relaxed" atomic_umax_relaxed.
  Admitted.
  Global Typeclasses Opaque atomic_umax_relaxed.
  
  (*
  pub unsafe fn atomic_fence_seqcst() {
      unreachable!()
  }
  *)
  Definition atomic_fence_seqcst (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_fence_seqcst :
    M.IsFunction.C "core::intrinsics::atomic_fence_seqcst" atomic_fence_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_fence_seqcst.
  
  (*
  pub unsafe fn atomic_fence_acquire() {
      unreachable!()
  }
  *)
  Definition atomic_fence_acquire (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_fence_acquire :
    M.IsFunction.C "core::intrinsics::atomic_fence_acquire" atomic_fence_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_fence_acquire.
  
  (*
  pub unsafe fn atomic_fence_release() {
      unreachable!()
  }
  *)
  Definition atomic_fence_release (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_fence_release :
    M.IsFunction.C "core::intrinsics::atomic_fence_release" atomic_fence_release.
  Admitted.
  Global Typeclasses Opaque atomic_fence_release.
  
  (*
  pub unsafe fn atomic_fence_acqrel() {
      unreachable!()
  }
  *)
  Definition atomic_fence_acqrel (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_fence_acqrel :
    M.IsFunction.C "core::intrinsics::atomic_fence_acqrel" atomic_fence_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_fence_acqrel.
  
  (*
  pub unsafe fn atomic_singlethreadfence_seqcst() {
      unreachable!()
  }
  *)
  Definition atomic_singlethreadfence_seqcst
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_singlethreadfence_seqcst :
    M.IsFunction.C
      "core::intrinsics::atomic_singlethreadfence_seqcst"
      atomic_singlethreadfence_seqcst.
  Admitted.
  Global Typeclasses Opaque atomic_singlethreadfence_seqcst.
  
  (*
  pub unsafe fn atomic_singlethreadfence_acquire() {
      unreachable!()
  }
  *)
  Definition atomic_singlethreadfence_acquire
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_singlethreadfence_acquire :
    M.IsFunction.C
      "core::intrinsics::atomic_singlethreadfence_acquire"
      atomic_singlethreadfence_acquire.
  Admitted.
  Global Typeclasses Opaque atomic_singlethreadfence_acquire.
  
  (*
  pub unsafe fn atomic_singlethreadfence_release() {
      unreachable!()
  }
  *)
  Definition atomic_singlethreadfence_release
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_singlethreadfence_release :
    M.IsFunction.C
      "core::intrinsics::atomic_singlethreadfence_release"
      atomic_singlethreadfence_release.
  Admitted.
  Global Typeclasses Opaque atomic_singlethreadfence_release.
  
  (*
  pub unsafe fn atomic_singlethreadfence_acqrel() {
      unreachable!()
  }
  *)
  Definition atomic_singlethreadfence_acqrel
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_atomic_singlethreadfence_acqrel :
    M.IsFunction.C
      "core::intrinsics::atomic_singlethreadfence_acqrel"
      atomic_singlethreadfence_acqrel.
  Admitted.
  Global Typeclasses Opaque atomic_singlethreadfence_acqrel.
  
  (*
  pub unsafe fn prefetch_read_data<T>(_data: *const T, _locality: i32) {
      unreachable!()
  }
  *)
  Definition prefetch_read_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _data; _locality ] =>
      ltac:(M.monadic
        (let _data := M.alloc (| _data |) in
        let _locality := M.alloc (| _locality |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_prefetch_read_data :
    M.IsFunction.C "core::intrinsics::prefetch_read_data" prefetch_read_data.
  Admitted.
  Global Typeclasses Opaque prefetch_read_data.
  
  (*
  pub unsafe fn prefetch_write_data<T>(_data: *const T, _locality: i32) {
      unreachable!()
  }
  *)
  Definition prefetch_write_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _data; _locality ] =>
      ltac:(M.monadic
        (let _data := M.alloc (| _data |) in
        let _locality := M.alloc (| _locality |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_prefetch_write_data :
    M.IsFunction.C "core::intrinsics::prefetch_write_data" prefetch_write_data.
  Admitted.
  Global Typeclasses Opaque prefetch_write_data.
  
  (*
  pub unsafe fn prefetch_read_instruction<T>(_data: *const T, _locality: i32) {
      unreachable!()
  }
  *)
  Definition prefetch_read_instruction (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _data; _locality ] =>
      ltac:(M.monadic
        (let _data := M.alloc (| _data |) in
        let _locality := M.alloc (| _locality |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_prefetch_read_instruction :
    M.IsFunction.C "core::intrinsics::prefetch_read_instruction" prefetch_read_instruction.
  Admitted.
  Global Typeclasses Opaque prefetch_read_instruction.
  
  (*
  pub unsafe fn prefetch_write_instruction<T>(_data: *const T, _locality: i32) {
      unreachable!()
  }
  *)
  Definition prefetch_write_instruction (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _data; _locality ] =>
      ltac:(M.monadic
        (let _data := M.alloc (| _data |) in
        let _locality := M.alloc (| _locality |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_prefetch_write_instruction :
    M.IsFunction.C "core::intrinsics::prefetch_write_instruction" prefetch_write_instruction.
  Admitted.
  Global Typeclasses Opaque prefetch_write_instruction.
  
  (*
  pub fn breakpoint() {
      unreachable!()
  }
  *)
  Definition breakpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_breakpoint :
    M.IsFunction.C "core::intrinsics::breakpoint" breakpoint.
  Admitted.
  Global Typeclasses Opaque breakpoint.
  
  (*
  pub fn rustc_peek<T>(_: T) -> T {
      unreachable!()
  }
  *)
  Definition rustc_peek (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ β0 ] =>
      ltac:(M.monadic
        (let β0 := M.alloc (| β0 |) in
        M.match_operator (|
          None,
          β0,
          [
            fun γ =>
              ltac:(M.monadic
                (M.never_to_any (|
                  M.call_closure (|
                    Ty.path "never",
                    M.get_function (| "core::panicking::panic", [], [] |),
                    [ mk_str (| "internal error: entered unreachable code" |) ]
                  |)
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rustc_peek :
    M.IsFunction.C "core::intrinsics::rustc_peek" rustc_peek.
  Admitted.
  Global Typeclasses Opaque rustc_peek.
  
  (*
  pub fn abort() -> ! {
      unreachable!()
  }
  *)
  Definition abort (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "never",
          M.get_function (| "core::panicking::panic", [], [] |),
          [ mk_str (| "internal error: entered unreachable code" |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_abort : M.IsFunction.C "core::intrinsics::abort" abort.
  Admitted.
  Global Typeclasses Opaque abort.
  
  (*
  pub const unsafe fn unreachable() -> ! {
      unreachable!()
  }
  *)
  Definition unreachable (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "never",
          M.get_function (| "core::panicking::panic", [], [] |),
          [ mk_str (| "internal error: entered unreachable code" |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unreachable :
    M.IsFunction.C "core::intrinsics::unreachable" unreachable.
  Admitted.
  Global Typeclasses Opaque unreachable.
  
  (*
  pub const unsafe fn assume(b: bool) {
      if !b {
          // SAFETY: the caller must guarantee the argument is never `false`
          unsafe { unreachable() }
      }
  }
  *)
  Definition assume (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ b ] =>
      ltac:(M.monadic
        (let b := M.alloc (| b |) in
        M.read (|
          M.match_operator (|
            Some (Ty.tuple []),
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use (M.alloc (| UnOp.not (| M.read (| b |) |) |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.never_to_any (|
                      M.call_closure (|
                        Ty.path "never",
                        M.get_function (| "core::intrinsics::unreachable", [], [] |),
                        []
                      |)
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_assume : M.IsFunction.C "core::intrinsics::assume" assume.
  Admitted.
  Global Typeclasses Opaque assume.
  
  (* pub const fn cold_path() {} *)
  Definition cold_path (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cold_path :
    M.IsFunction.C "core::intrinsics::cold_path" cold_path.
  Admitted.
  Global Typeclasses Opaque cold_path.
  
  (*
  pub const fn likely(b: bool) -> bool {
      if b {
          true
      } else {
          cold_path();
          false
      }
  }
  *)
  Definition likely (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ b ] =>
      ltac:(M.monadic
        (let b := M.alloc (| b |) in
        M.read (|
          M.match_operator (|
            Some (Ty.path "bool"),
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use b in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (| Value.Bool true |)));
              fun γ =>
                ltac:(M.monadic
                  (let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::cold_path", [], [] |),
                        []
                      |)
                    |) in
                  M.alloc (| Value.Bool false |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_likely : M.IsFunction.C "core::intrinsics::likely" likely.
  Admitted.
  Global Typeclasses Opaque likely.
  
  (*
  pub const fn unlikely(b: bool) -> bool {
      if b {
          cold_path();
          true
      } else {
          false
      }
  }
  *)
  Definition unlikely (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ b ] =>
      ltac:(M.monadic
        (let b := M.alloc (| b |) in
        M.read (|
          M.match_operator (|
            Some (Ty.path "bool"),
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use b in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_function (| "core::intrinsics::cold_path", [], [] |),
                        []
                      |)
                    |) in
                  M.alloc (| Value.Bool true |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unlikely :
    M.IsFunction.C "core::intrinsics::unlikely" unlikely.
  Admitted.
  Global Typeclasses Opaque unlikely.
  
  (*
  pub fn select_unpredictable<T>(b: bool, true_val: T, false_val: T) -> T {
      if b { true_val } else { false_val }
  }
  *)
  Definition select_unpredictable (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ b; true_val; false_val ] =>
      ltac:(M.monadic
        (let b := M.alloc (| b |) in
        let true_val := M.alloc (| true_val |) in
        let false_val := M.alloc (| false_val |) in
        M.read (|
          M.match_operator (|
            Some T,
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use b in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  true_val));
              fun γ => ltac:(M.monadic false_val)
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_select_unpredictable :
    M.IsFunction.C "core::intrinsics::select_unpredictable" select_unpredictable.
  Admitted.
  Global Typeclasses Opaque select_unpredictable.
  
  (*
  pub const fn assert_inhabited<T>() {
      unreachable!()
  }
  *)
  Definition assert_inhabited (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_assert_inhabited :
    M.IsFunction.C "core::intrinsics::assert_inhabited" assert_inhabited.
  Admitted.
  Global Typeclasses Opaque assert_inhabited.
  
  (*
  pub const fn assert_zero_valid<T>() {
      unreachable!()
  }
  *)
  Definition assert_zero_valid (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_assert_zero_valid :
    M.IsFunction.C "core::intrinsics::assert_zero_valid" assert_zero_valid.
  Admitted.
  Global Typeclasses Opaque assert_zero_valid.
  
  (*
  pub const fn assert_mem_uninitialized_valid<T>() {
      unreachable!()
  }
  *)
  Definition assert_mem_uninitialized_valid
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_assert_mem_uninitialized_valid :
    M.IsFunction.C
      "core::intrinsics::assert_mem_uninitialized_valid"
      assert_mem_uninitialized_valid.
  Admitted.
  Global Typeclasses Opaque assert_mem_uninitialized_valid.
  
  (*
  pub const fn caller_location() -> &'static crate::panic::Location<'static> {
      unreachable!()
  }
  *)
  Definition caller_location (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_caller_location :
    M.IsFunction.C "core::intrinsics::caller_location" caller_location.
  Admitted.
  Global Typeclasses Opaque caller_location.
  
  (*
  pub const fn forget<T: ?Sized>(_: T) {
      unreachable!()
  }
  *)
  Definition forget (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ β0 ] =>
      ltac:(M.monadic
        (let β0 := M.alloc (| β0 |) in
        M.match_operator (|
          None,
          β0,
          [
            fun γ =>
              ltac:(M.monadic
                (M.never_to_any (|
                  M.call_closure (|
                    Ty.path "never",
                    M.get_function (| "core::panicking::panic", [], [] |),
                    [ mk_str (| "internal error: entered unreachable code" |) ]
                  |)
                |)))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_forget : M.IsFunction.C "core::intrinsics::forget" forget.
  Admitted.
  Global Typeclasses Opaque forget.
  
  (*
  pub const unsafe fn transmute<Src, Dst>(_src: Src) -> Dst {
      unreachable!()
  }
  *)
  Definition transmute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ Src; Dst ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transmute :
    M.IsFunction.C "core::intrinsics::transmute" transmute.
  Admitted.
  Global Typeclasses Opaque transmute.
  
  (*
  pub const unsafe fn transmute_unchecked<Src, Dst>(_src: Src) -> Dst {
      unreachable!()
  }
  *)
  Definition transmute_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ Src; Dst ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_transmute_unchecked :
    M.IsFunction.C "core::intrinsics::transmute_unchecked" transmute_unchecked.
  Admitted.
  Global Typeclasses Opaque transmute_unchecked.
  
  (*
  pub const fn needs_drop<T: ?Sized>() -> bool {
      unreachable!()
  }
  *)
  Definition needs_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_needs_drop :
    M.IsFunction.C "core::intrinsics::needs_drop" needs_drop.
  Admitted.
  Global Typeclasses Opaque needs_drop.
  
  (*
  pub const unsafe fn offset<Ptr, Delta>(_dst: Ptr, _offset: Delta) -> Ptr {
      unreachable!()
  }
  *)
  Definition offset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ Ptr; Delta ], [ _dst; _offset ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _offset := M.alloc (| _offset |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_offset : M.IsFunction.C "core::intrinsics::offset" offset.
  Admitted.
  Global Typeclasses Opaque offset.
  
  (*
  pub const unsafe fn arith_offset<T>(_dst: *const T, _offset: isize) -> *const T {
      unreachable!()
  }
  *)
  Definition arith_offset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _offset ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _offset := M.alloc (| _offset |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_arith_offset :
    M.IsFunction.C "core::intrinsics::arith_offset" arith_offset.
  Admitted.
  Global Typeclasses Opaque arith_offset.
  
  (*
  pub fn ptr_mask<T>(_ptr: *const T, _mask: usize) -> *const T {
      unreachable!()
  }
  *)
  Definition ptr_mask (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _ptr; _mask ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        let _mask := M.alloc (| _mask |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ptr_mask :
    M.IsFunction.C "core::intrinsics::ptr_mask" ptr_mask.
  Admitted.
  Global Typeclasses Opaque ptr_mask.
  
  (*
  pub unsafe fn volatile_copy_nonoverlapping_memory<T>(_dst: *mut T, _src: *const T, _count: usize) {
      unreachable!()
  }
  *)
  Definition volatile_copy_nonoverlapping_memory
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src; _count ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        let _count := M.alloc (| _count |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_volatile_copy_nonoverlapping_memory :
    M.IsFunction.C
      "core::intrinsics::volatile_copy_nonoverlapping_memory"
      volatile_copy_nonoverlapping_memory.
  Admitted.
  Global Typeclasses Opaque volatile_copy_nonoverlapping_memory.
  
  (*
  pub unsafe fn volatile_copy_memory<T>(_dst: *mut T, _src: *const T, _count: usize) {
      unreachable!()
  }
  *)
  Definition volatile_copy_memory (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _src; _count ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _src := M.alloc (| _src |) in
        let _count := M.alloc (| _count |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_volatile_copy_memory :
    M.IsFunction.C "core::intrinsics::volatile_copy_memory" volatile_copy_memory.
  Admitted.
  Global Typeclasses Opaque volatile_copy_memory.
  
  (*
  pub unsafe fn volatile_set_memory<T>(_dst: *mut T, _val: u8, _count: usize) {
      unreachable!()
  }
  *)
  Definition volatile_set_memory (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _val; _count ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _val := M.alloc (| _val |) in
        let _count := M.alloc (| _count |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_volatile_set_memory :
    M.IsFunction.C "core::intrinsics::volatile_set_memory" volatile_set_memory.
  Admitted.
  Global Typeclasses Opaque volatile_set_memory.
  
  (*
  pub unsafe fn volatile_load<T>(_src: *const T) -> T {
      unreachable!()
  }
  *)
  Definition volatile_load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_volatile_load :
    M.IsFunction.C "core::intrinsics::volatile_load" volatile_load.
  Admitted.
  Global Typeclasses Opaque volatile_load.
  
  (*
  pub unsafe fn volatile_store<T>(_dst: *mut T, _val: T) {
      unreachable!()
  }
  *)
  Definition volatile_store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _val ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _val := M.alloc (| _val |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_volatile_store :
    M.IsFunction.C "core::intrinsics::volatile_store" volatile_store.
  Admitted.
  Global Typeclasses Opaque volatile_store.
  
  (*
  pub unsafe fn unaligned_volatile_load<T>(_src: *const T) -> T {
      unreachable!()
  }
  *)
  Definition unaligned_volatile_load (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _src ] =>
      ltac:(M.monadic
        (let _src := M.alloc (| _src |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unaligned_volatile_load :
    M.IsFunction.C "core::intrinsics::unaligned_volatile_load" unaligned_volatile_load.
  Admitted.
  Global Typeclasses Opaque unaligned_volatile_load.
  
  (*
  pub unsafe fn unaligned_volatile_store<T>(_dst: *mut T, _val: T) {
      unreachable!()
  }
  *)
  Definition unaligned_volatile_store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dst; _val ] =>
      ltac:(M.monadic
        (let _dst := M.alloc (| _dst |) in
        let _val := M.alloc (| _val |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unaligned_volatile_store :
    M.IsFunction.C "core::intrinsics::unaligned_volatile_store" unaligned_volatile_store.
  Admitted.
  Global Typeclasses Opaque unaligned_volatile_store.
  
  (*
  pub unsafe fn sqrtf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition sqrtf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sqrtf16 : M.IsFunction.C "core::intrinsics::sqrtf16" sqrtf16.
  Admitted.
  Global Typeclasses Opaque sqrtf16.
  
  (*
  pub unsafe fn sqrtf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition sqrtf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sqrtf32 : M.IsFunction.C "core::intrinsics::sqrtf32" sqrtf32.
  Admitted.
  Global Typeclasses Opaque sqrtf32.
  
  (*
  pub unsafe fn sqrtf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition sqrtf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sqrtf64 : M.IsFunction.C "core::intrinsics::sqrtf64" sqrtf64.
  Admitted.
  Global Typeclasses Opaque sqrtf64.
  
  (*
  pub unsafe fn sqrtf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition sqrtf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sqrtf128 :
    M.IsFunction.C "core::intrinsics::sqrtf128" sqrtf128.
  Admitted.
  Global Typeclasses Opaque sqrtf128.
  
  (*
  pub unsafe fn powif16(_a: f16, _x: i32) -> f16 {
      unreachable!()
  }
  *)
  Definition powif16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powif16 : M.IsFunction.C "core::intrinsics::powif16" powif16.
  Admitted.
  Global Typeclasses Opaque powif16.
  
  (*
  pub unsafe fn powif32(_a: f32, _x: i32) -> f32 {
      unreachable!()
  }
  *)
  Definition powif32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powif32 : M.IsFunction.C "core::intrinsics::powif32" powif32.
  Admitted.
  Global Typeclasses Opaque powif32.
  
  (*
  pub unsafe fn powif64(_a: f64, _x: i32) -> f64 {
      unreachable!()
  }
  *)
  Definition powif64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powif64 : M.IsFunction.C "core::intrinsics::powif64" powif64.
  Admitted.
  Global Typeclasses Opaque powif64.
  
  (*
  pub unsafe fn powif128(_a: f128, _x: i32) -> f128 {
      unreachable!()
  }
  *)
  Definition powif128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powif128 :
    M.IsFunction.C "core::intrinsics::powif128" powif128.
  Admitted.
  Global Typeclasses Opaque powif128.
  
  (*
  pub unsafe fn sinf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition sinf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sinf16 : M.IsFunction.C "core::intrinsics::sinf16" sinf16.
  Admitted.
  Global Typeclasses Opaque sinf16.
  
  (*
  pub unsafe fn sinf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition sinf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sinf32 : M.IsFunction.C "core::intrinsics::sinf32" sinf32.
  Admitted.
  Global Typeclasses Opaque sinf32.
  
  (*
  pub unsafe fn sinf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition sinf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sinf64 : M.IsFunction.C "core::intrinsics::sinf64" sinf64.
  Admitted.
  Global Typeclasses Opaque sinf64.
  
  (*
  pub unsafe fn sinf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition sinf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sinf128 : M.IsFunction.C "core::intrinsics::sinf128" sinf128.
  Admitted.
  Global Typeclasses Opaque sinf128.
  
  (*
  pub unsafe fn cosf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition cosf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cosf16 : M.IsFunction.C "core::intrinsics::cosf16" cosf16.
  Admitted.
  Global Typeclasses Opaque cosf16.
  
  (*
  pub unsafe fn cosf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition cosf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cosf32 : M.IsFunction.C "core::intrinsics::cosf32" cosf32.
  Admitted.
  Global Typeclasses Opaque cosf32.
  
  (*
  pub unsafe fn cosf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition cosf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cosf64 : M.IsFunction.C "core::intrinsics::cosf64" cosf64.
  Admitted.
  Global Typeclasses Opaque cosf64.
  
  (*
  pub unsafe fn cosf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition cosf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cosf128 : M.IsFunction.C "core::intrinsics::cosf128" cosf128.
  Admitted.
  Global Typeclasses Opaque cosf128.
  
  (*
  pub unsafe fn powf16(_a: f16, _x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition powf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powf16 : M.IsFunction.C "core::intrinsics::powf16" powf16.
  Admitted.
  Global Typeclasses Opaque powf16.
  
  (*
  pub unsafe fn powf32(_a: f32, _x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition powf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powf32 : M.IsFunction.C "core::intrinsics::powf32" powf32.
  Admitted.
  Global Typeclasses Opaque powf32.
  
  (*
  pub unsafe fn powf64(_a: f64, _x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition powf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powf64 : M.IsFunction.C "core::intrinsics::powf64" powf64.
  Admitted.
  Global Typeclasses Opaque powf64.
  
  (*
  pub unsafe fn powf128(_a: f128, _x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition powf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _x ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_powf128 : M.IsFunction.C "core::intrinsics::powf128" powf128.
  Admitted.
  Global Typeclasses Opaque powf128.
  
  (*
  pub unsafe fn expf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition expf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_expf16 : M.IsFunction.C "core::intrinsics::expf16" expf16.
  Admitted.
  Global Typeclasses Opaque expf16.
  
  (*
  pub unsafe fn expf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition expf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_expf32 : M.IsFunction.C "core::intrinsics::expf32" expf32.
  Admitted.
  Global Typeclasses Opaque expf32.
  
  (*
  pub unsafe fn expf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition expf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_expf64 : M.IsFunction.C "core::intrinsics::expf64" expf64.
  Admitted.
  Global Typeclasses Opaque expf64.
  
  (*
  pub unsafe fn expf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition expf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_expf128 : M.IsFunction.C "core::intrinsics::expf128" expf128.
  Admitted.
  Global Typeclasses Opaque expf128.
  
  (*
  pub unsafe fn exp2f16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition exp2f16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_exp2f16 : M.IsFunction.C "core::intrinsics::exp2f16" exp2f16.
  Admitted.
  Global Typeclasses Opaque exp2f16.
  
  (*
  pub unsafe fn exp2f32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition exp2f32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_exp2f32 : M.IsFunction.C "core::intrinsics::exp2f32" exp2f32.
  Admitted.
  Global Typeclasses Opaque exp2f32.
  
  (*
  pub unsafe fn exp2f64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition exp2f64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_exp2f64 : M.IsFunction.C "core::intrinsics::exp2f64" exp2f64.
  Admitted.
  Global Typeclasses Opaque exp2f64.
  
  (*
  pub unsafe fn exp2f128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition exp2f128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_exp2f128 :
    M.IsFunction.C "core::intrinsics::exp2f128" exp2f128.
  Admitted.
  Global Typeclasses Opaque exp2f128.
  
  (*
  pub unsafe fn logf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition logf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_logf16 : M.IsFunction.C "core::intrinsics::logf16" logf16.
  Admitted.
  Global Typeclasses Opaque logf16.
  
  (*
  pub unsafe fn logf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition logf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_logf32 : M.IsFunction.C "core::intrinsics::logf32" logf32.
  Admitted.
  Global Typeclasses Opaque logf32.
  
  (*
  pub unsafe fn logf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition logf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_logf64 : M.IsFunction.C "core::intrinsics::logf64" logf64.
  Admitted.
  Global Typeclasses Opaque logf64.
  
  (*
  pub unsafe fn logf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition logf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_logf128 : M.IsFunction.C "core::intrinsics::logf128" logf128.
  Admitted.
  Global Typeclasses Opaque logf128.
  
  (*
  pub unsafe fn log10f16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition log10f16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log10f16 :
    M.IsFunction.C "core::intrinsics::log10f16" log10f16.
  Admitted.
  Global Typeclasses Opaque log10f16.
  
  (*
  pub unsafe fn log10f32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition log10f32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log10f32 :
    M.IsFunction.C "core::intrinsics::log10f32" log10f32.
  Admitted.
  Global Typeclasses Opaque log10f32.
  
  (*
  pub unsafe fn log10f64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition log10f64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log10f64 :
    M.IsFunction.C "core::intrinsics::log10f64" log10f64.
  Admitted.
  Global Typeclasses Opaque log10f64.
  
  (*
  pub unsafe fn log10f128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition log10f128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log10f128 :
    M.IsFunction.C "core::intrinsics::log10f128" log10f128.
  Admitted.
  Global Typeclasses Opaque log10f128.
  
  (*
  pub unsafe fn log2f16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition log2f16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log2f16 : M.IsFunction.C "core::intrinsics::log2f16" log2f16.
  Admitted.
  Global Typeclasses Opaque log2f16.
  
  (*
  pub unsafe fn log2f32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition log2f32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log2f32 : M.IsFunction.C "core::intrinsics::log2f32" log2f32.
  Admitted.
  Global Typeclasses Opaque log2f32.
  
  (*
  pub unsafe fn log2f64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition log2f64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log2f64 : M.IsFunction.C "core::intrinsics::log2f64" log2f64.
  Admitted.
  Global Typeclasses Opaque log2f64.
  
  (*
  pub unsafe fn log2f128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition log2f128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_log2f128 :
    M.IsFunction.C "core::intrinsics::log2f128" log2f128.
  Admitted.
  Global Typeclasses Opaque log2f128.
  
  (*
  pub unsafe fn fmaf16(_a: f16, _b: f16, _c: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition fmaf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmaf16 : M.IsFunction.C "core::intrinsics::fmaf16" fmaf16.
  Admitted.
  Global Typeclasses Opaque fmaf16.
  
  (*
  pub unsafe fn fmaf32(_a: f32, _b: f32, _c: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition fmaf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmaf32 : M.IsFunction.C "core::intrinsics::fmaf32" fmaf32.
  Admitted.
  Global Typeclasses Opaque fmaf32.
  
  (*
  pub unsafe fn fmaf64(_a: f64, _b: f64, _c: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition fmaf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmaf64 : M.IsFunction.C "core::intrinsics::fmaf64" fmaf64.
  Admitted.
  Global Typeclasses Opaque fmaf64.
  
  (*
  pub unsafe fn fmaf128(_a: f128, _b: f128, _c: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition fmaf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmaf128 : M.IsFunction.C "core::intrinsics::fmaf128" fmaf128.
  Admitted.
  Global Typeclasses Opaque fmaf128.
  
  (*
  pub unsafe fn fmuladdf16(_a: f16, _b: f16, _c: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition fmuladdf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmuladdf16 :
    M.IsFunction.C "core::intrinsics::fmuladdf16" fmuladdf16.
  Admitted.
  Global Typeclasses Opaque fmuladdf16.
  
  (*
  pub unsafe fn fmuladdf32(_a: f32, _b: f32, _c: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition fmuladdf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmuladdf32 :
    M.IsFunction.C "core::intrinsics::fmuladdf32" fmuladdf32.
  Admitted.
  Global Typeclasses Opaque fmuladdf32.
  
  (*
  pub unsafe fn fmuladdf64(_a: f64, _b: f64, _c: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition fmuladdf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmuladdf64 :
    M.IsFunction.C "core::intrinsics::fmuladdf64" fmuladdf64.
  Admitted.
  Global Typeclasses Opaque fmuladdf64.
  
  (*
  pub unsafe fn fmuladdf128(_a: f128, _b: f128, _c: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition fmuladdf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _a; _b; _c ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        let _c := M.alloc (| _c |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmuladdf128 :
    M.IsFunction.C "core::intrinsics::fmuladdf128" fmuladdf128.
  Admitted.
  Global Typeclasses Opaque fmuladdf128.
  
  (*
  pub unsafe fn floorf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition floorf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_floorf16 :
    M.IsFunction.C "core::intrinsics::floorf16" floorf16.
  Admitted.
  Global Typeclasses Opaque floorf16.
  
  (*
  pub unsafe fn floorf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition floorf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_floorf32 :
    M.IsFunction.C "core::intrinsics::floorf32" floorf32.
  Admitted.
  Global Typeclasses Opaque floorf32.
  
  (*
  pub unsafe fn floorf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition floorf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_floorf64 :
    M.IsFunction.C "core::intrinsics::floorf64" floorf64.
  Admitted.
  Global Typeclasses Opaque floorf64.
  
  (*
  pub unsafe fn floorf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition floorf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_floorf128 :
    M.IsFunction.C "core::intrinsics::floorf128" floorf128.
  Admitted.
  Global Typeclasses Opaque floorf128.
  
  (*
  pub unsafe fn ceilf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition ceilf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ceilf16 : M.IsFunction.C "core::intrinsics::ceilf16" ceilf16.
  Admitted.
  Global Typeclasses Opaque ceilf16.
  
  (*
  pub unsafe fn ceilf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition ceilf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ceilf32 : M.IsFunction.C "core::intrinsics::ceilf32" ceilf32.
  Admitted.
  Global Typeclasses Opaque ceilf32.
  
  (*
  pub unsafe fn ceilf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition ceilf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ceilf64 : M.IsFunction.C "core::intrinsics::ceilf64" ceilf64.
  Admitted.
  Global Typeclasses Opaque ceilf64.
  
  (*
  pub unsafe fn ceilf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition ceilf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ceilf128 :
    M.IsFunction.C "core::intrinsics::ceilf128" ceilf128.
  Admitted.
  Global Typeclasses Opaque ceilf128.
  
  (*
  pub unsafe fn truncf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition truncf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_truncf16 :
    M.IsFunction.C "core::intrinsics::truncf16" truncf16.
  Admitted.
  Global Typeclasses Opaque truncf16.
  
  (*
  pub unsafe fn truncf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition truncf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_truncf32 :
    M.IsFunction.C "core::intrinsics::truncf32" truncf32.
  Admitted.
  Global Typeclasses Opaque truncf32.
  
  (*
  pub unsafe fn truncf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition truncf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_truncf64 :
    M.IsFunction.C "core::intrinsics::truncf64" truncf64.
  Admitted.
  Global Typeclasses Opaque truncf64.
  
  (*
  pub unsafe fn truncf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition truncf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_truncf128 :
    M.IsFunction.C "core::intrinsics::truncf128" truncf128.
  Admitted.
  Global Typeclasses Opaque truncf128.
  
  (*
  pub unsafe fn rintf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition rintf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rintf16 : M.IsFunction.C "core::intrinsics::rintf16" rintf16.
  Admitted.
  Global Typeclasses Opaque rintf16.
  
  (*
  pub unsafe fn rintf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition rintf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rintf32 : M.IsFunction.C "core::intrinsics::rintf32" rintf32.
  Admitted.
  Global Typeclasses Opaque rintf32.
  
  (*
  pub unsafe fn rintf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition rintf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rintf64 : M.IsFunction.C "core::intrinsics::rintf64" rintf64.
  Admitted.
  Global Typeclasses Opaque rintf64.
  
  (*
  pub unsafe fn rintf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition rintf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rintf128 :
    M.IsFunction.C "core::intrinsics::rintf128" rintf128.
  Admitted.
  Global Typeclasses Opaque rintf128.
  
  (*
  pub unsafe fn nearbyintf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition nearbyintf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_nearbyintf16 :
    M.IsFunction.C "core::intrinsics::nearbyintf16" nearbyintf16.
  Admitted.
  Global Typeclasses Opaque nearbyintf16.
  
  (*
  pub unsafe fn nearbyintf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition nearbyintf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_nearbyintf32 :
    M.IsFunction.C "core::intrinsics::nearbyintf32" nearbyintf32.
  Admitted.
  Global Typeclasses Opaque nearbyintf32.
  
  (*
  pub unsafe fn nearbyintf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition nearbyintf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_nearbyintf64 :
    M.IsFunction.C "core::intrinsics::nearbyintf64" nearbyintf64.
  Admitted.
  Global Typeclasses Opaque nearbyintf64.
  
  (*
  pub unsafe fn nearbyintf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition nearbyintf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_nearbyintf128 :
    M.IsFunction.C "core::intrinsics::nearbyintf128" nearbyintf128.
  Admitted.
  Global Typeclasses Opaque nearbyintf128.
  
  (*
  pub unsafe fn roundf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition roundf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundf16 :
    M.IsFunction.C "core::intrinsics::roundf16" roundf16.
  Admitted.
  Global Typeclasses Opaque roundf16.
  
  (*
  pub unsafe fn roundf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition roundf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundf32 :
    M.IsFunction.C "core::intrinsics::roundf32" roundf32.
  Admitted.
  Global Typeclasses Opaque roundf32.
  
  (*
  pub unsafe fn roundf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition roundf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundf64 :
    M.IsFunction.C "core::intrinsics::roundf64" roundf64.
  Admitted.
  Global Typeclasses Opaque roundf64.
  
  (*
  pub unsafe fn roundf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition roundf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundf128 :
    M.IsFunction.C "core::intrinsics::roundf128" roundf128.
  Admitted.
  Global Typeclasses Opaque roundf128.
  
  (*
  pub unsafe fn roundevenf16(_x: f16) -> f16 {
      unreachable!()
  }
  *)
  Definition roundevenf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundevenf16 :
    M.IsFunction.C "core::intrinsics::roundevenf16" roundevenf16.
  Admitted.
  Global Typeclasses Opaque roundevenf16.
  
  (*
  pub unsafe fn roundevenf32(_x: f32) -> f32 {
      unreachable!()
  }
  *)
  Definition roundevenf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundevenf32 :
    M.IsFunction.C "core::intrinsics::roundevenf32" roundevenf32.
  Admitted.
  Global Typeclasses Opaque roundevenf32.
  
  (*
  pub unsafe fn roundevenf64(_x: f64) -> f64 {
      unreachable!()
  }
  *)
  Definition roundevenf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundevenf64 :
    M.IsFunction.C "core::intrinsics::roundevenf64" roundevenf64.
  Admitted.
  Global Typeclasses Opaque roundevenf64.
  
  (*
  pub unsafe fn roundevenf128(_x: f128) -> f128 {
      unreachable!()
  }
  *)
  Definition roundevenf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_roundevenf128 :
    M.IsFunction.C "core::intrinsics::roundevenf128" roundevenf128.
  Admitted.
  Global Typeclasses Opaque roundevenf128.
  
  (*
  pub unsafe fn fadd_fast<T: Copy>(_a: T, _b: T) -> T {
      unreachable!()
  }
  *)
  Definition fadd_fast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fadd_fast :
    M.IsFunction.C "core::intrinsics::fadd_fast" fadd_fast.
  Admitted.
  Global Typeclasses Opaque fadd_fast.
  
  (*
  pub unsafe fn fsub_fast<T: Copy>(_a: T, _b: T) -> T {
      unreachable!()
  }
  *)
  Definition fsub_fast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fsub_fast :
    M.IsFunction.C "core::intrinsics::fsub_fast" fsub_fast.
  Admitted.
  Global Typeclasses Opaque fsub_fast.
  
  (*
  pub unsafe fn fmul_fast<T: Copy>(_a: T, _b: T) -> T {
      unreachable!()
  }
  *)
  Definition fmul_fast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmul_fast :
    M.IsFunction.C "core::intrinsics::fmul_fast" fmul_fast.
  Admitted.
  Global Typeclasses Opaque fmul_fast.
  
  (*
  pub unsafe fn fdiv_fast<T: Copy>(_a: T, _b: T) -> T {
      unreachable!()
  }
  *)
  Definition fdiv_fast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fdiv_fast :
    M.IsFunction.C "core::intrinsics::fdiv_fast" fdiv_fast.
  Admitted.
  Global Typeclasses Opaque fdiv_fast.
  
  (*
  pub unsafe fn frem_fast<T: Copy>(_a: T, _b: T) -> T {
      unreachable!()
  }
  *)
  Definition frem_fast (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_frem_fast :
    M.IsFunction.C "core::intrinsics::frem_fast" frem_fast.
  Admitted.
  Global Typeclasses Opaque frem_fast.
  
  (*
  pub unsafe fn float_to_int_unchecked<Float: Copy, Int: Copy>(_value: Float) -> Int {
      unreachable!()
  }
  *)
  Definition float_to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ Float; Int ], [ _value ] =>
      ltac:(M.monadic
        (let _value := M.alloc (| _value |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_float_to_int_unchecked :
    M.IsFunction.C "core::intrinsics::float_to_int_unchecked" float_to_int_unchecked.
  Admitted.
  Global Typeclasses Opaque float_to_int_unchecked.
  
  (*
  pub fn fadd_algebraic<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition fadd_algebraic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fadd_algebraic :
    M.IsFunction.C "core::intrinsics::fadd_algebraic" fadd_algebraic.
  Admitted.
  Global Typeclasses Opaque fadd_algebraic.
  
  (*
  pub fn fsub_algebraic<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition fsub_algebraic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fsub_algebraic :
    M.IsFunction.C "core::intrinsics::fsub_algebraic" fsub_algebraic.
  Admitted.
  Global Typeclasses Opaque fsub_algebraic.
  
  (*
  pub fn fmul_algebraic<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition fmul_algebraic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fmul_algebraic :
    M.IsFunction.C "core::intrinsics::fmul_algebraic" fmul_algebraic.
  Admitted.
  Global Typeclasses Opaque fmul_algebraic.
  
  (*
  pub fn fdiv_algebraic<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition fdiv_algebraic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fdiv_algebraic :
    M.IsFunction.C "core::intrinsics::fdiv_algebraic" fdiv_algebraic.
  Admitted.
  Global Typeclasses Opaque fdiv_algebraic.
  
  (*
  pub fn frem_algebraic<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition frem_algebraic (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_frem_algebraic :
    M.IsFunction.C "core::intrinsics::frem_algebraic" frem_algebraic.
  Admitted.
  Global Typeclasses Opaque frem_algebraic.
  
  (*
  pub const fn ctpop<T: Copy>(_x: T) -> u32 {
      unimplemented!()
  }
  *)
  Definition ctpop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ctpop : M.IsFunction.C "core::intrinsics::ctpop" ctpop.
  Admitted.
  Global Typeclasses Opaque ctpop.
  
  (*
  pub const fn ctlz<T: Copy>(_x: T) -> u32 {
      unimplemented!()
  }
  *)
  Definition ctlz (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ctlz : M.IsFunction.C "core::intrinsics::ctlz" ctlz.
  Admitted.
  Global Typeclasses Opaque ctlz.
  
  (*
  pub const unsafe fn ctlz_nonzero<T: Copy>(_x: T) -> u32 {
      unimplemented!()
  }
  *)
  Definition ctlz_nonzero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ctlz_nonzero :
    M.IsFunction.C "core::intrinsics::ctlz_nonzero" ctlz_nonzero.
  Admitted.
  Global Typeclasses Opaque ctlz_nonzero.
  
  (*
  pub const fn cttz<T: Copy>(_x: T) -> u32 {
      unimplemented!()
  }
  *)
  Definition cttz (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cttz : M.IsFunction.C "core::intrinsics::cttz" cttz.
  Admitted.
  Global Typeclasses Opaque cttz.
  
  (*
  pub const unsafe fn cttz_nonzero<T: Copy>(_x: T) -> u32 {
      unimplemented!()
  }
  *)
  Definition cttz_nonzero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_cttz_nonzero :
    M.IsFunction.C "core::intrinsics::cttz_nonzero" cttz_nonzero.
  Admitted.
  Global Typeclasses Opaque cttz_nonzero.
  
  (*
  pub const fn bswap<T: Copy>(_x: T) -> T {
      unimplemented!()
  }
  *)
  Definition bswap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bswap : M.IsFunction.C "core::intrinsics::bswap" bswap.
  Admitted.
  Global Typeclasses Opaque bswap.
  
  (*
  pub const fn bitreverse<T: Copy>(_x: T) -> T {
      unimplemented!()
  }
  *)
  Definition bitreverse (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_bitreverse :
    M.IsFunction.C "core::intrinsics::bitreverse" bitreverse.
  Admitted.
  Global Typeclasses Opaque bitreverse.
  
  (*
  pub const fn three_way_compare<T: Copy>(_lhs: T, _rhss: T) -> crate::cmp::Ordering {
      unimplemented!()
  }
  *)
  Definition three_way_compare (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _lhs; _rhss ] =>
      ltac:(M.monadic
        (let _lhs := M.alloc (| _lhs |) in
        let _rhss := M.alloc (| _rhss |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_three_way_compare :
    M.IsFunction.C "core::intrinsics::three_way_compare" three_way_compare.
  Admitted.
  Global Typeclasses Opaque three_way_compare.
  
  (*
  pub const fn add_with_overflow<T: Copy>(_x: T, _y: T) -> (T, bool) {
      unimplemented!()
  }
  *)
  Definition add_with_overflow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_add_with_overflow :
    M.IsFunction.C "core::intrinsics::add_with_overflow" add_with_overflow.
  Admitted.
  Global Typeclasses Opaque add_with_overflow.
  
  (*
  pub const fn sub_with_overflow<T: Copy>(_x: T, _y: T) -> (T, bool) {
      unimplemented!()
  }
  *)
  Definition sub_with_overflow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sub_with_overflow :
    M.IsFunction.C "core::intrinsics::sub_with_overflow" sub_with_overflow.
  Admitted.
  Global Typeclasses Opaque sub_with_overflow.
  
  (*
  pub const fn mul_with_overflow<T: Copy>(_x: T, _y: T) -> (T, bool) {
      unimplemented!()
  }
  *)
  Definition mul_with_overflow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_mul_with_overflow :
    M.IsFunction.C "core::intrinsics::mul_with_overflow" mul_with_overflow.
  Admitted.
  Global Typeclasses Opaque mul_with_overflow.
  
  (*
  pub const unsafe fn exact_div<T: Copy>(_x: T, _y: T) -> T {
      unimplemented!()
  }
  *)
  Definition exact_div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_exact_div :
    M.IsFunction.C "core::intrinsics::exact_div" exact_div.
  Admitted.
  Global Typeclasses Opaque exact_div.
  
  (*
  pub const unsafe fn unchecked_div<T: Copy>(_x: T, _y: T) -> T {
      unimplemented!()
  }
  *)
  Definition unchecked_div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unchecked_div :
    M.IsFunction.C "core::intrinsics::unchecked_div" unchecked_div.
  Admitted.
  Global Typeclasses Opaque unchecked_div.
  
  (*
  pub const unsafe fn unchecked_rem<T: Copy>(_x: T, _y: T) -> T {
      unimplemented!()
  }
  *)
  Definition unchecked_rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unchecked_rem :
    M.IsFunction.C "core::intrinsics::unchecked_rem" unchecked_rem.
  Admitted.
  Global Typeclasses Opaque unchecked_rem.
  
  (*
  pub const unsafe fn unchecked_shl<T: Copy, U: Copy>(_x: T, _y: U) -> T {
      unimplemented!()
  }
  *)
  Definition unchecked_shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T; U ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unchecked_shl :
    M.IsFunction.C "core::intrinsics::unchecked_shl" unchecked_shl.
  Admitted.
  Global Typeclasses Opaque unchecked_shl.
  
  (*
  pub const unsafe fn unchecked_shr<T: Copy, U: Copy>(_x: T, _y: U) -> T {
      unimplemented!()
  }
  *)
  Definition unchecked_shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T; U ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unchecked_shr :
    M.IsFunction.C "core::intrinsics::unchecked_shr" unchecked_shr.
  Admitted.
  Global Typeclasses Opaque unchecked_shr.
  
  (*
  pub const unsafe fn unchecked_add<T: Copy>(_x: T, _y: T) -> T {
      unimplemented!()
  }
  *)
  Definition unchecked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unchecked_add :
    M.IsFunction.C "core::intrinsics::unchecked_add" unchecked_add.
  Admitted.
  Global Typeclasses Opaque unchecked_add.
  
  (*
  pub const unsafe fn unchecked_sub<T: Copy>(_x: T, _y: T) -> T {
      unimplemented!()
  }
  *)
  Definition unchecked_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unchecked_sub :
    M.IsFunction.C "core::intrinsics::unchecked_sub" unchecked_sub.
  Admitted.
  Global Typeclasses Opaque unchecked_sub.
  
  (*
  pub const unsafe fn unchecked_mul<T: Copy>(_x: T, _y: T) -> T {
      unimplemented!()
  }
  *)
  Definition unchecked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_unchecked_mul :
    M.IsFunction.C "core::intrinsics::unchecked_mul" unchecked_mul.
  Admitted.
  Global Typeclasses Opaque unchecked_mul.
  
  (*
  pub const fn rotate_left<T: Copy>(_x: T, _shift: u32) -> T {
      unimplemented!()
  }
  *)
  Definition rotate_left (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _shift ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _shift := M.alloc (| _shift |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rotate_left :
    M.IsFunction.C "core::intrinsics::rotate_left" rotate_left.
  Admitted.
  Global Typeclasses Opaque rotate_left.
  
  (*
  pub const fn rotate_right<T: Copy>(_x: T, _shift: u32) -> T {
      unimplemented!()
  }
  *)
  Definition rotate_right (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x; _shift ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _shift := M.alloc (| _shift |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_rotate_right :
    M.IsFunction.C "core::intrinsics::rotate_right" rotate_right.
  Admitted.
  Global Typeclasses Opaque rotate_right.
  
  (*
  pub const fn wrapping_add<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition wrapping_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_wrapping_add :
    M.IsFunction.C "core::intrinsics::wrapping_add" wrapping_add.
  Admitted.
  Global Typeclasses Opaque wrapping_add.
  
  (*
  pub const fn wrapping_sub<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition wrapping_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_wrapping_sub :
    M.IsFunction.C "core::intrinsics::wrapping_sub" wrapping_sub.
  Admitted.
  Global Typeclasses Opaque wrapping_sub.
  
  (*
  pub const fn wrapping_mul<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition wrapping_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_wrapping_mul :
    M.IsFunction.C "core::intrinsics::wrapping_mul" wrapping_mul.
  Admitted.
  Global Typeclasses Opaque wrapping_mul.
  
  (*
  pub const fn saturating_add<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition saturating_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_saturating_add :
    M.IsFunction.C "core::intrinsics::saturating_add" saturating_add.
  Admitted.
  Global Typeclasses Opaque saturating_add.
  
  (*
  pub const fn saturating_sub<T: Copy>(_a: T, _b: T) -> T {
      unimplemented!()
  }
  *)
  Definition saturating_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_saturating_sub :
    M.IsFunction.C "core::intrinsics::saturating_sub" saturating_sub.
  Admitted.
  Global Typeclasses Opaque saturating_sub.
  
  (*
  pub const unsafe fn read_via_copy<T>(_ptr: *const T) -> T {
      unimplemented!()
  }
  *)
  Definition read_via_copy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _ptr ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_read_via_copy :
    M.IsFunction.C "core::intrinsics::read_via_copy" read_via_copy.
  Admitted.
  Global Typeclasses Opaque read_via_copy.
  
  (*
  pub const unsafe fn write_via_move<T>(_ptr: *mut T, _value: T) {
      unimplemented!()
  }
  *)
  Definition write_via_move (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _ptr; _value ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        let _value := M.alloc (| _value |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_write_via_move :
    M.IsFunction.C "core::intrinsics::write_via_move" write_via_move.
  Admitted.
  Global Typeclasses Opaque write_via_move.
  
  (*
  pub const fn discriminant_value<T>(_v: &T) -> <T as DiscriminantKind>::Discriminant {
      unimplemented!()
  }
  *)
  Definition discriminant_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _v ] =>
      ltac:(M.monadic
        (let _v := M.alloc (| _v |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_discriminant_value :
    M.IsFunction.C "core::intrinsics::discriminant_value" discriminant_value.
  Admitted.
  Global Typeclasses Opaque discriminant_value.
  
  Parameter catch_unwind : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
  
  Global Instance Instance_IsFunction_catch_unwind :
    M.IsFunction.C "core::intrinsics::catch_unwind" catch_unwind.
  Admitted.
  
  Parameter nontemporal_store : (list Value.t) -> (list Ty.t) -> (list Value.t) -> M.
  
  Global Instance Instance_IsFunction_nontemporal_store :
    M.IsFunction.C "core::intrinsics::nontemporal_store" nontemporal_store.
  Admitted.
  
  (*
  pub const unsafe fn ptr_offset_from<T>(_ptr: *const T, _base: *const T) -> isize {
      unimplemented!()
  }
  *)
  Definition ptr_offset_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _ptr; _base ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        let _base := M.alloc (| _base |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ptr_offset_from :
    M.IsFunction.C "core::intrinsics::ptr_offset_from" ptr_offset_from.
  Admitted.
  Global Typeclasses Opaque ptr_offset_from.
  
  (*
  pub const unsafe fn ptr_offset_from_unsigned<T>(_ptr: *const T, _base: *const T) -> usize {
      unimplemented!()
  }
  *)
  Definition ptr_offset_from_unsigned (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _ptr; _base ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        let _base := M.alloc (| _base |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ptr_offset_from_unsigned :
    M.IsFunction.C "core::intrinsics::ptr_offset_from_unsigned" ptr_offset_from_unsigned.
  Admitted.
  Global Typeclasses Opaque ptr_offset_from_unsigned.
  
  (*
  pub const fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8 {
      (ptr == other) as u8
  }
  *)
  Definition ptr_guaranteed_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ ptr; other ] =>
      ltac:(M.monadic
        (let ptr := M.alloc (| ptr |) in
        let other := M.alloc (| other |) in
        M.cast
          (Ty.path "u8")
          (M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [ M.read (| ptr |); M.read (| other |) ]
          |))))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ptr_guaranteed_cmp :
    M.IsFunction.C "core::intrinsics::ptr_guaranteed_cmp" ptr_guaranteed_cmp.
  Admitted.
  Global Typeclasses Opaque ptr_guaranteed_cmp.
  
  (*
  pub const unsafe fn raw_eq<T>(_a: &T, _b: &T) -> bool {
      unimplemented!()
  }
  *)
  Definition raw_eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _a; _b ] =>
      ltac:(M.monadic
        (let _a := M.alloc (| _a |) in
        let _b := M.alloc (| _b |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_raw_eq : M.IsFunction.C "core::intrinsics::raw_eq" raw_eq.
  Admitted.
  Global Typeclasses Opaque raw_eq.
  
  (*
  pub const unsafe fn compare_bytes(_left: *const u8, _right: *const u8, _bytes: usize) -> i32 {
      unimplemented!()
  }
  *)
  Definition compare_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _left; _right; _bytes ] =>
      ltac:(M.monadic
        (let _left := M.alloc (| _left |) in
        let _right := M.alloc (| _right |) in
        let _bytes := M.alloc (| _bytes |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_compare_bytes :
    M.IsFunction.C "core::intrinsics::compare_bytes" compare_bytes.
  Admitted.
  Global Typeclasses Opaque compare_bytes.
  
  (*
  pub const fn black_box<T>(_dummy: T) -> T {
      unimplemented!()
  }
  *)
  Definition black_box (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _dummy ] =>
      ltac:(M.monadic
        (let _dummy := M.alloc (| _dummy |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_black_box :
    M.IsFunction.C "core::intrinsics::black_box" black_box.
  Admitted.
  Global Typeclasses Opaque black_box.
  
  (*
  pub const fn const_eval_select<ARG: Tuple, F, G, RET>(
      _arg: ARG,
      _called_in_const: F,
      _called_at_rt: G,
  ) -> RET
  where
      G: FnOnce<ARG, Output = RET>,
      F: FnOnce<ARG, Output = RET>,
  {
      unreachable!()
  }
  *)
  Definition const_eval_select (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ ARG; F; G; RET ], [ _arg; _called_in_const; _called_at_rt ] =>
      ltac:(M.monadic
        (let _arg := M.alloc (| _arg |) in
        let _called_in_const := M.alloc (| _called_in_const |) in
        let _called_at_rt := M.alloc (| _called_at_rt |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_const_eval_select :
    M.IsFunction.C "core::intrinsics::const_eval_select" const_eval_select.
  Admitted.
  Global Typeclasses Opaque const_eval_select.
  
  (*
  pub const fn is_val_statically_known<T: Copy>(_arg: T) -> bool {
      false
  }
  *)
  Definition is_val_statically_known (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _arg ] =>
      ltac:(M.monadic
        (let _arg := M.alloc (| _arg |) in
        Value.Bool false))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_is_val_statically_known :
    M.IsFunction.C "core::intrinsics::is_val_statically_known" is_val_statically_known.
  Admitted.
  Global Typeclasses Opaque is_val_statically_known.
  
  (*
  pub const unsafe fn typed_swap<T>(x: *mut T, y: *mut T) {
      // SAFETY: The caller provided single non-overlapping items behind
      // pointers, so swapping them with `count: 1` is fine.
      unsafe { ptr::swap_nonoverlapping(x, y, 1) };
  }
  *)
  Definition typed_swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ x; y ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        let y := M.alloc (| y |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_function (| "core::ptr::swap_nonoverlapping", [], [ T ] |),
                [ M.read (| x |); M.read (| y |); Value.Integer IntegerKind.Usize 1 ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_typed_swap :
    M.IsFunction.C "core::intrinsics::typed_swap" typed_swap.
  Admitted.
  Global Typeclasses Opaque typed_swap.
  
  (*
  pub const fn ub_checks() -> bool {
      cfg!(ub_checks)
  }
  *)
  Definition ub_checks (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] => ltac:(M.monadic (Value.Bool true))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ub_checks :
    M.IsFunction.C "core::intrinsics::ub_checks" ub_checks.
  Admitted.
  Global Typeclasses Opaque ub_checks.
  
  (*
  pub const unsafe fn const_allocate(_size: usize, _align: usize) -> *mut u8 {
      // const eval overrides this function, but runtime code for now just returns null pointers.
      // See <https://github.com/rust-lang/rust/issues/93935>.
      crate::ptr::null_mut()
  }
  *)
  Definition const_allocate (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _size; _align ] =>
      ltac:(M.monadic
        (let _size := M.alloc (| _size |) in
        let _align := M.alloc (| _align |) in
        M.call_closure (|
          Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ],
          M.get_function (| "core::ptr::null_mut", [], [ Ty.path "u8" ] |),
          []
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_const_allocate :
    M.IsFunction.C "core::intrinsics::const_allocate" const_allocate.
  Admitted.
  Global Typeclasses Opaque const_allocate.
  
  (*
  pub const unsafe fn const_deallocate(_ptr: *mut u8, _size: usize, _align: usize) {
      // Runtime NOP
  }
  *)
  Definition const_deallocate (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _ptr; _size; _align ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        let _size := M.alloc (| _size |) in
        let _align := M.alloc (| _align |) in
        Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_const_deallocate :
    M.IsFunction.C "core::intrinsics::const_deallocate" const_deallocate.
  Admitted.
  Global Typeclasses Opaque const_deallocate.
  
  (*
  pub unsafe fn vtable_size(_ptr: *const ()) -> usize {
      unreachable!()
  }
  *)
  Definition vtable_size (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _ptr ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_vtable_size :
    M.IsFunction.C "core::intrinsics::vtable_size" vtable_size.
  Admitted.
  Global Typeclasses Opaque vtable_size.
  
  (*
  pub unsafe fn vtable_align(_ptr: *const ()) -> usize {
      unreachable!()
  }
  *)
  Definition vtable_align (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _ptr ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_vtable_align :
    M.IsFunction.C "core::intrinsics::vtable_align" vtable_align.
  Admitted.
  Global Typeclasses Opaque vtable_align.
  
  (*
  pub const fn size_of<T>() -> usize {
      unreachable!()
  }
  *)
  Definition size_of (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_size_of : M.IsFunction.C "core::intrinsics::size_of" size_of.
  Admitted.
  Global Typeclasses Opaque size_of.
  
  (*
  pub const fn min_align_of<T>() -> usize {
      unreachable!()
  }
  *)
  Definition min_align_of (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_min_align_of :
    M.IsFunction.C "core::intrinsics::min_align_of" min_align_of.
  Admitted.
  Global Typeclasses Opaque min_align_of.
  
  (*
  pub const unsafe fn pref_align_of<T>() -> usize {
      unreachable!()
  }
  *)
  Definition pref_align_of (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_pref_align_of :
    M.IsFunction.C "core::intrinsics::pref_align_of" pref_align_of.
  Admitted.
  Global Typeclasses Opaque pref_align_of.
  
  (*
  pub const fn variant_count<T>() -> usize {
      unreachable!()
  }
  *)
  Definition variant_count (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_variant_count :
    M.IsFunction.C "core::intrinsics::variant_count" variant_count.
  Admitted.
  Global Typeclasses Opaque variant_count.
  
  (*
  pub const unsafe fn size_of_val<T: ?Sized>(_ptr: *const T) -> usize {
      unreachable!()
  }
  *)
  Definition size_of_val (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _ptr ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_size_of_val :
    M.IsFunction.C "core::intrinsics::size_of_val" size_of_val.
  Admitted.
  Global Typeclasses Opaque size_of_val.
  
  (*
  pub const unsafe fn min_align_of_val<T: ?Sized>(_ptr: *const T) -> usize {
      unreachable!()
  }
  *)
  Definition min_align_of_val (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _ptr ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_min_align_of_val :
    M.IsFunction.C "core::intrinsics::min_align_of_val" min_align_of_val.
  Admitted.
  Global Typeclasses Opaque min_align_of_val.
  
  (*
  pub const fn type_name<T: ?Sized>() -> &'static str {
      unreachable!()
  }
  *)
  Definition type_name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_type_name :
    M.IsFunction.C "core::intrinsics::type_name" type_name.
  Admitted.
  Global Typeclasses Opaque type_name.
  
  (*
  pub const fn type_id<T: ?Sized + 'static>() -> u128 {
      unreachable!()
  }
  *)
  Definition type_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_type_id : M.IsFunction.C "core::intrinsics::type_id" type_id.
  Admitted.
  Global Typeclasses Opaque type_id.
  
  (*
  pub const fn aggregate_raw_ptr<P: AggregateRawPtr<D, Metadata = M>, D, M>(_data: D, _meta: M) -> P {
      // To implement a fallback we'd have to assume the layout of the pointer,
      // but the whole point of this intrinsic is that we shouldn't do that.
      unreachable!()
  }
  *)
  Definition aggregate_raw_ptr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ P; D; M_ ], [ _data; _meta ] =>
      ltac:(M.monadic
        (let _data := M.alloc (| _data |) in
        let _meta := M.alloc (| _meta |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_aggregate_raw_ptr :
    M.IsFunction.C "core::intrinsics::aggregate_raw_ptr" aggregate_raw_ptr.
  Admitted.
  Global Typeclasses Opaque aggregate_raw_ptr.
  
  (* Trait *)
  (* Empty module 'AggregateRawPtr' *)
  
  Module Impl_core_intrinsics_AggregateRawPtr_where_core_marker_Sized_P_where_core_ptr_metadata_Thin_T_pointer_const_T_for_pointer_const_P.
    Definition Self (P T : Ty.t) : Ty.t := Ty.apply (Ty.path "*const") [] [ P ].
    
    (*     type Metadata = <P as ptr::Pointee>::Metadata; *)
    Definition _Metadata (P T : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] P "Metadata".
    
    Axiom Implements :
      forall (P T : Ty.t),
      M.IsTraitInstance
        "core::intrinsics::AggregateRawPtr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "*const") [] [ T ] ]
        (Self P T)
        (* Instance *) [ ("Metadata", InstanceField.Ty (_Metadata P T)) ].
  End Impl_core_intrinsics_AggregateRawPtr_where_core_marker_Sized_P_where_core_ptr_metadata_Thin_T_pointer_const_T_for_pointer_const_P.
  
  Module Impl_core_intrinsics_AggregateRawPtr_where_core_marker_Sized_P_where_core_ptr_metadata_Thin_T_pointer_mut_T_for_pointer_mut_P.
    Definition Self (P T : Ty.t) : Ty.t := Ty.apply (Ty.path "*mut") [] [ P ].
    
    (*     type Metadata = <P as ptr::Pointee>::Metadata; *)
    Definition _Metadata (P T : Ty.t) : Ty.t :=
      Ty.associated_in_trait "core::ptr::metadata::Pointee" [] [] P "Metadata".
    
    Axiom Implements :
      forall (P T : Ty.t),
      M.IsTraitInstance
        "core::intrinsics::AggregateRawPtr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "*mut") [] [ T ] ]
        (Self P T)
        (* Instance *) [ ("Metadata", InstanceField.Ty (_Metadata P T)) ].
  End Impl_core_intrinsics_AggregateRawPtr_where_core_marker_Sized_P_where_core_ptr_metadata_Thin_T_pointer_mut_T_for_pointer_mut_P.
  
  (*
  pub const fn ptr_metadata<P: ptr::Pointee<Metadata = M> + ?Sized, M>(_ptr: *const P) -> M {
      // To implement a fallback we'd have to assume the layout of the pointer,
      // but the whole point of this intrinsic is that we shouldn't do that.
      unreachable!()
  }
  *)
  Definition ptr_metadata (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ P; M_ ], [ _ptr ] =>
      ltac:(M.monadic
        (let _ptr := M.alloc (| _ptr |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "internal error: entered unreachable code" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_ptr_metadata :
    M.IsFunction.C "core::intrinsics::ptr_metadata" ptr_metadata.
  Admitted.
  Global Typeclasses Opaque ptr_metadata.
  
  (*
  pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {
      #[rustc_intrinsic_const_stable_indirect]
      #[rustc_nounwind]
      #[rustc_intrinsic]
      #[rustc_intrinsic_must_be_overridden]
      const unsafe fn copy_nonoverlapping<T>(_src: *const T, _dst: *mut T, _count: usize) {
          unreachable!()
      }
  
      ub_checks::assert_unsafe_precondition!(
          check_language_ub,
          "ptr::copy_nonoverlapping requires that both pointer arguments are aligned and non-null \
          and the specified memory ranges do not overlap",
          (
              src: *const () = src as *const (),
              dst: *mut () = dst as *mut (),
              size: usize = size_of::<T>(),
              align: usize = align_of::<T>(),
              count: usize = count,
          ) => {
              let zero_size = count == 0 || size == 0;
              ub_checks::maybe_is_aligned_and_not_null(src, align, zero_size)
                  && ub_checks::maybe_is_aligned_and_not_null(dst, align, zero_size)
                  && ub_checks::maybe_is_nonoverlapping(src, dst, size, count)
          }
      );
  
      // SAFETY: the safety contract for `copy_nonoverlapping` must be
      // upheld by the caller.
      unsafe { copy_nonoverlapping(src, dst, count) }
  }
  *)
  Definition copy_nonoverlapping (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (| "core::ub_checks::check_language_ub", [], [] |),
                            []
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "core::intrinsics::copy_nonoverlapping.precondition_check",
                            [],
                            []
                          |),
                          [
                            M.cast
                              (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                              (M.read (| src |));
                            M.cast
                              (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                              (M.read (| dst |));
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "core::intrinsics::size_of", [], [ T ] |),
                              []
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "core::mem::align_of", [], [ T ] |),
                              []
                            |);
                            M.read (| count |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.tuple [],
              M.get_function (|
                "core::intrinsics::copy_nonoverlapping.copy_nonoverlapping",
                [],
                []
              |),
              [ M.read (| src |); M.read (| dst |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_copy_nonoverlapping :
    M.IsFunction.C "core::intrinsics::copy_nonoverlapping" copy_nonoverlapping.
  Admitted.
  Global Typeclasses Opaque copy_nonoverlapping.
  
  Module copy_nonoverlapping.
    (*
        const unsafe fn copy_nonoverlapping<T>(_src: *const T, _dst: *mut T, _count: usize) {
            unreachable!()
        }
    *)
    Definition copy_nonoverlapping (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ _src; _dst; _count ] =>
        ltac:(M.monadic
          (let _src := M.alloc (| _src |) in
          let _dst := M.alloc (| _dst |) in
          let _count := M.alloc (| _count |) in
          M.never_to_any (|
            M.call_closure (|
              Ty.path "never",
              M.get_function (| "core::panicking::panic", [], [] |),
              [ mk_str (| "internal error: entered unreachable code" |) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_copy_nonoverlapping :
      M.IsFunction.C
        "core::intrinsics::copy_nonoverlapping::copy_nonoverlapping"
        copy_nonoverlapping.
    Admitted.
    Global Typeclasses Opaque copy_nonoverlapping.
  End copy_nonoverlapping.
  
  (*
  pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {
      #[rustc_intrinsic_const_stable_indirect]
      #[rustc_nounwind]
      #[rustc_intrinsic]
      #[rustc_intrinsic_must_be_overridden]
      const unsafe fn copy<T>(_src: *const T, _dst: *mut T, _count: usize) {
          unreachable!()
      }
  
      // SAFETY: the safety contract for `copy` must be upheld by the caller.
      unsafe {
          ub_checks::assert_unsafe_precondition!(
              check_language_ub,
              "ptr::copy requires that both pointer arguments are aligned and non-null",
              (
                  src: *const () = src as *const (),
                  dst: *mut () = dst as *mut (),
                  align: usize = align_of::<T>(),
                  zero_size: bool = T::IS_ZST || count == 0,
              ) =>
              ub_checks::maybe_is_aligned_and_not_null(src, align, zero_size)
                  && ub_checks::maybe_is_aligned_and_not_null(dst, align, zero_size)
          );
          copy(src, dst, count)
      }
  }
  *)
  Definition copy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ src; dst; count ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        let dst := M.alloc (| dst |) in
        let count := M.alloc (| count |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (| "core::ub_checks::check_language_ub", [], [] |),
                            []
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (| "core::intrinsics::copy.precondition_check", [], [] |),
                          [
                            M.cast
                              (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                              (M.read (| src |));
                            M.cast
                              (Ty.apply (Ty.path "*mut") [] [ Ty.tuple [] ])
                              (M.read (| dst |));
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "core::mem::align_of", [], [ T ] |),
                              []
                            |);
                            LogicalOp.or (|
                              M.read (|
                                get_constant (|
                                  "core::mem::SizedTypeProperties::IS_ZST",
                                  Ty.path "bool"
                                |)
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                |)))
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::copy.copy", [], [] |),
              [ M.read (| src |); M.read (| dst |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_copy : M.IsFunction.C "core::intrinsics::copy" copy.
  Admitted.
  Global Typeclasses Opaque copy.
  
  Module copy.
    (*
        const unsafe fn copy<T>(_src: *const T, _dst: *mut T, _count: usize) {
            unreachable!()
        }
    *)
    Definition copy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ _src; _dst; _count ] =>
        ltac:(M.monadic
          (let _src := M.alloc (| _src |) in
          let _dst := M.alloc (| _dst |) in
          let _count := M.alloc (| _count |) in
          M.never_to_any (|
            M.call_closure (|
              Ty.path "never",
              M.get_function (| "core::panicking::panic", [], [] |),
              [ mk_str (| "internal error: entered unreachable code" |) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_copy : M.IsFunction.C "core::intrinsics::copy::copy" copy.
    Admitted.
    Global Typeclasses Opaque copy.
  End copy.
  
  (*
  pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {
      #[rustc_intrinsic_const_stable_indirect]
      #[rustc_nounwind]
      #[rustc_intrinsic]
      #[rustc_intrinsic_must_be_overridden]
      const unsafe fn write_bytes<T>(_dst: *mut T, _val: u8, _count: usize) {
          unreachable!()
      }
  
      // SAFETY: the safety contract for `write_bytes` must be upheld by the caller.
      unsafe {
          ub_checks::assert_unsafe_precondition!(
              check_language_ub,
              "ptr::write_bytes requires that the destination pointer is aligned and non-null",
              (
                  addr: *const () = dst as *const (),
                  align: usize = align_of::<T>(),
                  zero_size: bool = T::IS_ZST || count == 0,
              ) => ub_checks::maybe_is_aligned_and_not_null(addr, align, zero_size)
          );
          write_bytes(dst, val, count)
      }
  }
  *)
  Definition write_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ dst; val; count ] =>
      ltac:(M.monadic
        (let dst := M.alloc (| dst |) in
        let val := M.alloc (| val |) in
        let count := M.alloc (| count |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              Some (Ty.tuple []),
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_function (| "core::ub_checks::check_language_ub", [], [] |),
                            []
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "core::intrinsics::write_bytes.precondition_check",
                            [],
                            []
                          |),
                          [
                            M.cast
                              (Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ])
                              (M.read (| dst |));
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_function (| "core::mem::align_of", [], [ T ] |),
                              []
                            |);
                            LogicalOp.or (|
                              M.read (|
                                get_constant (|
                                  "core::mem::SizedTypeProperties::IS_ZST",
                                  Ty.path "bool"
                                |)
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| count |); Value.Integer IntegerKind.Usize 0 ]
                                |)))
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.tuple [],
              M.get_function (| "core::intrinsics::write_bytes.write_bytes", [], [] |),
              [ M.read (| dst |); M.read (| val |); M.read (| count |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_write_bytes :
    M.IsFunction.C "core::intrinsics::write_bytes" write_bytes.
  Admitted.
  Global Typeclasses Opaque write_bytes.
  
  Module write_bytes.
    (*
        const unsafe fn write_bytes<T>(_dst: *mut T, _val: u8, _count: usize) {
            unreachable!()
        }
    *)
    Definition write_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ _dst; _val; _count ] =>
        ltac:(M.monadic
          (let _dst := M.alloc (| _dst |) in
          let _val := M.alloc (| _val |) in
          let _count := M.alloc (| _count |) in
          M.never_to_any (|
            M.call_closure (|
              Ty.path "never",
              M.get_function (| "core::panicking::panic", [], [] |),
              [ mk_str (| "internal error: entered unreachable code" |) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_write_bytes :
      M.IsFunction.C "core::intrinsics::write_bytes::write_bytes" write_bytes.
    Admitted.
    Global Typeclasses Opaque write_bytes.
  End write_bytes.
  
  (*
  pub const fn minnumf16(_x: f16, _y: f16) -> f16 {
      unimplemented!();
  }
  *)
  Definition minnumf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_minnumf16 :
    M.IsFunction.C "core::intrinsics::minnumf16" minnumf16.
  Admitted.
  Global Typeclasses Opaque minnumf16.
  
  (*
  pub const fn minnumf32(_x: f32, _y: f32) -> f32 {
      unimplemented!();
  }
  *)
  Definition minnumf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_minnumf32 :
    M.IsFunction.C "core::intrinsics::minnumf32" minnumf32.
  Admitted.
  Global Typeclasses Opaque minnumf32.
  
  (*
  pub const fn minnumf64(_x: f64, _y: f64) -> f64 {
      unimplemented!();
  }
  *)
  Definition minnumf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_minnumf64 :
    M.IsFunction.C "core::intrinsics::minnumf64" minnumf64.
  Admitted.
  Global Typeclasses Opaque minnumf64.
  
  (*
  pub const fn minnumf128(_x: f128, _y: f128) -> f128 {
      unimplemented!();
  }
  *)
  Definition minnumf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_minnumf128 :
    M.IsFunction.C "core::intrinsics::minnumf128" minnumf128.
  Admitted.
  Global Typeclasses Opaque minnumf128.
  
  (*
  pub const fn maxnumf16(_x: f16, _y: f16) -> f16 {
      unimplemented!();
  }
  *)
  Definition maxnumf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maxnumf16 :
    M.IsFunction.C "core::intrinsics::maxnumf16" maxnumf16.
  Admitted.
  Global Typeclasses Opaque maxnumf16.
  
  (*
  pub const fn maxnumf32(_x: f32, _y: f32) -> f32 {
      unimplemented!();
  }
  *)
  Definition maxnumf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maxnumf32 :
    M.IsFunction.C "core::intrinsics::maxnumf32" maxnumf32.
  Admitted.
  Global Typeclasses Opaque maxnumf32.
  
  (*
  pub const fn maxnumf64(_x: f64, _y: f64) -> f64 {
      unimplemented!();
  }
  *)
  Definition maxnumf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maxnumf64 :
    M.IsFunction.C "core::intrinsics::maxnumf64" maxnumf64.
  Admitted.
  Global Typeclasses Opaque maxnumf64.
  
  (*
  pub const fn maxnumf128(_x: f128, _y: f128) -> f128 {
      unimplemented!();
  }
  *)
  Definition maxnumf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_maxnumf128 :
    M.IsFunction.C "core::intrinsics::maxnumf128" maxnumf128.
  Admitted.
  Global Typeclasses Opaque maxnumf128.
  
  (*
  pub const unsafe fn fabsf16(_x: f16) -> f16 {
      unimplemented!();
  }
  *)
  Definition fabsf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fabsf16 : M.IsFunction.C "core::intrinsics::fabsf16" fabsf16.
  Admitted.
  Global Typeclasses Opaque fabsf16.
  
  (*
  pub const unsafe fn fabsf32(_x: f32) -> f32 {
      unimplemented!();
  }
  *)
  Definition fabsf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fabsf32 : M.IsFunction.C "core::intrinsics::fabsf32" fabsf32.
  Admitted.
  Global Typeclasses Opaque fabsf32.
  
  (*
  pub const unsafe fn fabsf64(_x: f64) -> f64 {
      unimplemented!();
  }
  *)
  Definition fabsf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fabsf64 : M.IsFunction.C "core::intrinsics::fabsf64" fabsf64.
  Admitted.
  Global Typeclasses Opaque fabsf64.
  
  (*
  pub const unsafe fn fabsf128(_x: f128) -> f128 {
      unimplemented!();
  }
  *)
  Definition fabsf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fabsf128 :
    M.IsFunction.C "core::intrinsics::fabsf128" fabsf128.
  Admitted.
  Global Typeclasses Opaque fabsf128.
  
  (*
  pub const unsafe fn copysignf16(_x: f16, _y: f16) -> f16 {
      unimplemented!();
  }
  *)
  Definition copysignf16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_copysignf16 :
    M.IsFunction.C "core::intrinsics::copysignf16" copysignf16.
  Admitted.
  Global Typeclasses Opaque copysignf16.
  
  (*
  pub const unsafe fn copysignf32(_x: f32, _y: f32) -> f32 {
      unimplemented!();
  }
  *)
  Definition copysignf32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_copysignf32 :
    M.IsFunction.C "core::intrinsics::copysignf32" copysignf32.
  Admitted.
  Global Typeclasses Opaque copysignf32.
  
  (*
  pub const unsafe fn copysignf64(_x: f64, _y: f64) -> f64 {
      unimplemented!();
  }
  *)
  Definition copysignf64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_copysignf64 :
    M.IsFunction.C "core::intrinsics::copysignf64" copysignf64.
  Admitted.
  Global Typeclasses Opaque copysignf64.
  
  (*
  pub const unsafe fn copysignf128(_x: f128, _y: f128) -> f128 {
      unimplemented!();
  }
  *)
  Definition copysignf128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ _x; _y ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        let _y := M.alloc (| _y |) in
        M.never_to_any (|
          M.call_closure (|
            Ty.path "never",
            M.get_function (| "core::panicking::panic", [], [] |),
            [ mk_str (| "not implemented" |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_copysignf128 :
    M.IsFunction.C "core::intrinsics::copysignf128" copysignf128.
  Admitted.
  Global Typeclasses Opaque copysignf128.
End intrinsics.

Module ub_checks.
  Module check_language_ub.
    (*
            fn runtime($($arg: $ty),* ) $( -> $ret )? {
                $runtime
            }
    *)
    Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] => ltac:(M.monadic (UnOp.not (| Value.Bool false |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_runtime :
      M.IsFunction.C "core::ub_checks::check_language_ub::runtime" runtime.
    Admitted.
    Global Typeclasses Opaque runtime.
    
    (*
            const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                // Don't warn if one of the arguments is unused.
                $(let _ = $arg;)*
    
                $compiletime
            }
    *)
    Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] => ltac:(M.monadic (Value.Bool false))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_compiletime :
      M.IsFunction.C "core::ub_checks::check_language_ub::compiletime" compiletime.
    Admitted.
    Global Typeclasses Opaque compiletime.
  End check_language_ub.
  
  Module maybe_is_aligned_and_not_null.
    (*
            fn runtime($($arg: $ty),* ) $( -> $ret )? {
                $runtime
            }
    *)
    Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ ptr; align; is_zst ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let align := M.alloc (| align |) in
          let is_zst := M.alloc (| is_zst |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                "is_aligned_to",
                [],
                []
              |),
              [ M.read (| ptr |); M.read (| align |) ]
            |),
            ltac:(M.monadic
              (LogicalOp.or (|
                M.read (| is_zst |),
                ltac:(M.monadic
                  (UnOp.not (|
                    M.call_closure (|
                      Ty.path "bool",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                        "is_null",
                        [],
                        []
                      |),
                      [ M.read (| ptr |) ]
                    |)
                  |)))
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_runtime :
      M.IsFunction.C "core::ub_checks::maybe_is_aligned_and_not_null::runtime" runtime.
    Admitted.
    Global Typeclasses Opaque runtime.
    
    (*
            const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                // Don't warn if one of the arguments is unused.
                $(let _ = $arg;)*
    
                $compiletime
            }
    *)
    Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ ptr; align; is_zst ] =>
        ltac:(M.monadic
          (let ptr := M.alloc (| ptr |) in
          let align := M.alloc (| align |) in
          let is_zst := M.alloc (| is_zst |) in
          M.read (|
            M.match_operator (|
              None,
              ptr,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      align,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              None,
                              is_zst,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      LogicalOp.or (|
                                        M.read (| is_zst |),
                                        ltac:(M.monadic
                                          (UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                                                "is_null",
                                                [],
                                                []
                                              |),
                                              [ M.read (| ptr |) ]
                                            |)
                                          |)))
                                      |)
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_compiletime :
      M.IsFunction.C "core::ub_checks::maybe_is_aligned_and_not_null::compiletime" compiletime.
    Admitted.
    Global Typeclasses Opaque compiletime.
  End maybe_is_aligned_and_not_null.
  
  Module maybe_is_nonoverlapping.
    (*
            fn runtime($($arg: $ty),* ) $( -> $ret )? {
                $runtime
            }
    *)
    Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src; dst; size; count ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          let size := M.alloc (| size |) in
          let count := M.alloc (| count |) in
          M.read (|
            let~ src_usize : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                    "addr",
                    [],
                    []
                  |),
                  [ M.read (| src |) ]
                |)
              |) in
            let~ dst_usize : Ty.path "usize" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "*const") [] [ Ty.tuple [] ],
                    "addr",
                    [],
                    []
                  |),
                  [ M.read (| dst |) ]
                |)
              |) in
            M.match_operator (|
              None,
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                  M.get_associated_function (| Ty.path "usize", "checked_mul", [], [] |),
                  [ M.read (| size |); M.read (| count |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let size := M.copy (| γ0_0 |) in
                    let~ diff : Ty.path "usize" :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (| Ty.path "usize", "abs_diff", [], [] |),
                          [ M.read (| src_usize |); M.read (| dst_usize |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        BinOp.ge,
                        [ M.read (| diff |); M.read (| size |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_runtime :
      M.IsFunction.C "core::ub_checks::maybe_is_nonoverlapping::runtime" runtime.
    Admitted.
    Global Typeclasses Opaque runtime.
    
    (*
            const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                // Don't warn if one of the arguments is unused.
                $(let _ = $arg;)*
    
                $compiletime
            }
    *)
    Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src; dst; size; count ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let dst := M.alloc (| dst |) in
          let size := M.alloc (| size |) in
          let count := M.alloc (| count |) in
          M.read (|
            M.match_operator (|
              None,
              src,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      dst,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              None,
                              size,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      None,
                                      count,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_compiletime :
      M.IsFunction.C "core::ub_checks::maybe_is_nonoverlapping::compiletime" compiletime.
    Admitted.
    Global Typeclasses Opaque compiletime.
  End maybe_is_nonoverlapping.
End ub_checks.

Module char.
  Module methods.
    Module encode_utf8_raw.
      Module do_panic.
        (*
                fn runtime($($arg: $ty),* ) $( -> $ret )? {
                    $runtime
                }
        *)
        Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ code; len; dst_len ] =>
            ltac:(M.monadic
              (let code := M.alloc (| code |) in
              let len := M.alloc (| len |) in
              let dst_len := M.alloc (| dst_len |) in
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "core::fmt::Arguments",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Arguments",
                      "new_v1_formatted",
                      [],
                      []
                    |),
                    [
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    mk_str (| "encode_utf8: need " |);
                                    mk_str (| " bytes to encode U+" |);
                                    mk_str (| " but buffer has just " |)
                                  ]
                              |)
                            |)
                          |)
                        |));
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [],
                                        [ Ty.path "usize" ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.borrow (| Pointer.Kind.Ref, len |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_upper_hex",
                                        [],
                                        [ Ty.path "u32" ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.borrow (| Pointer.Kind.Ref, code |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [],
                                        [ Ty.path "usize" ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.borrow (| Pointer.Kind.Ref, dst_len |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |));
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Placeholder",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.Integer IntegerKind.Usize 0;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer IntegerKind.U32 0;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple "core::fmt::rt::Count::Implied" []
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Placeholder",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.Integer IntegerKind.Usize 1;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer IntegerKind.U32 8;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple
                                          "core::fmt::rt::Count::Is"
                                          [ Value.Integer IntegerKind.Usize 4 ]
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Placeholder",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.Integer IntegerKind.Usize 2;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer IntegerKind.U32 0;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple "core::fmt::rt::Count::Implied" []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |));
                      M.call_closure (|
                        Ty.path "core::fmt::rt::UnsafeArg",
                        M.get_associated_function (|
                          Ty.path "core::fmt::rt::UnsafeArg",
                          "new",
                          [],
                          []
                        |),
                        []
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_runtime :
          M.IsFunction.C "core::char::methods::encode_utf8_raw::do_panic::runtime" runtime.
        Admitted.
        Global Typeclasses Opaque runtime.
        
        (*
                const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                    // Don't warn if one of the arguments is unused.
                    $(let _ = $arg;)*
        
                    $compiletime
                }
        *)
        Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ code; len; dst_len ] =>
            ltac:(M.monadic
              (let code := M.alloc (| code |) in
              let len := M.alloc (| len |) in
              let dst_len := M.alloc (| dst_len |) in
              M.read (|
                M.match_operator (|
                  None,
                  code,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          None,
                          len,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  None,
                                  dst_len,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (|
                                              "core::panicking::panic_fmt",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::Arguments",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::Arguments",
                                                  "new_const",
                                                  [ Value.Integer IntegerKind.Usize 1 ],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          Value.Array
                                                            [
                                                              mk_str (|
                                                                "encode_utf8: buffer does not have enough bytes to encode code point"
                                                              |)
                                                            ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_compiletime :
          M.IsFunction.C "core::char::methods::encode_utf8_raw::do_panic::compiletime" compiletime.
        Admitted.
        Global Typeclasses Opaque compiletime.
      End do_panic.
    End encode_utf8_raw.
    
    Module encode_utf16_raw.
      Module do_panic.
        (*
                fn runtime($($arg: $ty),* ) $( -> $ret )? {
                    $runtime
                }
        *)
        Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ code; len; dst_len ] =>
            ltac:(M.monadic
              (let code := M.alloc (| code |) in
              let len := M.alloc (| len |) in
              let dst_len := M.alloc (| dst_len |) in
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "core::fmt::Arguments",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Arguments",
                      "new_v1_formatted",
                      [],
                      []
                    |),
                    [
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    mk_str (| "encode_utf16: need " |);
                                    mk_str (| " bytes to encode U+" |);
                                    mk_str (| " but buffer has just " |)
                                  ]
                              |)
                            |)
                          |)
                        |));
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [],
                                        [ Ty.path "usize" ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.borrow (| Pointer.Kind.Ref, len |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_upper_hex",
                                        [],
                                        [ Ty.path "u32" ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.borrow (| Pointer.Kind.Ref, code |) |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Argument",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [],
                                        [ Ty.path "usize" ]
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.borrow (| Pointer.Kind.Ref, dst_len |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |));
                      (* Unsize *)
                      M.pointer_coercion
                        (M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Placeholder",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.Integer IntegerKind.Usize 0;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer IntegerKind.U32 0;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple "core::fmt::rt::Count::Implied" []
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Placeholder",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.Integer IntegerKind.Usize 1;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer IntegerKind.U32 8;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple
                                          "core::fmt::rt::Count::Is"
                                          [ Value.Integer IntegerKind.Usize 4 ]
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.path "core::fmt::rt::Placeholder",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        Value.Integer IntegerKind.Usize 2;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer IntegerKind.U32 0;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple "core::fmt::rt::Count::Implied" []
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |));
                      M.call_closure (|
                        Ty.path "core::fmt::rt::UnsafeArg",
                        M.get_associated_function (|
                          Ty.path "core::fmt::rt::UnsafeArg",
                          "new",
                          [],
                          []
                        |),
                        []
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_runtime :
          M.IsFunction.C "core::char::methods::encode_utf16_raw::do_panic::runtime" runtime.
        Admitted.
        Global Typeclasses Opaque runtime.
        
        (*
                const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                    // Don't warn if one of the arguments is unused.
                    $(let _ = $arg;)*
        
                    $compiletime
                }
        *)
        Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ code; len; dst_len ] =>
            ltac:(M.monadic
              (let code := M.alloc (| code |) in
              let len := M.alloc (| len |) in
              let dst_len := M.alloc (| dst_len |) in
              M.read (|
                M.match_operator (|
                  None,
                  code,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          None,
                          len,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  None,
                                  dst_len,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (|
                                              "core::panicking::panic_fmt",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::Arguments",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::Arguments",
                                                  "new_const",
                                                  [ Value.Integer IntegerKind.Usize 1 ],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          Value.Array
                                                            [
                                                              mk_str (|
                                                                "encode_utf16: buffer does not have enough bytes to encode code point"
                                                              |)
                                                            ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_compiletime :
          M.IsFunction.C "core::char::methods::encode_utf16_raw::do_panic::compiletime" compiletime.
        Admitted.
        Global Typeclasses Opaque compiletime.
      End do_panic.
    End encode_utf16_raw.
  End methods.
End char.

Module ffi.
  Module c_str.
    Module strlen.
      (*
              fn runtime($($arg: $ty),* ) $( -> $ret )? {
                  $runtime
              }
      *)
      Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_function (| "core::ffi::c_str::strlen::runtime::strlen", [], [] |),
              [ M.read (| s |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_runtime :
        M.IsFunction.C "core::ffi::c_str::strlen::runtime" runtime.
      Admitted.
      Global Typeclasses Opaque runtime.
      
      (*
              const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                  // Don't warn if one of the arguments is unused.
                  $(let _ = $arg;)*
      
                  $compiletime
              }
      *)
      Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.read (|
              M.match_operator (|
                None,
                s,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let~ len : Ty.path "usize" :=
                        M.alloc (| Value.Integer IntegerKind.Usize 0 |) in
                      let~ _ : Ty.tuple [] :=
                        M.loop (|
                          Ty.tuple [],
                          ltac:(M.monadic
                            (M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.ne,
                                            [
                                              M.read (|
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "*const") [] [ Ty.path "i8" ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "*const")
                                                        []
                                                        [ Ty.path "i8" ],
                                                      "add",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| s |); M.read (| len |) ]
                                                  |)
                                                |)
                                              |);
                                              Value.Integer IntegerKind.I8 0
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.alloc (|
                                        let β := len in
                                        M.write (|
                                          β,
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.add,
                                            [ M.read (| β |); Value.Integer IntegerKind.Usize 1 ]
                                          |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)
                                        |)
                                      |)
                                    |)))
                              ]
                            |)))
                        |) in
                      len))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_compiletime :
        M.IsFunction.C "core::ffi::c_str::strlen::compiletime" compiletime.
      Admitted.
      Global Typeclasses Opaque compiletime.
    End strlen.
  End c_str.
End ffi.

Module panicking.
  Module panic_nounwind_fmt.
    (*
            fn runtime($($arg: $ty),* ) $( -> $ret )? {
                $runtime
            }
    *)
    Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ fmt; force_no_backtrace ] =>
        ltac:(M.monadic
          (let fmt := M.alloc (| fmt |) in
          let force_no_backtrace := M.alloc (| force_no_backtrace |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Some (Ty.tuple []),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.use (M.alloc (| Value.Bool false |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::intrinsics::abort", [], [] |),
                            []
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ pi : Ty.path "core::panic::panic_info::PanicInfo" :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::panic::panic_info::PanicInfo",
                  M.get_associated_function (|
                    Ty.path "core::panic::panic_info::PanicInfo",
                    "new",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, fmt |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "core::panic::location::Location" ],
                          M.get_associated_function (|
                            Ty.path "core::panic::location::Location",
                            "caller",
                            [],
                            []
                          |),
                          []
                        |)
                      |)
                    |);
                    Value.Bool false;
                    M.read (| force_no_backtrace |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "never",
                M.get_function (|
                  "core::panicking::panic_nounwind_fmt::runtime::panic_impl",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.borrow (| Pointer.Kind.Ref, pi |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_runtime :
      M.IsFunction.C "core::panicking::panic_nounwind_fmt::runtime" runtime.
    Admitted.
    Global Typeclasses Opaque runtime.
    
    (*
            const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                // Don't warn if one of the arguments is unused.
                $(let _ = $arg;)*
    
                $compiletime
            }
    *)
    Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ fmt; force_no_backtrace ] =>
        ltac:(M.monadic
          (let fmt := M.alloc (| fmt |) in
          let force_no_backtrace := M.alloc (| force_no_backtrace |) in
          M.read (|
            M.match_operator (|
              None,
              fmt,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      None,
                      force_no_backtrace,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [ M.read (| fmt |) ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_compiletime :
      M.IsFunction.C "core::panicking::panic_nounwind_fmt::compiletime" compiletime.
    Admitted.
    Global Typeclasses Opaque compiletime.
  End panic_nounwind_fmt.
End panicking.

Module slice.
  Module memchr.
    Module memchr_aligned.
      (*
              fn runtime($($arg: $ty),* ) $( -> $ret )? {
                  $runtime
              }
      *)
      Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x; text ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            let text := M.alloc (| text |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ len : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                      |)
                    |) in
                  let~ ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                      |)
                    |) in
                  let~ offset : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                          "align_offset",
                          [],
                          []
                        |),
                        [
                          M.read (| ptr |);
                          M.read (|
                            get_constant (| "core::slice::memchr::USIZE_BYTES", Ty.path "usize" |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| offset |); Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  offset,
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_trait_method (|
                                      "core::cmp::Ord",
                                      Ty.path "usize",
                                      [],
                                      [],
                                      "min",
                                      [],
                                      []
                                    |),
                                    [ M.read (| offset |); M.read (| len |) ]
                                  |)
                                |)
                              |) in
                            let~ slice :
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                              M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::ops::range::RangeTo")
                                            []
                                            [ Ty.path "usize" ]
                                        ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| text |) |)
                                        |);
                                        Value.StructRecord
                                          "core::ops::range::RangeTo"
                                          [ ("end_", M.read (| offset |)) ]
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.get_function (|
                                            "core::slice::memchr::memchr_naive",
                                            [],
                                            []
                                          |),
                                          [
                                            M.read (| x |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| slice |) |)
                                            |)
                                          ]
                                        |)
                                      |) in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let index := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| index |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ repeated_x : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (| Ty.path "usize", "repeat_u8", [], [] |),
                        [ M.read (| x |) ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.le,
                                        [
                                          M.read (| offset |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.sub,
                                            [
                                              M.read (| len |);
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.mul,
                                                [
                                                  Value.Integer IntegerKind.Usize 2;
                                                  M.read (|
                                                    get_constant (|
                                                      "core::slice::memchr::USIZE_BYTES",
                                                      Ty.path "usize"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  let~ u : Ty.path "usize" :=
                                    M.copy (|
                                      M.deref (|
                                        M.cast
                                          (Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ])
                                          (M.call_closure (|
                                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| ptr |); M.read (| offset |) ]
                                          |))
                                      |)
                                    |) in
                                  let~ v : Ty.path "usize" :=
                                    M.copy (|
                                      M.deref (|
                                        M.cast
                                          (Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ])
                                          (M.call_closure (|
                                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (| ptr |);
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.add,
                                                [
                                                  M.read (| offset |);
                                                  M.read (|
                                                    get_constant (|
                                                      "core::slice::memchr::USIZE_BYTES",
                                                      Ty.path "usize"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |))
                                      |)
                                    |) in
                                  let~ zu : Ty.path "bool" :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_function (|
                                          "core::slice::memchr::contains_zero_byte",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.bit_xor,
                                            [ M.read (| u |); M.read (| repeated_x |) ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  let~ zv : Ty.path "bool" :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_function (|
                                          "core::slice::memchr::contains_zero_byte",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.bit_xor,
                                            [ M.read (| v |); M.read (| repeated_x |) ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                LogicalOp.or (|
                                                  M.read (| zu |),
                                                  ltac:(M.monadic (M.read (| zv |)))
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (| M.read (| M.break (||) |) |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    let β := offset in
                                    M.write (|
                                      β,
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [
                                          M.read (| β |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.mul,
                                            [
                                              M.read (|
                                                get_constant (|
                                                  "core::slice::memchr::USIZE_BYTES",
                                                  Ty.path "usize"
                                                |)
                                              |);
                                              Value.Integer IntegerKind.Usize 2
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let~ slice :
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        M.get_function (|
                          "core::slice::raw::from_raw_parts",
                          [],
                          [ Ty.path "u8" ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "as_ptr",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                              |);
                              M.read (| offset |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            BinOp.Wrap.sub,
                            [
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |) ]
                              |);
                              M.read (| offset |)
                            ]
                          |)
                        ]
                      |)
                    |) in
                  M.match_operator (|
                    Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                M.get_function (| "core::slice::memchr::memchr_naive", [], [] |),
                                [
                                  M.read (| x |);
                                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |)
                                ]
                              |)
                            |) in
                          let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let i := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| offset |); M.read (| i |) ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_runtime :
        M.IsFunction.C "core::slice::memchr::memchr_aligned::runtime" runtime.
      Admitted.
      Global Typeclasses Opaque runtime.
      
      (*
              const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                  // Don't warn if one of the arguments is unused.
                  $(let _ = $arg;)*
      
                  $compiletime
              }
      *)
      Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ x; text ] =>
          ltac:(M.monadic
            (let x := M.alloc (| x |) in
            let text := M.alloc (| text |) in
            M.read (|
              M.match_operator (|
                None,
                x,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        None,
                        text,
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_function (| "core::slice::memchr::memchr_naive", [], [] |),
                                  [
                                    M.read (| x |);
                                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| text |) |) |)
                                  ]
                                |)
                              |)))
                        ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_compiletime :
        M.IsFunction.C "core::slice::memchr::memchr_aligned::compiletime" compiletime.
      Admitted.
      Global Typeclasses Opaque compiletime.
    End memchr_aligned.
  End memchr.
  
  Module ascii.
    Module is_ascii.
      (*
              fn runtime($($arg: $ty),* ) $( -> $ret )? {
                  $runtime
              }
      *)
      Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ len : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                      |)
                    |) in
                  let~ align_offset : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                          "align_offset",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                              "as_ptr",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                          |);
                          M.read (|
                            get_constant (|
                              "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                              Ty.path "usize"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.or (|
                                    LogicalOp.or (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.read (| len |);
                                          M.read (|
                                            get_constant (|
                                              "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                              Ty.path "usize"
                                            |)
                                          |)
                                        ]
                                      |),
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [ M.read (| len |); M.read (| align_offset |) ]
                                        |)))
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.read (|
                                            get_constant (|
                                              "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                              Ty.path "usize"
                                            |)
                                          |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_function (|
                                              "core::mem::align_of",
                                              [],
                                              [ Ty.path "usize" ]
                                            |),
                                            []
                                          |)
                                        ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_function (|
                                        "core::slice::ascii::is_ascii_simple",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| s |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ offset_to_aligned : Ty.path "usize" :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.path "usize"),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| align_offset |); Value.Integer IntegerKind.Usize 0
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              get_constant (|
                                "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                Ty.path "usize"
                              |)));
                          fun γ => ltac:(M.monadic align_offset)
                        ]
                      |)
                    |) in
                  let~ start : Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                      |)
                    |) in
                  let~ first_word : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ],
                          "read_unaligned",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ])
                            (M.read (| start |))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_function (|
                                      "core::slice::ascii::contains_nonascii",
                                      [],
                                      []
                                    |),
                                    [ M.read (| first_word |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Bool false |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.le,
                                                [ M.read (| offset_to_aligned |); M.read (| len |) ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (| "core::panicking::panic", [], [] |),
                                            [
                                              mk_str (|
                                                "assertion failed: offset_to_aligned <= len"
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ word_ptr : Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ] :=
                    M.alloc (|
                      M.cast
                        (Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ])
                        (M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                            "add",
                            [],
                            []
                          |),
                          [ M.read (| start |); M.read (| offset_to_aligned |) ]
                        |))
                    |) in
                  let~ byte_pos : Ty.path "usize" := M.copy (| offset_to_aligned |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "*const")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  "is_aligned_to",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (| word_ptr |);
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_function (|
                                                      "core::mem::align_of",
                                                      [],
                                                      [ Ty.path "usize" ]
                                                    |),
                                                    []
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (| "core::panicking::panic", [], [] |),
                                            [
                                              mk_str (|
                                                "assertion failed: word_ptr.is_aligned_to(mem::align_of::<usize>())"
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.read (| byte_pos |);
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.sub,
                                            [
                                              M.read (| len |);
                                              M.read (|
                                                get_constant (|
                                                  "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                                  Ty.path "usize"
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Some (Ty.tuple []),
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              BinOp.le,
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  BinOp.Wrap.add,
                                                                  [
                                                                    M.read (| byte_pos |);
                                                                    M.read (|
                                                                      get_constant (|
                                                                        "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                                                        Ty.path "usize"
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |);
                                                                M.read (| len |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.call_closure (|
                                                          Ty.path "never",
                                                          M.get_function (|
                                                            "core::panicking::panic",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            mk_str (|
                                                              "assertion failed: byte_pos + USIZE_SIZE <= len"
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := M.use (M.alloc (| Value.Bool true |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Some (Ty.tuple []),
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              BinOp.eq,
                                                              [
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "*const")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "*const")
                                                                      []
                                                                      [ Ty.path "usize" ],
                                                                    "cast",
                                                                    [],
                                                                    [ Ty.path "u8" ]
                                                                  |),
                                                                  [ M.read (| word_ptr |) ]
                                                                |);
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "*const")
                                                                    []
                                                                    [ Ty.path "u8" ],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path "*const")
                                                                      []
                                                                      [ Ty.path "u8" ],
                                                                    "wrapping_add",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.read (| start |);
                                                                    M.read (| byte_pos |)
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (|
                                                        M.call_closure (|
                                                          Ty.path "never",
                                                          M.get_function (|
                                                            "core::panicking::panic",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            mk_str (|
                                                              "assertion failed: word_ptr.cast::<u8>() == start.wrapping_add(byte_pos)"
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ word : Ty.path "usize" :=
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ],
                                        "read",
                                        [],
                                        []
                                      |),
                                      [ M.read (| word_ptr |) ]
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Some (Ty.tuple []),
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_function (|
                                                    "core::slice::ascii::contains_nonascii",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| word |) ]
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (| M.return_ (| Value.Bool false |) |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    let β := byte_pos in
                                    M.write (|
                                      β,
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [
                                          M.read (| β |);
                                          M.read (|
                                            get_constant (|
                                              "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                              Ty.path "usize"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      word_ptr,
                                      M.call_closure (|
                                        Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ],
                                          "add",
                                          [],
                                          []
                                        |),
                                        [ M.read (| word_ptr |); Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Some (Ty.tuple []),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            UnOp.not (|
                                              LogicalOp.and (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  BinOp.le,
                                                  [ M.read (| byte_pos |); M.read (| len |) ]
                                                |),
                                                ltac:(M.monadic
                                                  (M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.le,
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        BinOp.Wrap.sub,
                                                        [ M.read (| len |); M.read (| byte_pos |) ]
                                                      |);
                                                      M.read (|
                                                        get_constant (|
                                                          "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                                          Ty.path "usize"
                                                        |)
                                                      |)
                                                    ]
                                                  |)))
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (| "core::panicking::panic", [], [] |),
                                            [
                                              mk_str (|
                                                "assertion failed: byte_pos <= len && len - byte_pos <= USIZE_SIZE"
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ last_word : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ],
                          "read_unaligned",
                          [],
                          []
                        |),
                        [
                          M.cast
                            (Ty.apply (Ty.path "*const") [] [ Ty.path "usize" ])
                            (M.call_closure (|
                              Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                                "add",
                                [],
                                []
                              |),
                              [
                                M.read (| start |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.sub,
                                  [
                                    M.read (| len |);
                                    M.read (|
                                      get_constant (|
                                        "core::slice::ascii::is_ascii::runtime::USIZE_SIZE",
                                        Ty.path "usize"
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    UnOp.not (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_function (| "core::slice::ascii::contains_nonascii", [], [] |),
                        [ M.read (| last_word |) ]
                      |)
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_runtime :
        M.IsFunction.C "core::slice::ascii::is_ascii::runtime" runtime.
      Admitted.
      Global Typeclasses Opaque runtime.
      
      (*
              const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                  // Don't warn if one of the arguments is unused.
                  $(let _ = $arg;)*
      
                  $compiletime
              }
      *)
      Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ s ] =>
          ltac:(M.monadic
            (let s := M.alloc (| s |) in
            M.read (|
              M.match_operator (|
                None,
                s,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_function (| "core::slice::ascii::is_ascii_simple", [], [] |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_compiletime :
        M.IsFunction.C "core::slice::ascii::is_ascii::compiletime" compiletime.
      Admitted.
      Global Typeclasses Opaque compiletime.
    End is_ascii.
  End ascii.
  
  Module index.
    Module slice_start_index_len_fail.
      Module do_panic.
        (*
                fn runtime($($arg: $ty),* ) $( -> $ret )? {
                    $runtime
                }
        *)
        Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ index; len ] =>
            ltac:(M.monadic
              (let index := M.alloc (| index |) in
              let len := M.alloc (| len |) in
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "core::fmt::Arguments",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Arguments",
                      "new_v1",
                      [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2 ],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Value.Array
                                [
                                  mk_str (| "range start index " |);
                                  mk_str (| " out of range for slice of length " |)
                                ]
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Value.Array
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::rt::Argument",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::rt::Argument",
                                      "new_display",
                                      [],
                                      [ Ty.path "usize" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, index |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "core::fmt::rt::Argument",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::rt::Argument",
                                      "new_display",
                                      [],
                                      [ Ty.path "usize" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, len |) |)
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_runtime :
          M.IsFunction.C
            "core::slice::index::slice_start_index_len_fail::do_panic::runtime"
            runtime.
        Admitted.
        Global Typeclasses Opaque runtime.
        
        (*
                const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                    // Don't warn if one of the arguments is unused.
                    $(let _ = $arg;)*
        
                    $compiletime
                }
        *)
        Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ index; len ] =>
            ltac:(M.monadic
              (let index := M.alloc (| index |) in
              let len := M.alloc (| len |) in
              M.read (|
                M.match_operator (|
                  None,
                  index,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          None,
                          len,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::Arguments",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_const",
                                          [ Value.Integer IntegerKind.Usize 1 ],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Value.Array
                                                    [
                                                      mk_str (|
                                                        "slice start index is out of range for slice"
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_compiletime :
          M.IsFunction.C
            "core::slice::index::slice_start_index_len_fail::do_panic::compiletime"
            compiletime.
        Admitted.
        Global Typeclasses Opaque compiletime.
      End do_panic.
    End slice_start_index_len_fail.
    
    Module slice_end_index_len_fail.
      Module do_panic.
        (*
                fn runtime($($arg: $ty),* ) $( -> $ret )? {
                    $runtime
                }
        *)
        Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ index; len ] =>
            ltac:(M.monadic
              (let index := M.alloc (| index |) in
              let len := M.alloc (| len |) in
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "core::fmt::Arguments",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Arguments",
                      "new_v1",
                      [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2 ],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Value.Array
                                [
                                  mk_str (| "range end index " |);
                                  mk_str (| " out of range for slice of length " |)
                                ]
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Value.Array
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::rt::Argument",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::rt::Argument",
                                      "new_display",
                                      [],
                                      [ Ty.path "usize" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, index |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "core::fmt::rt::Argument",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::rt::Argument",
                                      "new_display",
                                      [],
                                      [ Ty.path "usize" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, len |) |)
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_runtime :
          M.IsFunction.C "core::slice::index::slice_end_index_len_fail::do_panic::runtime" runtime.
        Admitted.
        Global Typeclasses Opaque runtime.
        
        (*
                const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                    // Don't warn if one of the arguments is unused.
                    $(let _ = $arg;)*
        
                    $compiletime
                }
        *)
        Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ index; len ] =>
            ltac:(M.monadic
              (let index := M.alloc (| index |) in
              let len := M.alloc (| len |) in
              M.read (|
                M.match_operator (|
                  None,
                  index,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          None,
                          len,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::Arguments",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_const",
                                          [ Value.Integer IntegerKind.Usize 1 ],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Value.Array
                                                    [
                                                      mk_str (|
                                                        "slice end index is out of range for slice"
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_compiletime :
          M.IsFunction.C
            "core::slice::index::slice_end_index_len_fail::do_panic::compiletime"
            compiletime.
        Admitted.
        Global Typeclasses Opaque compiletime.
      End do_panic.
    End slice_end_index_len_fail.
    
    Module slice_index_order_fail.
      Module do_panic.
        (*
                fn runtime($($arg: $ty),* ) $( -> $ret )? {
                    $runtime
                }
        *)
        Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ index; end_ ] =>
            ltac:(M.monadic
              (let index := M.alloc (| index |) in
              let end_ := M.alloc (| end_ |) in
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "core::fmt::Arguments",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Arguments",
                      "new_v1",
                      [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2 ],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Value.Array
                                [
                                  mk_str (| "slice index starts at " |);
                                  mk_str (| " but ends at " |)
                                ]
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Value.Array
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::rt::Argument",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::rt::Argument",
                                      "new_display",
                                      [],
                                      [ Ty.path "usize" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, index |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "core::fmt::rt::Argument",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::rt::Argument",
                                      "new_display",
                                      [],
                                      [ Ty.path "usize" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, end_ |) |)
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_runtime :
          M.IsFunction.C "core::slice::index::slice_index_order_fail::do_panic::runtime" runtime.
        Admitted.
        Global Typeclasses Opaque runtime.
        
        (*
                const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                    // Don't warn if one of the arguments is unused.
                    $(let _ = $arg;)*
        
                    $compiletime
                }
        *)
        Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ index; end_ ] =>
            ltac:(M.monadic
              (let index := M.alloc (| index |) in
              let end_ := M.alloc (| end_ |) in
              M.read (|
                M.match_operator (|
                  None,
                  index,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          None,
                          end_,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::Arguments",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_const",
                                          [ Value.Integer IntegerKind.Usize 1 ],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Value.Array
                                                    [
                                                      mk_str (|
                                                        "slice index start is larger than end"
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance Instance_IsFunction_compiletime :
          M.IsFunction.C
            "core::slice::index::slice_index_order_fail::do_panic::compiletime"
            compiletime.
        Admitted.
        Global Typeclasses Opaque compiletime.
      End do_panic.
    End slice_index_order_fail.
  End index.
End slice.

Module str.
  Module validations.
    Module run_utf8_validation.
      (*
              fn runtime($($arg: $ty),* ) $( -> $ret )? {
                  $runtime
              }
      *)
      Definition runtime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                "align_offset",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                    "as_ptr",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
                |);
                M.read (|
                  get_constant (|
                    "core::str::validations::run_utf8_validation::USIZE_BYTES",
                    Ty.path "usize"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_runtime :
        M.IsFunction.C "core::str::validations::run_utf8_validation::runtime" runtime.
      Admitted.
      Global Typeclasses Opaque runtime.
      
      (*
              const fn compiletime($($arg: $ty),* ) $( -> $ret )? {
                  // Don't warn if one of the arguments is unused.
                  $(let _ = $arg;)*
      
                  $compiletime
              }
      *)
      Definition compiletime (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ v ] =>
          ltac:(M.monadic
            (let v := M.alloc (| v |) in
            M.read (|
              M.match_operator (|
                None,
                v,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance Instance_IsFunction_compiletime :
        M.IsFunction.C "core::str::validations::run_utf8_validation::compiletime" compiletime.
      Admitted.
      Global Typeclasses Opaque compiletime.
    End run_utf8_validation.
  End validations.
End str.
