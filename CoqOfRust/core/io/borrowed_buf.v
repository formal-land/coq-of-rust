(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module io.
  Module borrowed_buf.
    (* StructRecord
      {
        name := "BorrowedBuf";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("buf",
              Ty.apply
                (Ty.path "&mut")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ]
                    ]
                ]);
            ("filled", Ty.path "usize");
            ("init", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_for_core_io_borrowed_buf_BorrowedBuf.
      Definition Self : Ty.t := Ty.path "core::io::borrowed_buf::BorrowedBuf".
      
      (*
          fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
              f.debug_struct("BorrowedBuf")
                  .field("init", &self.init)
                  .field("filled", &self.filled)
                  .field("capacity", &self.capacity())
                  .finish()
          }
      *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::builders::DebugStruct",
                "finish",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugStruct" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::builders::DebugStruct",
                        "field",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "core::fmt::builders::DebugStruct" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::builders::DebugStruct",
                                "field",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [ Ty.path "core::fmt::builders::DebugStruct" ],
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::builders::DebugStruct",
                                        "field",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "core::fmt::builders::DebugStruct",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::Formatter",
                                                "debug_struct",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (| M.read (| f |) |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (| Value.String "BorrowedBuf" |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| Value.String "init" |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::io::borrowed_buf::BorrowedBuf",
                                                "init"
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| Value.String "filled" |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::io::borrowed_buf::BorrowedBuf",
                                        "filled"
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| Value.String "capacity" |) |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.path "core::io::borrowed_buf::BorrowedBuf",
                                    "capacity",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_io_borrowed_buf_BorrowedBuf.
    
    Module Impl_core_convert_From_ref_mut_slice_u8_for_core_io_borrowed_buf_BorrowedBuf.
      Definition Self : Ty.t := Ty.path "core::io::borrowed_buf::BorrowedBuf".
      
      (*
          fn from(slice: &'data mut [u8]) -> BorrowedBuf<'data> {
              let len = slice.len();
      
              BorrowedBuf {
                  // SAFETY: initialized data never becoming uninitialized is an invariant of BorrowedBuf
                  buf: unsafe { (slice as *mut [u8]).as_uninit_slice_mut().unwrap() },
                  filled: 0,
                  init: len,
              }
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ slice ] =>
          ltac:(M.monadic
            (let slice := M.alloc (| slice |) in
            M.read (|
              let~ len : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |) ]
                  |)
                |) in
              M.alloc (|
                Value.StructRecord
                  "core::io::borrowed_buf::BorrowedBuf"
                  [
                    ("buf",
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "u8" ]
                                      ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                []
                                                [ Ty.path "u8" ]
                                            ]
                                        ]
                                    ],
                                  "unwrap",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ Ty.path "u8" ]
                                              ]
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "*mut")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      "as_uninit_slice_mut",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.use
                                          (M.alloc (|
                                            M.borrow (|
                                              Pointer.Kind.MutPointer,
                                              M.deref (| M.read (| slice |) |)
                                            |)
                                          |))
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)
                        |)
                      |));
                    ("filled", Value.Integer IntegerKind.Usize 0);
                    ("init", M.read (| len |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_slice_u8_for_core_io_borrowed_buf_BorrowedBuf.
    
    Module Impl_core_convert_From_ref_mut_slice_core_mem_maybe_uninit_MaybeUninit_u8_for_core_io_borrowed_buf_BorrowedBuf.
      Definition Self : Ty.t := Ty.path "core::io::borrowed_buf::BorrowedBuf".
      
      (*
          fn from(buf: &'data mut [MaybeUninit<u8>]) -> BorrowedBuf<'data> {
              BorrowedBuf { buf, filled: 0, init: 0 }
          }
      *)
      Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ buf ] =>
          ltac:(M.monadic
            (let buf := M.alloc (| buf |) in
            Value.StructRecord
              "core::io::borrowed_buf::BorrowedBuf"
              [
                ("buf", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |));
                ("filled", Value.Integer IntegerKind.Usize 0);
                ("init", Value.Integer IntegerKind.Usize 0)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "&mut")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ] ]
              ]
          ]
          Self
          (* Instance *) [ ("from", InstanceField.Method from) ].
    End Impl_core_convert_From_ref_mut_slice_core_mem_maybe_uninit_MaybeUninit_u8_for_core_io_borrowed_buf_BorrowedBuf.
    
    Module Impl_core_io_borrowed_buf_BorrowedBuf.
      Definition Self : Ty.t := Ty.path "core::io::borrowed_buf::BorrowedBuf".
      
      (*
          pub fn capacity(&self) -> usize {
              self.buf.len()
          }
      *)
      Definition capacity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ] ],
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::io::borrowed_buf::BorrowedBuf",
                        "buf"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_capacity : M.IsAssociatedFunction Self "capacity" capacity.
      Smpl Add apply AssociatedFunction_capacity : is_associated.
      
      (*
          pub fn len(&self) -> usize {
              self.filled
          }
      *)
      Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "core::io::borrowed_buf::BorrowedBuf",
                "filled"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_len : M.IsAssociatedFunction Self "len" len.
      Smpl Add apply AssociatedFunction_len : is_associated.
      
      (*
          pub fn init_len(&self) -> usize {
              self.init
          }
      *)
      Definition init_len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "core::io::borrowed_buf::BorrowedBuf",
                "init"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_init_len : M.IsAssociatedFunction Self "init_len" init_len.
      Smpl Add apply AssociatedFunction_init_len : is_associated.
      
      (*
          pub fn filled(&self) -> &[u8] {
              // SAFETY: We only slice the filled part of the buffer, which is always valid
              unsafe {
                  let buf = self.buf.get_unchecked(..self.filled);
                  MaybeUninit::slice_assume_init_ref(buf)
              }
          }
      *)
      Definition filled (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ buf :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ],
                      "get_unchecked",
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::RangeTo") [] [ Ty.path "usize" ] ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::io::borrowed_buf::BorrowedBuf",
                              "buf"
                            |)
                          |)
                        |)
                      |);
                      Value.StructRecord
                        "core::ops::range::RangeTo"
                        [
                          ("end_",
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::io::borrowed_buf::BorrowedBuf",
                                "filled"
                              |)
                            |))
                        ]
                    ]
                  |)
                |) in
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          []
                          [ Ty.path "u8" ],
                        "slice_assume_init_ref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_filled : M.IsAssociatedFunction Self "filled" filled.
      Smpl Add apply AssociatedFunction_filled : is_associated.
      
      (*
          pub fn filled_mut(&mut self) -> &mut [u8] {
              // SAFETY: We only slice the filled part of the buffer, which is always valid
              unsafe {
                  let buf = self.buf.get_unchecked_mut(..self.filled);
                  MaybeUninit::slice_assume_init_mut(buf)
              }
          }
      *)
      Definition filled_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      let~ buf :
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ]
                            ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ],
                              "get_unchecked_mut",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "core::ops::range::RangeTo")
                                  []
                                  [ Ty.path "usize" ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::io::borrowed_buf::BorrowedBuf",
                                      "buf"
                                    |)
                                  |)
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::RangeTo"
                                [
                                  ("end_",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::io::borrowed_buf::BorrowedBuf",
                                        "filled"
                                      |)
                                    |))
                                ]
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ],
                                "slice_assume_init_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |) ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_filled_mut : M.IsAssociatedFunction Self "filled_mut" filled_mut.
      Smpl Add apply AssociatedFunction_filled_mut : is_associated.
      
      (*
          pub fn unfilled<'this>(&'this mut self) -> BorrowedCursor<'this> {
              BorrowedCursor {
                  start: self.filled,
                  // SAFETY: we never assign into `BorrowedCursor::buf`, so treating its
                  // lifetime covariantly is safe.
                  buf: unsafe {
                      mem::transmute::<&'this mut BorrowedBuf<'data>, &'this mut BorrowedBuf<'this>>(self)
                  },
              }
          }
      *)
      Definition unfilled (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::io::borrowed_buf::BorrowedCursor"
              [
                ("start",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::io::borrowed_buf::BorrowedBuf",
                      "filled"
                    |)
                  |));
                ("buf",
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "core::io::borrowed_buf::BorrowedBuf" ],
                            M.get_function (|
                              "core::intrinsics::transmute",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "core::io::borrowed_buf::BorrowedBuf" ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "core::io::borrowed_buf::BorrowedBuf" ]
                              ]
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_unfilled : M.IsAssociatedFunction Self "unfilled" unfilled.
      Smpl Add apply AssociatedFunction_unfilled : is_associated.
      
      (*
          pub fn clear(&mut self) -> &mut Self {
              self.filled = 0;
              self
          }
      *)
      Definition clear (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::io::borrowed_buf::BorrowedBuf",
                          "filled"
                        |),
                        Value.Integer IntegerKind.Usize 0
                      |)
                    |) in
                  M.alloc (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_clear : M.IsAssociatedFunction Self "clear" clear.
      Smpl Add apply AssociatedFunction_clear : is_associated.
      
      (*
          pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {
              self.init = cmp::max(self.init, n);
              self
          }
      *)
      Definition set_init (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::io::borrowed_buf::BorrowedBuf",
                          "init"
                        |),
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_function (| "core::cmp::max", [], [ Ty.path "usize" ] |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::io::borrowed_buf::BorrowedBuf",
                                "init"
                              |)
                            |);
                            M.read (| n |)
                          ]
                        |)
                      |)
                    |) in
                  M.alloc (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_set_init : M.IsAssociatedFunction Self "set_init" set_init.
      Smpl Add apply AssociatedFunction_set_init : is_associated.
    End Impl_core_io_borrowed_buf_BorrowedBuf.
    
    (* StructRecord
      {
        name := "BorrowedCursor";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("buf", Ty.apply (Ty.path "&mut") [] [ Ty.path "core::io::borrowed_buf::BorrowedBuf" ]);
            ("start", Ty.path "usize")
          ];
      } *)
    
    Module Impl_core_fmt_Debug_for_core_io_borrowed_buf_BorrowedCursor.
      Definition Self : Ty.t := Ty.path "core::io::borrowed_buf::BorrowedCursor".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "BorrowedCursor" |) |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "buf" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::io::borrowed_buf::BorrowedCursor",
                        "buf"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "start" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::io::borrowed_buf::BorrowedCursor",
                            "start"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_io_borrowed_buf_BorrowedCursor.
    
    Module Impl_core_io_borrowed_buf_BorrowedCursor.
      Definition Self : Ty.t := Ty.path "core::io::borrowed_buf::BorrowedCursor".
      
      (*
          pub fn reborrow<'this>(&'this mut self) -> BorrowedCursor<'this> {
              BorrowedCursor {
                  // SAFETY: we never assign into `BorrowedCursor::buf`, so treating its
                  // lifetime covariantly is safe.
                  buf: unsafe {
                      mem::transmute::<&'this mut BorrowedBuf<'a>, &'this mut BorrowedBuf<'this>>(
                          self.buf,
                      )
                  },
                  start: self.start,
              }
          }
      *)
      Definition reborrow (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.StructRecord
              "core::io::borrowed_buf::BorrowedCursor"
              [
                ("buf",
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [ Ty.path "core::io::borrowed_buf::BorrowedBuf" ],
                            M.get_function (|
                              "core::intrinsics::transmute",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "core::io::borrowed_buf::BorrowedBuf" ];
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.path "core::io::borrowed_buf::BorrowedBuf" ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::io::borrowed_buf::BorrowedCursor",
                                      "buf"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |));
                ("start",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::io::borrowed_buf::BorrowedCursor",
                      "start"
                    |)
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_reborrow : M.IsAssociatedFunction Self "reborrow" reborrow.
      Smpl Add apply AssociatedFunction_reborrow : is_associated.
      
      (*
          pub fn capacity(&self) -> usize {
              self.buf.capacity() - self.buf.filled
          }
      *)
      Definition capacity (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              M.call_closure (|
                Ty.path "usize",
                M.get_associated_function (|
                  Ty.path "core::io::borrowed_buf::BorrowedBuf",
                  "capacity",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::io::borrowed_buf::BorrowedCursor",
                          "buf"
                        |)
                      |)
                    |)
                  |)
                ]
              |),
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::io::borrowed_buf::BorrowedCursor",
                        "buf"
                      |)
                    |)
                  |),
                  "core::io::borrowed_buf::BorrowedBuf",
                  "filled"
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_capacity : M.IsAssociatedFunction Self "capacity" capacity.
      Smpl Add apply AssociatedFunction_capacity : is_associated.
      
      (*
          pub fn written(&self) -> usize {
              self.buf.filled - self.start
          }
      *)
      Definition written (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            BinOp.Wrap.sub (|
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::io::borrowed_buf::BorrowedCursor",
                        "buf"
                      |)
                    |)
                  |),
                  "core::io::borrowed_buf::BorrowedBuf",
                  "filled"
                |)
              |),
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "core::io::borrowed_buf::BorrowedCursor",
                  "start"
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_written : M.IsAssociatedFunction Self "written" written.
      Smpl Add apply AssociatedFunction_written : is_associated.
      
      (*
          pub fn init_ref(&self) -> &[u8] {
              // SAFETY: We only slice the initialized part of the buffer, which is always valid
              unsafe {
                  let buf = self.buf.buf.get_unchecked(self.buf.filled..self.buf.init);
                  MaybeUninit::slice_assume_init_ref(buf)
              }
          }
      *)
      Definition init_ref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ buf :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ],
                      "get_unchecked",
                      [],
                      [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ] ]
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::io::borrowed_buf::BorrowedCursor",
                                    "buf"
                                  |)
                                |)
                              |),
                              "core::io::borrowed_buf::BorrowedBuf",
                              "buf"
                            |)
                          |)
                        |)
                      |);
                      Value.StructRecord
                        "core::ops::range::Range"
                        [
                          ("start",
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::io::borrowed_buf::BorrowedCursor",
                                      "buf"
                                    |)
                                  |)
                                |),
                                "core::io::borrowed_buf::BorrowedBuf",
                                "filled"
                              |)
                            |));
                          ("end_",
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::io::borrowed_buf::BorrowedCursor",
                                      "buf"
                                    |)
                                  |)
                                |),
                                "core::io::borrowed_buf::BorrowedBuf",
                                "init"
                              |)
                            |))
                        ]
                    ]
                  |)
                |) in
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          []
                          [ Ty.path "u8" ],
                        "slice_assume_init_ref",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_init_ref : M.IsAssociatedFunction Self "init_ref" init_ref.
      Smpl Add apply AssociatedFunction_init_ref : is_associated.
      
      (*
          pub fn init_mut(&mut self) -> &mut [u8] {
              // SAFETY: We only slice the initialized part of the buffer, which is always valid
              unsafe {
                  let buf = self.buf.buf.get_unchecked_mut(self.buf.filled..self.buf.init);
                  MaybeUninit::slice_assume_init_mut(buf)
              }
          }
      *)
      Definition init_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.read (|
                      let~ buf :
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ]
                            ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ],
                              "get_unchecked_mut",
                              [],
                              [ Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]
                              ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::io::borrowed_buf::BorrowedCursor",
                                            "buf"
                                          |)
                                        |)
                                      |),
                                      "core::io::borrowed_buf::BorrowedBuf",
                                      "buf"
                                    |)
                                  |)
                                |)
                              |);
                              Value.StructRecord
                                "core::ops::range::Range"
                                [
                                  ("start",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::io::borrowed_buf::BorrowedCursor",
                                              "buf"
                                            |)
                                          |)
                                        |),
                                        "core::io::borrowed_buf::BorrowedBuf",
                                        "filled"
                                      |)
                                    |));
                                  ("end_",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::io::borrowed_buf::BorrowedCursor",
                                              "buf"
                                            |)
                                          |)
                                        |),
                                        "core::io::borrowed_buf::BorrowedBuf",
                                        "init"
                                      |)
                                    |))
                                ]
                            ]
                          |)
                        |) in
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ],
                                "slice_assume_init_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| buf |) |) |) ]
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_init_mut : M.IsAssociatedFunction Self "init_mut" init_mut.
      Smpl Add apply AssociatedFunction_init_mut : is_associated.
      
      (*
          pub fn uninit_mut(&mut self) -> &mut [MaybeUninit<u8>] {
              // SAFETY: always in bounds
              unsafe { self.buf.buf.get_unchecked_mut(self.buf.init..) }
          }
      *)
      Definition uninit_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ],
                            "get_unchecked_mut",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::ops::range::RangeFrom")
                                []
                                [ Ty.path "usize" ]
                            ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::io::borrowed_buf::BorrowedCursor",
                                          "buf"
                                        |)
                                      |)
                                    |),
                                    "core::io::borrowed_buf::BorrowedBuf",
                                    "buf"
                                  |)
                                |)
                              |)
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeFrom"
                              [
                                ("start",
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::io::borrowed_buf::BorrowedCursor",
                                            "buf"
                                          |)
                                        |)
                                      |),
                                      "core::io::borrowed_buf::BorrowedBuf",
                                      "init"
                                    |)
                                  |))
                              ]
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_uninit_mut : M.IsAssociatedFunction Self "uninit_mut" uninit_mut.
      Smpl Add apply AssociatedFunction_uninit_mut : is_associated.
      
      (*
          pub unsafe fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {
              // SAFETY: always in bounds
              unsafe { self.buf.buf.get_unchecked_mut(self.buf.filled..) }
          }
      *)
      Definition as_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ],
                            "get_unchecked_mut",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::ops::range::RangeFrom")
                                []
                                [ Ty.path "usize" ]
                            ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (|
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::io::borrowed_buf::BorrowedCursor",
                                          "buf"
                                        |)
                                      |)
                                    |),
                                    "core::io::borrowed_buf::BorrowedBuf",
                                    "buf"
                                  |)
                                |)
                              |)
                            |);
                            Value.StructRecord
                              "core::ops::range::RangeFrom"
                              [
                                ("start",
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::io::borrowed_buf::BorrowedCursor",
                                            "buf"
                                          |)
                                        |)
                                      |),
                                      "core::io::borrowed_buf::BorrowedBuf",
                                      "filled"
                                    |)
                                  |))
                              ]
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_as_mut : M.IsAssociatedFunction Self "as_mut" as_mut.
      Smpl Add apply AssociatedFunction_as_mut : is_associated.
      
      (*
          pub fn advance(&mut self, n: usize) -> &mut Self {
              let filled = self.buf.filled.strict_add(n);
              assert!(filled <= self.buf.init);
      
              self.buf.filled = filled;
              self
          }
      *)
      Definition advance (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ filled : Ty.path "usize" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (| Ty.path "usize", "strict_add", [], [] |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::io::borrowed_buf::BorrowedCursor",
                                    "buf"
                                  |)
                                |)
                              |),
                              "core::io::borrowed_buf::BorrowedBuf",
                              "filled"
                            |)
                          |);
                          M.read (| n |)
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    BinOp.le (|
                                      M.read (| filled |),
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (|
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::io::borrowed_buf::BorrowedCursor",
                                                "buf"
                                              |)
                                            |)
                                          |),
                                          "core::io::borrowed_buf::BorrowedBuf",
                                          "init"
                                        |)
                                      |)
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic", [], [] |),
                                  [
                                    M.read (|
                                      Value.String "assertion failed: filled <= self.buf.init"
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::io::borrowed_buf::BorrowedCursor",
                                "buf"
                              |)
                            |)
                          |),
                          "core::io::borrowed_buf::BorrowedBuf",
                          "filled"
                        |),
                        M.read (| filled |)
                      |)
                    |) in
                  M.alloc (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_advance : M.IsAssociatedFunction Self "advance" advance.
      Smpl Add apply AssociatedFunction_advance : is_associated.
      
      (*
          pub unsafe fn advance_unchecked(&mut self, n: usize) -> &mut Self {
              self.buf.filled += n;
              self.buf.init = cmp::max(self.buf.init, self.buf.filled);
              self
          }
      *)
      Definition advance_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::io::borrowed_buf::BorrowedCursor",
                                "buf"
                              |)
                            |)
                          |),
                          "core::io::borrowed_buf::BorrowedBuf",
                          "filled"
                        |) in
                      M.write (| β, BinOp.Wrap.add (| M.read (| β |), M.read (| n |) |) |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::io::borrowed_buf::BorrowedCursor",
                                "buf"
                              |)
                            |)
                          |),
                          "core::io::borrowed_buf::BorrowedBuf",
                          "init"
                        |),
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_function (| "core::cmp::max", [], [ Ty.path "usize" ] |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::io::borrowed_buf::BorrowedCursor",
                                      "buf"
                                    |)
                                  |)
                                |),
                                "core::io::borrowed_buf::BorrowedBuf",
                                "init"
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::io::borrowed_buf::BorrowedCursor",
                                      "buf"
                                    |)
                                  |)
                                |),
                                "core::io::borrowed_buf::BorrowedBuf",
                                "filled"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  M.alloc (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_advance_unchecked :
        M.IsAssociatedFunction Self "advance_unchecked" advance_unchecked.
      Smpl Add apply AssociatedFunction_advance_unchecked : is_associated.
      
      (*
          pub fn ensure_init(&mut self) -> &mut Self {
              let uninit = self.uninit_mut();
              // SAFETY: 0 is a valid value for MaybeUninit<u8> and the length matches the allocation
              // since it is comes from a slice reference.
              unsafe {
                  ptr::write_bytes(uninit.as_mut_ptr(), 0, uninit.len());
              }
              self.buf.init = self.buf.capacity();
      
              self
          }
      *)
      Definition ensure_init (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ uninit :
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&mut")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "u8" ]
                              ]
                          ],
                        M.get_associated_function (|
                          Ty.path "core::io::borrowed_buf::BorrowedCursor",
                          "uninit_mut",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_function (|
                            "core::intrinsics::write_bytes",
                            [],
                            [
                              Ty.apply
                                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                []
                                [ Ty.path "u8" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "*mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ],
                                "as_mut_ptr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.read (| uninit |) |)
                                |)
                              ]
                            |);
                            Value.Integer IntegerKind.U8 0;
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| uninit |) |) |) ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::io::borrowed_buf::BorrowedCursor",
                                "buf"
                              |)
                            |)
                          |),
                          "core::io::borrowed_buf::BorrowedBuf",
                          "init"
                        |),
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.path "core::io::borrowed_buf::BorrowedBuf",
                            "capacity",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::io::borrowed_buf::BorrowedCursor",
                                    "buf"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  M.alloc (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_ensure_init : M.IsAssociatedFunction Self "ensure_init" ensure_init.
      Smpl Add apply AssociatedFunction_ensure_init : is_associated.
      
      (*
          pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {
              self.buf.init = cmp::max(self.buf.init, self.buf.filled + n);
              self
          }
      *)
      Definition set_init (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (|
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::io::borrowed_buf::BorrowedCursor",
                                "buf"
                              |)
                            |)
                          |),
                          "core::io::borrowed_buf::BorrowedBuf",
                          "init"
                        |),
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_function (| "core::cmp::max", [], [ Ty.path "usize" ] |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "core::io::borrowed_buf::BorrowedCursor",
                                      "buf"
                                    |)
                                  |)
                                |),
                                "core::io::borrowed_buf::BorrowedBuf",
                                "init"
                              |)
                            |);
                            BinOp.Wrap.add (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (|
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::io::borrowed_buf::BorrowedCursor",
                                        "buf"
                                      |)
                                    |)
                                  |),
                                  "core::io::borrowed_buf::BorrowedBuf",
                                  "filled"
                                |)
                              |),
                              M.read (| n |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  M.alloc (| M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_set_init : M.IsAssociatedFunction Self "set_init" set_init.
      Smpl Add apply AssociatedFunction_set_init : is_associated.
      
      (*
          pub fn append(&mut self, buf: &[u8]) {
              assert!(self.capacity() >= buf.len());
      
              // SAFETY: we do not de-initialize any of the elements of the slice
              unsafe {
                  MaybeUninit::copy_from_slice(&mut self.as_mut()[..buf.len()], buf);
              }
      
              // SAFETY: We just added the entire contents of buf to the filled section.
              unsafe {
                  self.set_init(buf.len());
              }
              self.buf.filled += buf.len();
          }
      *)
      Definition append (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; buf ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let buf := M.alloc (| buf |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              UnOp.not (|
                                BinOp.ge (|
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.path "core::io::borrowed_buf::BorrowedCursor",
                                      "capacity",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |),
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| buf |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic", [], [] |),
                              [
                                M.read (|
                                  Value.String "assertion failed: self.capacity() >= buf.len()"
                                |)
                              ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                let~ _ :
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          []
                          [ Ty.path "u8" ],
                        "copy_from_slice",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "u8" ]
                                        ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::index::IndexMut",
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "u8" ]
                                      ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeTo")
                                        []
                                        [ Ty.path "usize" ]
                                    ],
                                    "index_mut",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ Ty.path "u8" ]
                                                ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.path "core::io::borrowed_buf::BorrowedCursor",
                                            "as_mut",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    Value.StructRecord
                                      "core::ops::range::RangeTo"
                                      [
                                        ("end_",
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                              "len",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| buf |) |)
                                              |)
                                            ]
                                          |))
                                      ]
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |) in
              let~ _ : Ty.tuple [] :=
                let~ _ :
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.path "core::io::borrowed_buf::BorrowedCursor" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.path "core::io::borrowed_buf::BorrowedCursor" ],
                      M.get_associated_function (|
                        Ty.path "core::io::borrowed_buf::BorrowedCursor",
                        "set_init",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::io::borrowed_buf::BorrowedCursor",
                            "buf"
                          |)
                        |)
                      |),
                      "core::io::borrowed_buf::BorrowedBuf",
                      "filled"
                    |) in
                  M.write (|
                    β,
                    BinOp.Wrap.add (|
                      M.read (| β |),
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "len",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| buf |) |) |) ]
                      |)
                    |)
                  |)
                |) in
              M.alloc (| Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_append : M.IsAssociatedFunction Self "append" append.
      Smpl Add apply AssociatedFunction_append : is_associated.
    End Impl_core_io_borrowed_buf_BorrowedCursor.
  End borrowed_buf.
End io.
