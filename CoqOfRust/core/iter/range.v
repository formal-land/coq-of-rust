(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module iter.
  Module range.
    Module Impl_core_iter_traits_marker_TrustedStep_for_core_ascii_ascii_char_AsciiChar.
      Definition Self : Ty.t := Ty.path "core::ascii::ascii_char::AsciiChar".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_core_ascii_ascii_char_AsciiChar.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_char.
      Definition Self : Ty.t := Ty.path "char".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_char.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i8.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i16.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i32.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i64.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i128.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_isize.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u8.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u16.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u32.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u64.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u128.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_usize.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv4Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv4Addr".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv4Addr.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv6Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv6Addr".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv6Addr.
    
    (* Trait *)
    Module Step.
      Definition forward (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Self,
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                "expect",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Self,
                    [],
                    [],
                    "forward_checked",
                    [],
                    []
                  |),
                  [ M.read (| start |); M.read (| count |) ]
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "overflow in `Step::forward`" |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_forward : M.IsProvidedMethod "core::iter::range::Step" "forward" forward.
      Definition forward_unchecked
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Self,
              M.get_trait_method (| "core::iter::range::Step", Self, [], [], "forward", [], [] |),
              [ M.read (| start |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_forward_unchecked :
        M.IsProvidedMethod "core::iter::range::Step" "forward_unchecked" forward_unchecked.
      Definition backward (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Self,
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                "expect",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Self ],
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Self,
                    [],
                    [],
                    "backward_checked",
                    [],
                    []
                  |),
                  [ M.read (| start |); M.read (| count |) ]
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "overflow in `Step::backward`" |) |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_backward :
        M.IsProvidedMethod "core::iter::range::Step" "backward" backward.
      Definition backward_unchecked
          (Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Self,
              M.get_trait_method (| "core::iter::range::Step", Self, [], [], "backward", [], [] |),
              [ M.read (| start |); M.read (| count |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_backward_unchecked :
        M.IsProvidedMethod "core::iter::range::Step" "backward_unchecked" backward_unchecked.
    End Step.
    
    Module Impl_core_iter_range_Step_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u8" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u8",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u8",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |)
                                |);
                                Value.Integer IntegerKind.U8 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u8") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u8" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u8",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u8",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u8", "MIN", Ty.path "u8" |)
                                |);
                                Value.Integer IntegerKind.U8 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u8",
                  M.get_associated_function (| Ty.path "u8", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u8") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_associated_function (| Ty.path "u8", "unchecked_add", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u8") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u8",
              M.get_associated_function (| Ty.path "u8", "unchecked_sub", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u8") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              let steps = ( *end - *start) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "u8",
                              BinOp.Wrap.sub,
                              [
                                M.read (| M.deref (| M.read (| end_ |) |) |);
                                M.read (| M.deref (| M.read (| start |) |) |)
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                          M.get_associated_function (| Ty.path "u8", "checked_add", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                          M.get_associated_function (| Ty.path "u8", "checked_sub", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u8.
    
    Module Impl_core_iter_range_Step_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i8" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i8",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i8",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i8", "MAX", Ty.path "i8" |)
                                |);
                                Value.Integer IntegerKind.I8 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i8") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i8" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i8",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i8",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i8", "MIN", Ty.path "i8" |)
                                |);
                                Value.Integer IntegerKind.I8 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i8",
                  M.get_associated_function (| Ty.path "i8", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i8") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ],
                  M.get_associated_function (| Ty.path "i8", "checked_add_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u8") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i8",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ],
                  M.get_associated_function (| Ty.path "i8", "checked_sub_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u8") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              let steps = ( *end as isize).wrapping_sub( *start as isize) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "isize",
                              M.get_associated_function (|
                                Ty.path "isize",
                                "wrapping_sub",
                                [],
                                []
                              |),
                              [
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| end_ |) |) |));
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| start |) |) |))
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i8" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i8",
                            M.get_associated_function (| Ty.path "i8", "wrapping_add", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i8") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.ge,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u8"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i8" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i8",
                            M.get_associated_function (| Ty.path "i8", "wrapping_sub", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i8") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i8" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i8.
    
    Module Impl_core_iter_range_Step_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u16" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u16" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u16",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u16",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u16", "MAX", Ty.path "u16" |)
                                |);
                                Value.Integer IntegerKind.U16 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u16") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u16" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u16" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u16",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u16",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u16", "MIN", Ty.path "u16" |)
                                |);
                                Value.Integer IntegerKind.U16 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u16",
                  M.get_associated_function (| Ty.path "u16", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u16") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_associated_function (| Ty.path "u16", "unchecked_add", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u16") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u16",
              M.get_associated_function (| Ty.path "u16", "unchecked_sub", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u16") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              let steps = ( *end - *start) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "u16",
                              BinOp.Wrap.sub,
                              [
                                M.read (| M.deref (| M.read (| end_ |) |) |);
                                M.read (| M.deref (| M.read (| start |) |) |)
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u16" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u16" ],
                          M.get_associated_function (| Ty.path "u16", "checked_add", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u16" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u16" ],
                          M.get_associated_function (| Ty.path "u16", "checked_sub", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u16.
    
    Module Impl_core_iter_range_Step_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i16" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i16",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i16",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i16", "MAX", Ty.path "i16" |)
                                |);
                                Value.Integer IntegerKind.I16 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i16") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i16" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i16",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i16",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i16", "MIN", Ty.path "i16" |)
                                |);
                                Value.Integer IntegerKind.I16 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i16",
                  M.get_associated_function (| Ty.path "i16", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i16") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ],
                  M.get_associated_function (| Ty.path "i16", "checked_add_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u16") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i16",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ],
                  M.get_associated_function (| Ty.path "i16", "checked_sub_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u16") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              let steps = ( *end as isize).wrapping_sub( *start as isize) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "isize",
                              M.get_associated_function (|
                                Ty.path "isize",
                                "wrapping_sub",
                                [],
                                []
                              |),
                              [
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| end_ |) |) |));
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| start |) |) |))
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i16" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i16",
                            M.get_associated_function (| Ty.path "i16", "wrapping_add", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i16") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.ge,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u16"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i16" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i16",
                            M.get_associated_function (| Ty.path "i16", "wrapping_sub", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i16") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i16" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i16.
    
    Module Impl_core_iter_range_Step_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u32" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u32",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u32",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u32", "MAX", Ty.path "u32" |)
                                |);
                                Value.Integer IntegerKind.U32 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u32") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u32" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u32",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u32",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u32", "MIN", Ty.path "u32" |)
                                |);
                                Value.Integer IntegerKind.U32 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u32",
                  M.get_associated_function (| Ty.path "u32", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u32") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u32", "unchecked_add", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u32") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u32",
              M.get_associated_function (| Ty.path "u32", "unchecked_sub", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u32") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              let steps = ( *end - *start) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "u32",
                              BinOp.Wrap.sub,
                              [
                                M.read (| M.deref (| M.read (| end_ |) |) |);
                                M.read (| M.deref (| M.read (| start |) |) |)
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                          M.get_associated_function (| Ty.path "u32", "checked_add", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                          M.get_associated_function (| Ty.path "u32", "checked_sub", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u32.
    
    Module Impl_core_iter_range_Step_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i32" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i32",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i32",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i32", "MAX", Ty.path "i32" |)
                                |);
                                Value.Integer IntegerKind.I32 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i32") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i32" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i32",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i32",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i32", "MIN", Ty.path "i32" |)
                                |);
                                Value.Integer IntegerKind.I32 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i32",
                  M.get_associated_function (| Ty.path "i32", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i32") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                  M.get_associated_function (| Ty.path "i32", "checked_add_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u32") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i32",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ],
                  M.get_associated_function (| Ty.path "i32", "checked_sub_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u32") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              let steps = ( *end as isize).wrapping_sub( *start as isize) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "isize",
                              M.get_associated_function (|
                                Ty.path "isize",
                                "wrapping_sub",
                                [],
                                []
                              |),
                              [
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| end_ |) |) |));
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| start |) |) |))
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i32" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i32",
                            M.get_associated_function (| Ty.path "i32", "wrapping_add", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i32") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.ge,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u32"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i32" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i32",
                            M.get_associated_function (| Ty.path "i32", "wrapping_sub", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i32") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i32" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i32.
    
    Module Impl_core_iter_range_Step_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u64" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u64",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |)
                                |);
                                Value.Integer IntegerKind.U64 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u64") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u64" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u64",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "u64", "MIN", Ty.path "u64" |)
                                |);
                                Value.Integer IntegerKind.U64 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u64") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_associated_function (| Ty.path "u64", "unchecked_add", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u64") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u64",
              M.get_associated_function (| Ty.path "u64", "unchecked_sub", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u64") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              let steps = ( *end - *start) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.sub,
                              [
                                M.read (| M.deref (| M.read (| end_ |) |) |);
                                M.read (| M.deref (| M.read (| start |) |) |)
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                          M.get_associated_function (| Ty.path "u64", "checked_add", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u64" ],
                          M.get_associated_function (| Ty.path "u64", "checked_sub", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u64.
    
    Module Impl_core_iter_range_Step_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i64" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i64",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i64",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i64", "MAX", Ty.path "i64" |)
                                |);
                                Value.Integer IntegerKind.I64 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i64") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i64" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i64",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i64",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (| Ty.path "i64", "MIN", Ty.path "i64" |)
                                |);
                                Value.Integer IntegerKind.I64 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i64",
                  M.get_associated_function (| Ty.path "i64", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i64") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ],
                  M.get_associated_function (| Ty.path "i64", "checked_add_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u64") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i64",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ],
                  M.get_associated_function (| Ty.path "i64", "checked_sub_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u64") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              let steps = ( *end as isize).wrapping_sub( *start as isize) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "isize",
                              M.get_associated_function (|
                                Ty.path "isize",
                                "wrapping_sub",
                                [],
                                []
                              |),
                              [
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| end_ |) |) |));
                                M.cast
                                  (Ty.path "isize")
                                  (M.read (| M.deref (| M.read (| start |) |) |))
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i64" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i64",
                            M.get_associated_function (| Ty.path "i64", "wrapping_add", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i64") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.ge,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "u64"; Ty.path "core::num::error::TryFromIntError" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "i64" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "i64",
                            M.get_associated_function (| Ty.path "i64", "wrapping_sub", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "i64") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i64" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i64.
    
    Module Impl_core_iter_range_Step_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "usize",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "usize",
                                    "MAX",
                                    Ty.path "usize"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.read (| M.use n |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "usize",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "usize",
                                    "MIN",
                                    Ty.path "usize"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (| Ty.path "usize", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.read (| M.use n |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (| Ty.path "usize", "unchecked_add", [], [] |),
              [ M.read (| start |); M.read (| M.use n |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (| Ty.path "usize", "unchecked_sub", [], [] |),
              [ M.read (| start |); M.read (| M.use n |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              let steps = ( *end - *start) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.copy (|
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.sub,
                                [
                                  M.read (| M.deref (| M.read (| end_ |) |) |);
                                  M.read (| M.deref (| M.read (| start |) |) |)
                                ]
                              |)
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "usize"; Ty.path "core::convert::Infallible" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          M.get_associated_function (| Ty.path "usize", "checked_add", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "usize"; Ty.path "core::convert::Infallible" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          M.get_associated_function (| Ty.path "usize", "checked_sub", [], [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_usize.
    
    Module Impl_core_iter_range_Step_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "isize" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "isize",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "isize",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "isize",
                                    "MAX",
                                    Ty.path "isize"
                                  |)
                                |);
                                Value.Integer IntegerKind.Isize 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "isize") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "isize" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "isize",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "isize",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "isize",
                                    "MIN",
                                    Ty.path "isize"
                                  |)
                                |);
                                Value.Integer IntegerKind.Isize 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_associated_function (| Ty.path "isize", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "isize") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ],
                  M.get_associated_function (| Ty.path "isize", "checked_add_unsigned", [], [] |),
                  [ M.read (| start |); M.read (| M.use n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "isize",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ],
                  M.get_associated_function (| Ty.path "isize", "checked_sub_unsigned", [], [] |),
                  [ M.read (| start |); M.read (| M.use n |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              let steps = ( *end as isize).wrapping_sub( *start as isize) as usize;
                              (steps, Some(steps))
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ steps : Ty.path "usize" :=
                        M.alloc (|
                          M.cast
                            (Ty.path "usize")
                            (M.call_closure (|
                              Ty.path "isize",
                              M.get_associated_function (|
                                Ty.path "isize",
                                "wrapping_sub",
                                [],
                                []
                              |),
                              [
                                M.read (| M.use (M.deref (| M.read (| end_ |) |)) |);
                                M.read (| M.use (M.deref (| M.read (| start |) |)) |)
                              ]
                            |))
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.read (| steps |);
                            Value.StructTuple "core::option::Option::Some" [ M.read (| steps |) ]
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "usize"; Ty.path "core::convert::Infallible" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "isize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "isize",
                            M.get_associated_function (| Ty.path "isize", "wrapping_add", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "isize") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.ge,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ]),
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "usize"; Ty.path "core::convert::Infallible" ],
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [],
                      [ Ty.path "usize" ],
                      "try_from",
                      [],
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let~ wrapped : Ty.path "isize" :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "isize",
                            M.get_associated_function (| Ty.path "isize", "wrapping_sub", [], [] |),
                            [ M.read (| start |); M.cast (Ty.path "isize") (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "isize" ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| wrapped |); M.read (| start |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_isize.
    
    Module Impl_core_iter_range_Step_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u128" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u128",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u128",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "u128",
                                    "MAX",
                                    Ty.path "u128"
                                  |)
                                |);
                                Value.Integer IntegerKind.U128 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "u128" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "u128",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "u128",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "u128",
                                    "MIN",
                                    Ty.path "u128"
                                  |)
                                |);
                                Value.Integer IntegerKind.U128 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (| Ty.path "u128", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u128",
              M.get_associated_function (| Ty.path "u128", "unchecked_add", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "u128",
              M.get_associated_function (| Ty.path "u128", "unchecked_sub", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              if let Ok(steps) = usize::try_from( *end - *start) {
                                  (steps, Some(steps))
                              } else {
                                  (usize::MAX, None)
                              }
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Some
                          (Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                            ]),
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    M.get_trait_method (|
                                      "core::convert::TryFrom",
                                      Ty.path "usize",
                                      [],
                                      [ Ty.path "u128" ],
                                      "try_from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u128",
                                        BinOp.Wrap.sub,
                                        [
                                          M.read (| M.deref (| M.read (| end_ |) |) |);
                                          M.read (| M.deref (| M.read (| start |) |) |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |) in
                              let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Ok",
                                  0
                                |) in
                              let steps := M.copy (| γ0_0 |) in
                              M.alloc (|
                                Value.Tuple
                                  [
                                    M.read (| steps |);
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [ M.read (| steps |) ]
                                  ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.Tuple
                                  [
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.path "usize",
                                        "MAX",
                                        Ty.path "usize"
                                      |)
                                    |);
                                    Value.StructTuple "core::option::Option::None" []
                                  ]
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_add(n as Self)
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
              M.get_associated_function (| Ty.path "u128", "checked_add", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_sub(n as Self)
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
              M.get_associated_function (| Ty.path "u128", "checked_sub", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u128.
    
    Module Impl_core_iter_range_Step_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i128" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i128",
                                          [],
                                          [],
                                          "forward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i128",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "i128",
                                    "MAX",
                                    Ty.path "i128"
                                  |)
                                |);
                                Value.Integer IntegerKind.I128 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "wrapping_add", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i128") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
                                  "is_none",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "i128" ],
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          Ty.path "i128",
                                          [],
                                          [],
                                          "backward_checked",
                                          [],
                                          []
                                        |),
                                        [ M.read (| start |); M.read (| n |) ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          None,
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "i128",
                              BinOp.Wrap.sub,
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "i128",
                                    "MIN",
                                    Ty.path "i128"
                                  |)
                                |);
                                Value.Integer IntegerKind.I128 1
                              ]
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "i128",
                  M.get_associated_function (| Ty.path "i128", "wrapping_sub", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "i128") (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.checked_add_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i128",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
                  M.get_associated_function (| Ty.path "i128", "checked_add_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.checked_sub_unsigned(n as $unsigned).unwrap_unchecked() }
              }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.path "i128",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
                "unwrap_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
                  M.get_associated_function (| Ty.path "i128", "checked_sub_unsigned", [], [] |),
                  [ M.read (| start |); M.cast (Ty.path "u128") (M.read (| n |)) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {
                          if *start <= *end {
                              match end.checked_sub( *start) {
                                  Some(result) => {
                                      if let Ok(steps) = usize::try_from(result) {
                                          (steps, Some(steps))
                                      } else {
                                          (usize::MAX, None)
                                      }
                                  }
                                  // If the difference is too big for e.g. i128,
                                  // it's also gonna be too big for usize with fewer bits.
                                  None => (usize::MAX, None),
                              }
                          } else {
                              (0, None)
                          }
                      }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              BinOp.le,
                              [
                                M.read (| M.deref (| M.read (| start |) |) |);
                                M.read (| M.deref (| M.read (| end_ |) |) |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        Some
                          (Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                            ]),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
                            M.get_associated_function (| Ty.path "i128", "checked_sub", [], [] |),
                            [
                              M.read (| M.deref (| M.read (| end_ |) |) |);
                              M.read (| M.deref (| M.read (| start |) |) |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let result := M.copy (| γ0_0 |) in
                              M.match_operator (|
                                Some
                                  (Ty.tuple
                                    [
                                      Ty.path "usize";
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ]
                                    ]),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "usize";
                                                Ty.path "core::num::error::TryFromIntError"
                                              ],
                                            M.get_trait_method (|
                                              "core::convert::TryFrom",
                                              Ty.path "usize",
                                              [],
                                              [ Ty.path "i128" ],
                                              "try_from",
                                              [],
                                              []
                                            |),
                                            [ M.read (| result |) ]
                                          |)
                                        |) in
                                      let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::result::Result::Ok",
                                          0
                                        |) in
                                      let steps := M.copy (| γ0_0 |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            M.read (| steps |);
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| steps |) ]
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        Value.Tuple
                                          [
                                            M.read (|
                                              get_associated_constant (|
                                                Ty.path "usize",
                                                "MAX",
                                                Ty.path "usize"
                                              |)
                                            |);
                                            Value.StructTuple "core::option::Option::None" []
                                          ]
                                      |)))
                                ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                              M.alloc (|
                                Value.Tuple
                                  [
                                    M.read (|
                                      get_associated_constant (|
                                        Ty.path "usize",
                                        "MAX",
                                        Ty.path "usize"
                                      |)
                                    |);
                                    Value.StructTuple "core::option::Option::None" []
                                  ]
                              |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple "core::option::Option::None" []
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_add(n as Self)
                      }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
              M.get_associated_function (| Ty.path "i128", "checked_add", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "i128") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_sub(n as Self)
                      }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "i128" ],
              M.get_associated_function (| Ty.path "i128", "checked_sub", [], [] |),
              [ M.read (| start |); M.cast (Ty.path "i128") (M.read (| n |)) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i128.
    
    Module Impl_core_iter_range_Step_for_char.
      Definition Self : Ty.t := Ty.path "char".
      
      (*
          fn steps_between(&start: &char, &end: &char) -> (usize, Option<usize>) {
              let start = start as u32;
              let end = end as u32;
              if start <= end {
                  let count = end - start;
                  if start < 0xD800 && 0xE000 <= end {
                      if let Ok(steps) = usize::try_from(count - 0x800) {
                          (steps, Some(steps))
                      } else {
                          (usize::MAX, None)
                      }
                  } else {
                      if let Ok(steps) = usize::try_from(count) {
                          (steps, Some(steps))
                      } else {
                          (usize::MAX, None)
                      }
                  }
              } else {
                  (0, None)
              }
          }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      None,
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.read (|
                              let~ start : Ty.path "u32" :=
                                M.alloc (| M.cast (Ty.path "u32") (M.read (| start |)) |) in
                              let~ end_ : Ty.path "u32" :=
                                M.alloc (| M.cast (Ty.path "u32") (M.read (| end_ |)) |) in
                              M.match_operator (|
                                Some
                                  (Ty.tuple
                                    [
                                      Ty.path "usize";
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ]
                                    ]),
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.le,
                                              [ M.read (| start |); M.read (| end_ |) ]
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let~ count : Ty.path "u32" :=
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.path "u32",
                                            BinOp.Wrap.sub,
                                            [ M.read (| end_ |); M.read (| start |) ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        Some
                                          (Ty.tuple
                                            [
                                              Ty.path "usize";
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "usize" ]
                                            ]),
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    LogicalOp.and (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        BinOp.lt,
                                                        [
                                                          M.read (| start |);
                                                          Value.Integer IntegerKind.U32 55296
                                                        ]
                                                      |),
                                                      ltac:(M.monadic
                                                        (M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.le,
                                                          [
                                                            Value.Integer IntegerKind.U32 57344;
                                                            M.read (| end_ |)
                                                          ]
                                                        |)))
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.match_operator (|
                                                Some
                                                  (Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "usize" ]
                                                    ]),
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [
                                                                Ty.path "usize";
                                                                Ty.path
                                                                  "core::num::error::TryFromIntError"
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::convert::TryFrom",
                                                              Ty.path "usize",
                                                              [],
                                                              [ Ty.path "u32" ],
                                                              "try_from",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                Ty.path "u32",
                                                                BinOp.Wrap.sub,
                                                                [
                                                                  M.read (| count |);
                                                                  Value.Integer IntegerKind.U32 2048
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::result::Result::Ok",
                                                          0
                                                        |) in
                                                      let steps := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        Value.Tuple
                                                          [
                                                            M.read (| steps |);
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              [ M.read (| steps |) ]
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        Value.Tuple
                                                          [
                                                            M.read (|
                                                              get_associated_constant (|
                                                                Ty.path "usize",
                                                                "MAX",
                                                                Ty.path "usize"
                                                              |)
                                                            |);
                                                            Value.StructTuple
                                                              "core::option::Option::None"
                                                              []
                                                          ]
                                                      |)))
                                                ]
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                Some
                                                  (Ty.tuple
                                                    [
                                                      Ty.path "usize";
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "usize" ]
                                                    ]),
                                                M.alloc (| Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [
                                                                Ty.path "usize";
                                                                Ty.path
                                                                  "core::num::error::TryFromIntError"
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::convert::TryFrom",
                                                              Ty.path "usize",
                                                              [],
                                                              [ Ty.path "u32" ],
                                                              "try_from",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.read (| count |) ]
                                                          |)
                                                        |) in
                                                      let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::result::Result::Ok",
                                                          0
                                                        |) in
                                                      let steps := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        Value.Tuple
                                                          [
                                                            M.read (| steps |);
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              [ M.read (| steps |) ]
                                                          ]
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.alloc (|
                                                        Value.Tuple
                                                          [
                                                            M.read (|
                                                              get_associated_constant (|
                                                                Ty.path "usize",
                                                                "MAX",
                                                                Ty.path "usize"
                                                              |)
                                                            |);
                                                            Value.StructTuple
                                                              "core::option::Option::None"
                                                              []
                                                          ]
                                                      |)))
                                                ]
                                              |)))
                                        ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.Integer IntegerKind.Usize 0;
                                            Value.StructTuple "core::option::Option::None" []
                                          ]
                                      |)))
                                ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn forward_checked(start: char, count: usize) -> Option<char> {
              let start = start as u32;
              let mut res = Step::forward_checked(start, count)?;
              if start < 0xD800 && 0xD800 <= res {
                  res = Step::forward_checked(res, 0x800)?;
              }
              if res <= char::MAX as u32 {
                  // SAFETY: res is a valid unicode scalar
                  // (below 0x110000 and not in 0xD800..0xE000)
                  Some(unsafe { char::from_u32_unchecked(res) })
              } else {
                  None
              }
          }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ start : Ty.path "u32" :=
                    M.alloc (| M.cast (Ty.path "u32") (M.read (| start |)) |) in
                  let~ res : Ty.path "u32" :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.path "u32"),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ];
                                Ty.path "u32"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u32",
                                  [],
                                  [],
                                  "forward_checked",
                                  [],
                                  []
                                |),
                                [ M.read (| start |); M.read (| count |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "char" ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "char" ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.lt,
                                      [ M.read (| start |); Value.Integer IntegerKind.U32 55296 ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.le,
                                        [ Value.Integer IntegerKind.U32 55296; M.read (| res |) ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  res,
                                  M.read (|
                                    M.match_operator (|
                                      Some (Ty.path "u32"),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "core::convert::Infallible" ];
                                              Ty.path "u32"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "u32" ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "u32" ],
                                              M.get_trait_method (|
                                                "core::iter::range::Step",
                                                Ty.path "u32",
                                                [],
                                                [],
                                                "forward_checked",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (| res |);
                                                Value.Integer IntegerKind.Usize 2048
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "char" ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "char" ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "core::convert::Infallible" ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    Some (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "char" ]),
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.le,
                                  [
                                    M.read (| res |);
                                    M.cast
                                      (Ty.path "u32")
                                      (M.read (|
                                        get_associated_constant (|
                                          Ty.path "char",
                                          "MAX",
                                          Ty.path "char"
                                        |)
                                      |))
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  Ty.path "char",
                                  M.get_associated_function (|
                                    Ty.path "char",
                                    "from_u32_unchecked",
                                    [],
                                    []
                                  |),
                                  [ M.read (| res |) ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                    ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn backward_checked(start: char, count: usize) -> Option<char> {
              let start = start as u32;
              let mut res = Step::backward_checked(start, count)?;
              if start >= 0xE000 && 0xE000 > res {
                  res = Step::backward_checked(res, 0x800)?;
              }
              // SAFETY: res is a valid unicode scalar
              // (below 0x110000 and not in 0xD800..0xE000)
              Some(unsafe { char::from_u32_unchecked(res) })
          }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ start : Ty.path "u32" :=
                    M.alloc (| M.cast (Ty.path "u32") (M.read (| start |)) |) in
                  let~ res : Ty.path "u32" :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.path "u32"),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ];
                                Ty.path "u32"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u32",
                                  [],
                                  [],
                                  "backward_checked",
                                  [],
                                  []
                                |),
                                [ M.read (| start |); M.read (| count |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "char" ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "char" ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.ge,
                                      [ M.read (| start |); Value.Integer IntegerKind.U32 57344 ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.gt,
                                        [ Value.Integer IntegerKind.U32 57344; M.read (| res |) ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  res,
                                  M.read (|
                                    M.match_operator (|
                                      Some (Ty.path "u32"),
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "core::convert::Infallible" ];
                                              Ty.path "u32"
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "u32" ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "u32" ],
                                              M.get_trait_method (|
                                                "core::iter::range::Step",
                                                Ty.path "u32",
                                                [],
                                                [],
                                                "backward_checked",
                                                [],
                                                []
                                              |),
                                              [
                                                M.read (| res |);
                                                Value.Integer IntegerKind.Usize 2048
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ Ty.path "char" ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ Ty.path "char" ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "core::convert::Infallible" ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.call_closure (|
                          Ty.path "char",
                          M.get_associated_function (|
                            Ty.path "char",
                            "from_u32_unchecked",
                            [],
                            []
                          |),
                          [ M.read (| res |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn forward_unchecked(start: char, count: usize) -> char {
              let start = start as u32;
              // SAFETY: the caller must guarantee that this doesn't overflow
              // the range of values for a char.
              let mut res = unsafe { Step::forward_unchecked(start, count) };
              if start < 0xD800 && 0xD800 <= res {
                  // SAFETY: the caller must guarantee that this doesn't overflow
                  // the range of values for a char.
                  res = unsafe { Step::forward_unchecked(res, 0x800) };
              }
              // SAFETY: because of the previous contract, this is guaranteed
              // by the caller to be a valid char.
              unsafe { char::from_u32_unchecked(res) }
          }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let~ start : Ty.path "u32" :=
                M.alloc (| M.cast (Ty.path "u32") (M.read (| start |)) |) in
              let~ res : Ty.path "u32" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "u32",
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u32",
                      [],
                      [],
                      "forward_unchecked",
                      [],
                      []
                    |),
                    [ M.read (| start |); M.read (| count |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.lt,
                                  [ M.read (| start |); Value.Integer IntegerKind.U32 55296 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.le,
                                    [ Value.Integer IntegerKind.U32 55296; M.read (| res |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              res,
                              M.call_closure (|
                                Ty.path "u32",
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u32",
                                  [],
                                  [],
                                  "forward_unchecked",
                                  [],
                                  []
                                |),
                                [ M.read (| res |); Value.Integer IntegerKind.Usize 2048 ]
                              |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "char",
                  M.get_associated_function (| Ty.path "char", "from_u32_unchecked", [], [] |),
                  [ M.read (| res |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn backward_unchecked(start: char, count: usize) -> char {
              let start = start as u32;
              // SAFETY: the caller must guarantee that this doesn't overflow
              // the range of values for a char.
              let mut res = unsafe { Step::backward_unchecked(start, count) };
              if start >= 0xE000 && 0xE000 > res {
                  // SAFETY: the caller must guarantee that this doesn't overflow
                  // the range of values for a char.
                  res = unsafe { Step::backward_unchecked(res, 0x800) };
              }
              // SAFETY: because of the previous contract, this is guaranteed
              // by the caller to be a valid char.
              unsafe { char::from_u32_unchecked(res) }
          }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let~ start : Ty.path "u32" :=
                M.alloc (| M.cast (Ty.path "u32") (M.read (| start |)) |) in
              let~ res : Ty.path "u32" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "u32",
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u32",
                      [],
                      [],
                      "backward_unchecked",
                      [],
                      []
                    |),
                    [ M.read (| start |); M.read (| count |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Some (Ty.tuple []),
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ge,
                                  [ M.read (| start |); Value.Integer IntegerKind.U32 57344 ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ Value.Integer IntegerKind.U32 57344; M.read (| res |) ]
                                  |)))
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.alloc (|
                            M.write (|
                              res,
                              M.call_closure (|
                                Ty.path "u32",
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u32",
                                  [],
                                  [],
                                  "backward_unchecked",
                                  [],
                                  []
                                |),
                                [ M.read (| res |); Value.Integer IntegerKind.Usize 2048 ]
                              |)
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "char",
                  M.get_associated_function (| Ty.path "char", "from_u32_unchecked", [], [] |),
                  [ M.read (| res |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_char.
    
    Module Impl_core_iter_range_Step_for_core_ascii_ascii_char_AsciiChar.
      Definition Self : Ty.t := Ty.path "core::ascii::ascii_char::AsciiChar".
      
      (*
          fn steps_between(&start: &AsciiChar, &end: &AsciiChar) -> (usize, Option<usize>) {
              Step::steps_between(&start.to_u8(), &end.to_u8())
          }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      None,
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                                ],
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u8",
                                [],
                                [],
                                "steps_between",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "u8",
                                          M.get_associated_function (|
                                            Ty.path "core::ascii::ascii_char::AsciiChar",
                                            "to_u8",
                                            [],
                                            []
                                          |),
                                          [ M.read (| start |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "u8",
                                          M.get_associated_function (|
                                            Ty.path "core::ascii::ascii_char::AsciiChar",
                                            "to_u8",
                                            [],
                                            []
                                          |),
                                          [ M.read (| end_ |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn forward_checked(start: AsciiChar, count: usize) -> Option<AsciiChar> {
              let end = Step::forward_checked(start.to_u8(), count)?;
              AsciiChar::from_u8(end)
          }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ end_ : Ty.path "u8" :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.path "u8"),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ];
                                Ty.path "u8"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u8",
                                  [],
                                  [],
                                  "forward_checked",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "u8",
                                    M.get_associated_function (|
                                      Ty.path "core::ascii::ascii_char::AsciiChar",
                                      "to_u8",
                                      [],
                                      []
                                    |),
                                    [ M.read (| start |) ]
                                  |);
                                  M.read (| count |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                      M.get_associated_function (|
                        Ty.path "core::ascii::ascii_char::AsciiChar",
                        "from_u8",
                        [],
                        []
                      |),
                      [ M.read (| end_ |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn backward_checked(start: AsciiChar, count: usize) -> Option<AsciiChar> {
              let end = Step::backward_checked(start.to_u8(), count)?;
      
              // SAFETY: Values below that of a valid ASCII character are also valid ASCII
              Some(unsafe { AsciiChar::from_u8_unchecked(end) })
          }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ end_ : Ty.path "u8" :=
                    M.copy (|
                      M.match_operator (|
                        Some (Ty.path "u8"),
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "core::convert::Infallible" ];
                                Ty.path "u8"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u8" ],
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u8",
                                  [],
                                  [],
                                  "backward_checked",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "u8",
                                    M.get_associated_function (|
                                      Ty.path "core::ascii::ascii_char::AsciiChar",
                                      "to_u8",
                                      [],
                                      []
                                    |),
                                    [ M.read (| start |) ]
                                  |);
                                  M.read (| count |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          [],
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.call_closure (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          M.get_associated_function (|
                            Ty.path "core::ascii::ascii_char::AsciiChar",
                            "from_u8_unchecked",
                            [],
                            []
                          |),
                          [ M.read (| end_ |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn forward_unchecked(start: AsciiChar, count: usize) -> AsciiChar {
              // SAFETY: Caller asserts that result is a valid ASCII character,
              // and therefore it is a valid u8.
              let end = unsafe { Step::forward_unchecked(start.to_u8(), count) };
      
              // SAFETY: Caller asserts that result is a valid ASCII character.
              unsafe { AsciiChar::from_u8_unchecked(end) }
          }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let~ end_ : Ty.path "u8" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "u8",
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u8",
                      [],
                      [],
                      "forward_unchecked",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          [],
                          []
                        |),
                        [ M.read (| start |) ]
                      |);
                      M.read (| count |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::ascii::ascii_char::AsciiChar",
                  M.get_associated_function (|
                    Ty.path "core::ascii::ascii_char::AsciiChar",
                    "from_u8_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| end_ |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn backward_unchecked(start: AsciiChar, count: usize) -> AsciiChar {
              // SAFETY: Caller asserts that result is a valid ASCII character,
              // and therefore it is a valid u8.
              let end = unsafe { Step::backward_unchecked(start.to_u8(), count) };
      
              // SAFETY: Caller asserts that result is a valid ASCII character.
              unsafe { AsciiChar::from_u8_unchecked(end) }
          }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let~ end_ : Ty.path "u8" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "u8",
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u8",
                      [],
                      [],
                      "backward_unchecked",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          [],
                          []
                        |),
                        [ M.read (| start |) ]
                      |);
                      M.read (| count |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::ascii::ascii_char::AsciiChar",
                  M.get_associated_function (|
                    Ty.path "core::ascii::ascii_char::AsciiChar",
                    "from_u8_unchecked",
                    [],
                    []
                  |),
                  [ M.read (| end_ |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_core_ascii_ascii_char_AsciiChar.
    
    Module Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv4Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv4Addr".
      
      (*
          fn steps_between(&start: &Ipv4Addr, &end: &Ipv4Addr) -> (usize, Option<usize>) {
              u32::steps_between(&start.to_bits(), &end.to_bits())
          }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      None,
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                                ],
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u32",
                                [],
                                [],
                                "steps_between",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "u32",
                                          M.get_associated_function (|
                                            Ty.path "core::net::ip_addr::Ipv4Addr",
                                            "to_bits",
                                            [],
                                            []
                                          |),
                                          [ M.read (| start |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "u32",
                                          M.get_associated_function (|
                                            Ty.path "core::net::ip_addr::Ipv4Addr",
                                            "to_bits",
                                            [],
                                            []
                                          |),
                                          [ M.read (| end_ |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn forward_checked(start: Ipv4Addr, count: usize) -> Option<Ipv4Addr> {
              u32::forward_checked(start.to_bits(), count).map(Ipv4Addr::from_bits)
          }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "core::net::ip_addr::Ipv4Addr" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                "map",
                [],
                [
                  Ty.path "core::net::ip_addr::Ipv4Addr";
                  Ty.function [ Ty.path "u32" ] (Ty.path "core::net::ip_addr::Ipv4Addr")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    [],
                    "forward_checked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv4Addr",
                  "from_bits",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn backward_checked(start: Ipv4Addr, count: usize) -> Option<Ipv4Addr> {
              u32::backward_checked(start.to_bits(), count).map(Ipv4Addr::from_bits)
          }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "core::net::ip_addr::Ipv4Addr" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                "map",
                [],
                [
                  Ty.path "core::net::ip_addr::Ipv4Addr";
                  Ty.function [ Ty.path "u32" ] (Ty.path "core::net::ip_addr::Ipv4Addr")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    [],
                    "backward_checked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv4Addr",
                  "from_bits",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn forward_unchecked(start: Ipv4Addr, count: usize) -> Ipv4Addr {
              // SAFETY: Since u32 and Ipv4Addr are losslessly convertible,
              //   this is as safe as the u32 version.
              Ipv4Addr::from_bits(unsafe { u32::forward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.path "core::net::ip_addr::Ipv4Addr",
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv4Addr",
                "from_bits",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    [],
                    "forward_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn backward_unchecked(start: Ipv4Addr, count: usize) -> Ipv4Addr {
              // SAFETY: Since u32 and Ipv4Addr are losslessly convertible,
              //   this is as safe as the u32 version.
              Ipv4Addr::from_bits(unsafe { u32::backward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.path "core::net::ip_addr::Ipv4Addr",
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv4Addr",
                "from_bits",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    [],
                    "backward_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv4Addr.
    
    Module Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv6Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv6Addr".
      
      (*
          fn steps_between(&start: &Ipv6Addr, &end: &Ipv6Addr) -> (usize, Option<usize>) {
              u128::steps_between(&start.to_bits(), &end.to_bits())
          }
      *)
      Definition steps_between (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              None,
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      None,
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.call_closure (|
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                                ],
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u128",
                                [],
                                [],
                                "steps_between",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "u128",
                                          M.get_associated_function (|
                                            Ty.path "core::net::ip_addr::Ipv6Addr",
                                            "to_bits",
                                            [],
                                            []
                                          |),
                                          [ M.read (| start |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "u128",
                                          M.get_associated_function (|
                                            Ty.path "core::net::ip_addr::Ipv6Addr",
                                            "to_bits",
                                            [],
                                            []
                                          |),
                                          [ M.read (| end_ |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn forward_checked(start: Ipv6Addr, count: usize) -> Option<Ipv6Addr> {
              u128::forward_checked(start.to_bits(), count).map(Ipv6Addr::from_bits)
          }
      *)
      Definition forward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "core::net::ip_addr::Ipv6Addr" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
                "map",
                [],
                [
                  Ty.path "core::net::ip_addr::Ipv6Addr";
                  Ty.function [ Ty.path "u128" ] (Ty.path "core::net::ip_addr::Ipv6Addr")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    [],
                    "forward_checked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u128",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv6Addr",
                  "from_bits",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn backward_checked(start: Ipv6Addr, count: usize) -> Option<Ipv6Addr> {
              u128::backward_checked(start.to_bits(), count).map(Ipv6Addr::from_bits)
          }
      *)
      Definition backward_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "core::net::ip_addr::Ipv6Addr" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
                "map",
                [],
                [
                  Ty.path "core::net::ip_addr::Ipv6Addr";
                  Ty.function [ Ty.path "u128" ] (Ty.path "core::net::ip_addr::Ipv6Addr")
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u128" ],
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    [],
                    "backward_checked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u128",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv6Addr",
                  "from_bits",
                  [],
                  []
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn forward_unchecked(start: Ipv6Addr, count: usize) -> Ipv6Addr {
              // SAFETY: Since u128 and Ipv6Addr are losslessly convertible,
              //   this is as safe as the u128 version.
              Ipv6Addr::from_bits(unsafe { u128::forward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition forward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.path "core::net::ip_addr::Ipv6Addr",
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv6Addr",
                "from_bits",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    [],
                    "forward_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u128",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn backward_unchecked(start: Ipv6Addr, count: usize) -> Ipv6Addr {
              // SAFETY: Since u128 and Ipv6Addr are losslessly convertible,
              //   this is as safe as the u128 version.
              Ipv6Addr::from_bits(unsafe { u128::backward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition backward_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              Ty.path "core::net::ip_addr::Ipv6Addr",
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv6Addr",
                "from_bits",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "u128",
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    [],
                    "backward_unchecked",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u128",
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        [],
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv6Addr.
    
    (* Trait *)
    (* Empty module 'RangeIteratorImpl' *)
    
    Module Impl_core_iter_range_RangeIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          default fn spec_next(&mut self) -> Option<A> {
              if self.start < self.end {
                  let n =
                      Step::forward_checked(self.start.clone(), 1).expect("`Step` invariants not upheld");
                  Some(mem::replace(&mut self.start, n))
              } else {
                  None
              }
          }
      *)
      Definition spec_next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ A ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                A,
                                [],
                                [ A ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ n : A :=
                        M.alloc (|
                          M.call_closure (|
                            A,
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [] [ A ],
                              "expect",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  A,
                                  [],
                                  [],
                                  "forward_checked",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    A,
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      [],
                                      "clone",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::Range",
                                          "start"
                                        |)
                                      |)
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| mk_str (| "`Step` invariants not upheld" |) |)
                              |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              A,
                              M.get_function (| "core::mem::replace", [], [ A ] |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::ops::range::Range",
                                        "start"
                                      |)
                                    |)
                                  |)
                                |);
                                M.read (| n |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_nth(&mut self, n: usize) -> Option<A> {
              if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {
                  if plus_n < self.end {
                      self.start =
                          Step::forward_checked(plus_n.clone(), 1).expect("`Step` invariants not upheld");
                      return Some(plus_n);
                  }
              }
      
              self.start = self.end.clone();
              None
          }
      *)
      Definition spec_nth (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    [],
                                    "forward_checked",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::Range",
                                            "start"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let plus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              A,
                                              [],
                                              [ A ],
                                              "lt",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (| Pointer.Kind.Ref, plus_n |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "end"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "start"
                                                |),
                                                M.call_closure (|
                                                  A,
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ A ],
                                                    "expect",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ A ],
                                                      M.get_trait_method (|
                                                        "core::iter::range::Step",
                                                        A,
                                                        [],
                                                        [],
                                                        "forward_checked",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          A,
                                                          M.get_trait_method (|
                                                            "core::clone::Clone",
                                                            A,
                                                            [],
                                                            [],
                                                            "clone",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.borrow (| Pointer.Kind.Ref, plus_n |)
                                                          ]
                                                        |);
                                                        Value.Integer IntegerKind.Usize 1
                                                      ]
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        mk_str (| "`Step` invariants not upheld" |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::Range",
                          "start"
                        |),
                        M.call_closure (|
                          A,
                          M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::ops::range::Range",
                                "end"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
              let steps = Step::steps_between(&self.start, &self.end);
              let available = steps.1.unwrap_or(steps.0);
      
              let taken = available.min(n);
      
              self.start =
                  Step::forward_checked(self.start.clone(), taken).expect("`Step` invariants not upheld");
      
              NonZero::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_by
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ steps :
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                      ],
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      A,
                      [],
                      [],
                      "steps_between",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "start"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ available : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                      "unwrap_or",
                      [],
                      []
                    |),
                    [
                      M.read (| M.SubPointer.get_tuple_field (| steps, 1 |) |);
                      M.read (| M.SubPointer.get_tuple_field (| steps, 0 |) |)
                    ]
                  |)
                |) in
              let~ taken : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::cmp::Ord",
                      Ty.path "usize",
                      [],
                      [],
                      "min",
                      [],
                      []
                    |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::Range",
                      "start"
                    |),
                    M.call_closure (|
                      A,
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::option::Option") [] [ A ],
                        "expect",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ A ],
                          M.get_trait_method (|
                            "core::iter::range::Step",
                            A,
                            [],
                            [],
                            "forward_checked",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              A,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                A,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |)
                              ]
                            |);
                            M.read (| taken |)
                          ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "`Step` invariants not upheld" |) |)
                        |)
                      ]
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.tuple [];
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                    "map_or",
                    [],
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.tuple [];
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                        ];
                      Ty.function
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.tuple [];
                            Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                          ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [ M.read (| n |); M.read (| taken |) ]
                        |)
                      ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_next_back(&mut self) -> Option<A> {
              if self.start < self.end {
                  self.end =
                      Step::backward_checked(self.end.clone(), 1).expect("`Step` invariants not upheld");
                  Some(self.end.clone())
              } else {
                  None
              }
          }
      *)
      Definition spec_next_back
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ A ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                A,
                                [],
                                [ A ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "end"
                            |),
                            M.call_closure (|
                              A,
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                "expect",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    [],
                                    "backward_checked",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::Range",
                                            "end"
                                          |)
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.Usize 1
                                  ]
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| mk_str (| "`Step` invariants not upheld" |) |)
                                |)
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              A,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                A,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_nth_back(&mut self, n: usize) -> Option<A> {
              if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {
                  if minus_n > self.start {
                      self.end =
                          Step::backward_checked(minus_n, 1).expect("`Step` invariants not upheld");
                      return Some(self.end.clone());
                  }
              }
      
              self.end = self.start.clone();
              None
          }
      *)
      Definition spec_nth_back
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    [],
                                    "backward_checked",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::Range",
                                            "end"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let minus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              A,
                                              [],
                                              [ A ],
                                              "gt",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (| Pointer.Kind.Ref, minus_n |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "start"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "end"
                                                |),
                                                M.call_closure (|
                                                  A,
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      []
                                                      [ A ],
                                                    "expect",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ A ],
                                                      M.get_trait_method (|
                                                        "core::iter::range::Step",
                                                        A,
                                                        [],
                                                        [],
                                                        "backward_checked",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.read (| minus_n |);
                                                        Value.Integer IntegerKind.Usize 1
                                                      ]
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        mk_str (| "`Step` invariants not upheld" |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    [],
                                                    "clone",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::ops::range::Range",
                                                        "end"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::Range",
                          "end"
                        |),
                        M.call_closure (|
                          A,
                          M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::ops::range::Range",
                                "start"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
              let steps = Step::steps_between(&self.start, &self.end);
              let available = steps.1.unwrap_or(steps.0);
      
              let taken = available.min(n);
      
              self.end =
                  Step::backward_checked(self.end.clone(), taken).expect("`Step` invariants not upheld");
      
              NonZero::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_back_by
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ steps :
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                      ],
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      A,
                      [],
                      [],
                      "steps_between",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "start"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ available : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                      "unwrap_or",
                      [],
                      []
                    |),
                    [
                      M.read (| M.SubPointer.get_tuple_field (| steps, 1 |) |);
                      M.read (| M.SubPointer.get_tuple_field (| steps, 0 |) |)
                    ]
                  |)
                |) in
              let~ taken : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::cmp::Ord",
                      Ty.path "usize",
                      [],
                      [],
                      "min",
                      [],
                      []
                    |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::Range",
                      "end"
                    |),
                    M.call_closure (|
                      A,
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::option::Option") [] [ A ],
                        "expect",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ A ],
                          M.get_trait_method (|
                            "core::iter::range::Step",
                            A,
                            [],
                            [],
                            "backward_checked",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              A,
                              M.get_trait_method (|
                                "core::clone::Clone",
                                A,
                                [],
                                [],
                                "clone",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |);
                            M.read (| taken |)
                          ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "`Step` invariants not upheld" |) |)
                        |)
                      ]
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.tuple [];
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                    "map_or",
                    [],
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.tuple [];
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                        ];
                      Ty.function
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.tuple [];
                            Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                          ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [ M.read (| n |); M.read (| taken |) ]
                        |)
                      ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeIteratorImpl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("spec_next", InstanceField.Method (spec_next A));
            ("spec_nth", InstanceField.Method (spec_nth A));
            ("spec_advance_by", InstanceField.Method (spec_advance_by A));
            ("spec_next_back", InstanceField.Method (spec_next_back A));
            ("spec_nth_back", InstanceField.Method (spec_nth_back A));
            ("spec_advance_back_by", InstanceField.Method (spec_advance_back_by A))
          ].
    End Impl_core_iter_range_RangeIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_range_RangeIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_Range_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ T ].
      
      (*
          fn spec_next(&mut self) -> Option<T> {
              if self.start < self.end {
                  let old = self.start;
                  // SAFETY: just checked precondition
                  self.start = unsafe { Step::forward_unchecked(old, 1) };
                  Some(old)
              } else {
                  None
              }
          }
      *)
      Definition spec_next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ T ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                T,
                                [],
                                [ T ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ old : T :=
                        M.copy (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::Range",
                            "start"
                          |)
                        |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "start"
                            |),
                            M.call_closure (|
                              T,
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                T,
                                [],
                                [],
                                "forward_unchecked",
                                [],
                                []
                              |),
                              [ M.read (| old |); Value.Integer IntegerKind.Usize 1 ]
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| old |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_nth(&mut self, n: usize) -> Option<T> {
              if let Some(plus_n) = Step::forward_checked(self.start, n) {
                  if plus_n < self.end {
                      // SAFETY: just checked precondition
                      self.start = unsafe { Step::forward_unchecked(plus_n, 1) };
                      return Some(plus_n);
                  }
              }
      
              self.start = self.end;
              None
          }
      *)
      Definition spec_nth (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    T,
                                    [],
                                    [],
                                    "forward_checked",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::ops::range::Range",
                                        "start"
                                      |)
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let plus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              T,
                                              [],
                                              [ T ],
                                              "lt",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (| Pointer.Kind.Ref, plus_n |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "end"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "start"
                                                |),
                                                M.call_closure (|
                                                  T,
                                                  M.get_trait_method (|
                                                    "core::iter::range::Step",
                                                    T,
                                                    [],
                                                    [],
                                                    "forward_unchecked",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| plus_n |);
                                                    Value.Integer IntegerKind.Usize 1
                                                  ]
                                                |)
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::Range",
                          "start"
                        |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::Range",
                            "end"
                          |)
                        |)
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
              let steps = Step::steps_between(&self.start, &self.end);
              let available = steps.1.unwrap_or(steps.0);
      
              let taken = available.min(n);
      
              // SAFETY: the conditions above ensure that the count is in bounds. If start <= end
              // then steps_between either returns a bound to which we clamp or returns None which
              // together with the initial inequality implies more than usize::MAX steps.
              // Otherwise 0 is returned which always safe to use.
              self.start = unsafe { Step::forward_unchecked(self.start, taken) };
      
              NonZero::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_by
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ steps :
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                      ],
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      T,
                      [],
                      [],
                      "steps_between",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "start"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ available : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                      "unwrap_or",
                      [],
                      []
                    |),
                    [
                      M.read (| M.SubPointer.get_tuple_field (| steps, 1 |) |);
                      M.read (| M.SubPointer.get_tuple_field (| steps, 0 |) |)
                    ]
                  |)
                |) in
              let~ taken : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::cmp::Ord",
                      Ty.path "usize",
                      [],
                      [],
                      "min",
                      [],
                      []
                    |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::Range",
                      "start"
                    |),
                    M.call_closure (|
                      T,
                      M.get_trait_method (|
                        "core::iter::range::Step",
                        T,
                        [],
                        [],
                        "forward_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::Range",
                            "start"
                          |)
                        |);
                        M.read (| taken |)
                      ]
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.tuple [];
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                    "map_or",
                    [],
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.tuple [];
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                        ];
                      Ty.function
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.tuple [];
                            Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                          ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [ M.read (| n |); M.read (| taken |) ]
                        |)
                      ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_next_back(&mut self) -> Option<T> {
              if self.start < self.end {
                  // SAFETY: just checked precondition
                  self.end = unsafe { Step::backward_unchecked(self.end, 1) };
                  Some(self.end)
              } else {
                  None
              }
          }
      *)
      Definition spec_next_back
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.apply (Ty.path "core::option::Option") [] [ T ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                T,
                                [],
                                [ T ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.tuple [] :=
                        M.alloc (|
                          M.write (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "end"
                            |),
                            M.call_closure (|
                              T,
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                T,
                                [],
                                [],
                                "backward_unchecked",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |);
                                Value.Integer IntegerKind.Usize 1
                              ]
                            |)
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::ops::range::Range",
                                "end"
                              |)
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_nth_back(&mut self, n: usize) -> Option<T> {
              if let Some(minus_n) = Step::backward_checked(self.end, n) {
                  if minus_n > self.start {
                      // SAFETY: just checked precondition
                      self.end = unsafe { Step::backward_unchecked(minus_n, 1) };
                      return Some(self.end);
                  }
              }
      
              self.end = self.start;
              None
          }
      *)
      Definition spec_nth_back
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    T,
                                    [],
                                    [],
                                    "backward_checked",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "core::ops::range::Range",
                                        "end"
                                      |)
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let minus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              T,
                                              [],
                                              [ T ],
                                              "gt",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (| Pointer.Kind.Ref, minus_n |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "start"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::Range",
                                                  "end"
                                                |),
                                                M.call_closure (|
                                                  T,
                                                  M.get_trait_method (|
                                                    "core::iter::range::Step",
                                                    T,
                                                    [],
                                                    [],
                                                    "backward_unchecked",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| minus_n |);
                                                    Value.Integer IntegerKind.Usize 1
                                                  ]
                                                |)
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::ops::range::Range",
                                                    "end"
                                                  |)
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::Range",
                          "end"
                        |),
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::Range",
                            "start"
                          |)
                        |)
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
              let steps = Step::steps_between(&self.start, &self.end);
              let available = steps.1.unwrap_or(steps.0);
      
              let taken = available.min(n);
      
              // SAFETY: same as the spec_advance_by() implementation
              self.end = unsafe { Step::backward_unchecked(self.end, taken) };
      
              NonZero::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_back_by
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ steps :
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ] :=
                M.alloc (|
                  M.call_closure (|
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                      ],
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      T,
                      [],
                      [],
                      "steps_between",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "start"
                            |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::Range",
                              "end"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |) in
              let~ available : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                      "unwrap_or",
                      [],
                      []
                    |),
                    [
                      M.read (| M.SubPointer.get_tuple_field (| steps, 1 |) |);
                      M.read (| M.SubPointer.get_tuple_field (| steps, 0 |) |)
                    ]
                  |)
                |) in
              let~ taken : Ty.path "usize" :=
                M.alloc (|
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_trait_method (|
                      "core::cmp::Ord",
                      Ty.path "usize",
                      [],
                      [],
                      "min",
                      [],
                      []
                    |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::Range",
                      "end"
                    |),
                    M.call_closure (|
                      T,
                      M.get_trait_method (|
                        "core::iter::range::Step",
                        T,
                        [],
                        [],
                        "backward_unchecked",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::ops::range::Range",
                            "end"
                          |)
                        |);
                        M.read (| taken |)
                      ]
                    |)
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.tuple [];
                      Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                    "map_or",
                    [],
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.tuple [];
                          Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                        ];
                      Ty.function
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.tuple [];
                            Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                          ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ] ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ],
                        "new",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [ M.read (| n |); M.read (| taken |) ]
                        |)
                      ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeIteratorImpl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("spec_next", InstanceField.Method (spec_next T));
            ("spec_nth", InstanceField.Method (spec_nth T));
            ("spec_advance_by", InstanceField.Method (spec_advance_by T));
            ("spec_next_back", InstanceField.Method (spec_next_back T));
            ("spec_nth_back", InstanceField.Method (spec_nth_back T));
            ("spec_advance_back_by", InstanceField.Method (spec_advance_back_by T))
          ].
    End Impl_core_iter_range_RangeIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_Range_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          fn next(&mut self) -> Option<A> {
              self.spec_next()
          }
      *)
      Definition next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "spec_next",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.start < self.end {
                  Step::steps_between(&self.start, &self.end)
              } else {
                  (0, Some(0))
              }
          }
      *)
      Definition size_hint (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some
                  (Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                    ]),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                A,
                                [],
                                [ A ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                            ],
                          M.get_trait_method (|
                            "core::iter::range::Step",
                            A,
                            [],
                            [],
                            "steps_between",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer IntegerKind.Usize 0;
                            Value.StructTuple
                              "core::option::Option::Some"
                              [ Value.Integer IntegerKind.Usize 0 ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              if self.start < self.end {
                  Step::steps_between(&self.start, &self.end).1.expect("count overflowed usize")
              } else {
                  0
              }
          }
      *)
      Definition count (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Some (Ty.path "usize"),
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialOrd",
                                A,
                                [],
                                [ A ],
                                "lt",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::ops::range::Range",
                                    "start"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "core::ops::range::Range",
                                    "end"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            "expect",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_tuple_field (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::range::Step",
                                      A,
                                      [],
                                      [],
                                      "steps_between",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              self,
                                              "core::ops::range::Range",
                                              "start"
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              self,
                                              "core::ops::range::Range",
                                              "end"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |),
                                1
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| mk_str (| "count overflowed usize" |) |)
                            |)
                          ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 0 |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<A> {
              self.spec_nth(n)
          }
      *)
      Definition nth (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "spec_nth",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |); M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<A> {
              self.next_back()
          }
      *)
      Definition last (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn min(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next()
          }
      *)
      Definition min (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "next",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn max(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next_back()
          }
      *)
      Definition max (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn is_sorted(self) -> bool {
              true
          }
      *)
      Definition is_sorted (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Bool true))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
              self.spec_advance_by(n)
          }
      *)
      Definition advance_by (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.tuple [];
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "spec_advance_by",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |); M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item
          where
              Self: TrustedRandomAccessNoCoerce,
          {
              // SAFETY: The TrustedRandomAccess contract requires that callers only pass an index
              // that is in bounds.
              // Additionally Self: TrustedRandomAccess is only implemented for Copy types
              // which means even repeated reads of the same index would be safe.
              unsafe { Step::forward_unchecked(self.start.clone(), idx) }
          }
      *)
      Definition __iterator_get_unchecked
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.call_closure (|
              A,
              M.get_trait_method (|
                "core::iter::range::Step",
                A,
                [],
                [],
                "forward_unchecked",
                [],
                []
              |),
              [
                M.call_closure (|
                  A,
                  M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::ops::range::Range",
                        "start"
                      |)
                    |)
                  ]
                |);
                M.read (| idx |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("next", InstanceField.Method (next A));
            ("size_hint", InstanceField.Method (size_hint A));
            ("count", InstanceField.Method (count A));
            ("nth", InstanceField.Method (nth A));
            ("last", InstanceField.Method (last A));
            ("min", InstanceField.Method (min A));
            ("max", InstanceField.Method (max A));
            ("is_sorted", InstanceField.Method (is_sorted A));
            ("advance_by", InstanceField.Method (advance_by A));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_usize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_usize.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u16.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_isize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "isize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_isize.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i16.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u32.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_usize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_usize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_usize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_usize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u8" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u16" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_isize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "isize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_isize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_isize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "isize" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_isize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i8" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i16" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u32" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i32" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u64" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u64.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "u64" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u64.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i64" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i64.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "i64" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Method value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i64.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "u8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "i8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "u16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u16.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ Ty.path "i16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i16.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ A ].
      
      (*
          fn next_back(&mut self) -> Option<A> {
              self.spec_next_back()
          }
      *)
      Definition next_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "spec_next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<A> {
              self.spec_nth_back(n)
          }
      *)
      Definition nth_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "spec_nth_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |); M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {
              self.spec_advance_back_by(n)
          }
      *)
      Definition advance_back_by
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.tuple [];
                  Ty.apply (Ty.path "core::num::nonzero::NonZero") [] [ Ty.path "usize" ]
                ],
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ A ],
                [],
                [],
                "spec_advance_back_by",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |); M.read (| n |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back A));
            ("nth_back", InstanceField.Method (nth_back A));
            ("advance_back_by", InstanceField.Method (advance_back_by A))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [] [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          fn next(&mut self) -> Option<A> {
              let n = Step::forward(self.start.clone(), 1);
              Some(mem::replace(&mut self.start, n))
          }
      *)
      Definition next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let~ n : A :=
                M.alloc (|
                  M.call_closure (|
                    A,
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      A,
                      [],
                      [],
                      "forward",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        A,
                        M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeFrom",
                              "start"
                            |)
                          |)
                        ]
                      |);
                      Value.Integer IntegerKind.Usize 1
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.call_closure (|
                      A,
                      M.get_function (| "core::mem::replace", [], [ A ] |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::ops::range::RangeFrom",
                                "start"
                              |)
                            |)
                          |)
                        |);
                        M.read (| n |)
                      ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (usize::MAX, None)
          }
      *)
      Definition size_hint (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (| get_associated_constant (| Ty.path "usize", "MAX", Ty.path "usize" |) |);
                Value.StructTuple "core::option::Option::None" []
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<A> {
              let plus_n = Step::forward(self.start.clone(), n);
              self.start = Step::forward(plus_n.clone(), 1);
              Some(plus_n)
          }
      *)
      Definition nth (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let~ plus_n : A :=
                M.alloc (|
                  M.call_closure (|
                    A,
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      A,
                      [],
                      [],
                      "forward",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        A,
                        M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeFrom",
                              "start"
                            |)
                          |)
                        ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.alloc (|
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::ops::range::RangeFrom",
                      "start"
                    |),
                    M.call_closure (|
                      A,
                      M.get_trait_method (|
                        "core::iter::range::Step",
                        A,
                        [],
                        [],
                        "forward",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          A,
                          M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                          [ M.borrow (| Pointer.Kind.Ref, plus_n |) ]
                        |);
                        Value.Integer IntegerKind.Usize 1
                      ]
                    |)
                  |)
                |) in
              M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| plus_n |) ] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("next", InstanceField.Method (next A));
            ("size_hint", InstanceField.Method (size_hint A));
            ("nth", InstanceField.Method (nth A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeFrom_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeFrom_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeFrom") [] [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
    
    (* Trait *)
    (* Empty module 'RangeInclusiveIteratorImpl' *)
    
    Module Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          default fn spec_next(&mut self) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  let n =
                      Step::forward_checked(self.start.clone(), 1).expect("`Step` invariants not upheld");
                  mem::replace(&mut self.start, n)
              } else {
                  self.exhausted = true;
                  self.start.clone()
              })
          }
      *)
      Definition spec_next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ is_iterating : Ty.path "bool" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          A,
                          [],
                          [ A ],
                          "lt",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "start"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            Some A,
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ n : A :=
                                    M.alloc (|
                                      M.call_closure (|
                                        A,
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                          "expect",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                            M.get_trait_method (|
                                              "core::iter::range::Step",
                                              A,
                                              [],
                                              [],
                                              "forward_checked",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                A,
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  A,
                                                  [],
                                                  [],
                                                  "clone",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "core::ops::range::RangeInclusive",
                                                      "start"
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              mk_str (| "`Step` invariants not upheld" |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_function (| "core::mem::replace", [], [ A ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "start"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "exhausted"
                                        |),
                                        Value.Bool true
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, A) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  let n =
                      Step::forward_checked(self.start.clone(), 1).expect("`Step` invariants not upheld");
                  let n = mem::replace(&mut self.start, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start.clone())?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_fold
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        [],
                                        "from_output",
                                        [],
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ accum : B := M.copy (| init |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          A,
                                          [],
                                          [ A ],
                                          "lt",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "start"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "end"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ n : A :=
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                        "expect",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                          M.get_trait_method (|
                                            "core::iter::range::Step",
                                            A,
                                            [],
                                            [],
                                            "forward_checked",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              A,
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                A,
                                                [],
                                                [],
                                                "clone",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::ops::range::RangeInclusive",
                                                    "start"
                                                  |)
                                                |)
                                              ]
                                            |);
                                            Value.Integer IntegerKind.Usize 1
                                          ]
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "`Step` invariants not upheld" |) |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                let~ n : A :=
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_function (| "core::mem::replace", [], [ A ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "start"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      accum,
                                      M.read (|
                                        M.match_operator (|
                                          Some B,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::ops::control_flow::ControlFlow")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "core::ops::try_trait::Try"
                                                    []
                                                    []
                                                    R
                                                    "Residual";
                                                  B
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                R,
                                                [],
                                                [],
                                                "branch",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  R,
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [],
                                                    [ Ty.tuple [ B; A ] ],
                                                    "call_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.MutRef, f |);
                                                    Value.Tuple
                                                      [ M.read (| accum |); M.read (| n |) ]
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          R,
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            R,
                                                            [],
                                                            [
                                                              Ty.associated_in_trait
                                                                "core::ops::try_trait::Try"
                                                                []
                                                                []
                                                                R
                                                                "Residual"
                                                            ],
                                                            "from_residual",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "exhausted"
                        |),
                        Value.Bool true
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      A,
                                      [],
                                      [ A ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  accum,
                                  M.read (|
                                    M.match_operator (|
                                      Some B,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "core::ops::try_trait::Try"
                                                []
                                                []
                                                R
                                                "Residual";
                                              B
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            R,
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              R,
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                F,
                                                [],
                                                [ Ty.tuple [ B; A ] ],
                                                "call_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.MutRef, f |);
                                                Value.Tuple
                                                  [
                                                    M.read (| accum |);
                                                    M.call_closure (|
                                                      A,
                                                      M.get_trait_method (|
                                                        "core::clone::Clone",
                                                        A,
                                                        [],
                                                        [],
                                                        "clone",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "core::ops::range::RangeInclusive",
                                                            "start"
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      R,
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        R,
                                                        [],
                                                        [
                                                          Ty.associated_in_trait
                                                            "core::ops::try_trait::Try"
                                                            []
                                                            []
                                                            R
                                                            "Residual"
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      R,
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        [],
                        "from_output",
                        [],
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_next_back(&mut self) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  let n =
                      Step::backward_checked(self.end.clone(), 1).expect("`Step` invariants not upheld");
                  mem::replace(&mut self.end, n)
              } else {
                  self.exhausted = true;
                  self.end.clone()
              })
          }
      *)
      Definition spec_next_back
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ is_iterating : Ty.path "bool" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          A,
                          [],
                          [ A ],
                          "lt",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "start"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            Some A,
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ n : A :=
                                    M.alloc (|
                                      M.call_closure (|
                                        A,
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                          "expect",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                            M.get_trait_method (|
                                              "core::iter::range::Step",
                                              A,
                                              [],
                                              [],
                                              "backward_checked",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                A,
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  A,
                                                  [],
                                                  [],
                                                  "clone",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "core::ops::range::RangeInclusive",
                                                      "end"
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              mk_str (| "`Step` invariants not upheld" |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_function (| "core::mem::replace", [], [ A ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "end"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "exhausted"
                                        |),
                                        Value.Bool true
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          default fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, A) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  let n =
                      Step::backward_checked(self.end.clone(), 1).expect("`Step` invariants not upheld");
                  let n = mem::replace(&mut self.end, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start.clone())?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_rfold
          (A : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        [],
                                        "from_output",
                                        [],
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ accum : B := M.copy (| init |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          A,
                                          [],
                                          [ A ],
                                          "lt",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "start"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "end"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ n : A :=
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                        "expect",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                          M.get_trait_method (|
                                            "core::iter::range::Step",
                                            A,
                                            [],
                                            [],
                                            "backward_checked",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              A,
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                A,
                                                [],
                                                [],
                                                "clone",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "core::ops::range::RangeInclusive",
                                                    "end"
                                                  |)
                                                |)
                                              ]
                                            |);
                                            Value.Integer IntegerKind.Usize 1
                                          ]
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "`Step` invariants not upheld" |) |)
                                        |)
                                      ]
                                    |)
                                  |) in
                                let~ n : A :=
                                  M.alloc (|
                                    M.call_closure (|
                                      A,
                                      M.get_function (| "core::mem::replace", [], [ A ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "end"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      accum,
                                      M.read (|
                                        M.match_operator (|
                                          Some B,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::ops::control_flow::ControlFlow")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "core::ops::try_trait::Try"
                                                    []
                                                    []
                                                    R
                                                    "Residual";
                                                  B
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                R,
                                                [],
                                                [],
                                                "branch",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  R,
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [],
                                                    [ Ty.tuple [ B; A ] ],
                                                    "call_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.MutRef, f |);
                                                    Value.Tuple
                                                      [ M.read (| accum |); M.read (| n |) ]
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          R,
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            R,
                                                            [],
                                                            [
                                                              Ty.associated_in_trait
                                                                "core::ops::try_trait::Try"
                                                                []
                                                                []
                                                                R
                                                                "Residual"
                                                            ],
                                                            "from_residual",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "exhausted"
                        |),
                        Value.Bool true
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      A,
                                      [],
                                      [ A ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  accum,
                                  M.read (|
                                    M.match_operator (|
                                      Some B,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "core::ops::try_trait::Try"
                                                []
                                                []
                                                R
                                                "Residual";
                                              B
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            R,
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              R,
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                F,
                                                [],
                                                [ Ty.tuple [ B; A ] ],
                                                "call_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.MutRef, f |);
                                                Value.Tuple
                                                  [
                                                    M.read (| accum |);
                                                    M.call_closure (|
                                                      A,
                                                      M.get_trait_method (|
                                                        "core::clone::Clone",
                                                        A,
                                                        [],
                                                        [],
                                                        "clone",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "core::ops::range::RangeInclusive",
                                                            "start"
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      R,
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        R,
                                                        [],
                                                        [
                                                          Ty.associated_in_trait
                                                            "core::ops::try_trait::Try"
                                                            []
                                                            []
                                                            R
                                                            "Residual"
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      R,
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        [],
                        "from_output",
                        [],
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeInclusiveIteratorImpl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("spec_next", InstanceField.Method (spec_next A));
            ("spec_try_fold", InstanceField.Method (spec_try_fold A));
            ("spec_next_back", InstanceField.Method (spec_next_back A));
            ("spec_try_rfold", InstanceField.Method (spec_try_rfold A))
          ].
    End Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_RangeInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ T ].
      
      (*
          fn spec_next(&mut self) -> Option<T> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::forward_unchecked(self.start, 1) };
                  mem::replace(&mut self.start, n)
              } else {
                  self.exhausted = true;
                  self.start
              })
          }
      *)
      Definition spec_next (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ T ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ is_iterating : Ty.path "bool" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          T,
                          [],
                          [ T ],
                          "lt",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "start"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            Some T,
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ n : T :=
                                    M.alloc (|
                                      M.call_closure (|
                                        T,
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          T,
                                          [],
                                          [],
                                          "forward_unchecked",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "start"
                                            |)
                                          |);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      T,
                                      M.get_function (| "core::mem::replace", [], [ T ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "start"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "exhausted"
                                        |),
                                        Value.Bool true
                                      |)
                                    |) in
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeInclusive",
                                    "start"
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, T) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::forward_unchecked(self.start, 1) };
                  let n = mem::replace(&mut self.start, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start)?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_fold
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ T ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        [],
                                        "from_output",
                                        [],
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ accum : B := M.copy (| init |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          T,
                                          [],
                                          [ T ],
                                          "lt",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "start"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "end"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ n : T :=
                                  M.alloc (|
                                    M.call_closure (|
                                      T,
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        T,
                                        [],
                                        [],
                                        "forward_unchecked",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |)
                                        |);
                                        Value.Integer IntegerKind.Usize 1
                                      ]
                                    |)
                                  |) in
                                let~ n : T :=
                                  M.alloc (|
                                    M.call_closure (|
                                      T,
                                      M.get_function (| "core::mem::replace", [], [ T ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "start"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      accum,
                                      M.read (|
                                        M.match_operator (|
                                          Some B,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::ops::control_flow::ControlFlow")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "core::ops::try_trait::Try"
                                                    []
                                                    []
                                                    R
                                                    "Residual";
                                                  B
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                R,
                                                [],
                                                [],
                                                "branch",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  R,
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [],
                                                    [ Ty.tuple [ B; T ] ],
                                                    "call_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.MutRef, f |);
                                                    Value.Tuple
                                                      [ M.read (| accum |); M.read (| n |) ]
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          R,
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            R,
                                                            [],
                                                            [
                                                              Ty.associated_in_trait
                                                                "core::ops::try_trait::Try"
                                                                []
                                                                []
                                                                R
                                                                "Residual"
                                                            ],
                                                            "from_residual",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "exhausted"
                        |),
                        Value.Bool true
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      T,
                                      [],
                                      [ T ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  accum,
                                  M.read (|
                                    M.match_operator (|
                                      Some B,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "core::ops::try_trait::Try"
                                                []
                                                []
                                                R
                                                "Residual";
                                              B
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            R,
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              R,
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                F,
                                                [],
                                                [ Ty.tuple [ B; T ] ],
                                                "call_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.MutRef, f |);
                                                Value.Tuple
                                                  [
                                                    M.read (| accum |);
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::ops::range::RangeInclusive",
                                                        "start"
                                                      |)
                                                    |)
                                                  ]
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      R,
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        R,
                                                        [],
                                                        [
                                                          Ty.associated_in_trait
                                                            "core::ops::try_trait::Try"
                                                            []
                                                            []
                                                            R
                                                            "Residual"
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      R,
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        [],
                        "from_output",
                        [],
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_next_back(&mut self) -> Option<T> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::backward_unchecked(self.end, 1) };
                  mem::replace(&mut self.end, n)
              } else {
                  self.exhausted = true;
                  self.end
              })
          }
      *)
      Definition spec_next_back
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ T ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ is_iterating : Ty.path "bool" :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          T,
                          [],
                          [ T ],
                          "lt",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "start"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::ops::range::RangeInclusive",
                              "end"
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            Some T,
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let~ n : T :=
                                    M.alloc (|
                                      M.call_closure (|
                                        T,
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          T,
                                          [],
                                          [],
                                          "backward_unchecked",
                                          [],
                                          []
                                        |),
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "end"
                                            |)
                                          |);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      T,
                                      M.get_function (| "core::mem::replace", [], [ T ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "end"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.alloc (|
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "exhausted"
                                        |),
                                        Value.Bool true
                                      |)
                                    |) in
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "core::ops::range::RangeInclusive",
                                    "end"
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, T) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::backward_unchecked(self.end, 1) };
                  let n = mem::replace(&mut self.end, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start)?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_rfold
          (T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ T ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      R,
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        [],
                                        "from_output",
                                        [],
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ accum : B := M.copy (| init |) in
                  let~ _ : Ty.tuple [] :=
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Some (Ty.tuple []),
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          T,
                                          [],
                                          [ T ],
                                          "lt",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "start"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "core::ops::range::RangeInclusive",
                                              "end"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ n : T :=
                                  M.alloc (|
                                    M.call_closure (|
                                      T,
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        T,
                                        [],
                                        [],
                                        "backward_unchecked",
                                        [],
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        |);
                                        Value.Integer IntegerKind.Usize 1
                                      ]
                                    |)
                                  |) in
                                let~ n : T :=
                                  M.alloc (|
                                    M.call_closure (|
                                      T,
                                      M.get_function (| "core::mem::replace", [], [ T ] |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "core::ops::range::RangeInclusive",
                                                "end"
                                              |)
                                            |)
                                          |)
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  M.alloc (|
                                    M.write (|
                                      accum,
                                      M.read (|
                                        M.match_operator (|
                                          Some B,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::ops::control_flow::ControlFlow")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "core::ops::try_trait::Try"
                                                    []
                                                    []
                                                    R
                                                    "Residual";
                                                  B
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                R,
                                                [],
                                                [],
                                                "branch",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  R,
                                                  M.get_trait_method (|
                                                    "core::ops::function::FnMut",
                                                    F,
                                                    [],
                                                    [ Ty.tuple [ B; T ] ],
                                                    "call_mut",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.MutRef, f |);
                                                    Value.Tuple
                                                      [ M.read (| accum |); M.read (| n |) ]
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          R,
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            R,
                                                            [],
                                                            [
                                                              Ty.associated_in_trait
                                                                "core::ops::try_trait::Try"
                                                                []
                                                                []
                                                                R
                                                                "Residual"
                                                            ],
                                                            "from_residual",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "exhausted"
                        |),
                        Value.Bool true
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      T,
                                      [],
                                      [ T ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.alloc (|
                                M.write (|
                                  accum,
                                  M.read (|
                                    M.match_operator (|
                                      Some B,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "core::ops::try_trait::Try"
                                                []
                                                []
                                                R
                                                "Residual";
                                              B
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            R,
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              R,
                                              M.get_trait_method (|
                                                "core::ops::function::FnMut",
                                                F,
                                                [],
                                                [ Ty.tuple [ B; T ] ],
                                                "call_mut",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.MutRef, f |);
                                                Value.Tuple
                                                  [
                                                    M.read (| accum |);
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "core::ops::range::RangeInclusive",
                                                        "start"
                                                      |)
                                                    |)
                                                  ]
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      R,
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        R,
                                                        [],
                                                        [
                                                          Ty.associated_in_trait
                                                            "core::ops::try_trait::Try"
                                                            []
                                                            []
                                                            R
                                                            "Residual"
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      R,
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        [],
                        "from_output",
                        [],
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeInclusiveIteratorImpl"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *)
          [
            ("spec_next", InstanceField.Method (spec_next T));
            ("spec_try_fold", InstanceField.Method (spec_try_fold T));
            ("spec_next_back", InstanceField.Method (spec_next_back T));
            ("spec_try_rfold", InstanceField.Method (spec_try_rfold T))
          ].
    End Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_RangeInclusive_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          fn next(&mut self) -> Option<A> {
              self.spec_next()
          }
      *)
      Definition next (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                [],
                [],
                "spec_next",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.is_empty() {
                  return (0, Some(0));
              }
      
              let hint = Step::steps_between(&self.start, &self.end);
              (hint.0.saturating_add(1), hint.1.and_then(|steps| steps.checked_add(1)))
          }
      *)
      Definition size_hint (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.Tuple
                                      [
                                        Value.Integer IntegerKind.Usize 0;
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [ Value.Integer IntegerKind.Usize 0 ]
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ hint :
                      Ty.tuple
                        [
                          Ty.path "usize";
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                        ] :=
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple
                          [
                            Ty.path "usize";
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ]
                          ],
                        M.get_trait_method (|
                          "core::iter::range::Step",
                          A,
                          [],
                          [],
                          "steps_between",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::ops::range::RangeInclusive",
                                  "start"
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "core::ops::range::RangeInclusive",
                                  "end"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.Tuple
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (| Ty.path "usize", "saturating_add", [], [] |),
                          [
                            M.read (| M.SubPointer.get_tuple_field (| hint, 0 |) |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            "and_then",
                            [],
                            [
                              Ty.path "usize";
                              Ty.function
                                [ Ty.tuple [ Ty.path "usize" ] ]
                                (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ])
                            ]
                          |),
                          [
                            M.read (| M.SubPointer.get_tuple_field (| hint, 1 |) |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [ Ty.tuple [ Ty.path "usize" ] ]
                                            (Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ])),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let steps := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.path "usize" ],
                                                M.get_associated_function (|
                                                  Ty.path "usize",
                                                  "checked_add",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (| steps |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn count(self) -> usize {
              if self.is_empty() {
                  return 0;
              }
      
              Step::steps_between(&self.start, &self.end)
                  .1
                  .and_then(|steps| steps.checked_add(1))
                  .expect("count overflowed usize")
          }
      *)
      Definition count (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (| M.return_ (| Value.Integer IntegerKind.Usize 0 |) |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                        "expect",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            "and_then",
                            [],
                            [
                              Ty.path "usize";
                              Ty.function
                                [ Ty.tuple [ Ty.path "usize" ] ]
                                (Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ])
                            ]
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_tuple_field (|
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.tuple
                                      [
                                        Ty.path "usize";
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ]
                                      ],
                                    M.get_trait_method (|
                                      "core::iter::range::Step",
                                      A,
                                      [],
                                      [],
                                      "steps_between",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              self,
                                              "core::ops::range::RangeInclusive",
                                              "start"
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              self,
                                              "core::ops::range::RangeInclusive",
                                              "end"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |),
                                1
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Some
                                          (Ty.function
                                            [ Ty.tuple [ Ty.path "usize" ] ]
                                            (Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ])),
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let steps := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.path "usize" ],
                                                M.get_associated_function (|
                                                  Ty.path "usize",
                                                  "checked_add",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (| steps |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "count overflowed usize" |) |)
                        |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
      
              if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {
                  use crate::cmp::Ordering::*;
      
                  match plus_n.partial_cmp(&self.end) {
                      Some(Less) => {
                          self.start = Step::forward(plus_n.clone(), 1);
                          return Some(plus_n);
                      }
                      Some(Equal) => {
                          self.start = plus_n.clone();
                          self.exhausted = true;
                          return Some(plus_n);
                      }
                      _ => {}
                  }
              }
      
              self.start = self.end.clone();
              self.exhausted = true;
              None
          }
      *)
      Definition nth (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    [],
                                    "forward_checked",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let plus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ],
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    A,
                                    [],
                                    [ A ],
                                    "partial_cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, plus_n |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Less" |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::RangeInclusive",
                                                  "start"
                                                |),
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::iter::range::Step",
                                                    A,
                                                    [],
                                                    [],
                                                    "forward",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      A,
                                                      M.get_trait_method (|
                                                        "core::clone::Clone",
                                                        A,
                                                        [],
                                                        [],
                                                        "clone",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, plus_n |) ]
                                                    |);
                                                    Value.Integer IntegerKind.Usize 1
                                                  ]
                                                |)
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::RangeInclusive",
                                                  "start"
                                                |),
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    [],
                                                    "clone",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.borrow (| Pointer.Kind.Ref, plus_n |) ]
                                                |)
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::RangeInclusive",
                                                  "exhausted"
                                                |),
                                                Value.Bool true
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "start"
                        |),
                        M.call_closure (|
                          A,
                          M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::ops::range::RangeInclusive",
                                "end"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "exhausted"
                        |),
                        Value.Bool true
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, Self::Item) -> R,
              R: Try<Output = B>,
          {
              self.spec_try_fold(init, f)
          }
      *)
      Definition try_fold (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              R,
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                [],
                [],
                "spec_try_fold",
                [],
                [ B; F; R ]
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                M.read (| init |);
                M.read (| f |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn $fold<AAA, FFF>(mut self, init: AAA, fold: FFF) -> AAA
              where
                  FFF: FnMut(AAA, Self::Item) -> AAA,
              {
                  use crate::ops::NeverShortCircuit;
      
                  self.$try_fold(init, NeverShortCircuit::wrap_mut_2(fold)).0
              }
      *)
      Definition fold (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ AAA; FFF ], [ self; init; fold ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let fold := M.alloc (| fold |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [] [ AAA ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                      [],
                      [],
                      "try_fold",
                      [],
                      [
                        AAA;
                        Ty.associated_unknown;
                        Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [] [ AAA ]
                      ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, self |);
                      M.read (| init |);
                      M.call_closure (|
                        Ty.associated_unknown,
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [] [ AAA ],
                          "wrap_mut_2",
                          [],
                          [ AAA; A; FFF ]
                        |),
                        [ M.read (| fold |) ]
                      |)
                    ]
                  |)
                |),
                "core::ops::try_trait::NeverShortCircuit",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn last(mut self) -> Option<A> {
              self.next_back()
          }
      *)
      Definition last (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn min(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next()
          }
      *)
      Definition min (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                [],
                [],
                "next",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn max(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next_back()
          }
      *)
      Definition max (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                [],
                [],
                "next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, self |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn is_sorted(self) -> bool {
              true
          }
      *)
      Definition is_sorted (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Bool true))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("next", InstanceField.Method (next A));
            ("size_hint", InstanceField.Method (size_hint A));
            ("count", InstanceField.Method (count A));
            ("nth", InstanceField.Method (nth A));
            ("try_fold", InstanceField.Method (try_fold A));
            ("fold", InstanceField.Method (fold A));
            ("last", InstanceField.Method (last A));
            ("min", InstanceField.Method (min A));
            ("max", InstanceField.Method (max A));
            ("is_sorted", InstanceField.Method (is_sorted A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ].
      
      (*
          fn next_back(&mut self) -> Option<A> {
              self.spec_next_back()
          }
      *)
      Definition next_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ A ],
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                [],
                [],
                "spec_next_back",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
      
              if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {
                  use crate::cmp::Ordering::*;
      
                  match minus_n.partial_cmp(&self.start) {
                      Some(Greater) => {
                          self.end = Step::backward(minus_n.clone(), 1);
                          return Some(minus_n);
                      }
                      Some(Equal) => {
                          self.end = minus_n.clone();
                          self.exhausted = true;
                          return Some(minus_n);
                      }
                      _ => {}
                  }
              }
      
              self.end = self.start.clone();
              self.exhausted = true;
              None
          }
      *)
      Definition nth_back (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::ops::range::RangeInclusive")
                                        []
                                        [ A ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Some (Ty.tuple []),
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ A ],
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    [],
                                    "backward_checked",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      A,
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        [],
                                        "clone",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let minus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              Some (Ty.tuple []),
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ],
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    A,
                                    [],
                                    [ A ],
                                    "partial_cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, minus_n |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (|
                                        γ0_0,
                                        "core::cmp::Ordering::Greater"
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::RangeInclusive",
                                                  "end"
                                                |),
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::iter::range::Step",
                                                    A,
                                                    [],
                                                    [],
                                                    "backward",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      A,
                                                      M.get_trait_method (|
                                                        "core::clone::Clone",
                                                        A,
                                                        [],
                                                        [],
                                                        "clone",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, minus_n |) ]
                                                    |);
                                                    Value.Integer IntegerKind.Usize 1
                                                  ]
                                                |)
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| minus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::RangeInclusive",
                                                  "end"
                                                |),
                                                M.call_closure (|
                                                  A,
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    [],
                                                    "clone",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.borrow (| Pointer.Kind.Ref, minus_n |) ]
                                                |)
                                              |)
                                            |) in
                                          let~ _ : Ty.tuple [] :=
                                            M.alloc (|
                                              M.write (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "core::ops::range::RangeInclusive",
                                                  "exhausted"
                                                |),
                                                Value.Bool true
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| minus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "end"
                        |),
                        M.call_closure (|
                          A,
                          M.get_trait_method (| "core::clone::Clone", A, [], [], "clone", [], [] |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "core::ops::range::RangeInclusive",
                                "start"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::ops::range::RangeInclusive",
                          "exhausted"
                        |),
                        Value.Bool true
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, Self::Item) -> R,
              R: Try<Output = B>,
          {
              self.spec_try_rfold(init, f)
          }
      *)
      Definition try_rfold (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              R,
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                [],
                [],
                "spec_try_rfold",
                [],
                [ B; F; R ]
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                M.read (| init |);
                M.read (| f |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
              fn $fold<AAA, FFF>(mut self, init: AAA, fold: FFF) -> AAA
              where
                  FFF: FnMut(AAA, Self::Item) -> AAA,
              {
                  use crate::ops::NeverShortCircuit;
      
                  self.$try_fold(init, NeverShortCircuit::wrap_mut_2(fold)).0
              }
      *)
      Definition rfold (A : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match ε, τ, α with
        | [], [ AAA; FFF ], [ self; init; fold ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let fold := M.alloc (| fold |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [] [ AAA ],
                    M.get_trait_method (|
                      "core::iter::traits::double_ended::DoubleEndedIterator",
                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ],
                      [],
                      [],
                      "try_rfold",
                      [],
                      [
                        AAA;
                        Ty.associated_unknown;
                        Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [] [ AAA ]
                      ]
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, self |);
                      M.read (| init |);
                      M.call_closure (|
                        Ty.associated_unknown,
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [] [ AAA ],
                          "wrap_mut_2",
                          [],
                          [ AAA; A; FFF ]
                        |),
                        [ M.read (| fold |) ]
                      |)
                    ]
                  |)
                |),
                "core::ops::try_trait::NeverShortCircuit",
                0
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back A));
            ("nth_back", InstanceField.Method (nth_back A));
            ("try_rfold", InstanceField.Method (try_rfold A));
            ("rfold", InstanceField.Method (rfold A))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [] [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self A)
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
  End range.
End iter.
