(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module iter.
  Module range.
    Module Impl_core_iter_traits_marker_TrustedStep_for_core_ascii_ascii_char_AsciiChar.
      Definition Self : Ty.t := Ty.path "core::ascii::ascii_char::AsciiChar".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_core_ascii_ascii_char_AsciiChar.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_char.
      Definition Self : Ty.t := Ty.path "char".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_char.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i8.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i16.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i32.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i64.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_i128.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_isize.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u8.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u16.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u32.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u64.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_u128.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_usize.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv4Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv4Addr".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv4Addr.
    
    Module Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv6Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv6Addr".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedStep"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedStep_for_core_net_ip_addr_Ipv6Addr.
    
    (* Trait *)
    Module Step.
      Definition forward (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Self ],
                "expect",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Self,
                    [],
                    "forward_checked",
                    []
                  |),
                  [ M.read (| start |); M.read (| count |) ]
                |);
                M.read (| Value.String "overflow in `Step::forward`" |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom ProvidedMethod_forward : M.IsProvidedMethod "core::iter::range::Step" "forward" forward.
      Definition forward_unchecked (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_trait_method (| "core::iter::range::Step", Self, [], "forward", [] |),
              [ M.read (| start |); M.read (| count |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom ProvidedMethod_forward_unchecked :
        M.IsProvidedMethod "core::iter::range::Step" "forward_unchecked" forward_unchecked.
      Definition backward (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Self ],
                "expect",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Self,
                    [],
                    "backward_checked",
                    []
                  |),
                  [ M.read (| start |); M.read (| count |) ]
                |);
                M.read (| Value.String "overflow in `Step::backward`" |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom ProvidedMethod_backward :
        M.IsProvidedMethod "core::iter::range::Step" "backward" backward.
      Definition backward_unchecked (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_trait_method (| "core::iter::range::Step", Self, [], "backward", [] |),
              [ M.read (| start |); M.read (| count |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom ProvidedMethod_backward_unchecked :
        M.IsProvidedMethod "core::iter::range::Step" "backward_unchecked" backward_unchecked.
    End Step.
    
    Module Impl_core_iter_range_Step_for_u8.
      Definition Self : Ty.t := Ty.path "u8".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u8", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u8" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u8",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.U8,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u8" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u8",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.U8,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u8", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              Some(( *end - *start) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (BinOp.Panic.sub (|
                                Integer.U8,
                                M.read (| M.read (| end_ |) |),
                                M.read (| M.read (| start |) |)
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "checked_add", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u8", "checked_sub", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u8.
    
    Module Impl_core_iter_range_Step_for_i8.
      Definition Self : Ty.t := Ty.path "i8".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i8", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i8" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i8",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.I8,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i8" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i8",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.I8,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i8", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              Some(( *end as isize).wrapping_sub( *start as isize) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (M.call_closure (|
                                M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                                [
                                  M.rust_cast (M.read (| M.read (| end_ |) |));
                                  M.rust_cast (M.read (| M.read (| start |) |))
                                ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "wrapping_add", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ge (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u8",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i8", "wrapping_sub", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.le (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i8.
    
    Module Impl_core_iter_range_Step_for_u16.
      Definition Self : Ty.t := Ty.path "u16".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u16", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u16" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u16",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.U16,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u16" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u16",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.U16,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u16", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              Some(( *end - *start) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (BinOp.Panic.sub (|
                                Integer.U16,
                                M.read (| M.read (| end_ |) |),
                                M.read (| M.read (| start |) |)
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "checked_add", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u16", "checked_sub", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u16.
    
    Module Impl_core_iter_range_Step_for_i16.
      Definition Self : Ty.t := Ty.path "i16".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i16", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i16" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i16",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.I16,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i16" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i16",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.I16,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i16", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              Some(( *end as isize).wrapping_sub( *start as isize) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (M.call_closure (|
                                M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                                [
                                  M.rust_cast (M.read (| M.read (| end_ |) |));
                                  M.rust_cast (M.read (| M.read (| start |) |))
                                ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "wrapping_add", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ge (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u16",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i16", "wrapping_sub", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.le (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i16.
    
    Module Impl_core_iter_range_Step_for_u32.
      Definition Self : Ty.t := Ty.path "u32".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u32", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u32",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.U32,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u32",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.U32,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u32", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              Some(( *end - *start) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (BinOp.Panic.sub (|
                                Integer.U32,
                                M.read (| M.read (| end_ |) |),
                                M.read (| M.read (| start |) |)
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "checked_add", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u32", "checked_sub", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u32.
    
    Module Impl_core_iter_range_Step_for_i32.
      Definition Self : Ty.t := Ty.path "i32".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i32", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i32" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i32",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.I32,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i32" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i32",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.I32,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              Some(( *end as isize).wrapping_sub( *start as isize) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (M.call_closure (|
                                M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                                [
                                  M.rust_cast (M.read (| M.read (| end_ |) |));
                                  M.rust_cast (M.read (| M.read (| start |) |))
                                ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "wrapping_add", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ge (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u32",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i32", "wrapping_sub", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.le (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i32.
    
    Module Impl_core_iter_range_Step_for_u64.
      Definition Self : Ty.t := Ty.path "u64".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u64" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u64",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.U64,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u64" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u64",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.U64,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u64", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              Some(( *end - *start) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (BinOp.Panic.sub (|
                                Integer.U64,
                                M.read (| M.read (| end_ |) |),
                                M.read (| M.read (| start |) |)
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "checked_add", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "u64", "checked_sub", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u64.
    
    Module Impl_core_iter_range_Step_for_i64.
      Definition Self : Ty.t := Ty.path "i64".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i64", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i64" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i64",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.I64,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i64" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i64",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.I64,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i64", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              Some(( *end as isize).wrapping_sub( *start as isize) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (M.call_closure (|
                                M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                                [
                                  M.rust_cast (M.read (| M.read (| end_ |) |));
                                  M.rust_cast (M.read (| M.read (| start |) |))
                                ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "wrapping_add", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ge (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "u64",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i64", "wrapping_sub", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.le (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i64.
    
    Module Impl_core_iter_range_Step_for_usize.
      Definition Self : Ty.t := Ty.path "usize".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "unchecked_add", [] |),
              [ M.read (| start |); M.read (| M.use n |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "usize", "unchecked_sub", [] |),
              [ M.read (| start |); M.read (| M.use n |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "usize",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.Usize,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_add", [] |),
                  [ M.read (| start |); M.read (| M.use n |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "usize",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.Usize,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "usize", "wrapping_sub", [] |),
                  [ M.read (| start |); M.read (| M.use n |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $u_narrower <= usize
                              Some(( *end - *start) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.use
                                (M.alloc (|
                                  BinOp.Panic.sub (|
                                    Integer.Usize,
                                    M.read (| M.read (| end_ |) |),
                                    M.read (| M.read (| start |) |)
                                  |)
                                |))
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_add(n),
                              Err(_) => None, // if n is out of range, `unsigned_start + n` is too
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "checked_add", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match Self::try_from(n) {
                              Ok(n) => start.checked_sub(n),
                              Err(_) => None, // if n is out of range, `unsigned_start - n` is too
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "usize", "checked_sub", [] |),
                          [ M.read (| start |); M.read (| n |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_usize.
    
    Module Impl_core_iter_range_Step_for_isize.
      Definition Self : Ty.t := Ty.path "isize".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "isize", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "isize" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "isize",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.Isize,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "isize" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "isize",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.Isize,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              // This relies on $i_narrower <= usize
                              //
                              // Casting to isize extends the width but preserves the sign.
                              // Use wrapping_sub in isize space and cast to usize to compute
                              // the difference that might not fit inside the range of isize.
                              Some(( *end as isize).wrapping_sub( *start as isize) as usize)
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.rust_cast
                              (M.call_closure (|
                                M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                                [
                                  M.read (| M.use (M.read (| end_ |)) |);
                                  M.read (| M.use (M.read (| start |)) |)
                                ]
                              |))
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_add(n as Self);
                                  if wrapped >= start {
                                      Some(wrapped)
                                  } else {
                                      None // Addition overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 + n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "wrapping_add", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.ge (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          match $u_narrower::try_from(n) {
                              Ok(n) => {
                                  // Wrapping handles cases like
                                  // `Step::forward(-120_i8, 200) == Some(80_i8)`,
                                  // even though 200 is out of range for i8.
                                  let wrapped = start.wrapping_sub(n as Self);
                                  if wrapped <= start {
                                      Some(wrapped)
                                  } else {
                                      None // Subtraction overflowed
                                  }
                              }
                              // If n is out of range of e.g. u8,
                              // then it is bigger than the entire range for i8 is wide
                              // so `any_i8 - n` necessarily overflows i8.
                              Err(_) => None,
                          }
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.path "usize",
                      [ Ty.path "usize" ],
                      "try_from",
                      []
                    |),
                    [ M.read (| n |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Ok",
                          0
                        |) in
                      let n := M.copy (| γ0_0 |) in
                      let wrapped :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "isize", "wrapping_sub", [] |),
                            [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.le (M.read (| wrapped |)) (M.read (| start |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  [ M.read (| wrapped |) ]
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_tuple_field (|
                          γ,
                          "core::result::Result::Err",
                          0
                        |) in
                      M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_isize.
    
    Module Impl_core_iter_range_Step_for_u128.
      Definition Self : Ty.t := Ty.path "u128".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u128" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u128",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.U128,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "u128" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "u128",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.U128,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "u128", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              usize::try_from( *end - *start).ok()
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError" ],
                            "ok",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::convert::TryFrom",
                                Ty.path "usize",
                                [ Ty.path "u128" ],
                                "try_from",
                                []
                              |),
                              [
                                BinOp.Panic.sub (|
                                  Integer.U128,
                                  M.read (| M.read (| end_ |) |),
                                  M.read (| M.read (| start |) |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_add(n as Self)
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "checked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_sub(n as Self)
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "u128", "checked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_u128.
    
    Module Impl_core_iter_range_Step_for_i128.
      Definition Self : Ty.t := Ty.path "i128".
      
      (*
              unsafe fn forward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.
                  unsafe { start.unchecked_add(n as Self) }
              }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "unchecked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              unsafe fn backward_unchecked(start: Self, n: usize) -> Self {
                  // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.
                  unsafe { start.unchecked_sub(n as Self) }
              }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "unchecked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn forward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::forward_checked(start, n).is_none() {
                      let _ = Self::MAX + 1;
                  }
                  // Do wrapping math to allow e.g. `Step::forward(-128i8, 255)`.
                  start.wrapping_add(n as Self)
              }
      *)
      Definition forward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i128" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i128",
                                        [],
                                        "forward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.add (|
                              Integer.I128,
                              M.read (| M.get_constant (| "core::num::MAX" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_add", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn backward(start: Self, n: usize) -> Self {
                  // In debug builds, trigger a panic on overflow.
                  // This should optimize completely out in release builds.
                  if Self::backward_checked(start, n).is_none() {
                      let _ = Self::MIN - 1;
                  }
                  // Do wrapping math to allow e.g. `Step::backward(127i8, 255)`.
                  start.wrapping_sub(n as Self)
              }
      *)
      Definition backward (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.read (|
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "core::option::Option") [ Ty.path "i128" ],
                                  "is_none",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        Ty.path "i128",
                                        [],
                                        "backward_checked",
                                        []
                                      |),
                                      [ M.read (| start |); M.read (| n |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.match_operator (|
                          M.alloc (|
                            BinOp.Panic.sub (|
                              Integer.I128,
                              M.read (| M.get_constant (| "core::num::MIN" |) |),
                              Value.Integer 1
                            |)
                          |),
                          [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "i128", "wrapping_sub", [] |),
                  [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn steps_between(start: &Self, end: &Self) -> Option<usize> {
                          if *start <= *end {
                              match end.checked_sub( *start) {
                                  Some(result) => usize::try_from(result).ok(),
                                  // If the difference is too big for e.g. i128,
                                  // it's also gonna be too big for usize with fewer bits.
                                  None => None,
                              }
                          } else {
                              None
                          }
                      }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; end_ ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let end_ := M.alloc (| end_ |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.le
                              (M.read (| M.read (| start |) |))
                              (M.read (| M.read (| end_ |) |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (| Ty.path "i128", "checked_sub", [] |),
                            [ M.read (| M.read (| end_ |) |); M.read (| M.read (| start |) |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::option::Option::Some",
                                  0
                                |) in
                              let result := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.path "usize"; Ty.path "core::num::error::TryFromIntError"
                                      ],
                                    "ok",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::convert::TryFrom",
                                        Ty.path "usize",
                                        [ Ty.path "i128" ],
                                        "try_from",
                                        []
                                      |),
                                      [ M.read (| result |) ]
                                    |)
                                  ]
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                        ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn forward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_add(n as Self)
                      }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "checked_add", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
                      fn backward_checked(start: Self, n: usize) -> Option<Self> {
                          start.checked_sub(n as Self)
                      }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; n ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_associated_function (| Ty.path "i128", "checked_sub", [] |),
              [ M.read (| start |); M.rust_cast (M.read (| n |)) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked);
            ("forward", InstanceField.Method forward);
            ("backward", InstanceField.Method backward);
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked)
          ].
    End Impl_core_iter_range_Step_for_i128.
    
    Module Impl_core_iter_range_Step_for_char.
      Definition Self : Ty.t := Ty.path "char".
      
      (*
          fn steps_between(&start: &char, &end: &char) -> Option<usize> {
              let start = start as u32;
              let end = end as u32;
              if start <= end {
                  let count = end - start;
                  if start < 0xD800 && 0xE000 <= end {
                      usize::try_from(count - 0x800).ok()
                  } else {
                      usize::try_from(count).ok()
                  }
              } else {
                  None
              }
          }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.read (|
                              let start := M.alloc (| M.rust_cast (M.read (| start |)) |) in
                              let end_ := M.alloc (| M.rust_cast (M.read (| end_ |)) |) in
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            BinOp.Pure.le (M.read (| start |)) (M.read (| end_ |))
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let count :=
                                        M.alloc (|
                                          BinOp.Panic.sub (|
                                            Integer.U32,
                                            M.read (| end_ |),
                                            M.read (| start |)
                                          |)
                                        |) in
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    LogicalOp.and (|
                                                      BinOp.Pure.lt
                                                        (M.read (| start |))
                                                        (Value.Integer 55296),
                                                      ltac:(M.monadic
                                                        (BinOp.Pure.le
                                                          (Value.Integer 57344)
                                                          (M.read (| end_ |))))
                                                    |)
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "usize";
                                                        Ty.path "core::num::error::TryFromIntError"
                                                      ],
                                                    "ok",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::convert::TryFrom",
                                                        Ty.path "usize",
                                                        [ Ty.path "u32" ],
                                                        "try_from",
                                                        []
                                                      |),
                                                      [
                                                        BinOp.Panic.sub (|
                                                          Integer.U32,
                                                          M.read (| count |),
                                                          Value.Integer 2048
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "usize";
                                                        Ty.path "core::num::error::TryFromIntError"
                                                      ],
                                                    "ok",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::convert::TryFrom",
                                                        Ty.path "usize",
                                                        [ Ty.path "u32" ],
                                                        "try_from",
                                                        []
                                                      |),
                                                      [ M.read (| count |) ]
                                                    |)
                                                  ]
                                                |)
                                              |)))
                                        ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        Value.StructTuple "core::option::Option::None" []
                                      |)))
                                ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn forward_checked(start: char, count: usize) -> Option<char> {
              let start = start as u32;
              let mut res = Step::forward_checked(start, count)?;
              if start < 0xD800 && 0xD800 <= res {
                  res = Step::forward_checked(res, 0x800)?;
              }
              if res <= char::MAX as u32 {
                  // SAFETY: res is a valid unicode scalar
                  // (below 0x110000 and not in 0xD800..0xE000)
                  Some(unsafe { char::from_u32_unchecked(res) })
              } else {
                  None
              }
          }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let start := M.alloc (| M.rust_cast (M.read (| start |)) |) in
                  let res :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u32",
                                  [],
                                  "forward_checked",
                                  []
                                |),
                                [ M.read (| start |); M.read (| count |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "char" ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    BinOp.Pure.lt (M.read (| start |)) (Value.Integer 55296),
                                    ltac:(M.monadic
                                      (BinOp.Pure.le (Value.Integer 55296) (M.read (| res |))))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                res,
                                M.read (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "u32" ],
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::range::Step",
                                              Ty.path "u32",
                                              [],
                                              "forward_checked",
                                              []
                                            |),
                                            [ M.read (| res |); Value.Integer 2048 ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [ Ty.path "char" ],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          [ Ty.path "core::convert::Infallible" ]
                                                      ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.le
                                  (M.read (| res |))
                                  (M.rust_cast
                                    (M.read (| M.get_constant (| "core::char::methods::MAX" |) |)))
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "char",
                                    "from_u32_unchecked",
                                    []
                                  |),
                                  [ M.read (| res |) ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn backward_checked(start: char, count: usize) -> Option<char> {
              let start = start as u32;
              let mut res = Step::backward_checked(start, count)?;
              if start >= 0xE000 && 0xE000 > res {
                  res = Step::backward_checked(res, 0x800)?;
              }
              // SAFETY: res is a valid unicode scalar
              // (below 0x110000 and not in 0xD800..0xE000)
              Some(unsafe { char::from_u32_unchecked(res) })
          }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let start := M.alloc (| M.rust_cast (M.read (| start |)) |) in
                  let res :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u32",
                                  [],
                                  "backward_checked",
                                  []
                                |),
                                [ M.read (| start |); M.read (| count |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "char" ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    BinOp.Pure.ge (M.read (| start |)) (Value.Integer 57344),
                                    ltac:(M.monadic
                                      (BinOp.Pure.gt (Value.Integer 57344) (M.read (| res |))))
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                res,
                                M.read (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "u32" ],
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::range::Step",
                                              Ty.path "u32",
                                              [],
                                              "backward_checked",
                                              []
                                            |),
                                            [ M.read (| res |); Value.Integer 2048 ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        [ Ty.path "char" ],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          [ Ty.path "core::convert::Infallible" ]
                                                      ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.call_closure (|
                          M.get_associated_function (| Ty.path "char", "from_u32_unchecked", [] |),
                          [ M.read (| res |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn forward_unchecked(start: char, count: usize) -> char {
              let start = start as u32;
              // SAFETY: the caller must guarantee that this doesn't overflow
              // the range of values for a char.
              let mut res = unsafe { Step::forward_unchecked(start, count) };
              if start < 0xD800 && 0xD800 <= res {
                  // SAFETY: the caller must guarantee that this doesn't overflow
                  // the range of values for a char.
                  res = unsafe { Step::forward_unchecked(res, 0x800) };
              }
              // SAFETY: because of the previous contract, this is guaranteed
              // by the caller to be a valid char.
              unsafe { char::from_u32_unchecked(res) }
          }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let start := M.alloc (| M.rust_cast (M.read (| start |)) |) in
              let res :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u32",
                      [],
                      "forward_unchecked",
                      []
                    |),
                    [ M.read (| start |); M.read (| count |) ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.and (|
                                BinOp.Pure.lt (M.read (| start |)) (Value.Integer 55296),
                                ltac:(M.monadic
                                  (BinOp.Pure.le (Value.Integer 55296) (M.read (| res |))))
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.write (|
                            res,
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u32",
                                [],
                                "forward_unchecked",
                                []
                              |),
                              [ M.read (| res |); Value.Integer 2048 ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "char", "from_u32_unchecked", [] |),
                  [ M.read (| res |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn backward_unchecked(start: char, count: usize) -> char {
              let start = start as u32;
              // SAFETY: the caller must guarantee that this doesn't overflow
              // the range of values for a char.
              let mut res = unsafe { Step::backward_unchecked(start, count) };
              if start >= 0xE000 && 0xE000 > res {
                  // SAFETY: the caller must guarantee that this doesn't overflow
                  // the range of values for a char.
                  res = unsafe { Step::backward_unchecked(res, 0x800) };
              }
              // SAFETY: because of the previous contract, this is guaranteed
              // by the caller to be a valid char.
              unsafe { char::from_u32_unchecked(res) }
          }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let start := M.alloc (| M.rust_cast (M.read (| start |)) |) in
              let res :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u32",
                      [],
                      "backward_unchecked",
                      []
                    |),
                    [ M.read (| start |); M.read (| count |) ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              LogicalOp.and (|
                                BinOp.Pure.ge (M.read (| start |)) (Value.Integer 57344),
                                ltac:(M.monadic
                                  (BinOp.Pure.gt (Value.Integer 57344) (M.read (| res |))))
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.write (|
                            res,
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u32",
                                [],
                                "backward_unchecked",
                                []
                              |),
                              [ M.read (| res |); Value.Integer 2048 ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "char", "from_u32_unchecked", [] |),
                  [ M.read (| res |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_char.
    
    Module Impl_core_iter_range_Step_for_core_ascii_ascii_char_AsciiChar.
      Definition Self : Ty.t := Ty.path "core::ascii::ascii_char::AsciiChar".
      
      (*
          fn steps_between(&start: &AsciiChar, &end: &AsciiChar) -> Option<usize> {
              Step::steps_between(&start.to_u8(), &end.to_u8())
          }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u8",
                                [],
                                "steps_between",
                                []
                              |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::ascii::ascii_char::AsciiChar",
                                      "to_u8",
                                      []
                                    |),
                                    [ M.read (| start |) ]
                                  |)
                                |);
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::ascii::ascii_char::AsciiChar",
                                      "to_u8",
                                      []
                                    |),
                                    [ M.read (| end_ |) ]
                                  |)
                                |)
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn forward_checked(start: AsciiChar, count: usize) -> Option<AsciiChar> {
              let end = Step::forward_checked(start.to_u8(), count)?;
              AsciiChar::from_u8(end)
          }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let end_ :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "u8" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u8",
                                  [],
                                  "forward_checked",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::ascii::ascii_char::AsciiChar",
                                      "to_u8",
                                      []
                                    |),
                                    [ M.read (| start |) ]
                                  |);
                                  M.read (| count |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::ascii::ascii_char::AsciiChar",
                        "from_u8",
                        []
                      |),
                      [ M.read (| end_ |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn backward_checked(start: AsciiChar, count: usize) -> Option<AsciiChar> {
              let end = Step::backward_checked(start.to_u8(), count)?;
      
              // SAFETY: Values below that of a valid ASCII character are also valid ASCII
              Some(unsafe { AsciiChar::from_u8_unchecked(end) })
          }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let end_ :=
                    M.copy (|
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply (Ty.path "core::option::Option") [ Ty.path "u8" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  Ty.path "u8",
                                  [],
                                  "backward_checked",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::ascii::ascii_char::AsciiChar",
                                      "to_u8",
                                      []
                                    |),
                                    [ M.read (| start |) ]
                                  |);
                                  M.read (| count |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "core::ascii::ascii_char::AsciiChar" ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              [ Ty.path "core::convert::Infallible" ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::ascii::ascii_char::AsciiChar",
                            "from_u8_unchecked",
                            []
                          |),
                          [ M.read (| end_ |) ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn forward_unchecked(start: AsciiChar, count: usize) -> AsciiChar {
              // SAFETY: Caller asserts that result is a valid ASCII character,
              // and therefore it is a valid u8.
              let end = unsafe { Step::forward_unchecked(start.to_u8(), count) };
      
              // SAFETY: Caller asserts that result is a valid ASCII character.
              unsafe { AsciiChar::from_u8_unchecked(end) }
          }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let end_ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u8",
                      [],
                      "forward_unchecked",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          []
                        |),
                        [ M.read (| start |) ]
                      |);
                      M.read (| count |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::ascii::ascii_char::AsciiChar",
                    "from_u8_unchecked",
                    []
                  |),
                  [ M.read (| end_ |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn backward_unchecked(start: AsciiChar, count: usize) -> AsciiChar {
              // SAFETY: Caller asserts that result is a valid ASCII character,
              // and therefore it is a valid u8.
              let end = unsafe { Step::backward_unchecked(start.to_u8(), count) };
      
              // SAFETY: Caller asserts that result is a valid ASCII character.
              unsafe { AsciiChar::from_u8_unchecked(end) }
          }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.read (|
              let end_ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      Ty.path "u8",
                      [],
                      "backward_unchecked",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::ascii::ascii_char::AsciiChar",
                          "to_u8",
                          []
                        |),
                        [ M.read (| start |) ]
                      |);
                      M.read (| count |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "core::ascii::ascii_char::AsciiChar",
                    "from_u8_unchecked",
                    []
                  |),
                  [ M.read (| end_ |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_core_ascii_ascii_char_AsciiChar.
    
    Module Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv4Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv4Addr".
      
      (*
          fn steps_between(&start: &Ipv4Addr, &end: &Ipv4Addr) -> Option<usize> {
              u32::steps_between(&start.to_bits(), &end.to_bits())
          }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u32",
                                [],
                                "steps_between",
                                []
                              |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::net::ip_addr::Ipv4Addr",
                                      "to_bits",
                                      []
                                    |),
                                    [ M.read (| start |) ]
                                  |)
                                |);
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::net::ip_addr::Ipv4Addr",
                                      "to_bits",
                                      []
                                    |),
                                    [ M.read (| end_ |) ]
                                  |)
                                |)
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn forward_checked(start: Ipv4Addr, count: usize) -> Option<Ipv4Addr> {
              u32::forward_checked(start.to_bits(), count).map(Ipv4Addr::from_bits)
          }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ],
                "map",
                [
                  Ty.path "core::net::ip_addr::Ipv4Addr";
                  Ty.function [ Ty.path "u32" ] (Ty.path "core::net::ip_addr::Ipv4Addr")
                ]
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    "forward_checked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv4Addr",
                  "from_bits",
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn backward_checked(start: Ipv4Addr, count: usize) -> Option<Ipv4Addr> {
              u32::backward_checked(start.to_bits(), count).map(Ipv4Addr::from_bits)
          }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Ty.path "u32" ],
                "map",
                [
                  Ty.path "core::net::ip_addr::Ipv4Addr";
                  Ty.function [ Ty.path "u32" ] (Ty.path "core::net::ip_addr::Ipv4Addr")
                ]
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    "backward_checked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv4Addr",
                  "from_bits",
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn forward_unchecked(start: Ipv4Addr, count: usize) -> Ipv4Addr {
              // SAFETY: Since u32 and Ipv4Addr are losslessly convertible,
              //   this is as safe as the u32 version.
              Ipv4Addr::from_bits(unsafe { u32::forward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv4Addr",
                "from_bits",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    "forward_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn backward_unchecked(start: Ipv4Addr, count: usize) -> Ipv4Addr {
              // SAFETY: Since u32 and Ipv4Addr are losslessly convertible,
              //   this is as safe as the u32 version.
              Ipv4Addr::from_bits(unsafe { u32::backward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv4Addr",
                "from_bits",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u32",
                    [],
                    "backward_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv4Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv4Addr.
    
    Module Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv6Addr.
      Definition Self : Ty.t := Ty.path "core::net::ip_addr::Ipv6Addr".
      
      (*
          fn steps_between(&start: &Ipv6Addr, &end: &Ipv6Addr) -> Option<usize> {
              u128::steps_between(&start.to_bits(), &end.to_bits())
          }
      *)
      Definition steps_between (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ β0; β1 ] =>
          ltac:(M.monadic
            (let β0 := M.alloc (| β0 |) in
            let β1 := M.alloc (| β1 |) in
            M.match_operator (|
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let start := M.copy (| γ |) in
                    M.match_operator (|
                      β1,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let end_ := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                Ty.path "u128",
                                [],
                                "steps_between",
                                []
                              |),
                              [
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::net::ip_addr::Ipv6Addr",
                                      "to_bits",
                                      []
                                    |),
                                    [ M.read (| start |) ]
                                  |)
                                |);
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::net::ip_addr::Ipv6Addr",
                                      "to_bits",
                                      []
                                    |),
                                    [ M.read (| end_ |) ]
                                  |)
                                |)
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn forward_checked(start: Ipv6Addr, count: usize) -> Option<Ipv6Addr> {
              u128::forward_checked(start.to_bits(), count).map(Ipv6Addr::from_bits)
          }
      *)
      Definition forward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Ty.path "u128" ],
                "map",
                [
                  Ty.path "core::net::ip_addr::Ipv6Addr";
                  Ty.function [ Ty.path "u128" ] (Ty.path "core::net::ip_addr::Ipv6Addr")
                ]
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    "forward_checked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv6Addr",
                  "from_bits",
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn backward_checked(start: Ipv6Addr, count: usize) -> Option<Ipv6Addr> {
              u128::backward_checked(start.to_bits(), count).map(Ipv6Addr::from_bits)
          }
      *)
      Definition backward_checked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [ Ty.path "u128" ],
                "map",
                [
                  Ty.path "core::net::ip_addr::Ipv6Addr";
                  Ty.function [ Ty.path "u128" ] (Ty.path "core::net::ip_addr::Ipv6Addr")
                ]
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    "backward_checked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |);
                M.get_associated_function (|
                  Ty.path "core::net::ip_addr::Ipv6Addr",
                  "from_bits",
                  []
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn forward_unchecked(start: Ipv6Addr, count: usize) -> Ipv6Addr {
              // SAFETY: Since u128 and Ipv6Addr are losslessly convertible,
              //   this is as safe as the u128 version.
              Ipv6Addr::from_bits(unsafe { u128::forward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition forward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv6Addr",
                "from_bits",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    "forward_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn backward_unchecked(start: Ipv6Addr, count: usize) -> Ipv6Addr {
              // SAFETY: Since u128 and Ipv6Addr are losslessly convertible,
              //   this is as safe as the u128 version.
              Ipv6Addr::from_bits(unsafe { u128::backward_unchecked(start.to_bits(), count) })
          }
      *)
      Definition backward_unchecked (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ start; count ] =>
          ltac:(M.monadic
            (let start := M.alloc (| start |) in
            let count := M.alloc (| count |) in
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "core::net::ip_addr::Ipv6Addr",
                "from_bits",
                []
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::range::Step",
                    Ty.path "u128",
                    [],
                    "backward_unchecked",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::net::ip_addr::Ipv6Addr",
                        "to_bits",
                        []
                      |),
                      [ M.read (| start |) ]
                    |);
                    M.read (| count |)
                  ]
                |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::range::Step"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("steps_between", InstanceField.Method steps_between);
            ("forward_checked", InstanceField.Method forward_checked);
            ("backward_checked", InstanceField.Method backward_checked);
            ("forward_unchecked", InstanceField.Method forward_unchecked);
            ("backward_unchecked", InstanceField.Method backward_unchecked)
          ].
    End Impl_core_iter_range_Step_for_core_net_ip_addr_Ipv6Addr.
    
    (* Trait *)
    (* Empty module 'RangeIteratorImpl' *)
    
    Module Impl_core_iter_range_RangeIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          default fn spec_next(&mut self) -> Option<A> {
              if self.start < self.end {
                  let n =
                      Step::forward_checked(self.start.clone(), 1).expect("`Step` invariants not upheld");
                  Some(mem::replace(&mut self.start, n))
              } else {
                  None
              }
          }
      *)
      Definition spec_next (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (| "core::cmp::PartialOrd", A, [ A ], "lt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let n :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [ A ],
                              "expect",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  A,
                                  [],
                                  "forward_checked",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      "clone",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::Range",
                                        "start"
                                      |)
                                    ]
                                  |);
                                  Value.Integer 1
                                ]
                              |);
                              M.read (| Value.String "`Step` invariants not upheld" |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_function (| "core::mem::replace", [ A ] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.read (| n |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_nth(&mut self, n: usize) -> Option<A> {
              if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {
                  if plus_n < self.end {
                      self.start =
                          Step::forward_checked(plus_n.clone(), 1).expect("`Step` invariants not upheld");
                      return Some(plus_n);
                  }
              }
      
              self.start = self.end.clone();
              None
          }
      *)
      Definition spec_nth (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    "forward_checked",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::Range",
                                          "start"
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let plus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              A,
                                              [ A ],
                                              "lt",
                                              []
                                            |),
                                            [
                                              plus_n;
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "end"
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "start"
                                              |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "core::option::Option") [ A ],
                                                  "expect",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::range::Step",
                                                      A,
                                                      [],
                                                      "forward_checked",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::clone::Clone",
                                                          A,
                                                          [],
                                                          "clone",
                                                          []
                                                        |),
                                                        [ plus_n ]
                                                      |);
                                                      Value.Integer 1
                                                    ]
                                                  |);
                                                  M.read (|
                                                    Value.String "`Step` invariants not upheld"
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::Range",
                        "start"
                      |),
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::Range",
                            "end"
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
              let available = if self.start <= self.end {
                  Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)
              } else {
                  0
              };
      
              let taken = available.min(n);
      
              self.start =
                  Step::forward_checked(self.start.clone(), taken).expect("`Step` invariants not upheld");
      
              NonZeroUsize::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_by (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let available :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    A,
                                    [ A ],
                                    "le",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                "unwrap_or",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    "steps_between",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |);
                                M.read (| M.get_constant (| "core::num::MAX" |) |)
                              ]
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                    ]
                  |)
                |) in
              let taken :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "min", [] |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "start"
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [ A ],
                      "expect",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::range::Step",
                          A,
                          [],
                          "forward_checked",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::ops::range::Range",
                                "start"
                              |)
                            ]
                          |);
                          M.read (| taken |)
                        ]
                      |);
                      M.read (| Value.String "`Step` invariants not upheld" |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                    "map_or",
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ];
                      Ty.function
                        [ Ty.path "core::num::nonzero::NonZeroUsize" ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "new",
                        []
                      |),
                      [ BinOp.Panic.sub (| Integer.Usize, M.read (| n |), M.read (| taken |) |) ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_next_back(&mut self) -> Option<A> {
              if self.start < self.end {
                  self.end =
                      Step::backward_checked(self.end.clone(), 1).expect("`Step` invariants not upheld");
                  Some(self.end.clone())
              } else {
                  None
              }
          }
      *)
      Definition spec_next_back (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (| "core::cmp::PartialOrd", A, [ A ], "lt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::Range",
                            "end"
                          |),
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::option::Option") [ A ],
                              "expect",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::range::Step",
                                  A,
                                  [],
                                  "backward_checked",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      A,
                                      [],
                                      "clone",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::Range",
                                        "end"
                                      |)
                                    ]
                                  |);
                                  Value.Integer 1
                                ]
                              |);
                              M.read (| Value.String "`Step` invariants not upheld" |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.call_closure (|
                              M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_nth_back(&mut self, n: usize) -> Option<A> {
              if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {
                  if minus_n > self.start {
                      self.end =
                          Step::backward_checked(minus_n, 1).expect("`Step` invariants not upheld");
                      return Some(self.end.clone());
                  }
              }
      
              self.end = self.start.clone();
              None
          }
      *)
      Definition spec_nth_back (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    "backward_checked",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::Range",
                                          "end"
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let minus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              A,
                                              [ A ],
                                              "gt",
                                              []
                                            |),
                                            [
                                              minus_n;
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "start"
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "end"
                                              |),
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "core::option::Option") [ A ],
                                                  "expect",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::iter::range::Step",
                                                      A,
                                                      [],
                                                      "backward_checked",
                                                      []
                                                    |),
                                                    [ M.read (| minus_n |); Value.Integer 1 ]
                                                  |);
                                                  M.read (|
                                                    Value.String "`Step` invariants not upheld"
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::clone::Clone",
                                                    A,
                                                    [],
                                                    "clone",
                                                    []
                                                  |),
                                                  [
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.read (| self |),
                                                      "core::ops::range::Range",
                                                      "end"
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::Range",
                        "end"
                      |),
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::Range",
                            "start"
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
              let available = if self.start <= self.end {
                  Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)
              } else {
                  0
              };
      
              let taken = available.min(n);
      
              self.end =
                  Step::backward_checked(self.end.clone(), taken).expect("`Step` invariants not upheld");
      
              NonZeroUsize::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_back_by (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let available :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    A,
                                    [ A ],
                                    "le",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                "unwrap_or",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    "steps_between",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |);
                                M.read (| M.get_constant (| "core::num::MAX" |) |)
                              ]
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                    ]
                  |)
                |) in
              let taken :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "min", [] |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "end"
                  |),
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [ A ],
                      "expect",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::range::Step",
                          A,
                          [],
                          "backward_checked",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::ops::range::Range",
                                "end"
                              |)
                            ]
                          |);
                          M.read (| taken |)
                        ]
                      |);
                      M.read (| Value.String "`Step` invariants not upheld" |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                    "map_or",
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ];
                      Ty.function
                        [ Ty.path "core::num::nonzero::NonZeroUsize" ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "new",
                        []
                      |),
                      [ BinOp.Panic.sub (| Integer.Usize, M.read (| n |), M.read (| taken |) |) ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeIteratorImpl"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("spec_next", InstanceField.Method (spec_next A));
            ("spec_nth", InstanceField.Method (spec_nth A));
            ("spec_advance_by", InstanceField.Method (spec_advance_by A));
            ("spec_next_back", InstanceField.Method (spec_next_back A));
            ("spec_nth_back", InstanceField.Method (spec_nth_back A));
            ("spec_advance_back_by", InstanceField.Method (spec_advance_back_by A))
          ].
    End Impl_core_iter_range_RangeIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_range_RangeIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_Range_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ T ].
      
      (*
          fn spec_next(&mut self) -> Option<T> {
              if self.start < self.end {
                  let old = self.start;
                  // SAFETY: just checked precondition
                  self.start = unsafe { Step::forward_unchecked(old, 1) };
                  Some(old)
              } else {
                  None
              }
          }
      *)
      Definition spec_next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let old :=
                        M.copy (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::Range",
                            "start"
                          |)
                        |) in
                      let _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::Range",
                            "start"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::range::Step",
                              T,
                              [],
                              "forward_unchecked",
                              []
                            |),
                            [ M.read (| old |); Value.Integer 1 ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple "core::option::Option::Some" [ M.read (| old |) ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_nth(&mut self, n: usize) -> Option<T> {
              if let Some(plus_n) = Step::forward_checked(self.start, n) {
                  if plus_n < self.end {
                      // SAFETY: just checked precondition
                      self.start = unsafe { Step::forward_unchecked(plus_n, 1) };
                      return Some(plus_n);
                  }
              }
      
              self.start = self.end;
              None
          }
      *)
      Definition spec_nth (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    T,
                                    [],
                                    "forward_checked",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::Range",
                                        "start"
                                      |)
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let plus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              T,
                                              [ T ],
                                              "lt",
                                              []
                                            |),
                                            [
                                              plus_n;
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "end"
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "start"
                                              |),
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::range::Step",
                                                  T,
                                                  [],
                                                  "forward_unchecked",
                                                  []
                                                |),
                                                [ M.read (| plus_n |); Value.Integer 1 ]
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::Range",
                        "start"
                      |),
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::ops::range::Range",
                          "end"
                        |)
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
              let available = if self.start <= self.end {
                  Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)
              } else {
                  0
              };
      
              let taken = available.min(n);
      
              // SAFETY: the conditions above ensure that the count is in bounds. If start <= end
              // then steps_between either returns a bound to which we clamp or returns None which
              // together with the initial inequality implies more than usize::MAX steps.
              // Otherwise 0 is returned which always safe to use.
              self.start = unsafe { Step::forward_unchecked(self.start, taken) };
      
              NonZeroUsize::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_by (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let available :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    T,
                                    [ T ],
                                    "le",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                "unwrap_or",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    T,
                                    [],
                                    "steps_between",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |);
                                M.read (| M.get_constant (| "core::num::MAX" |) |)
                              ]
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                    ]
                  |)
                |) in
              let taken :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "min", [] |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "start"
                  |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      T,
                      [],
                      "forward_unchecked",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::ops::range::Range",
                          "start"
                        |)
                      |);
                      M.read (| taken |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                    "map_or",
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ];
                      Ty.function
                        [ Ty.path "core::num::nonzero::NonZeroUsize" ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "new",
                        []
                      |),
                      [ BinOp.Panic.sub (| Integer.Usize, M.read (| n |), M.read (| taken |) |) ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_next_back(&mut self) -> Option<T> {
              if self.start < self.end {
                  // SAFETY: just checked precondition
                  self.end = unsafe { Step::backward_unchecked(self.end, 1) };
                  Some(self.end)
              } else {
                  None
              }
          }
      *)
      Definition spec_next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.write (|
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::Range",
                            "end"
                          |),
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::range::Step",
                              T,
                              [],
                              "backward_unchecked",
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              |);
                              Value.Integer 1
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::ops::range::Range",
                                "end"
                              |)
                            |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_nth_back(&mut self, n: usize) -> Option<T> {
              if let Some(minus_n) = Step::backward_checked(self.end, n) {
                  if minus_n > self.start {
                      // SAFETY: just checked precondition
                      self.end = unsafe { Step::backward_unchecked(minus_n, 1) };
                      return Some(self.end);
                  }
              }
      
              self.end = self.start;
              None
          }
      *)
      Definition spec_nth_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    T,
                                    [],
                                    "backward_checked",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::Range",
                                        "end"
                                      |)
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let minus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialOrd",
                                              T,
                                              [ T ],
                                              "gt",
                                              []
                                            |),
                                            [
                                              minus_n;
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "start"
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::Range",
                                                "end"
                                              |),
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::range::Step",
                                                  T,
                                                  [],
                                                  "backward_unchecked",
                                                  []
                                                |),
                                                [ M.read (| minus_n |); Value.Integer 1 ]
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::ops::range::Range",
                                                    "end"
                                                  |)
                                                |)
                                              ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::Range",
                        "end"
                      |),
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::ops::range::Range",
                          "start"
                        |)
                      |)
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
              let available = if self.start <= self.end {
                  Step::steps_between(&self.start, &self.end).unwrap_or(usize::MAX)
              } else {
                  0
              };
      
              let taken = available.min(n);
      
              // SAFETY: same as the spec_advance_by() implementation
              self.end = unsafe { Step::backward_unchecked(self.end, taken) };
      
              NonZeroUsize::new(n - taken).map_or(Ok(()), Err)
          }
      *)
      Definition spec_advance_back_by (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let available :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    T,
                                    [ T ],
                                    "le",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                "unwrap_or",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    T,
                                    [],
                                    "steps_between",
                                    []
                                  |),
                                  [
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "start"
                                    |);
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::Range",
                                      "end"
                                    |)
                                  ]
                                |);
                                M.read (| M.get_constant (| "core::num::MAX" |) |)
                              ]
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                    ]
                  |)
                |) in
              let taken :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::cmp::Ord", Ty.path "usize", [], "min", [] |),
                    [ M.read (| available |); M.read (| n |) ]
                  |)
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::Range",
                    "end"
                  |),
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::range::Step",
                      T,
                      [],
                      "backward_unchecked",
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::ops::range::Range",
                          "end"
                        |)
                      |);
                      M.read (| taken |)
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::num::nonzero::NonZeroUsize" ],
                    "map_or",
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ];
                      Ty.function
                        [ Ty.path "core::num::nonzero::NonZeroUsize" ]
                        (Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.tuple []; Ty.path "core::num::nonzero::NonZeroUsize" ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::num::nonzero::NonZeroUsize",
                        "new",
                        []
                      |),
                      [ BinOp.Panic.sub (| Integer.Usize, M.read (| n |), M.read (| taken |) |) ]
                    |);
                    Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ];
                    M.constructor_as_closure "core::result::Result::Err"
                  ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeIteratorImpl"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("spec_next", InstanceField.Method (spec_next T));
            ("spec_nth", InstanceField.Method (spec_nth T));
            ("spec_advance_by", InstanceField.Method (spec_advance_by T));
            ("spec_next_back", InstanceField.Method (spec_next_back T));
            ("spec_nth_back", InstanceField.Method (spec_nth_back T));
            ("spec_advance_back_by", InstanceField.Method (spec_advance_back_by T))
          ].
    End Impl_core_iter_range_RangeIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_Range_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          fn next(&mut self) -> Option<A> {
              self.spec_next()
          }
      *)
      Definition next (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "spec_next",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.start < self.end {
                  let hint = Step::steps_between(&self.start, &self.end);
                  (hint.unwrap_or(usize::MAX), hint)
              } else {
                  (0, Some(0))
              }
          }
      *)
      Definition size_hint (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (| "core::cmp::PartialOrd", A, [ A ], "lt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  M.read (| self |),
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let hint :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::range::Step",
                              A,
                              [],
                              "steps_between",
                              []
                            |),
                            [
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::ops::range::Range",
                                "start"
                              |);
                              M.SubPointer.get_struct_record_field (|
                                M.read (| self |),
                                "core::ops::range::Range",
                                "end"
                              |)
                            ]
                          |)
                        |) in
                      M.alloc (|
                        Value.Tuple
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                                "unwrap_or",
                                []
                              |),
                              [
                                M.read (| hint |);
                                M.read (| M.get_constant (| "core::num::MAX" |) |)
                              ]
                            |);
                            M.read (| hint |)
                          ]
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        Value.Tuple
                          [
                            Value.Integer 0;
                            Value.StructTuple "core::option::Option::Some" [ Value.Integer 0 ]
                          ]
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              if self.start < self.end {
                  Step::steps_between(&self.start, &self.end).expect("count overflowed usize")
              } else {
                  0
              }
          }
      *)
      Definition count (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (| "core::cmp::PartialOrd", A, [ A ], "lt", [] |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                            "expect",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                A,
                                [],
                                "steps_between",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::ops::range::Range",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::ops::range::Range",
                                  "end"
                                |)
                              ]
                            |);
                            M.read (| Value.String "count overflowed usize" |)
                          ]
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Integer 0 |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<A> {
              self.spec_nth(n)
          }
      *)
      Definition nth (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "spec_nth",
                []
              |),
              [ M.read (| self |); M.read (| n |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<A> {
              self.next_back()
          }
      *)
      Definition last (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn min(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next()
          }
      *)
      Definition min (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "next",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn max(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next_back()
          }
      *)
      Definition max (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn is_sorted(self) -> bool {
              true
          }
      *)
      Definition is_sorted (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Bool true))
        | _, _ => M.impossible
        end.
      
      (*
          fn advance_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
              self.spec_advance_by(n)
          }
      *)
      Definition advance_by (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "spec_advance_by",
                []
              |),
              [ M.read (| self |); M.read (| n |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item
          where
              Self: TrustedRandomAccessNoCoerce,
          {
              // SAFETY: The TrustedRandomAccess contract requires that callers only pass an index
              // that is in bounds.
              // Additionally Self: TrustedRandomAccess is only implemented for Copy types
              // which means even repeated reads of the same index would be safe.
              unsafe { Step::forward_unchecked(self.start.clone(), idx) }
          }
      *)
      Definition __iterator_get_unchecked (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; idx ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let idx := M.alloc (| idx |) in
            M.call_closure (|
              M.get_trait_method (| "core::iter::range::Step", A, [], "forward_unchecked", [] |),
              [
                M.call_closure (|
                  M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                  [
                    M.SubPointer.get_struct_record_field (|
                      M.read (| self |),
                      "core::ops::range::Range",
                      "start"
                    |)
                  ]
                |);
                M.read (| idx |)
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("next", InstanceField.Method (next A));
            ("size_hint", InstanceField.Method (size_hint A));
            ("count", InstanceField.Method (count A));
            ("nth", InstanceField.Method (nth A));
            ("last", InstanceField.Method (last A));
            ("min", InstanceField.Method (min A));
            ("max", InstanceField.Method (max A));
            ("is_sorted", InstanceField.Method (is_sorted A));
            ("advance_by", InstanceField.Method (advance_by A));
            ("__iterator_get_unchecked", InstanceField.Method (__iterator_get_unchecked A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_usize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_usize.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u16.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_isize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "isize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_isize.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i16.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_u32.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_Range_i32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_usize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_usize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_usize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_usize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u8" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u16" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_isize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "isize" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_isize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_isize.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "isize" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_isize.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i8.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i8" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i8.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i16.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i16" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i16.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u32" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i32" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i32.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i32" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i32.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u64" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_u64.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "u64" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_u64.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i64" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccess"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_adapters_zip_TrustedRandomAccess_for_core_ops_range_Range_i64.
    
    Module Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i64.
      Definition Self : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "i64" ].
      
      (*             const MAY_HAVE_SIDE_EFFECT: bool = false; *)
      (* Ty.path "bool" *)
      Definition value_MAY_HAVE_SIDE_EFFECT : Value.t :=
        M.run ltac:(M.monadic (M.alloc (| Value.Bool false |))).
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::adapters::zip::TrustedRandomAccessNoCoerce"
          Self
          (* Trait polymorphic types *) []
          (* Instance *)
          [ ("value_MAY_HAVE_SIDE_EFFECT", InstanceField.Constant value_MAY_HAVE_SIDE_EFFECT) ].
    End Impl_core_iter_adapters_zip_TrustedRandomAccessNoCoerce_for_core_ops_range_Range_i64.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ Ty.path "u8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i8.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ Ty.path "i8" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i8.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ Ty.path "u16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_u16.
    
    Module Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i16.
      Definition Self : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ Ty.path "i16" ].
      
      Axiom Implements :
        M.IsTraitInstance
          "core::iter::traits::exact_size::ExactSizeIterator"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_exact_size_ExactSizeIterator_for_core_ops_range_RangeInclusive_i16.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ A ].
      
      (*
          fn next_back(&mut self) -> Option<A> {
              self.spec_next_back()
          }
      *)
      Definition next_back (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "spec_next_back",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<A> {
              self.spec_nth_back(n)
          }
      *)
      Definition nth_back (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "spec_nth_back",
                []
              |),
              [ M.read (| self |); M.read (| n |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn advance_back_by(&mut self, n: usize) -> Result<(), NonZeroUsize> {
              self.spec_advance_back_by(n)
          }
      *)
      Definition advance_back_by (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::Range") [ A ],
                [],
                "spec_advance_back_by",
                []
              |),
              [ M.read (| self |); M.read (| n |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back A));
            ("nth_back", InstanceField.Method (nth_back A));
            ("advance_back_by", InstanceField.Method (advance_back_by A))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::Range") [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_Range_A.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::RangeFrom") [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          fn next(&mut self) -> Option<A> {
              let n = Step::forward(self.start.clone(), 1);
              Some(mem::replace(&mut self.start, n))
          }
      *)
      Definition next (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              let n :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::iter::range::Step", A, [], "forward", [] |),
                    [
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeFrom",
                            "start"
                          |)
                        ]
                      |);
                      Value.Integer 1
                    ]
                  |)
                |) in
              M.alloc (|
                Value.StructTuple
                  "core::option::Option::Some"
                  [
                    M.call_closure (|
                      M.get_function (| "core::mem::replace", [ A ] |),
                      [
                        M.SubPointer.get_struct_record_field (|
                          M.read (| self |),
                          "core::ops::range::RangeFrom",
                          "start"
                        |);
                        M.read (| n |)
                      ]
                    |)
                  ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              (usize::MAX, None)
          }
      *)
      Definition size_hint (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Tuple
              [
                M.read (| M.get_constant (| "core::num::MAX" |) |);
                Value.StructTuple "core::option::Option::None" []
              ]))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<A> {
              let plus_n = Step::forward(self.start.clone(), n);
              self.start = Step::forward(plus_n.clone(), 1);
              Some(plus_n)
          }
      *)
      Definition nth (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.read (|
              let plus_n :=
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (| "core::iter::range::Step", A, [], "forward", [] |),
                    [
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeFrom",
                            "start"
                          |)
                        ]
                      |);
                      M.read (| n |)
                    ]
                  |)
                |) in
              let _ :=
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.read (| self |),
                    "core::ops::range::RangeFrom",
                    "start"
                  |),
                  M.call_closure (|
                    M.get_trait_method (| "core::iter::range::Step", A, [], "forward", [] |),
                    [
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [ plus_n ]
                      |);
                      Value.Integer 1
                    ]
                  |)
                |) in
              M.alloc (| Value.StructTuple "core::option::Option::Some" [ M.read (| plus_n |) ] |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("next", InstanceField.Method (next A));
            ("size_hint", InstanceField.Method (size_hint A));
            ("nth", InstanceField.Method (nth A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeFrom_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::RangeFrom") [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeFrom_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
      Definition Self (A : Ty.t) : Ty.t := Ty.apply (Ty.path "core::ops::range::RangeFrom") [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeFrom_A.
    
    (* Trait *)
    (* Empty module 'RangeInclusiveIteratorImpl' *)
    
    Module Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          default fn spec_next(&mut self) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  let n =
                      Step::forward_checked(self.start.clone(), 1).expect("`Step` invariants not upheld");
                  mem::replace(&mut self.start, n)
              } else {
                  self.exhausted = true;
                  self.start.clone()
              })
          }
      *)
      Definition spec_next (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let is_iterating :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::cmp::PartialOrd", A, [ A ], "lt", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "start"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "end"
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let n :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "core::option::Option") [ A ],
                                          "expect",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::range::Step",
                                              A,
                                              [],
                                              "forward_checked",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  A,
                                                  [],
                                                  "clone",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::ops::range::RangeInclusive",
                                                    "start"
                                                  |)
                                                ]
                                              |);
                                              Value.Integer 1
                                            ]
                                          |);
                                          M.read (| Value.String "`Step` invariants not upheld" |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ A ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "exhausted"
                                      |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, A) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  let n =
                      Step::forward_checked(self.start.clone(), 1).expect("`Step` invariants not upheld");
                  let n = mem::replace(&mut self.start, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start.clone())?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_fold (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        "from_output",
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let accum := M.copy (| init |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          A,
                                          [ A ],
                                          "lt",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |);
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::option::Option") [ A ],
                                        "expect",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::range::Step",
                                            A,
                                            [],
                                            "forward_checked",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                A,
                                                [],
                                                "clone",
                                                []
                                              |),
                                              [
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "core::ops::range::RangeInclusive",
                                                  "start"
                                                |)
                                              ]
                                            |);
                                            Value.Integer 1
                                          ]
                                        |);
                                        M.read (| Value.String "`Step` invariants not upheld" |)
                                      ]
                                    |)
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ A ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let _ :=
                                  M.write (|
                                    accum,
                                    M.read (|
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::Try",
                                              R,
                                              [],
                                              "branch",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ B; A ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  f;
                                                  Value.Tuple [ M.read (| accum |); M.read (| n |) ]
                                                ]
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Break",
                                                  0
                                                |) in
                                              let residual := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::FromResidual",
                                                          R,
                                                          [ Ty.associated ],
                                                          "from_residual",
                                                          []
                                                        |),
                                                        [ M.read (| residual |) ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                  0
                                                |) in
                                              let val := M.copy (| γ0_0 |) in
                                              val))
                                        ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "exhausted"
                      |),
                      Value.Bool true
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      A,
                                      [ A ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "start"
                                      |);
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "end"
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                accum,
                                M.read (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          R,
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              F,
                                              [ Ty.tuple [ B; A ] ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              f;
                                              Value.Tuple
                                                [
                                                  M.read (| accum |);
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      A,
                                                      [],
                                                      "clone",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::ops::range::RangeInclusive",
                                                        "start"
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      R,
                                                      [ Ty.associated ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        "from_output",
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_next_back(&mut self) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  let n =
                      Step::backward_checked(self.end.clone(), 1).expect("`Step` invariants not upheld");
                  mem::replace(&mut self.end, n)
              } else {
                  self.exhausted = true;
                  self.end.clone()
              })
          }
      *)
      Definition spec_next_back (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let is_iterating :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::cmp::PartialOrd", A, [ A ], "lt", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "start"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "end"
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let n :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "core::option::Option") [ A ],
                                          "expect",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::range::Step",
                                              A,
                                              [],
                                              "backward_checked",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  A,
                                                  [],
                                                  "clone",
                                                  []
                                                |),
                                                [
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.read (| self |),
                                                    "core::ops::range::RangeInclusive",
                                                    "end"
                                                  |)
                                                ]
                                              |);
                                              Value.Integer 1
                                            ]
                                          |);
                                          M.read (| Value.String "`Step` invariants not upheld" |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ A ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "exhausted"
                                      |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          default fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, A) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  let n =
                      Step::backward_checked(self.end.clone(), 1).expect("`Step` invariants not upheld");
                  let n = mem::replace(&mut self.end, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start.clone())?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_rfold (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        "from_output",
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let accum := M.copy (| init |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          A,
                                          [ A ],
                                          "lt",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |);
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "core::option::Option") [ A ],
                                        "expect",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::range::Step",
                                            A,
                                            [],
                                            "backward_checked",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::clone::Clone",
                                                A,
                                                [],
                                                "clone",
                                                []
                                              |),
                                              [
                                                M.SubPointer.get_struct_record_field (|
                                                  M.read (| self |),
                                                  "core::ops::range::RangeInclusive",
                                                  "end"
                                                |)
                                              ]
                                            |);
                                            Value.Integer 1
                                          ]
                                        |);
                                        M.read (| Value.String "`Step` invariants not upheld" |)
                                      ]
                                    |)
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ A ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let _ :=
                                  M.write (|
                                    accum,
                                    M.read (|
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::Try",
                                              R,
                                              [],
                                              "branch",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ B; A ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  f;
                                                  Value.Tuple [ M.read (| accum |); M.read (| n |) ]
                                                ]
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Break",
                                                  0
                                                |) in
                                              let residual := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::FromResidual",
                                                          R,
                                                          [ Ty.associated ],
                                                          "from_residual",
                                                          []
                                                        |),
                                                        [ M.read (| residual |) ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                  0
                                                |) in
                                              let val := M.copy (| γ0_0 |) in
                                              val))
                                        ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "exhausted"
                      |),
                      Value.Bool true
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      A,
                                      [ A ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "start"
                                      |);
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "end"
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                accum,
                                M.read (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          R,
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              F,
                                              [ Ty.tuple [ B; A ] ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              f;
                                              Value.Tuple
                                                [
                                                  M.read (| accum |);
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      A,
                                                      [],
                                                      "clone",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::ops::range::RangeInclusive",
                                                        "start"
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      R,
                                                      [ Ty.associated ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        "from_output",
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeInclusiveIteratorImpl"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("spec_next", InstanceField.Method (spec_next A));
            ("spec_try_fold", InstanceField.Method (spec_try_fold A));
            ("spec_next_back", InstanceField.Method (spec_next_back A));
            ("spec_try_rfold", InstanceField.Method (spec_try_rfold A))
          ].
    End Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_RangeInclusive_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ T ].
      
      (*
          fn spec_next(&mut self) -> Option<T> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };
                  mem::replace(&mut self.start, n)
              } else {
                  self.exhausted = true;
                  self.start.clone()
              })
          }
      *)
      Definition spec_next (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ T ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let is_iterating :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "start"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "end"
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let n :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          T,
                                          [],
                                          "forward_unchecked",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              T,
                                              [],
                                              "clone",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "start"
                                              |)
                                            ]
                                          |);
                                          Value.Integer 1
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ T ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "exhausted"
                                      |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        T,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, T) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };
                  let n = mem::replace(&mut self.start, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start.clone())?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_fold (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ T ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        "from_output",
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let accum := M.copy (| init |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          T,
                                          [ T ],
                                          "lt",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |);
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        T,
                                        [],
                                        "forward_unchecked",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            T,
                                            [],
                                            "clone",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::ops::range::RangeInclusive",
                                              "start"
                                            |)
                                          ]
                                        |);
                                        Value.Integer 1
                                      ]
                                    |)
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ T ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let _ :=
                                  M.write (|
                                    accum,
                                    M.read (|
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::Try",
                                              R,
                                              [],
                                              "branch",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ B; T ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  f;
                                                  Value.Tuple [ M.read (| accum |); M.read (| n |) ]
                                                ]
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Break",
                                                  0
                                                |) in
                                              let residual := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::FromResidual",
                                                          R,
                                                          [ Ty.associated ],
                                                          "from_residual",
                                                          []
                                                        |),
                                                        [ M.read (| residual |) ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                  0
                                                |) in
                                              let val := M.copy (| γ0_0 |) in
                                              val))
                                        ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "exhausted"
                      |),
                      Value.Bool true
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      T,
                                      [ T ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "start"
                                      |);
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "end"
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                accum,
                                M.read (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          R,
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              F,
                                              [ Ty.tuple [ B; T ] ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              f;
                                              Value.Tuple
                                                [
                                                  M.read (| accum |);
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      T,
                                                      [],
                                                      "clone",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::ops::range::RangeInclusive",
                                                        "start"
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      R,
                                                      [ Ty.associated ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        "from_output",
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_next_back(&mut self) -> Option<T> {
              if self.is_empty() {
                  return None;
              }
              let is_iterating = self.start < self.end;
              Some(if is_iterating {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };
                  mem::replace(&mut self.end, n)
              } else {
                  self.exhausted = true;
                  self.end.clone()
              })
          }
      *)
      Definition spec_next_back (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ T ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let is_iterating :=
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (| "core::cmp::PartialOrd", T, [ T ], "lt", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "start"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "end"
                          |)
                        ]
                      |)
                    |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.read (|
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ := M.use is_iterating in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  let n :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::range::Step",
                                          T,
                                          [],
                                          "backward_unchecked",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              T,
                                              [],
                                              "clone",
                                              []
                                            |),
                                            [
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "end"
                                              |)
                                            ]
                                          |);
                                          Value.Integer 1
                                        ]
                                      |)
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ T ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.write (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "exhausted"
                                      |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        T,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |)
                                      ]
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn spec_try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, T) -> R,
              R: Try<Output = B>,
          {
              if self.is_empty() {
                  return try { init };
              }
      
              let mut accum = init;
      
              while self.start < self.end {
                  // SAFETY: just checked precondition
                  let n = unsafe { Step::backward_unchecked(self.end.clone(), 1) };
                  let n = mem::replace(&mut self.end, n);
                  accum = f(accum, n)?;
              }
      
              self.exhausted = true;
      
              if self.start == self.end {
                  accum = f(accum, self.start.clone())?;
              }
      
              try { accum }
          }
      *)
      Definition spec_try_rfold (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match τ, α with
        | [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ T ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        R,
                                        [],
                                        "from_output",
                                        []
                                      |),
                                      [ M.read (| init |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let accum := M.copy (| init |) in
                  let _ :=
                    M.loop (|
                      ltac:(M.monadic
                        (M.match_operator (|
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          T,
                                          [ T ],
                                          "lt",
                                          []
                                        |),
                                        [
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "start"
                                          |);
                                          M.SubPointer.get_struct_record_field (|
                                            M.read (| self |),
                                            "core::ops::range::RangeInclusive",
                                            "end"
                                          |)
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  M.is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::range::Step",
                                        T,
                                        [],
                                        "backward_unchecked",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::clone::Clone",
                                            T,
                                            [],
                                            "clone",
                                            []
                                          |),
                                          [
                                            M.SubPointer.get_struct_record_field (|
                                              M.read (| self |),
                                              "core::ops::range::RangeInclusive",
                                              "end"
                                            |)
                                          ]
                                        |);
                                        Value.Integer 1
                                      ]
                                    |)
                                  |) in
                                let n :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (| "core::mem::replace", [ T ] |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |);
                                        M.read (| n |)
                                      ]
                                    |)
                                  |) in
                                let _ :=
                                  M.write (|
                                    accum,
                                    M.read (|
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::Try",
                                              R,
                                              [],
                                              "branch",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::ops::function::FnMut",
                                                  F,
                                                  [ Ty.tuple [ B; T ] ],
                                                  "call_mut",
                                                  []
                                                |),
                                                [
                                                  f;
                                                  Value.Tuple [ M.read (| accum |); M.read (| n |) ]
                                                ]
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Break",
                                                  0
                                                |) in
                                              let residual := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::FromResidual",
                                                          R,
                                                          [ Ty.associated ],
                                                          "from_residual",
                                                          []
                                                        |),
                                                        [ M.read (| residual |) ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                  0
                                                |) in
                                              let val := M.copy (| γ0_0 |) in
                                              val))
                                        ]
                                      |)
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let _ :=
                                        M.alloc (|
                                          M.never_to_any (| M.read (| M.break (||) |) |)
                                        |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "exhausted"
                      |),
                      Value.Bool true
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      T,
                                      [ T ],
                                      "eq",
                                      []
                                    |),
                                    [
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "start"
                                      |);
                                      M.SubPointer.get_struct_record_field (|
                                        M.read (| self |),
                                        "core::ops::range::RangeInclusive",
                                        "end"
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let _ :=
                              M.write (|
                                accum,
                                M.read (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          R,
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::function::FnMut",
                                              F,
                                              [ Ty.tuple [ B; T ] ],
                                              "call_mut",
                                              []
                                            |),
                                            [
                                              f;
                                              Value.Tuple
                                                [
                                                  M.read (| accum |);
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      T,
                                                      [],
                                                      "clone",
                                                      []
                                                    |),
                                                    [
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.read (| self |),
                                                        "core::ops::range::RangeInclusive",
                                                        "start"
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      R,
                                                      [ Ty.associated ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |)
                                |)
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        R,
                        [],
                        "from_output",
                        []
                      |),
                      [ M.read (| accum |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::iter::range::RangeInclusiveIteratorImpl"
          (Self T)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("spec_next", InstanceField.Method (spec_next T));
            ("spec_try_fold", InstanceField.Method (spec_try_fold T));
            ("spec_next_back", InstanceField.Method (spec_next_back T));
            ("spec_try_rfold", InstanceField.Method (spec_try_rfold T))
          ].
    End Impl_core_iter_range_RangeInclusiveIteratorImpl_where_core_iter_traits_marker_TrustedStep_T_for_core_ops_range_RangeInclusive_T.
    
    Module Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ].
      
      (*     type Item = A; *)
      Definition _Item (A : Ty.t) : Ty.t := A.
      
      (*
          fn next(&mut self) -> Option<A> {
              self.spec_next()
          }
      *)
      Definition next (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                [],
                "spec_next",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn size_hint(&self) -> (usize, Option<usize>) {
              if self.is_empty() {
                  return (0, Some(0));
              }
      
              match Step::steps_between(&self.start, &self.end) {
                  Some(hint) => (hint.saturating_add(1), hint.checked_add(1)),
                  None => (usize::MAX, None),
              }
          }
      *)
      Definition size_hint (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.Tuple
                                      [
                                        Value.Integer 0;
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          [ Value.Integer 0 ]
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::range::Step",
                          A,
                          [],
                          "steps_between",
                          []
                        |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "start"
                          |);
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "end"
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let hint := M.copy (| γ0_0 |) in
                          M.alloc (|
                            Value.Tuple
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "saturating_add",
                                    []
                                  |),
                                  [ M.read (| hint |); Value.Integer 1 ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "checked_add",
                                    []
                                  |),
                                  [ M.read (| hint |); Value.Integer 1 ]
                                |)
                              ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            Value.Tuple
                              [
                                M.read (| M.get_constant (| "core::num::MAX" |) |);
                                Value.StructTuple "core::option::Option::None" []
                              ]
                          |)))
                    ]
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn count(self) -> usize {
              if self.is_empty() {
                  return 0;
              }
      
              Step::steps_between(&self.start, &self.end)
                  .and_then(|steps| steps.checked_add(1))
                  .expect("count overflowed usize")
          }
      *)
      Definition count (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ self ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| Value.Integer 0 |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                        "expect",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ],
                            "and_then",
                            [
                              Ty.path "usize";
                              Ty.function
                                [ Ty.tuple [ Ty.path "usize" ] ]
                                (Ty.apply (Ty.path "core::option::Option") [ Ty.path "usize" ])
                            ]
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::range::Step",
                                A,
                                [],
                                "steps_between",
                                []
                              |),
                              [
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::ops::range::RangeInclusive",
                                  "start"
                                |);
                                M.SubPointer.get_struct_record_field (|
                                  self,
                                  "core::ops::range::RangeInclusive",
                                  "end"
                                |)
                              ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    M.match_operator (|
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let steps := M.copy (| γ |) in
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "usize",
                                                "checked_add",
                                                []
                                              |),
                                              [ M.read (| steps |); Value.Integer 1 ]
                                            |)))
                                      ]
                                    |)
                                  | _ => M.impossible (||)
                                  end))
                          ]
                        |);
                        M.read (| Value.String "count overflowed usize" |)
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth(&mut self, n: usize) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
      
              if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {
                  use crate::cmp::Ordering::*;
      
                  match plus_n.partial_cmp(&self.end) {
                      Some(Less) => {
                          self.start = Step::forward(plus_n.clone(), 1);
                          return Some(plus_n);
                      }
                      Some(Equal) => {
                          self.start = plus_n.clone();
                          self.exhausted = true;
                          return Some(plus_n);
                      }
                      _ => {}
                  }
              }
      
              self.start = self.end.clone();
              self.exhausted = true;
              None
          }
      *)
      Definition nth (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    "forward_checked",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "start"
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let plus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    A,
                                    [ A ],
                                    "partial_cmp",
                                    []
                                  |),
                                  [
                                    plus_n;
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::RangeInclusive",
                                      "end"
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "start"
                                              |),
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::range::Step",
                                                  A,
                                                  [],
                                                  "forward",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      A,
                                                      [],
                                                      "clone",
                                                      []
                                                    |),
                                                    [ plus_n ]
                                                  |);
                                                  Value.Integer 1
                                                ]
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "start"
                                              |),
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  A,
                                                  [],
                                                  "clone",
                                                  []
                                                |),
                                                [ plus_n ]
                                              |)
                                            |) in
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "exhausted"
                                              |),
                                              Value.Bool true
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| plus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "start"
                      |),
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "end"
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "exhausted"
                      |),
                      Value.Bool true
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, Self::Item) -> R,
              R: Try<Output = B>,
          {
              self.spec_try_fold(init, f)
          }
      *)
      Definition try_fold (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                [],
                "spec_try_fold",
                [ B; F; R ]
              |),
              [ M.read (| self |); M.read (| init |); M.read (| f |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn $fold<AAA, FFF>(mut self, init: AAA, fold: FFF) -> AAA
              where
                  FFF: FnMut(AAA, Self::Item) -> AAA,
              {
                  use crate::ops::NeverShortCircuit;
      
                  self.$try_fold(init, NeverShortCircuit::wrap_mut_2(fold)).0
              }
      *)
      Definition fold (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [ AAA; FFF ], [ self; init; fold ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let fold := M.alloc (| fold |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                      [],
                      "try_fold",
                      [
                        AAA;
                        Ty.associated;
                        Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ AAA ]
                      ]
                    |),
                    [
                      self;
                      M.read (| init |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ AAA ],
                          "wrap_mut_2",
                          [ AAA; A; FFF ]
                        |),
                        [ M.read (| fold |) ]
                      |)
                    ]
                  |)
                |),
                "core::ops::try_trait::NeverShortCircuit",
                0
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn last(mut self) -> Option<A> {
              self.next_back()
          }
      *)
      Definition last (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn min(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next()
          }
      *)
      Definition min (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                [],
                "next",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn max(mut self) -> Option<A>
          where
              A: Ord,
          {
              self.next_back()
          }
      *)
      Definition max (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::double_ended::DoubleEndedIterator",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                [],
                "next_back",
                []
              |),
              [ self ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn is_sorted(self) -> bool {
              true
          }
      *)
      Definition is_sorted (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            Value.Bool true))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::iterator::Iterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item A));
            ("next", InstanceField.Method (next A));
            ("size_hint", InstanceField.Method (size_hint A));
            ("count", InstanceField.Method (count A));
            ("nth", InstanceField.Method (nth A));
            ("try_fold", InstanceField.Method (try_fold A));
            ("fold", InstanceField.Method (fold A));
            ("last", InstanceField.Method (last A));
            ("min", InstanceField.Method (min A));
            ("max", InstanceField.Method (max A));
            ("is_sorted", InstanceField.Method (is_sorted A))
          ].
    End Impl_core_iter_traits_iterator_Iterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ].
      
      (*
          fn next_back(&mut self) -> Option<A> {
              self.spec_next_back()
          }
      *)
      Definition next_back (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                [],
                "spec_next_back",
                []
              |),
              [ M.read (| self |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn nth_back(&mut self, n: usize) -> Option<A> {
              if self.is_empty() {
                  return None;
              }
      
              if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {
                  use crate::cmp::Ordering::*;
      
                  match minus_n.partial_cmp(&self.start) {
                      Some(Greater) => {
                          self.end = Step::backward(minus_n.clone(), 1);
                          return Some(minus_n);
                      }
                      Some(Equal) => {
                          self.end = minus_n.clone();
                          self.exhausted = true;
                          return Some(minus_n);
                      }
                      _ => {}
                  }
              }
      
              self.end = self.start.clone();
              self.exhausted = true;
              None
          }
      *)
      Definition nth_back (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [], [ self; n ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let n := M.alloc (| n |) in
            M.catch_return (|
              ltac:(M.monadic
                (M.read (|
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                                      "is_empty",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::range::Step",
                                    A,
                                    [],
                                    "backward_checked",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::clone::Clone",
                                        A,
                                        [],
                                        "clone",
                                        []
                                      |),
                                      [
                                        M.SubPointer.get_struct_record_field (|
                                          M.read (| self |),
                                          "core::ops::range::RangeInclusive",
                                          "end"
                                        |)
                                      ]
                                    |);
                                    M.read (| n |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let minus_n := M.copy (| γ0_0 |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    A,
                                    [ A ],
                                    "partial_cmp",
                                    []
                                  |),
                                  [
                                    minus_n;
                                    M.SubPointer.get_struct_record_field (|
                                      M.read (| self |),
                                      "core::ops::range::RangeInclusive",
                                      "start"
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "end"
                                              |),
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::range::Step",
                                                  A,
                                                  [],
                                                  "backward",
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      A,
                                                      [],
                                                      "clone",
                                                      []
                                                    |),
                                                    [ minus_n ]
                                                  |);
                                                  Value.Integer 1
                                                ]
                                              |)
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| minus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "end"
                                              |),
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  A,
                                                  [],
                                                  "clone",
                                                  []
                                                |),
                                                [ minus_n ]
                                              |)
                                            |) in
                                          let _ :=
                                            M.write (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.read (| self |),
                                                "core::ops::range::RangeInclusive",
                                                "exhausted"
                                              |),
                                              Value.Bool true
                                            |) in
                                          M.return_ (|
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              [ M.read (| minus_n |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "end"
                      |),
                      M.call_closure (|
                        M.get_trait_method (| "core::clone::Clone", A, [], "clone", [] |),
                        [
                          M.SubPointer.get_struct_record_field (|
                            M.read (| self |),
                            "core::ops::range::RangeInclusive",
                            "start"
                          |)
                        ]
                      |)
                    |) in
                  let _ :=
                    M.write (|
                      M.SubPointer.get_struct_record_field (|
                        M.read (| self |),
                        "core::ops::range::RangeInclusive",
                        "exhausted"
                      |),
                      Value.Bool true
                    |) in
                  M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                |)))
            |)))
        | _, _ => M.impossible
        end.
      
      (*
          fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R
          where
              Self: Sized,
              F: FnMut(B, Self::Item) -> R,
              R: Try<Output = B>,
          {
              self.spec_try_rfold(init, f)
          }
      *)
      Definition try_rfold (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [ B; F; R ], [ self; init; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::range::RangeInclusiveIteratorImpl",
                Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                [],
                "spec_try_rfold",
                [ B; F; R ]
              |),
              [ M.read (| self |); M.read (| init |); M.read (| f |) ]
            |)))
        | _, _ => M.impossible
        end.
      
      (*
              fn $fold<AAA, FFF>(mut self, init: AAA, fold: FFF) -> AAA
              where
                  FFF: FnMut(AAA, Self::Item) -> AAA,
              {
                  use crate::ops::NeverShortCircuit;
      
                  self.$try_fold(init, NeverShortCircuit::wrap_mut_2(fold)).0
              }
      *)
      Definition rfold (A : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self A in
        match τ, α with
        | [ AAA; FFF ], [ self; init; fold ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let init := M.alloc (| init |) in
            let fold := M.alloc (| fold |) in
            M.read (|
              M.SubPointer.get_struct_tuple_field (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::double_ended::DoubleEndedIterator",
                      Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ],
                      [],
                      "try_rfold",
                      [
                        AAA;
                        Ty.associated;
                        Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ AAA ]
                      ]
                    |),
                    [
                      self;
                      M.read (| init |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::ops::try_trait::NeverShortCircuit") [ AAA ],
                          "wrap_mut_2",
                          [ AAA; A; FFF ]
                        |),
                        [ M.read (| fold |) ]
                      |)
                    ]
                  |)
                |),
                "core::ops::try_trait::NeverShortCircuit",
                0
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::double_ended::DoubleEndedIterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *)
          [
            ("next_back", InstanceField.Method (next_back A));
            ("nth_back", InstanceField.Method (nth_back A));
            ("try_rfold", InstanceField.Method (try_rfold A));
            ("rfold", InstanceField.Method (rfold A))
          ].
    End Impl_core_iter_traits_double_ended_DoubleEndedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::TrustedLen"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_TrustedLen_where_core_iter_traits_marker_TrustedStep_A_for_core_ops_range_RangeInclusive_A.
    
    Module Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
      Definition Self (A : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "core::ops::range::RangeInclusive") [ A ].
      
      Axiom Implements :
        forall (A : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::marker::FusedIterator"
          (Self A)
          (* Trait polymorphic types *) []
          (* Instance *) [].
    End Impl_core_iter_traits_marker_FusedIterator_where_core_iter_range_Step_A_for_core_ops_range_RangeInclusive_A.
  End range.
End iter.
