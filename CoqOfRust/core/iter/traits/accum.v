(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module iter.
  Module traits.
    Module accum.
      (* Trait *)
      (* Empty module 'Sum' *)
      
      (* Trait *)
      (* Empty module 'Product' *)
      
      Module Impl_core_iter_traits_accum_Sum_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i8";
                    Ty.function [ Ty.tuple [ Ty.path "i8"; Ty.path "i8" ] ] (Ty.path "i8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.I8
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_i8.
      
      Module Impl_core_iter_traits_accum_Product_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i8";
                    Ty.function [ Ty.tuple [ Ty.path "i8"; Ty.path "i8" ] ] (Ty.path "i8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.I8
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_i8.
      
      Module Impl_core_iter_traits_accum_Sum_ref__i8_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i8";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i8"; Ty.apply (Ty.path "&") [ Ty.path "i8" ] ] ]
                      (Ty.path "i8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "i8",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i8" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i8" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__i8_for_i8.
      
      Module Impl_core_iter_traits_accum_Product_ref__i8_for_i8.
        Definition Self : Ty.t := Ty.path "i8".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i8";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i8"; Ty.apply (Ty.path "&") [ Ty.path "i8" ] ] ]
                      (Ty.path "i8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "i8",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i8" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i8" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__i8_for_i8.
      
      Module Impl_core_iter_traits_accum_Sum_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i16";
                    Ty.function [ Ty.tuple [ Ty.path "i16"; Ty.path "i16" ] ] (Ty.path "i16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.I16
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_i16.
      
      Module Impl_core_iter_traits_accum_Product_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i16";
                    Ty.function [ Ty.tuple [ Ty.path "i16"; Ty.path "i16" ] ] (Ty.path "i16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.I16
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_i16.
      
      Module Impl_core_iter_traits_accum_Sum_ref__i16_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i16";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i16"; Ty.apply (Ty.path "&") [ Ty.path "i16" ] ] ]
                      (Ty.path "i16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "i16",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i16" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i16" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__i16_for_i16.
      
      Module Impl_core_iter_traits_accum_Product_ref__i16_for_i16.
        Definition Self : Ty.t := Ty.path "i16".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i16";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i16"; Ty.apply (Ty.path "&") [ Ty.path "i16" ] ] ]
                      (Ty.path "i16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "i16",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i16" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i16" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__i16_for_i16.
      
      Module Impl_core_iter_traits_accum_Sum_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i32";
                    Ty.function [ Ty.tuple [ Ty.path "i32"; Ty.path "i32" ] ] (Ty.path "i32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.I32
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_i32.
      
      Module Impl_core_iter_traits_accum_Product_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i32";
                    Ty.function [ Ty.tuple [ Ty.path "i32"; Ty.path "i32" ] ] (Ty.path "i32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.I32
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_i32.
      
      Module Impl_core_iter_traits_accum_Sum_ref__i32_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i32";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i32"; Ty.apply (Ty.path "&") [ Ty.path "i32" ] ] ]
                      (Ty.path "i32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "i32",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i32" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i32" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__i32_for_i32.
      
      Module Impl_core_iter_traits_accum_Product_ref__i32_for_i32.
        Definition Self : Ty.t := Ty.path "i32".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i32";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i32"; Ty.apply (Ty.path "&") [ Ty.path "i32" ] ] ]
                      (Ty.path "i32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "i32",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i32" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i32" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__i32_for_i32.
      
      Module Impl_core_iter_traits_accum_Sum_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i64";
                    Ty.function [ Ty.tuple [ Ty.path "i64"; Ty.path "i64" ] ] (Ty.path "i64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.I64
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_i64.
      
      Module Impl_core_iter_traits_accum_Product_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i64";
                    Ty.function [ Ty.tuple [ Ty.path "i64"; Ty.path "i64" ] ] (Ty.path "i64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.I64
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_i64.
      
      Module Impl_core_iter_traits_accum_Sum_ref__i64_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i64";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i64"; Ty.apply (Ty.path "&") [ Ty.path "i64" ] ] ]
                      (Ty.path "i64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "i64",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i64" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i64" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__i64_for_i64.
      
      Module Impl_core_iter_traits_accum_Product_ref__i64_for_i64.
        Definition Self : Ty.t := Ty.path "i64".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i64";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i64"; Ty.apply (Ty.path "&") [ Ty.path "i64" ] ] ]
                      (Ty.path "i64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "i64",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i64" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i64" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__i64_for_i64.
      
      Module Impl_core_iter_traits_accum_Sum_for_i128.
        Definition Self : Ty.t := Ty.path "i128".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i128";
                    Ty.function [ Ty.tuple [ Ty.path "i128"; Ty.path "i128" ] ] (Ty.path "i128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.I128
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_i128.
      
      Module Impl_core_iter_traits_accum_Product_for_i128.
        Definition Self : Ty.t := Ty.path "i128".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i128";
                    Ty.function [ Ty.tuple [ Ty.path "i128"; Ty.path "i128" ] ] (Ty.path "i128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.I128
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_i128.
      
      Module Impl_core_iter_traits_accum_Sum_ref__i128_for_i128.
        Definition Self : Ty.t := Ty.path "i128".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i128";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i128"; Ty.apply (Ty.path "&") [ Ty.path "i128" ] ] ]
                      (Ty.path "i128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "i128",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i128" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i128" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__i128_for_i128.
      
      Module Impl_core_iter_traits_accum_Product_ref__i128_for_i128.
        Definition Self : Ty.t := Ty.path "i128".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "i128";
                    Ty.function
                      [ Ty.tuple [ Ty.path "i128"; Ty.apply (Ty.path "&") [ Ty.path "i128" ] ] ]
                      (Ty.path "i128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "i128",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "i128" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "i128" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__i128_for_i128.
      
      Module Impl_core_iter_traits_accum_Sum_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "isize";
                    Ty.function [ Ty.tuple [ Ty.path "isize"; Ty.path "isize" ] ] (Ty.path "isize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.Isize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_isize.
      
      Module Impl_core_iter_traits_accum_Product_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "isize";
                    Ty.function [ Ty.tuple [ Ty.path "isize"; Ty.path "isize" ] ] (Ty.path "isize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.Isize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_isize.
      
      Module Impl_core_iter_traits_accum_Sum_ref__isize_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "isize";
                    Ty.function
                      [ Ty.tuple [ Ty.path "isize"; Ty.apply (Ty.path "&") [ Ty.path "isize" ] ] ]
                      (Ty.path "isize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "isize",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "isize" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "isize" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__isize_for_isize.
      
      Module Impl_core_iter_traits_accum_Product_ref__isize_for_isize.
        Definition Self : Ty.t := Ty.path "isize".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "isize";
                    Ty.function
                      [ Ty.tuple [ Ty.path "isize"; Ty.apply (Ty.path "&") [ Ty.path "isize" ] ] ]
                      (Ty.path "isize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "isize",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "isize" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "isize" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__isize_for_isize.
      
      Module Impl_core_iter_traits_accum_Sum_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u8";
                    Ty.function [ Ty.tuple [ Ty.path "u8"; Ty.path "u8" ] ] (Ty.path "u8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.U8
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_u8.
      
      Module Impl_core_iter_traits_accum_Product_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u8";
                    Ty.function [ Ty.tuple [ Ty.path "u8"; Ty.path "u8" ] ] (Ty.path "u8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.U8
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_u8.
      
      Module Impl_core_iter_traits_accum_Sum_ref__u8_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u8";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u8"; Ty.apply (Ty.path "&") [ Ty.path "u8" ] ] ]
                      (Ty.path "u8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "u8",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u8" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u8" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__u8_for_u8.
      
      Module Impl_core_iter_traits_accum_Product_ref__u8_for_u8.
        Definition Self : Ty.t := Ty.path "u8".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u8";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u8"; Ty.apply (Ty.path "&") [ Ty.path "u8" ] ] ]
                      (Ty.path "u8")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "u8",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u8" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u8" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__u8_for_u8.
      
      Module Impl_core_iter_traits_accum_Sum_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u16";
                    Ty.function [ Ty.tuple [ Ty.path "u16"; Ty.path "u16" ] ] (Ty.path "u16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.U16
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_u16.
      
      Module Impl_core_iter_traits_accum_Product_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u16";
                    Ty.function [ Ty.tuple [ Ty.path "u16"; Ty.path "u16" ] ] (Ty.path "u16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.U16
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_u16.
      
      Module Impl_core_iter_traits_accum_Sum_ref__u16_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u16";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u16"; Ty.apply (Ty.path "&") [ Ty.path "u16" ] ] ]
                      (Ty.path "u16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "u16",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__u16_for_u16.
      
      Module Impl_core_iter_traits_accum_Product_ref__u16_for_u16.
        Definition Self : Ty.t := Ty.path "u16".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u16";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u16"; Ty.apply (Ty.path "&") [ Ty.path "u16" ] ] ]
                      (Ty.path "u16")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "u16",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__u16_for_u16.
      
      Module Impl_core_iter_traits_accum_Sum_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u32";
                    Ty.function [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ] (Ty.path "u32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.U32
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_u32.
      
      Module Impl_core_iter_traits_accum_Product_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u32";
                    Ty.function [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ] (Ty.path "u32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.U32
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_u32.
      
      Module Impl_core_iter_traits_accum_Sum_ref__u32_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u32";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u32"; Ty.apply (Ty.path "&") [ Ty.path "u32" ] ] ]
                      (Ty.path "u32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "u32",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__u32_for_u32.
      
      Module Impl_core_iter_traits_accum_Product_ref__u32_for_u32.
        Definition Self : Ty.t := Ty.path "u32".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u32";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u32"; Ty.apply (Ty.path "&") [ Ty.path "u32" ] ] ]
                      (Ty.path "u32")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "u32",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__u32_for_u32.
      
      Module Impl_core_iter_traits_accum_Sum_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u64";
                    Ty.function [ Ty.tuple [ Ty.path "u64"; Ty.path "u64" ] ] (Ty.path "u64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.U64
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_u64.
      
      Module Impl_core_iter_traits_accum_Product_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u64";
                    Ty.function [ Ty.tuple [ Ty.path "u64"; Ty.path "u64" ] ] (Ty.path "u64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.U64
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_u64.
      
      Module Impl_core_iter_traits_accum_Sum_ref__u64_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u64";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u64"; Ty.apply (Ty.path "&") [ Ty.path "u64" ] ] ]
                      (Ty.path "u64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "u64",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__u64_for_u64.
      
      Module Impl_core_iter_traits_accum_Product_ref__u64_for_u64.
        Definition Self : Ty.t := Ty.path "u64".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u64";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u64"; Ty.apply (Ty.path "&") [ Ty.path "u64" ] ] ]
                      (Ty.path "u64")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "u64",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__u64_for_u64.
      
      Module Impl_core_iter_traits_accum_Sum_for_u128.
        Definition Self : Ty.t := Ty.path "u128".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u128";
                    Ty.function [ Ty.tuple [ Ty.path "u128"; Ty.path "u128" ] ] (Ty.path "u128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.U128
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_u128.
      
      Module Impl_core_iter_traits_accum_Product_for_u128.
        Definition Self : Ty.t := Ty.path "u128".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u128";
                    Ty.function [ Ty.tuple [ Ty.path "u128"; Ty.path "u128" ] ] (Ty.path "u128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.U128
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_u128.
      
      Module Impl_core_iter_traits_accum_Sum_ref__u128_for_u128.
        Definition Self : Ty.t := Ty.path "u128".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u128";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u128"; Ty.apply (Ty.path "&") [ Ty.path "u128" ] ] ]
                      (Ty.path "u128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "u128",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u128" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u128" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__u128_for_u128.
      
      Module Impl_core_iter_traits_accum_Product_ref__u128_for_u128.
        Definition Self : Ty.t := Ty.path "u128".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "u128";
                    Ty.function
                      [ Ty.tuple [ Ty.path "u128"; Ty.apply (Ty.path "&") [ Ty.path "u128" ] ] ]
                      (Ty.path "u128")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "u128",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "u128" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "u128" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__u128_for_u128.
      
      Module Impl_core_iter_traits_accum_Sum_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "usize";
                    Ty.function [ Ty.tuple [ Ty.path "usize"; Ty.path "usize" ] ] (Ty.path "usize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_usize.
      
      Module Impl_core_iter_traits_accum_Product_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "usize";
                    Ty.function [ Ty.tuple [ Ty.path "usize"; Ty.path "usize" ] ] (Ty.path "usize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.Usize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_usize.
      
      Module Impl_core_iter_traits_accum_Sum_ref__usize_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "usize";
                    Ty.function
                      [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [ Ty.path "usize" ] ] ]
                      (Ty.path "usize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 0;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "usize",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "usize" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "usize" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__usize_for_usize.
      
      Module Impl_core_iter_traits_accum_Product_ref__usize_for_usize.
        Definition Self : Ty.t := Ty.path "usize".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "usize";
                    Ty.function
                      [ Ty.tuple [ Ty.path "usize"; Ty.apply (Ty.path "&") [ Ty.path "usize" ] ] ]
                      (Ty.path "usize")
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.Integer 1;
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "usize",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "usize" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "usize" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__usize_for_usize.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i8" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i8.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i8" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i8.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i8_for_core_num_wrapping_Wrapping_i8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i8" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i8_for_core_num_wrapping_Wrapping_i8.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i8_for_core_num_wrapping_Wrapping_i8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i8" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i8" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i8_for_core_num_wrapping_Wrapping_i8.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i16" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i16.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i16" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i16.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i16_for_core_num_wrapping_Wrapping_i16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i16" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i16_for_core_num_wrapping_Wrapping_i16.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i16_for_core_num_wrapping_Wrapping_i16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i16" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i16" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i16_for_core_num_wrapping_Wrapping_i16.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i32" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i32.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i32" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i32.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i32_for_core_num_wrapping_Wrapping_i32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i32" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i32_for_core_num_wrapping_Wrapping_i32.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i32_for_core_num_wrapping_Wrapping_i32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i32" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i32" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i32_for_core_num_wrapping_Wrapping_i32.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i64" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i64.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i64" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i64.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i64_for_core_num_wrapping_Wrapping_i64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i64" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i64_for_core_num_wrapping_Wrapping_i64.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i64_for_core_num_wrapping_Wrapping_i64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i64" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i64" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i64_for_core_num_wrapping_Wrapping_i64.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i128" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_i128.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "i128" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_i128.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i128_for_core_num_wrapping_Wrapping_i128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "i128" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i128" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_i128_for_core_num_wrapping_Wrapping_i128.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i128_for_core_num_wrapping_Wrapping_i128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "i128" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "i128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "i128" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "i128" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_i128_for_core_num_wrapping_Wrapping_i128.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_isize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "isize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "isize" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_isize.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_isize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "isize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "isize" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_isize.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_isize_for_core_num_wrapping_Wrapping_isize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "isize" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "isize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "isize" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_isize_for_core_num_wrapping_Wrapping_isize.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_isize_for_core_num_wrapping_Wrapping_isize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "isize" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "isize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "isize" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "isize" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_isize_for_core_num_wrapping_Wrapping_isize.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u8" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u8.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u8" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u8.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u8_for_core_num_wrapping_Wrapping_u8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u8" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u8_for_core_num_wrapping_Wrapping_u8.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u8_for_core_num_wrapping_Wrapping_u8.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u8" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u8" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u8" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u8_for_core_num_wrapping_Wrapping_u8.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u16" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u16.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u16" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u16.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u16_for_core_num_wrapping_Wrapping_u16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u16" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u16_for_core_num_wrapping_Wrapping_u16.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u16_for_core_num_wrapping_Wrapping_u16.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u16" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u16" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u16" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u16_for_core_num_wrapping_Wrapping_u16.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u32" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u32.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u32" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u32.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u32_for_core_num_wrapping_Wrapping_u32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u32" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u32_for_core_num_wrapping_Wrapping_u32.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u32_for_core_num_wrapping_Wrapping_u32.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u32" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u32" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u32" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u32_for_core_num_wrapping_Wrapping_u32.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u64" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u64.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u64" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u64.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u64_for_core_num_wrapping_Wrapping_u64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u64" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u64_for_core_num_wrapping_Wrapping_u64.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u64_for_core_num_wrapping_Wrapping_u64.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u64" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u64" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u64" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u64_for_core_num_wrapping_Wrapping_u64.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u128" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_u128.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "u128" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_u128.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u128_for_core_num_wrapping_Wrapping_u128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "u128" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u128" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_u128_for_core_num_wrapping_Wrapping_u128.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u128_for_core_num_wrapping_Wrapping_u128.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "u128" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "u128" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "u128" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "u128" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_u128_for_core_num_wrapping_Wrapping_u128.
      
      Module Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_usize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "usize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "usize" ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_core_num_wrapping_Wrapping_usize.
      
      Module Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_usize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "usize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::num::wrapping::Wrapping")
                                                  [ Ty.path "usize" ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_core_num_wrapping_Wrapping_usize.
      
      Module Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_usize_for_core_num_wrapping_Wrapping_usize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $zero,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "usize" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 0 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "usize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "usize" ]
                                                  ]
                                              ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ]
            ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__core_num_wrapping_Wrapping_usize_for_core_num_wrapping_Wrapping_usize.
      
      Module Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_usize_for_core_num_wrapping_Wrapping_usize.
        Definition Self : Ty.t :=
          Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ].
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            $one,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "core::num::wrapping::Wrapping")
                                  [ Ty.path "usize" ]
                              ]
                          ]
                      ]
                      (Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ])
                  ]
                |),
                [
                  M.read (| iter |);
                  Value.StructTuple "core::num::wrapping::Wrapping" [ Value.Integer 1 ];
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path "core::num::wrapping::Wrapping")
                                                [ Ty.path "usize" ],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::num::wrapping::Wrapping")
                                                      [ Ty.path "usize" ]
                                                  ]
                                              ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *)
            [
              (* A *)
              Ty.apply
                (Ty.path "&")
                [ Ty.apply (Ty.path "core::num::wrapping::Wrapping") [ Ty.path "usize" ] ]
            ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__core_num_wrapping_Wrapping_usize_for_core_num_wrapping_Wrapping_usize.
      
      Module Impl_core_iter_traits_accum_Sum_for_f32.
        Definition Self : Ty.t := Ty.path "f32".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            0.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f32";
                    Ty.function [ Ty.tuple [ Ty.path "f32"; Ty.path "f32" ] ] (Ty.path "f32")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_f32.
      
      Module Impl_core_iter_traits_accum_Product_for_f32.
        Definition Self : Ty.t := Ty.path "f32".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            1.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f32";
                    Ty.function [ Ty.tuple [ Ty.path "f32"; Ty.path "f32" ] ] (Ty.path "f32")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.Usize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_f32.
      
      Module Impl_core_iter_traits_accum_Sum_ref__f32_for_f32.
        Definition Self : Ty.t := Ty.path "f32".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            0.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f32";
                    Ty.function
                      [ Ty.tuple [ Ty.path "f32"; Ty.apply (Ty.path "&") [ Ty.path "f32" ] ] ]
                      (Ty.path "f32")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "f32",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "f32" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "f32" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__f32_for_f32.
      
      Module Impl_core_iter_traits_accum_Product_ref__f32_for_f32.
        Definition Self : Ty.t := Ty.path "f32".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            1.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f32";
                    Ty.function
                      [ Ty.tuple [ Ty.path "f32"; Ty.apply (Ty.path "&") [ Ty.path "f32" ] ] ]
                      (Ty.path "f32")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "f32",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "f32" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "f32" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__f32_for_f32.
      
      Module Impl_core_iter_traits_accum_Sum_for_f64.
        Definition Self : Ty.t := Ty.path "f64".
        
        (*
                    fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            0.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f64";
                    Ty.function [ Ty.tuple [ Ty.path "f64"; Ty.path "f64" ] ] (Ty.path "f64")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.add
                                            Integer.Usize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_for_f64.
      
      Module Impl_core_iter_traits_accum_Product_for_f64.
        Definition Self : Ty.t := Ty.path "f64".
        
        (*
                    fn product<I: Iterator<Item=Self>>(iter: I) -> Self {
                        iter.fold(
                            1.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f64";
                    Ty.function [ Ty.tuple [ Ty.path "f64"; Ty.path "f64" ] ] (Ty.path "f64")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          BinOp.Wrap.mul
                                            Integer.Usize
                                            (M.read (| a |))
                                            (M.read (| b |))))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) []
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_for_f64.
      
      Module Impl_core_iter_traits_accum_Sum_ref__f64_for_f64.
        Definition Self : Ty.t := Ty.path "f64".
        
        (*
                    fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            0.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a + b,
                        )
                    }
        *)
        Definition sum (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f64";
                    Ty.function
                      [ Ty.tuple [ Ty.path "f64"; Ty.apply (Ty.path "&") [ Ty.path "f64" ] ] ]
                      (Ty.path "f64")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "f64",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "f64" ] ],
                                              "add",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "f64" ] ]
            (* Instance *) [ ("sum", InstanceField.Method sum) ].
      End Impl_core_iter_traits_accum_Sum_ref__f64_for_f64.
      
      Module Impl_core_iter_traits_accum_Product_ref__f64_for_f64.
        Definition Self : Ty.t := Ty.path "f64".
        
        (*
                    fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {
                        iter.fold(
                            1.0,
                            #[rustc_inherit_overflow_checks]
                            |a, b| a * b,
                        )
                    }
        *)
        Definition product (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  I,
                  [],
                  "fold",
                  [
                    Ty.path "f64";
                    Ty.function
                      [ Ty.tuple [ Ty.path "f64"; Ty.apply (Ty.path "&") [ Ty.path "f64" ] ] ]
                      (Ty.path "f64")
                  ]
                |),
                [
                  M.read (| iter |);
                  M.read (| UnsupportedLiteral |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0; α1 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let a := M.copy (| γ |) in
                                  M.match_operator (|
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let b := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "f64",
                                              [ Ty.apply (Ty.path "&") [ Ty.path "f64" ] ],
                                              "mul",
                                              []
                                            |),
                                            [ M.read (| a |); M.read (| b |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.apply (Ty.path "&") [ Ty.path "f64" ] ]
            (* Instance *) [ ("product", InstanceField.Method product) ].
      End Impl_core_iter_traits_accum_Product_ref__f64_for_f64.
      
      Module Impl_core_iter_traits_accum_Sum_where_core_iter_traits_accum_Sum_T_U_core_result_Result_U_E_for_core_result_Result_T_E.
        Definition Self (T U E : Ty.t) : Ty.t := Ty.apply (Ty.path "core::result::Result") [ T; E ].
        
        (*
            fn sum<I>(iter: I) -> Result<T, E>
            where
                I: Iterator<Item = Result<U, E>>,
            {
                iter::try_process(iter, |i| i.sum())
            }
        *)
        Definition sum (T U E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T U E in
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_function (|
                  "core::iter::adapters::try_process",
                  [
                    I;
                    U;
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.path "core::convert::Infallible"; E ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::GenericShunt")
                              [
                                I;
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.path "core::convert::Infallible"; E ]
                              ]
                          ]
                      ]
                      T;
                    T
                  ]
                |),
                [
                  M.read (| iter |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let i := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::GenericShunt")
                                        [
                                          I;
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.path "core::convert::Infallible"; E ]
                                        ],
                                      [],
                                      "sum",
                                      [ T ]
                                    |),
                                    [ M.read (| i |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T U E : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            (Self T U E)
            (* Trait polymorphic types *)
            [ (* A *) Ty.apply (Ty.path "core::result::Result") [ U; E ] ]
            (* Instance *) [ ("sum", InstanceField.Method (sum T U E)) ].
      End Impl_core_iter_traits_accum_Sum_where_core_iter_traits_accum_Sum_T_U_core_result_Result_U_E_for_core_result_Result_T_E.
      
      Module Impl_core_iter_traits_accum_Product_where_core_iter_traits_accum_Product_T_U_core_result_Result_U_E_for_core_result_Result_T_E.
        Definition Self (T U E : Ty.t) : Ty.t := Ty.apply (Ty.path "core::result::Result") [ T; E ].
        
        (*
            fn product<I>(iter: I) -> Result<T, E>
            where
                I: Iterator<Item = Result<U, E>>,
            {
                iter::try_process(iter, |i| i.product())
            }
        *)
        Definition product (T U E : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T U E in
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_function (|
                  "core::iter::adapters::try_process",
                  [
                    I;
                    U;
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.path "core::convert::Infallible"; E ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::GenericShunt")
                              [
                                I;
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.path "core::convert::Infallible"; E ]
                              ]
                          ]
                      ]
                      T;
                    T
                  ]
                |),
                [
                  M.read (| iter |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let i := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::GenericShunt")
                                        [
                                          I;
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.path "core::convert::Infallible"; E ]
                                        ],
                                      [],
                                      "product",
                                      [ T ]
                                    |),
                                    [ M.read (| i |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T U E : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            (Self T U E)
            (* Trait polymorphic types *)
            [ (* A *) Ty.apply (Ty.path "core::result::Result") [ U; E ] ]
            (* Instance *) [ ("product", InstanceField.Method (product T U E)) ].
      End Impl_core_iter_traits_accum_Product_where_core_iter_traits_accum_Product_T_U_core_result_Result_U_E_for_core_result_Result_T_E.
      
      Module Impl_core_iter_traits_accum_Sum_where_core_iter_traits_accum_Sum_T_U_core_option_Option_U_for_core_option_Option_T.
        Definition Self (T U : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [ T ].
        
        (*
            fn sum<I>(iter: I) -> Option<T>
            where
                I: Iterator<Item = Option<U>>,
            {
                iter::try_process(iter, |i| i.sum())
            }
        *)
        Definition sum (T U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T U in
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_function (|
                  "core::iter::adapters::try_process",
                  [
                    I;
                    U;
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::convert::Infallible" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::GenericShunt")
                              [
                                I;
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [ Ty.path "core::convert::Infallible" ]
                              ]
                          ]
                      ]
                      T;
                    T
                  ]
                |),
                [
                  M.read (| iter |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let i := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::GenericShunt")
                                        [
                                          I;
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                      [],
                                      "sum",
                                      [ T ]
                                    |),
                                    [ M.read (| i |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T U : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::accum::Sum"
            (Self T U)
            (* Trait polymorphic types *)
            [ (* A *) Ty.apply (Ty.path "core::option::Option") [ U ] ]
            (* Instance *) [ ("sum", InstanceField.Method (sum T U)) ].
      End Impl_core_iter_traits_accum_Sum_where_core_iter_traits_accum_Sum_T_U_core_option_Option_U_for_core_option_Option_T.
      
      Module Impl_core_iter_traits_accum_Product_where_core_iter_traits_accum_Product_T_U_core_option_Option_U_for_core_option_Option_T.
        Definition Self (T U : Ty.t) : Ty.t := Ty.apply (Ty.path "core::option::Option") [ T ].
        
        (*
            fn product<I>(iter: I) -> Option<T>
            where
                I: Iterator<Item = Option<U>>,
            {
                iter::try_process(iter, |i| i.product())
            }
        *)
        Definition product (T U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T U in
          match τ, α with
          | [ _ as I ], [ iter ] =>
            ltac:(M.monadic
              (let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_function (|
                  "core::iter::adapters::try_process",
                  [
                    I;
                    U;
                    Ty.apply
                      (Ty.path "core::option::Option")
                      [ Ty.path "core::convert::Infallible" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::GenericShunt")
                              [
                                I;
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  [ Ty.path "core::convert::Infallible" ]
                              ]
                          ]
                      ]
                      T;
                    T
                  ]
                |),
                [
                  M.read (| iter |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let i := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::GenericShunt")
                                        [
                                          I;
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            [ Ty.path "core::convert::Infallible" ]
                                        ],
                                      [],
                                      "product",
                                      [ T ]
                                    |),
                                    [ M.read (| i |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)))
          | _, _ => M.impossible
          end.
        
        Axiom Implements :
          forall (T U : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::accum::Product"
            (Self T U)
            (* Trait polymorphic types *)
            [ (* A *) Ty.apply (Ty.path "core::option::Option") [ U ] ]
            (* Instance *) [ ("product", InstanceField.Method (product T U)) ].
      End Impl_core_iter_traits_accum_Product_where_core_iter_traits_accum_Product_T_U_core_option_Option_U_for_core_option_Option_T.
    End accum.
  End traits.
End iter.
