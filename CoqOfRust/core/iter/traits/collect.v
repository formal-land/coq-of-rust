(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module iter.
  Module traits.
    Module collect.
      (* Trait *)
      (* Empty module 'FromIterator' *)
      
      (* Trait *)
      (* Empty module 'IntoIterator' *)
      
      Module Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_iterator_Iterator_I_for_I.
        Definition Self (I : Ty.t) : Ty.t := I.
        
        (*     type Item = I::Item; *)
        Definition _Item (I : Ty.t) : Ty.t := Ty.associated.
        
        (*     type IntoIter = I; *)
        Definition _IntoIter (I : Ty.t) : Ty.t := I.
        
        (*
            fn into_iter(self) -> I {
                self
            }
        *)
        Definition into_iter (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self I in
          match τ, α with
          | [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              M.read (| self |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (I : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::IntoIterator"
            (Self I)
            (* Trait polymorphic types *) []
            (* Instance *)
            [
              ("Item", InstanceField.Ty (_Item I));
              ("IntoIter", InstanceField.Ty (_IntoIter I));
              ("into_iter", InstanceField.Method (into_iter I))
            ].
      End Impl_core_iter_traits_collect_IntoIterator_where_core_iter_traits_iterator_Iterator_I_for_I.
      
      (* Trait *)
      Module Extend.
        Definition extend_one (A Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; item ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let item := M.alloc (| item |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::Extend",
                        Self,
                        [ A ],
                        "extend",
                        [ Ty.apply (Ty.path "core::option::Option") [ A ] ]
                      |),
                      [
                        M.read (| self |);
                        Value.StructTuple "core::option::Option::Some" [ M.read (| item |) ]
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom ProvidedMethod_extend_one :
          forall (A : Ty.t),
          M.IsProvidedMethod "core::iter::traits::collect::Extend" "extend_one" (extend_one A).
        Definition extend_reserve (A Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; additional ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let additional := M.alloc (| additional |) in
              M.read (|
                M.match_operator (|
                  additional,
                  [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom ProvidedMethod_extend_reserve :
          forall (A : Ty.t),
          M.IsProvidedMethod
            "core::iter::traits::collect::Extend"
            "extend_reserve"
            (extend_reserve A).
      End Extend.
      
      Module Impl_core_iter_traits_collect_Extend_Tuple__for_Tuple_.
        Definition Self : Ty.t := Ty.tuple [].
        
        (*
            fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {
                iter.into_iter().for_each(drop)
            }
        *)
        Definition extend (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [ T ], [ self; iter ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let iter := M.alloc (| iter |) in
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.associated,
                  [],
                  "for_each",
                  [ Ty.function [ Ty.tuple [] ] (Ty.tuple []) ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      T,
                      [],
                      "into_iter",
                      []
                    |),
                    [ M.read (| iter |) ]
                  |);
                  M.get_function (| "core::mem::drop", [ Ty.tuple [] ] |)
                ]
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*     fn extend_one(&mut self, _item: ()) {} *)
        Definition extend_one (τ : list Ty.t) (α : list Value.t) : M :=
          match τ, α with
          | [], [ self; _item ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let _item := M.alloc (| _item |) in
              Value.Tuple []))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::iter::traits::collect::Extend"
            Self
            (* Trait polymorphic types *) [ (* A *) Ty.tuple [] ]
            (* Instance *)
            [
              ("extend", InstanceField.Method extend);
              ("extend_one", InstanceField.Method extend_one)
            ].
      End Impl_core_iter_traits_collect_Extend_Tuple__for_Tuple_.
      
      Module Impl_core_iter_traits_collect_Extend_where_core_iter_traits_collect_Extend_ExtendA_A_where_core_iter_traits_collect_Extend_ExtendB_B_Tuple_A_B__for_Tuple_ExtendA_ExtendB_.
        Definition Self (A B ExtendA ExtendB : Ty.t) : Ty.t := Ty.tuple [ ExtendA; ExtendB ].
        
        (*
            fn extend<T: IntoIterator<Item = (A, B)>>(&mut self, into_iter: T) {
                let (a, b) = self;
                let iter = into_iter.into_iter();
        
                fn extend<'a, A, B>(
                    a: &'a mut impl Extend<A>,
                    b: &'a mut impl Extend<B>,
                ) -> impl FnMut((), (A, B)) + 'a {
                    move |(), (t, u)| {
                        a.extend_one(t);
                        b.extend_one(u);
                    }
                }
        
                let (lower_bound, _) = iter.size_hint();
                if lower_bound > 0 {
                    a.extend_reserve(lower_bound);
                    b.extend_reserve(lower_bound);
                }
        
                iter.fold((), extend(a, b));
            }
        *)
        Definition extend (A B ExtendA ExtendB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self A B ExtendA ExtendB in
          match τ, α with
          | [ T ], [ self; into_iter ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let into_iter := M.alloc (| into_iter |) in
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let a := M.alloc (| γ1_0 |) in
                        let b := M.alloc (| γ1_1 |) in
                        let~ iter :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                T,
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| into_iter |) ]
                            |)
                          |) in
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.associated,
                                [],
                                "size_hint",
                                []
                              |),
                              [ iter ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let lower_bound := M.copy (| γ0_0 |) in
                                let~ _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                BinOp.gt (|
                                                  M.read (| lower_bound |),
                                                  Value.Integer IntegerKind.Usize 0
                                                |)
                                              |)) in
                                          let _ :=
                                            M.is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::collect::Extend",
                                                  ExtendA,
                                                  [ A ],
                                                  "extend_reserve",
                                                  []
                                                |),
                                                [ M.read (| a |); M.read (| lower_bound |) ]
                                              |)
                                            |) in
                                          let~ _ :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::collect::Extend",
                                                  ExtendB,
                                                  [ B ],
                                                  "extend_reserve",
                                                  []
                                                |),
                                                [ M.read (| b |); M.read (| lower_bound |) ]
                                              |)
                                            |) in
                                          M.alloc (| Value.Tuple [] |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                let~ _ :=
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.associated,
                                        [],
                                        "fold",
                                        [ Ty.tuple []; Ty.associated ]
                                      |),
                                      [
                                        M.read (| iter |);
                                        Value.Tuple [];
                                        M.call_closure (|
                                          M.get_associated_function (| Self, "extend.extend", [] |),
                                          [ M.read (| a |); M.read (| b |) ]
                                        |)
                                      ]
                                    |)
                                  |) in
                                M.alloc (| Value.Tuple [] |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn extend_one(&mut self, item: (A, B)) {
                self.0.extend_one(item.0);
                self.1.extend_one(item.1);
            }
        *)
        Definition extend_one (A B ExtendA ExtendB : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self A B ExtendA ExtendB in
          match τ, α with
          | [], [ self; item ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let item := M.alloc (| item |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::Extend",
                        ExtendA,
                        [ A ],
                        "extend_one",
                        []
                      |),
                      [
                        M.SubPointer.get_tuple_field (| M.read (| self |), 0 |);
                        M.read (| M.SubPointer.get_tuple_field (| item, 0 |) |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::Extend",
                        ExtendB,
                        [ B ],
                        "extend_one",
                        []
                      |),
                      [
                        M.SubPointer.get_tuple_field (| M.read (| self |), 1 |);
                        M.read (| M.SubPointer.get_tuple_field (| item, 1 |) |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn extend_reserve(&mut self, additional: usize) {
                self.0.extend_reserve(additional);
                self.1.extend_reserve(additional);
            }
        *)
        Definition extend_reserve
            (A B ExtendA ExtendB : Ty.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self A B ExtendA ExtendB in
          match τ, α with
          | [], [ self; additional ] =>
            ltac:(M.monadic
              (let self := M.alloc (| self |) in
              let additional := M.alloc (| additional |) in
              M.read (|
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::Extend",
                        ExtendA,
                        [ A ],
                        "extend_reserve",
                        []
                      |),
                      [
                        M.SubPointer.get_tuple_field (| M.read (| self |), 0 |);
                        M.read (| additional |)
                      ]
                    |)
                  |) in
                let~ _ :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::Extend",
                        ExtendB,
                        [ B ],
                        "extend_reserve",
                        []
                      |),
                      [
                        M.SubPointer.get_tuple_field (| M.read (| self |), 1 |);
                        M.read (| additional |)
                      ]
                    |)
                  |) in
                M.alloc (| Value.Tuple [] |)
              |)))
          | _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (A B ExtendA ExtendB : Ty.t),
          M.IsTraitInstance
            "core::iter::traits::collect::Extend"
            (Self A B ExtendA ExtendB)
            (* Trait polymorphic types *) [ (* A *) Ty.tuple [ A; B ] ]
            (* Instance *)
            [
              ("extend", InstanceField.Method (extend A B ExtendA ExtendB));
              ("extend_one", InstanceField.Method (extend_one A B ExtendA ExtendB));
              ("extend_reserve", InstanceField.Method (extend_reserve A B ExtendA ExtendB))
            ].
      End Impl_core_iter_traits_collect_Extend_where_core_iter_traits_collect_Extend_ExtendA_A_where_core_iter_traits_collect_Extend_ExtendB_B_Tuple_A_B__for_Tuple_ExtendA_ExtendB_.
    End collect.
  End traits.
End iter.
