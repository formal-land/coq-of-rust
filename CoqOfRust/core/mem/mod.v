(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module mem.
  (*
  pub const fn forget<T>(t: T) {
      let _ = ManuallyDrop::new(t);
  }
  *)
  Definition forget (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ t ] =>
      ltac:(M.monadic
        (let t := M.alloc (| t |) in
        M.read (|
          M.match_operator (|
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ T ],
                  "new",
                  [],
                  []
                |),
                [ M.read (| t |) ]
              |)
            |),
            [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_forget : M.IsFunction "core::mem::forget" forget.
  Smpl Add apply Function_forget : is_function.
  
  (*
  pub fn forget_unsized<T: ?Sized>(t: T) {
      intrinsics::forget(t)
  }
  *)
  Definition forget_unsized (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ t ] =>
      ltac:(M.monadic
        (let t := M.alloc (| t |) in
        M.call_closure (|
          Ty.tuple [],
          M.get_function (| "core::intrinsics::forget", [], [ T ] |),
          [ M.read (| t |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_forget_unsized : M.IsFunction "core::mem::forget_unsized" forget_unsized.
  Smpl Add apply Function_forget_unsized : is_function.
  
  (*
  pub const fn size_of<T>() -> usize {
      intrinsics::size_of::<T>()
  }
  *)
  Definition size_of (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::size_of", [], [ T ] |),
          []
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_size_of : M.IsFunction "core::mem::size_of" size_of.
  Smpl Add apply Function_size_of : is_function.
  
  (*
  pub const fn size_of_val<T: ?Sized>(val: &T) -> usize {
      // SAFETY: `val` is a reference, so it's a valid raw pointer
      unsafe { intrinsics::size_of_val(val) }
  }
  *)
  Definition size_of_val (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ val ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::size_of_val", [], [ T ] |),
          [ M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| val |) |) |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_size_of_val : M.IsFunction "core::mem::size_of_val" size_of_val.
  Smpl Add apply Function_size_of_val : is_function.
  
  (*
  pub const unsafe fn size_of_val_raw<T: ?Sized>(val: *const T) -> usize {
      // SAFETY: the caller must provide a valid raw pointer
      unsafe { intrinsics::size_of_val(val) }
  }
  *)
  Definition size_of_val_raw (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ val ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::size_of_val", [], [ T ] |),
          [ M.read (| val |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_size_of_val_raw : M.IsFunction "core::mem::size_of_val_raw" size_of_val_raw.
  Smpl Add apply Function_size_of_val_raw : is_function.
  
  (*
  pub fn min_align_of<T>() -> usize {
      intrinsics::min_align_of::<T>()
  }
  *)
  Definition min_align_of (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::min_align_of", [], [ T ] |),
          []
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_min_align_of : M.IsFunction "core::mem::min_align_of" min_align_of.
  Smpl Add apply Function_min_align_of : is_function.
  
  (*
  pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {
      // SAFETY: val is a reference, so it's a valid raw pointer
      unsafe { intrinsics::min_align_of_val(val) }
  }
  *)
  Definition min_align_of_val (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ val ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::min_align_of_val", [], [ T ] |),
          [ M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| val |) |) |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_min_align_of_val : M.IsFunction "core::mem::min_align_of_val" min_align_of_val.
  Smpl Add apply Function_min_align_of_val : is_function.
  
  (*
  pub const fn align_of<T>() -> usize {
      intrinsics::min_align_of::<T>()
  }
  *)
  Definition align_of (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::min_align_of", [], [ T ] |),
          []
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_align_of : M.IsFunction "core::mem::align_of" align_of.
  Smpl Add apply Function_align_of : is_function.
  
  (*
  pub const fn align_of_val<T: ?Sized>(val: &T) -> usize {
      // SAFETY: val is a reference, so it's a valid raw pointer
      unsafe { intrinsics::min_align_of_val(val) }
  }
  *)
  Definition align_of_val (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ val ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::min_align_of_val", [], [ T ] |),
          [ M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| val |) |) |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_align_of_val : M.IsFunction "core::mem::align_of_val" align_of_val.
  Smpl Add apply Function_align_of_val : is_function.
  
  (*
  pub const unsafe fn align_of_val_raw<T: ?Sized>(val: *const T) -> usize {
      // SAFETY: the caller must provide a valid raw pointer
      unsafe { intrinsics::min_align_of_val(val) }
  }
  *)
  Definition align_of_val_raw (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ val ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::min_align_of_val", [], [ T ] |),
          [ M.read (| val |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_align_of_val_raw : M.IsFunction "core::mem::align_of_val_raw" align_of_val_raw.
  Smpl Add apply Function_align_of_val_raw : is_function.
  
  (*
  pub const fn needs_drop<T: ?Sized>() -> bool {
      intrinsics::needs_drop::<T>()
  }
  *)
  Definition needs_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "bool",
          M.get_function (| "core::intrinsics::needs_drop", [], [ T ] |),
          []
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_needs_drop : M.IsFunction "core::mem::needs_drop" needs_drop.
  Smpl Add apply Function_needs_drop : is_function.
  
  (*
  pub const unsafe fn zeroed<T>() -> T {
      // SAFETY: the caller must guarantee that an all-zero value is valid for `T`.
      unsafe {
          intrinsics::assert_zero_valid::<T>();
          MaybeUninit::zeroed().assume_init()
      }
  }
  *)
  Definition zeroed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_function (| "core::intrinsics::assert_zero_valid", [], [ T ] |),
                []
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              T,
              M.get_associated_function (|
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                "assume_init",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                    "zeroed",
                    [],
                    []
                  |),
                  []
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_zeroed : M.IsFunction "core::mem::zeroed" zeroed.
  Smpl Add apply Function_zeroed : is_function.
  
  (*
  pub unsafe fn uninitialized<T>() -> T {
      // SAFETY: the caller must guarantee that an uninitialized value is valid for `T`.
      unsafe {
          intrinsics::assert_mem_uninitialized_valid::<T>();
          let mut val = MaybeUninit::<T>::uninit();
  
          // Fill memory with 0x01, as an imperfect mitigation for old code that uses this function on
          // bool, nonnull, and noundef types. But don't do this if we actively want to detect UB.
          if !cfg!(any(miri, sanitize = "memory")) {
              val.as_mut_ptr().write_bytes(0x01, 1);
          }
  
          val.assume_init()
      }
  }
  *)
  Definition uninitialized (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.read (|
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_function (| "core::intrinsics::assert_mem_uninitialized_valid", [], [ T ] |),
                []
              |)
            |) in
          let~ val : Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                  "uninit",
                  [],
                  []
                |),
                []
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.use (M.alloc (| UnOp.not (| Value.Bool false |) |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let~ _ : Ty.tuple [] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.tuple [],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "*mut") [] [ T ],
                            "write_bytes",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "*mut") [] [ T ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                                "as_mut_ptr",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, val |) ]
                            |);
                            Value.Integer IntegerKind.U8 1;
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |)
                      |) in
                    M.alloc (| Value.Tuple [] |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.alloc (|
            M.call_closure (|
              T,
              M.get_associated_function (|
                Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ T ],
                "assume_init",
                [],
                []
              |),
              [ M.read (| val |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_uninitialized : M.IsFunction "core::mem::uninitialized" uninitialized.
  Smpl Add apply Function_uninitialized : is_function.
  
  (*
  pub const fn swap<T>(x: &mut T, y: &mut T) {
      // SAFETY: `&mut` guarantees these are typed readable and writable
      // as well as non-overlapping.
      unsafe { intrinsics::typed_swap(x, y) }
  }
  *)
  Definition swap (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ x; y ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        let y := M.alloc (| y |) in
        M.call_closure (|
          Ty.tuple [],
          M.get_function (| "core::intrinsics::typed_swap", [], [ T ] |),
          [
            M.borrow (| Pointer.Kind.MutPointer, M.deref (| M.read (| x |) |) |);
            M.borrow (| Pointer.Kind.MutPointer, M.deref (| M.read (| y |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_swap : M.IsFunction "core::mem::swap" swap.
  Smpl Add apply Function_swap : is_function.
  
  (*
  pub fn take<T: Default>(dest: &mut T) -> T {
      replace(dest, T::default())
  }
  *)
  Definition take (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ dest ] =>
      ltac:(M.monadic
        (let dest := M.alloc (| dest |) in
        M.call_closure (|
          T,
          M.get_function (| "core::mem::replace", [], [ T ] |),
          [
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| dest |) |) |);
            M.call_closure (|
              T,
              M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
              []
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_take : M.IsFunction "core::mem::take" take.
  Smpl Add apply Function_take : is_function.
  
  (*
  pub const fn replace<T>(dest: &mut T, src: T) -> T {
      // It may be tempting to use `swap` to avoid `unsafe` here. Don't!
      // The compiler optimizes the implementation below to two `memcpy`s
      // while `swap` would require at least three. See PR#83022 for details.
  
      // SAFETY: We read from `dest` but directly write `src` into it afterwards,
      // such that the old value is not duplicated. Nothing is dropped and
      // nothing here can panic.
      unsafe {
          let result = ptr::read(dest);
          ptr::write(dest, src);
          result
      }
  }
  *)
  Definition replace (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ dest; src ] =>
      ltac:(M.monadic
        (let dest := M.alloc (| dest |) in
        let src := M.alloc (| src |) in
        M.read (|
          let~ result : T :=
            M.alloc (|
              M.call_closure (|
                T,
                M.get_function (| "core::ptr::read", [], [ T ] |),
                [ M.borrow (| Pointer.Kind.ConstPointer, M.deref (| M.read (| dest |) |) |) ]
              |)
            |) in
          let~ _ : Ty.tuple [] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_function (| "core::ptr::write", [], [ T ] |),
                [
                  M.borrow (| Pointer.Kind.MutPointer, M.deref (| M.read (| dest |) |) |);
                  M.read (| src |)
                ]
              |)
            |) in
          result
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_replace : M.IsFunction "core::mem::replace" replace.
  Smpl Add apply Function_replace : is_function.
  
  (* pub fn drop<T>(_x: T) {} *)
  Definition drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ _x ] =>
      ltac:(M.monadic
        (let _x := M.alloc (| _x |) in
        Value.Tuple []))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_drop : M.IsFunction "core::mem::drop" drop.
  Smpl Add apply Function_drop : is_function.
  
  (*
  pub const fn copy<T: Copy>(x: &T) -> T {
      *x
  }
  *)
  Definition copy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ x ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        M.read (| M.deref (| M.read (| x |) |) |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_copy : M.IsFunction "core::mem::copy" copy.
  Smpl Add apply Function_copy : is_function.
  
  (*
  pub const unsafe fn transmute_copy<Src, Dst>(src: &Src) -> Dst {
      assert!(
          size_of::<Src>() >= size_of::<Dst>(),
          "cannot transmute_copy if Dst is larger than Src"
      );
  
      // If Dst has a higher alignment requirement, src might not be suitably aligned.
      if align_of::<Dst>() > align_of::<Src>() {
          // SAFETY: `src` is a reference which is guaranteed to be valid for reads.
          // The caller must guarantee that the actual transmutation is safe.
          unsafe { ptr::read_unaligned(src as *const Src as *const Dst) }
      } else {
          // SAFETY: `src` is a reference which is guaranteed to be valid for reads.
          // We just checked that `src as *const Dst` was properly aligned.
          // The caller must guarantee that the actual transmutation is safe.
          unsafe { ptr::read(src as *const Src as *const Dst) }
      }
  }
  *)
  Definition transmute_copy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ Src; Dst ], [ src ] =>
      ltac:(M.monadic
        (let src := M.alloc (| src |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          UnOp.not (|
                            BinOp.ge (|
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_function (| "core::mem::size_of", [], [ Src ] |),
                                []
                              |),
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_function (| "core::mem::size_of", [], [ Dst ] |),
                                []
                              |)
                            |)
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [ Value.Integer IntegerKind.Usize 1 ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.read (|
                                              Value.String
                                                "cannot transmute_copy if Dst is larger than Src"
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        BinOp.gt (|
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::mem::align_of", [], [ Dst ] |),
                            []
                          |),
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "core::mem::align_of", [], [ Src ] |),
                            []
                          |)
                        |)
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      Dst,
                      M.get_function (| "core::ptr::read_unaligned", [], [ Dst ] |),
                      [
                        M.cast
                          (Ty.apply (Ty.path "*const") [] [ Dst ])
                          (M.read (|
                            M.use
                              (M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.ConstPointer,
                                  M.deref (| M.read (| src |) |)
                                |)
                              |))
                          |))
                      ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.call_closure (|
                      Dst,
                      M.get_function (| "core::ptr::read", [], [ Dst ] |),
                      [
                        M.cast
                          (Ty.apply (Ty.path "*const") [] [ Dst ])
                          (M.read (|
                            M.use
                              (M.alloc (|
                                M.borrow (|
                                  Pointer.Kind.ConstPointer,
                                  M.deref (| M.read (| src |) |)
                                |)
                              |))
                          |))
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_transmute_copy : M.IsFunction "core::mem::transmute_copy" transmute_copy.
  Smpl Add apply Function_transmute_copy : is_function.
  
  (* StructTuple
    {
      name := "Discriminant";
      const_params := [];
      ty_params := [ "T" ];
      fields := [ Ty.associated_in_trait "core::marker::DiscriminantKind" [] [] T "Discriminant" ];
    } *)
  
  Module Impl_core_marker_Copy_for_core_mem_Discriminant_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::mem::Discriminant") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_marker_Copy_for_core_mem_Discriminant_T.
  
  Module Impl_core_clone_Clone_for_core_mem_Discriminant_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::mem::Discriminant") [] [ T ].
    
    (*
        fn clone(&self) -> Self {
            *self
        }
    *)
    Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_for_core_mem_Discriminant_T.
  
  Module Impl_core_cmp_PartialEq_for_core_mem_Discriminant_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::mem::Discriminant") [] [ T ].
    
    (*
        fn eq(&self, rhs: &Self) -> bool {
            self.0 == rhs.0
        }
    *)
    Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.associated_in_trait "core::marker::DiscriminantKind" [] [] T "Discriminant",
              [],
              [ Ty.associated_in_trait "core::marker::DiscriminantKind" [] [] T "Discriminant" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "core::mem::Discriminant",
                  0
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| rhs |) |),
                  "core::mem::Discriminant",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_for_core_mem_Discriminant_T.
  
  Module Impl_core_cmp_Eq_for_core_mem_Discriminant_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::mem::Discriminant") [] [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_cmp_Eq_for_core_mem_Discriminant_T.
  
  Module Impl_core_hash_Hash_for_core_mem_Discriminant_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::mem::Discriminant") [] [ T ].
    
    (*
        fn hash<H: hash::Hasher>(&self, state: &mut H) {
            self.0.hash(state);
        }
    *)
    Definition hash (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [ H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.associated_in_trait "core::marker::DiscriminantKind" [] [] T "Discriminant",
                    [],
                    [],
                    "hash",
                    [],
                    [ H ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "core::mem::Discriminant",
                        0
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("hash", InstanceField.Method (hash T)) ].
  End Impl_core_hash_Hash_for_core_mem_Discriminant_T.
  
  Module Impl_core_fmt_Debug_for_core_mem_Discriminant_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "core::mem::Discriminant") [] [ T ].
    
    (*
        fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt.debug_tuple("Discriminant").field(&self.0).finish()
        }
    *)
    Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match ε, τ, α with
      | [], [], [ self; fmt ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let fmt := M.alloc (| fmt |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::builders::DebugTuple",
              "finish",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::builders::DebugTuple" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::builders::DebugTuple",
                      "field",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "core::fmt::builders::DebugTuple",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Formatter",
                              "debug_tuple",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| fmt |) |) |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.read (| Value.String "Discriminant" |) |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "core::mem::Discriminant",
                              0
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_for_core_mem_Discriminant_T.
  
  (*
  pub const fn discriminant<T>(v: &T) -> Discriminant<T> {
      Discriminant(intrinsics::discriminant_value(v))
  }
  *)
  Definition discriminant (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ v ] =>
      ltac:(M.monadic
        (let v := M.alloc (| v |) in
        Value.StructTuple
          "core::mem::Discriminant"
          [
            M.call_closure (|
              Ty.associated_in_trait "core::marker::DiscriminantKind" [] [] T "Discriminant",
              M.get_function (| "core::intrinsics::discriminant_value", [], [ T ] |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |) ]
            |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_discriminant : M.IsFunction "core::mem::discriminant" discriminant.
  Smpl Add apply Function_discriminant : is_function.
  
  (*
  pub const fn variant_count<T>() -> usize {
      intrinsics::variant_count::<T>()
  }
  *)
  Definition variant_count (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "usize",
          M.get_function (| "core::intrinsics::variant_count", [], [ T ] |),
          []
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Function_variant_count : M.IsFunction "core::mem::variant_count" variant_count.
  Smpl Add apply Function_variant_count : is_function.
  
  (* Trait *)
  (* Empty module 'SizedTypeProperties' *)
  
  Module Impl_core_mem_SizedTypeProperties_for_T.
    Definition Self (T : Ty.t) : Ty.t := T.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::mem::SizedTypeProperties"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self T)
        (* Instance *) [].
  End Impl_core_mem_SizedTypeProperties_for_T.
End mem.
