(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module mem.
  Module transmutability.
    (* Trait *)
    Module TransmuteFrom.
      Definition transmute
          (ASSUME : Value.t)
          (Src Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.read (|
              let~ transmute :
                  Ty.apply
                    (Ty.path "core::mem::transmutability::TransmuteFrom::transmute::Transmute")
                    []
                    [ Src; Self ] :=
                M.alloc (|
                  Value.StructRecord
                    "core::mem::transmutability::TransmuteFrom::transmute::Transmute"
                    [
                      ("src",
                        M.call_closure (|
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Src ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Src ],
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| src |) ]
                        |))
                    ]
                |) in
              let~ dst : Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Self ] :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    transmute,
                    "core::mem::transmutability::TransmuteFrom::transmute::Transmute",
                    "dst"
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Self,
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Self ],
                    "into_inner",
                    [],
                    []
                  |),
                  [ M.read (| dst |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_transmute :
        forall (ASSUME : Value.t) (Src : Ty.t),
        M.IsProvidedMethod
          "core::mem::transmutability::TransmuteFrom"
          "transmute"
          (transmute ASSUME Src).
    End TransmuteFrom.
    
    (* StructRecord
      {
        name := "Assume";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("alignment", Ty.path "bool");
            ("lifetimes", Ty.path "bool");
            ("safety", Ty.path "bool");
            ("validity", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_marker_StructuralPartialEq_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_mem_transmutability_Assume.
    
    Module Impl_core_cmp_PartialEq_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  BinOp.eq (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::mem::transmutability::Assume",
                        "alignment"
                      |)
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "core::mem::transmutability::Assume",
                        "alignment"
                      |)
                    |)
                  |),
                  ltac:(M.monadic
                    (BinOp.eq (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::mem::transmutability::Assume",
                          "lifetimes"
                        |)
                      |),
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "core::mem::transmutability::Assume",
                          "lifetimes"
                        |)
                      |)
                    |)))
                |),
                ltac:(M.monadic
                  (BinOp.eq (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::mem::transmutability::Assume",
                        "safety"
                      |)
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "core::mem::transmutability::Assume",
                        "safety"
                      |)
                    |)
                  |)))
              |),
              ltac:(M.monadic
                (BinOp.eq (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "core::mem::transmutability::Assume",
                      "validity"
                    |)
                  |),
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "core::mem::transmutability::Assume",
                      "validity"
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_for_core_mem_transmutability_Assume.
    
    Module Impl_core_cmp_Eq_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_mem_transmutability_Assume.
    
    Module Impl_core_clone_Clone_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_mem_transmutability_Assume.
    
    Module Impl_core_marker_Copy_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_mem_transmutability_Assume.
    
    Module Impl_core_fmt_Debug_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field4_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "Assume" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "alignment" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::mem::transmutability::Assume",
                        "alignment"
                      |)
                    |)
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| M.read (| Value.String "lifetimes" |) |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::mem::transmutability::Assume",
                        "lifetimes"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "safety" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::mem::transmutability::Assume",
                        "safety"
                      |)
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| Value.String "validity" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::mem::transmutability::Assume",
                            "validity"
                          |)
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_mem_transmutability_Assume.
    
    Module Impl_core_marker_ConstParamTy__for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::ConstParamTy_"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_ConstParamTy__for_core_mem_transmutability_Assume.
    
    Module Impl_core_marker_UnsizedConstParamTy_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::UnsizedConstParamTy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_UnsizedConstParamTy_for_core_mem_transmutability_Assume.
    
    Module Impl_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*
          pub const NOTHING: Self =
              Self { alignment: false, lifetimes: false, safety: false, validity: false };
      *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_NOTHING : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              Value.StructRecord
                "core::mem::transmutability::Assume"
                [
                  ("alignment", Value.Bool false);
                  ("lifetimes", Value.Bool false);
                  ("safety", Value.Bool false);
                  ("validity", Value.Bool false)
                ]
            |))).
      
      Axiom AssociatedConstant_value_NOTHING :
        M.IsAssociatedConstant Self "value_NOTHING" value_NOTHING.
      Smpl Add apply AssociatedConstant_value_NOTHING : is_associated.
      
      (*     pub const ALIGNMENT: Self = Self { alignment: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_ALIGNMENT : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.struct_record_update
                (M.read (| M.get_constant "core::mem::transmutability::NOTHING" |))
                [ ("alignment", Value.Bool true) ]
            |))).
      
      Axiom AssociatedConstant_value_ALIGNMENT :
        M.IsAssociatedConstant Self "value_ALIGNMENT" value_ALIGNMENT.
      Smpl Add apply AssociatedConstant_value_ALIGNMENT : is_associated.
      
      (*     pub const LIFETIMES: Self = Self { lifetimes: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_LIFETIMES : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.struct_record_update
                (M.read (| M.get_constant "core::mem::transmutability::NOTHING" |))
                [ ("lifetimes", Value.Bool true) ]
            |))).
      
      Axiom AssociatedConstant_value_LIFETIMES :
        M.IsAssociatedConstant Self "value_LIFETIMES" value_LIFETIMES.
      Smpl Add apply AssociatedConstant_value_LIFETIMES : is_associated.
      
      (*     pub const SAFETY: Self = Self { safety: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_SAFETY : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.struct_record_update
                (M.read (| M.get_constant "core::mem::transmutability::NOTHING" |))
                [ ("safety", Value.Bool true) ]
            |))).
      
      Axiom AssociatedConstant_value_SAFETY :
        M.IsAssociatedConstant Self "value_SAFETY" value_SAFETY.
      Smpl Add apply AssociatedConstant_value_SAFETY : is_associated.
      
      (*     pub const VALIDITY: Self = Self { validity: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_VALIDITY : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.struct_record_update
                (M.read (| M.get_constant "core::mem::transmutability::NOTHING" |))
                [ ("validity", Value.Bool true) ]
            |))).
      
      Axiom AssociatedConstant_value_VALIDITY :
        M.IsAssociatedConstant Self "value_VALIDITY" value_VALIDITY.
      Smpl Add apply AssociatedConstant_value_VALIDITY : is_associated.
      
      (*
          pub const fn and(self, other_assumptions: Self) -> Self {
              Self {
                  alignment: self.alignment || other_assumptions.alignment,
                  lifetimes: self.lifetimes || other_assumptions.lifetimes,
                  safety: self.safety || other_assumptions.safety,
                  validity: self.validity || other_assumptions.validity,
              }
          }
      *)
      Definition and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            Value.StructRecord
              "core::mem::transmutability::Assume"
              [
                ("alignment",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "alignment"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "alignment"
                        |)
                      |)))
                  |));
                ("lifetimes",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "lifetimes"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "lifetimes"
                        |)
                      |)))
                  |));
                ("safety",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "safety"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "safety"
                        |)
                      |)))
                  |));
                ("validity",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "validity"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "validity"
                        |)
                      |)))
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_and : M.IsAssociatedFunction Self "and" and.
      Smpl Add apply AssociatedFunction_and : is_associated.
      
      (*
          pub const fn but_not(self, other_assumptions: Self) -> Self {
              Self {
                  alignment: self.alignment && !other_assumptions.alignment,
                  lifetimes: self.lifetimes && !other_assumptions.lifetimes,
                  safety: self.safety && !other_assumptions.safety,
                  validity: self.validity && !other_assumptions.validity,
              }
          }
      *)
      Definition but_not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            Value.StructRecord
              "core::mem::transmutability::Assume"
              [
                ("alignment",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "alignment"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "alignment"
                          |)
                        |)
                      |)))
                  |));
                ("lifetimes",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "lifetimes"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "lifetimes"
                          |)
                        |)
                      |)))
                  |));
                ("safety",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "safety"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "safety"
                          |)
                        |)
                      |)))
                  |));
                ("validity",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "validity"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "validity"
                          |)
                        |)
                      |)))
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom AssociatedFunction_but_not : M.IsAssociatedFunction Self "but_not" but_not.
      Smpl Add apply AssociatedFunction_but_not : is_associated.
    End Impl_core_mem_transmutability_Assume.
    
    Module Impl_core_ops_arith_Add_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*     type Output = Assume; *)
      Definition _Output : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*
          fn add(self, other_assumptions: Assume) -> Assume {
              self.and(other_assumptions)
          }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            M.call_closure (|
              Ty.path "core::mem::transmutability::Assume",
              M.get_associated_function (|
                Ty.path "core::mem::transmutability::Assume",
                "and",
                [],
                []
              |),
              [ M.read (| self |); M.read (| other_assumptions |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_for_core_mem_transmutability_Assume.
    
    Module Impl_core_ops_arith_Sub_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*     type Output = Assume; *)
      Definition _Output : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*
          fn sub(self, other_assumptions: Assume) -> Assume {
              self.but_not(other_assumptions)
          }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            M.call_closure (|
              Ty.path "core::mem::transmutability::Assume",
              M.get_associated_function (|
                Ty.path "core::mem::transmutability::Assume",
                "but_not",
                [],
                []
              |),
              [ M.read (| self |); M.read (| other_assumptions |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_for_core_mem_transmutability_Assume.
  End transmutability.
End mem.
