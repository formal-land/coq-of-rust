(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module mem.
  Module transmutability.
    (* Trait *)
    Module TransmuteFrom.
      Definition transmute
          (ASSUME : Value.t)
          (Src Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ src ] =>
          ltac:(M.monadic
            (let src := M.alloc (| src |) in
            M.read (|
              let~ transmute :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::mem::transmutability::TransmuteFrom::transmute::Transmute")
                        []
                        [ Src; Self ]
                    ] :=
                M.alloc (|
                  Value.StructRecord
                    "core::mem::transmutability::TransmuteFrom::transmute::Transmute"
                    []
                    [ Src; Self ]
                    [
                      ("src",
                        M.call_closure (|
                          Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Src ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Src ],
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| src |) ]
                        |))
                    ]
                |) in
              let~ dst :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [ Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Self ] ] :=
                M.copy (|
                  M.SubPointer.get_struct_record_field (|
                    transmute,
                    "core::mem::transmutability::TransmuteFrom::transmute::Transmute",
                    "dst"
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Self,
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::mem::manually_drop::ManuallyDrop") [] [ Self ],
                    "into_inner",
                    [],
                    []
                  |),
                  [ M.read (| dst |) ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_transmute :
        forall (ASSUME : Value.t) (Src : Ty.t),
        M.IsProvidedMethod
          "core::mem::transmutability::TransmuteFrom"
          "transmute"
          (transmute ASSUME Src).
    End TransmuteFrom.
    
    (* StructRecord
      {
        name := "Assume";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("alignment", Ty.path "bool");
            ("lifetimes", Ty.path "bool");
            ("safety", Ty.path "bool");
            ("validity", Ty.path "bool")
          ];
      } *)
    
    Module Impl_core_marker_StructuralPartialEq_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_core_mem_transmutability_Assume.
    
    Module Impl_core_cmp_PartialEq_core_mem_transmutability_Assume_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other := M.alloc (| other |) in
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::mem::transmutability::Assume",
                          "alignment"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "core::mem::transmutability::Assume",
                          "alignment"
                        |)
                      |)
                    ]
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      BinOp.eq,
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::mem::transmutability::Assume",
                            "lifetimes"
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "core::mem::transmutability::Assume",
                            "lifetimes"
                          |)
                        |)
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::mem::transmutability::Assume",
                          "safety"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "core::mem::transmutability::Assume",
                          "safety"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::mem::transmutability::Assume",
                        "validity"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "core::mem::transmutability::Assume",
                        "validity"
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "core::mem::transmutability::Assume" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_core_mem_transmutability_Assume_for_core_mem_transmutability_Assume.
    
    Module Impl_core_cmp_Eq_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_core_mem_transmutability_Assume.
    
    Module Impl_core_clone_Clone_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            M.read (|
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.path "core::mem::transmutability::Assume" ],
                Value.DeclaredButUndefined,
                [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_mem_transmutability_Assume.
    
    Module Impl_core_marker_Copy_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_mem_transmutability_Assume.
    
    Module Impl_core_fmt_Debug_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let f := M.alloc (| f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field4_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Assume" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "alignment" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::mem::transmutability::Assume",
                          "alignment"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "lifetimes" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::mem::transmutability::Assume",
                          "lifetimes"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "safety" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::mem::transmutability::Assume",
                          "safety"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "validity" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::mem::transmutability::Assume",
                              "validity"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_mem_transmutability_Assume.
    
    Module Impl_core_marker_ConstParamTy__for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::ConstParamTy_"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_ConstParamTy__for_core_mem_transmutability_Assume.
    
    Module Impl_core_marker_UnsizedConstParamTy_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::UnsizedConstParamTy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_UnsizedConstParamTy_for_core_mem_transmutability_Assume.
    
    Module Impl_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*
          pub const NOTHING: Self =
              Self { alignment: false, lifetimes: false, safety: false, validity: false };
      *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_NOTHING (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Value.StructRecord
              "core::mem::transmutability::Assume"
              []
              []
              [
                ("alignment", Value.Bool false);
                ("lifetimes", Value.Bool false);
                ("safety", Value.Bool false);
                ("validity", Value.Bool false)
              ]
          |))).
      
      Global Instance AssociatedConstant_value_NOTHING :
        M.IsAssociatedFunction.C Self "NOTHING" value_NOTHING.
      Admitted.
      Global Typeclasses Opaque value_NOTHING.
      
      (*     pub const ALIGNMENT: Self = Self { alignment: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_ALIGNMENT (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            M.struct_record_update
              (M.read (|
                get_associated_constant (|
                  Ty.path "core::mem::transmutability::Assume",
                  "NOTHING",
                  Ty.path "core::mem::transmutability::Assume"
                |)
              |))
              [ ("alignment", Value.Bool true) ]
          |))).
      
      Global Instance AssociatedConstant_value_ALIGNMENT :
        M.IsAssociatedFunction.C Self "ALIGNMENT" value_ALIGNMENT.
      Admitted.
      Global Typeclasses Opaque value_ALIGNMENT.
      
      (*     pub const LIFETIMES: Self = Self { lifetimes: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_LIFETIMES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            M.struct_record_update
              (M.read (|
                get_associated_constant (|
                  Ty.path "core::mem::transmutability::Assume",
                  "NOTHING",
                  Ty.path "core::mem::transmutability::Assume"
                |)
              |))
              [ ("lifetimes", Value.Bool true) ]
          |))).
      
      Global Instance AssociatedConstant_value_LIFETIMES :
        M.IsAssociatedFunction.C Self "LIFETIMES" value_LIFETIMES.
      Admitted.
      Global Typeclasses Opaque value_LIFETIMES.
      
      (*     pub const SAFETY: Self = Self { safety: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_SAFETY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            M.struct_record_update
              (M.read (|
                get_associated_constant (|
                  Ty.path "core::mem::transmutability::Assume",
                  "NOTHING",
                  Ty.path "core::mem::transmutability::Assume"
                |)
              |))
              [ ("safety", Value.Bool true) ]
          |))).
      
      Global Instance AssociatedConstant_value_SAFETY :
        M.IsAssociatedFunction.C Self "SAFETY" value_SAFETY.
      Admitted.
      Global Typeclasses Opaque value_SAFETY.
      
      (*     pub const VALIDITY: Self = Self { validity: true, ..Self::NOTHING }; *)
      (* Ty.path "core::mem::transmutability::Assume" *)
      Definition value_VALIDITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            M.struct_record_update
              (M.read (|
                get_associated_constant (|
                  Ty.path "core::mem::transmutability::Assume",
                  "NOTHING",
                  Ty.path "core::mem::transmutability::Assume"
                |)
              |))
              [ ("validity", Value.Bool true) ]
          |))).
      
      Global Instance AssociatedConstant_value_VALIDITY :
        M.IsAssociatedFunction.C Self "VALIDITY" value_VALIDITY.
      Admitted.
      Global Typeclasses Opaque value_VALIDITY.
      
      (*
          pub const fn and(self, other_assumptions: Self) -> Self {
              Self {
                  alignment: self.alignment || other_assumptions.alignment,
                  lifetimes: self.lifetimes || other_assumptions.lifetimes,
                  safety: self.safety || other_assumptions.safety,
                  validity: self.validity || other_assumptions.validity,
              }
          }
      *)
      Definition and (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            Value.StructRecord
              "core::mem::transmutability::Assume"
              []
              []
              [
                ("alignment",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "alignment"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "alignment"
                        |)
                      |)))
                  |));
                ("lifetimes",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "lifetimes"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "lifetimes"
                        |)
                      |)))
                  |));
                ("safety",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "safety"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "safety"
                        |)
                      |)))
                  |));
                ("validity",
                  LogicalOp.or (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "validity"
                      |)
                    |),
                    ltac:(M.monadic
                      (M.read (|
                        M.SubPointer.get_struct_record_field (|
                          other_assumptions,
                          "core::mem::transmutability::Assume",
                          "validity"
                        |)
                      |)))
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_and : M.IsAssociatedFunction.C Self "and" and.
      Admitted.
      Global Typeclasses Opaque and.
      
      (*
          pub const fn but_not(self, other_assumptions: Self) -> Self {
              Self {
                  alignment: self.alignment && !other_assumptions.alignment,
                  lifetimes: self.lifetimes && !other_assumptions.lifetimes,
                  safety: self.safety && !other_assumptions.safety,
                  validity: self.validity && !other_assumptions.validity,
              }
          }
      *)
      Definition but_not (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            Value.StructRecord
              "core::mem::transmutability::Assume"
              []
              []
              [
                ("alignment",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "alignment"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "alignment"
                          |)
                        |)
                      |)))
                  |));
                ("lifetimes",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "lifetimes"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "lifetimes"
                          |)
                        |)
                      |)))
                  |));
                ("safety",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "safety"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "safety"
                          |)
                        |)
                      |)))
                  |));
                ("validity",
                  LogicalOp.and (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "core::mem::transmutability::Assume",
                        "validity"
                      |)
                    |),
                    ltac:(M.monadic
                      (UnOp.not (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            other_assumptions,
                            "core::mem::transmutability::Assume",
                            "validity"
                          |)
                        |)
                      |)))
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_but_not : M.IsAssociatedFunction.C Self "but_not" but_not.
      Admitted.
      Global Typeclasses Opaque but_not.
    End Impl_core_mem_transmutability_Assume.
    
    Module Impl_core_ops_arith_Add_core_mem_transmutability_Assume_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*     type Output = Assume; *)
      Definition _Output : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*
          fn add(self, other_assumptions: Assume) -> Assume {
              self.and(other_assumptions)
          }
      *)
      Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            M.call_closure (|
              Ty.path "core::mem::transmutability::Assume",
              M.get_associated_function (|
                Ty.path "core::mem::transmutability::Assume",
                "and",
                [],
                []
              |),
              [ M.read (| self |); M.read (| other_assumptions |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Add"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "core::mem::transmutability::Assume" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
    End Impl_core_ops_arith_Add_core_mem_transmutability_Assume_for_core_mem_transmutability_Assume.
    
    Module Impl_core_ops_arith_Sub_core_mem_transmutability_Assume_for_core_mem_transmutability_Assume.
      Definition Self : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*     type Output = Assume; *)
      Definition _Output : Ty.t := Ty.path "core::mem::transmutability::Assume".
      
      (*
          fn sub(self, other_assumptions: Assume) -> Assume {
              self.but_not(other_assumptions)
          }
      *)
      Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other_assumptions ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let other_assumptions := M.alloc (| other_assumptions |) in
            M.call_closure (|
              Ty.path "core::mem::transmutability::Assume",
              M.get_associated_function (|
                Ty.path "core::mem::transmutability::Assume",
                "but_not",
                [],
                []
              |),
              [ M.read (| self |); M.read (| other_assumptions |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::ops::arith::Sub"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "core::mem::transmutability::Assume" ]
          Self
          (* Instance *)
          [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
    End Impl_core_ops_arith_Sub_core_mem_transmutability_Assume_for_core_mem_transmutability_Assume.
  End transmutability.
End mem.
