(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module dec2flt.
    Module float.
      (* Trait *)
      (* Empty module 'RawFloat' *)
      
      Module Impl_core_num_dec2flt_float_RawFloat_for_f32.
        Definition Self : Ty.t := Ty.path "f32".
        
        (*     const INFINITY: Self = f32::INFINITY; *)
        (* Ty.path "f32" *)
        Definition value_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (get_associated_constant (| Ty.path "f32", "INFINITY", Ty.path "f32" |))).
        
        (*     const NEG_INFINITY: Self = f32::NEG_INFINITY; *)
        (* Ty.path "f32" *)
        Definition value_NEG_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic
            (get_associated_constant (| Ty.path "f32", "NEG_INFINITY", Ty.path "f32" |))).
        
        (*     const NAN: Self = f32::NAN; *)
        (* Ty.path "f32" *)
        Definition value_NAN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (get_associated_constant (| Ty.path "f32", "NAN", Ty.path "f32" |))).
        
        (*     const NEG_NAN: Self = -f32::NAN; *)
        (* Ty.path "f32" *)
        Definition value_NEG_NAN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic
            (M.alloc (|
              Ty.path "f32",
              UnOp.neg (|
                M.read (| get_associated_constant (| Ty.path "f32", "NAN", Ty.path "f32" |) |)
              |)
            |))).
        
        (*     const MANTISSA_EXPLICIT_BITS: usize = 23; *)
        (* Ty.path "usize" *)
        Definition value_MANTISSA_EXPLICIT_BITS
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 23 |))).
        
        (*     const MIN_EXPONENT_ROUND_TO_EVEN: i32 = -17; *)
        (* Ty.path "i32" *)
        Definition value_MIN_EXPONENT_ROUND_TO_EVEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-17) |))).
        
        (*     const MAX_EXPONENT_ROUND_TO_EVEN: i32 = 10; *)
        (* Ty.path "i32" *)
        Definition value_MAX_EXPONENT_ROUND_TO_EVEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 10 |))).
        
        (*     const MIN_EXPONENT_FAST_PATH: i64 = -10; *)
        (* Ty.path "i64" *)
        Definition value_MIN_EXPONENT_FAST_PATH
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i64", Value.Integer IntegerKind.I64 (-10) |))).
        
        (*     const MAX_EXPONENT_FAST_PATH: i64 = 10; *)
        (* Ty.path "i64" *)
        Definition value_MAX_EXPONENT_FAST_PATH
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i64", Value.Integer IntegerKind.I64 10 |))).
        
        (*     const MAX_EXPONENT_DISGUISED_FAST_PATH: i64 = 17; *)
        (* Ty.path "i64" *)
        Definition value_MAX_EXPONENT_DISGUISED_FAST_PATH
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i64", Value.Integer IntegerKind.I64 17 |))).
        
        (*     const MINIMUM_EXPONENT: i32 = -127; *)
        (* Ty.path "i32" *)
        Definition value_MINIMUM_EXPONENT
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-127) |))).
        
        (*     const INFINITE_POWER: i32 = 0xFF; *)
        (* Ty.path "i32" *)
        Definition value_INFINITE_POWER (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 255 |))).
        
        (*     const SIGN_INDEX: usize = 31; *)
        (* Ty.path "usize" *)
        Definition value_SIGN_INDEX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 31 |))).
        
        (*     const SMALLEST_POWER_OF_TEN: i32 = -65; *)
        (* Ty.path "i32" *)
        Definition value_SMALLEST_POWER_OF_TEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-65) |))).
        
        (*     const LARGEST_POWER_OF_TEN: i32 = 38; *)
        (* Ty.path "i32" *)
        Definition value_LARGEST_POWER_OF_TEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 38 |))).
        
        (*
            fn from_u64(v: u64) -> Self {
                debug_assert!(v <= Self::MAX_MANTISSA_FAST_PATH);
                v as _
            }
        *)
        Definition from_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v := M.alloc (| Ty.path "u64", v |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            Ty.path "bool",
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.le,
                                                [
                                                  M.read (| v |);
                                                  M.read (|
                                                    get_constant (|
                                                      "core::num::dec2flt::float::RawFloat::MAX_MANTISSA_FAST_PATH",
                                                      Ty.path "u64"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: v <= Self::MAX_MANTISSA_FAST_PATH"
                                            |)
                                          ]
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (Value.Tuple []))
                                ]
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (| Ty.path "f32", M.cast (Ty.path "f32") (M.read (| v |)) |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn from_u64_bits(v: u64) -> Self {
                f32::from_bits((v & 0xFFFFFFFF) as u32)
            }
        *)
        Definition from_u64_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v := M.alloc (| Ty.path "u64", v |) in
              M.call_closure (|
                Ty.path "f32",
                M.get_associated_function (| Ty.path "f32", "from_bits", [], [] |),
                [
                  M.cast
                    (Ty.path "u32")
                    (M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [ M.read (| v |); Value.Integer IntegerKind.U64 4294967295 ]
                    |))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn pow10_fast_path(exponent: usize) -> Self {
                #[allow(clippy::use_self)]
                const TABLE: [f32; 16] =
                    [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 0., 0., 0., 0., 0.];
                TABLE[exponent & 15]
            }
        *)
        Definition pow10_fast_path (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ exponent ] =>
            ltac:(M.monadic
              (let exponent := M.alloc (| Ty.path "usize", exponent |) in
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::num::dec2flt::float::pow10_fast_path::TABLE",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 16 ]
                      [ Ty.path "f32" ]
                  |),
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.bit_and,
                    [ M.read (| exponent |); Value.Integer IntegerKind.Usize 15 ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn integer_decode(self) -> (u64, i16, i8) {
                let bits = self.to_bits();
                let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;
                let mantissa =
                    if exponent == 0 { (bits & 0x7fffff) << 1 } else { (bits & 0x7fffff) | 0x800000 };
                // Exponent bias + mantissa shift
                exponent -= 127 + 23;
                (mantissa as u64, exponent, sign)
            }
        *)
        Definition integer_decode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| Ty.path "f32", self |) in
              M.read (|
                let~ bits : Ty.path "u32" :=
                  M.call_closure (|
                    Ty.path "u32",
                    M.get_associated_function (| Ty.path "f32", "to_bits", [], [] |),
                    [ M.read (| self |) ]
                  |) in
                let~ sign : Ty.path "i8" :=
                  M.match_operator (|
                    Ty.path "i8",
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u32",
                                      BinOp.Wrap.shr,
                                      [ M.read (| bits |); Value.Integer IntegerKind.I32 31 ]
                                    |);
                                    Value.Integer IntegerKind.U32 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          Value.Integer IntegerKind.I8 1));
                      fun γ => ltac:(M.monadic (Value.Integer IntegerKind.I8 (-1)))
                    ]
                  |) in
                let~ exponent : Ty.path "i16" :=
                  M.cast
                    (Ty.path "i16")
                    (M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.shr,
                          [ M.read (| bits |); Value.Integer IntegerKind.I32 23 ]
                        |);
                        Value.Integer IntegerKind.U32 255
                      ]
                    |)) in
                let~ mantissa : Ty.path "u32" :=
                  M.match_operator (|
                    Ty.path "u32",
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| exponent |); Value.Integer IntegerKind.I16 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.call_closure (|
                            Ty.path "u32",
                            BinOp.Wrap.shl,
                            [
                              M.call_closure (|
                                Ty.path "u32",
                                BinOp.Wrap.bit_and,
                                [ M.read (| bits |); Value.Integer IntegerKind.U32 8388607 ]
                              |);
                              Value.Integer IntegerKind.I32 1
                            ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "u32",
                            BinOp.Wrap.bit_or,
                            [
                              M.call_closure (|
                                Ty.path "u32",
                                BinOp.Wrap.bit_and,
                                [ M.read (| bits |); Value.Integer IntegerKind.U32 8388607 ]
                              |);
                              Value.Integer IntegerKind.U32 8388608
                            ]
                          |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  let β := exponent in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "i16",
                      BinOp.Wrap.sub,
                      [
                        M.read (| β |);
                        M.call_closure (|
                          Ty.path "i16",
                          BinOp.Wrap.add,
                          [ Value.Integer IntegerKind.I16 127; Value.Integer IntegerKind.I16 23 ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Ty.tuple [ Ty.path "u64"; Ty.path "i16"; Ty.path "i8" ],
                  Value.Tuple
                    [
                      M.cast (Ty.path "u64") (M.read (| mantissa |));
                      M.read (| exponent |);
                      M.read (| sign |)
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn classify(self) -> FpCategory {
                self.classify()
            }
        *)
        Definition classify (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| Ty.path "f32", self |) in
              M.call_closure (|
                Ty.path "core::num::FpCategory",
                M.get_associated_function (| Ty.path "f32", "classify", [], [] |),
                [ M.read (| self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::num::dec2flt::float::RawFloat"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            Self
            (* Instance *)
            [
              ("value_INFINITY", InstanceField.Method value_INFINITY);
              ("value_NEG_INFINITY", InstanceField.Method value_NEG_INFINITY);
              ("value_NAN", InstanceField.Method value_NAN);
              ("value_NEG_NAN", InstanceField.Method value_NEG_NAN);
              ("value_MANTISSA_EXPLICIT_BITS", InstanceField.Method value_MANTISSA_EXPLICIT_BITS);
              ("value_MIN_EXPONENT_ROUND_TO_EVEN",
                InstanceField.Method value_MIN_EXPONENT_ROUND_TO_EVEN);
              ("value_MAX_EXPONENT_ROUND_TO_EVEN",
                InstanceField.Method value_MAX_EXPONENT_ROUND_TO_EVEN);
              ("value_MIN_EXPONENT_FAST_PATH", InstanceField.Method value_MIN_EXPONENT_FAST_PATH);
              ("value_MAX_EXPONENT_FAST_PATH", InstanceField.Method value_MAX_EXPONENT_FAST_PATH);
              ("value_MAX_EXPONENT_DISGUISED_FAST_PATH",
                InstanceField.Method value_MAX_EXPONENT_DISGUISED_FAST_PATH);
              ("value_MINIMUM_EXPONENT", InstanceField.Method value_MINIMUM_EXPONENT);
              ("value_INFINITE_POWER", InstanceField.Method value_INFINITE_POWER);
              ("value_SIGN_INDEX", InstanceField.Method value_SIGN_INDEX);
              ("value_SMALLEST_POWER_OF_TEN", InstanceField.Method value_SMALLEST_POWER_OF_TEN);
              ("value_LARGEST_POWER_OF_TEN", InstanceField.Method value_LARGEST_POWER_OF_TEN);
              ("from_u64", InstanceField.Method from_u64);
              ("from_u64_bits", InstanceField.Method from_u64_bits);
              ("pow10_fast_path", InstanceField.Method pow10_fast_path);
              ("integer_decode", InstanceField.Method integer_decode);
              ("classify", InstanceField.Method classify)
            ].
      End Impl_core_num_dec2flt_float_RawFloat_for_f32.
      
      Module Impl_core_num_dec2flt_float_RawFloat_for_f64.
        Definition Self : Ty.t := Ty.path "f64".
        
        (*     const INFINITY: Self = f64::INFINITY; *)
        (* Ty.path "f64" *)
        Definition value_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "INFINITY", Ty.path "f64" |))).
        
        (*     const NEG_INFINITY: Self = f64::NEG_INFINITY; *)
        (* Ty.path "f64" *)
        Definition value_NEG_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic
            (get_associated_constant (| Ty.path "f64", "NEG_INFINITY", Ty.path "f64" |))).
        
        (*     const NAN: Self = f64::NAN; *)
        (* Ty.path "f64" *)
        Definition value_NAN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "NAN", Ty.path "f64" |))).
        
        (*     const NEG_NAN: Self = -f64::NAN; *)
        (* Ty.path "f64" *)
        Definition value_NEG_NAN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic
            (M.alloc (|
              Ty.path "f64",
              UnOp.neg (|
                M.read (| get_associated_constant (| Ty.path "f64", "NAN", Ty.path "f64" |) |)
              |)
            |))).
        
        (*     const MANTISSA_EXPLICIT_BITS: usize = 52; *)
        (* Ty.path "usize" *)
        Definition value_MANTISSA_EXPLICIT_BITS
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 52 |))).
        
        (*     const MIN_EXPONENT_ROUND_TO_EVEN: i32 = -4; *)
        (* Ty.path "i32" *)
        Definition value_MIN_EXPONENT_ROUND_TO_EVEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-4) |))).
        
        (*     const MAX_EXPONENT_ROUND_TO_EVEN: i32 = 23; *)
        (* Ty.path "i32" *)
        Definition value_MAX_EXPONENT_ROUND_TO_EVEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 23 |))).
        
        (*     const MIN_EXPONENT_FAST_PATH: i64 = -22; *)
        (* Ty.path "i64" *)
        Definition value_MIN_EXPONENT_FAST_PATH
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i64", Value.Integer IntegerKind.I64 (-22) |))).
        
        (*     const MAX_EXPONENT_FAST_PATH: i64 = 22; *)
        (* Ty.path "i64" *)
        Definition value_MAX_EXPONENT_FAST_PATH
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i64", Value.Integer IntegerKind.I64 22 |))).
        
        (*     const MAX_EXPONENT_DISGUISED_FAST_PATH: i64 = 37; *)
        (* Ty.path "i64" *)
        Definition value_MAX_EXPONENT_DISGUISED_FAST_PATH
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i64", Value.Integer IntegerKind.I64 37 |))).
        
        (*     const MINIMUM_EXPONENT: i32 = -1023; *)
        (* Ty.path "i32" *)
        Definition value_MINIMUM_EXPONENT
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-1023) |))).
        
        (*     const INFINITE_POWER: i32 = 0x7FF; *)
        (* Ty.path "i32" *)
        Definition value_INFINITE_POWER (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 2047 |))).
        
        (*     const SIGN_INDEX: usize = 63; *)
        (* Ty.path "usize" *)
        Definition value_SIGN_INDEX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 63 |))).
        
        (*     const SMALLEST_POWER_OF_TEN: i32 = -342; *)
        (* Ty.path "i32" *)
        Definition value_SMALLEST_POWER_OF_TEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-342) |))).
        
        (*     const LARGEST_POWER_OF_TEN: i32 = 308; *)
        (* Ty.path "i32" *)
        Definition value_LARGEST_POWER_OF_TEN
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 308 |))).
        
        (*
            fn from_u64(v: u64) -> Self {
                debug_assert!(v <= Self::MAX_MANTISSA_FAST_PATH);
                v as _
            }
        *)
        Definition from_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v := M.alloc (| Ty.path "u64", v |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            Ty.path "bool",
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.le,
                                                [
                                                  M.read (| v |);
                                                  M.read (|
                                                    get_constant (|
                                                      "core::num::dec2flt::float::RawFloat::MAX_MANTISSA_FAST_PATH",
                                                      Ty.path "u64"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: v <= Self::MAX_MANTISSA_FAST_PATH"
                                            |)
                                          ]
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (Value.Tuple []))
                                ]
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (| Ty.path "f64", M.cast (Ty.path "f64") (M.read (| v |)) |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn from_u64_bits(v: u64) -> Self {
                f64::from_bits(v)
            }
        *)
        Definition from_u64_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v := M.alloc (| Ty.path "u64", v |) in
              M.call_closure (|
                Ty.path "f64",
                M.get_associated_function (| Ty.path "f64", "from_bits", [], [] |),
                [ M.read (| v |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn pow10_fast_path(exponent: usize) -> Self {
                const TABLE: [f64; 32] = [
                    1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13, 1e14, 1e15,
                    1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22, 0., 0., 0., 0., 0., 0., 0., 0., 0.,
                ];
                TABLE[exponent & 31]
            }
        *)
        Definition pow10_fast_path (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ exponent ] =>
            ltac:(M.monadic
              (let exponent := M.alloc (| Ty.path "usize", exponent |) in
              M.read (|
                M.SubPointer.get_array_field (|
                  get_constant (|
                    "core::num::dec2flt::float::pow10_fast_path::TABLE",
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "f64" ]
                  |),
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.bit_and,
                    [ M.read (| exponent |); Value.Integer IntegerKind.Usize 31 ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn integer_decode(self) -> (u64, i16, i8) {
                let bits = self.to_bits();
                let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };
                let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;
                let mantissa = if exponent == 0 {
                    (bits & 0xfffffffffffff) << 1
                } else {
                    (bits & 0xfffffffffffff) | 0x10000000000000
                };
                // Exponent bias + mantissa shift
                exponent -= 1023 + 52;
                (mantissa, exponent, sign)
            }
        *)
        Definition integer_decode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| Ty.path "f64", self |) in
              M.read (|
                let~ bits : Ty.path "u64" :=
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                    [ M.read (| self |) ]
                  |) in
                let~ sign : Ty.path "i8" :=
                  M.match_operator (|
                    Ty.path "i8",
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.shr,
                                      [ M.read (| bits |); Value.Integer IntegerKind.I32 63 ]
                                    |);
                                    Value.Integer IntegerKind.U64 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          Value.Integer IntegerKind.I8 1));
                      fun γ => ltac:(M.monadic (Value.Integer IntegerKind.I8 (-1)))
                    ]
                  |) in
                let~ exponent : Ty.path "i16" :=
                  M.cast
                    (Ty.path "i16")
                    (M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.shr,
                          [ M.read (| bits |); Value.Integer IntegerKind.I32 52 ]
                        |);
                        Value.Integer IntegerKind.U64 2047
                      ]
                    |)) in
                let~ mantissa : Ty.path "u64" :=
                  M.match_operator (|
                    Ty.path "u64",
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [ M.read (| exponent |); Value.Integer IntegerKind.I16 0 ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.shl,
                            [
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.bit_and,
                                [ M.read (| bits |); Value.Integer IntegerKind.U64 4503599627370495
                                ]
                              |);
                              Value.Integer IntegerKind.I32 1
                            ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "u64",
                            BinOp.Wrap.bit_or,
                            [
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.bit_and,
                                [ M.read (| bits |); Value.Integer IntegerKind.U64 4503599627370495
                                ]
                              |);
                              Value.Integer IntegerKind.U64 4503599627370496
                            ]
                          |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  let β := exponent in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "i16",
                      BinOp.Wrap.sub,
                      [
                        M.read (| β |);
                        M.call_closure (|
                          Ty.path "i16",
                          BinOp.Wrap.add,
                          [ Value.Integer IntegerKind.I16 1023; Value.Integer IntegerKind.I16 52 ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Ty.tuple [ Ty.path "u64"; Ty.path "i16"; Ty.path "i8" ],
                  Value.Tuple [ M.read (| mantissa |); M.read (| exponent |); M.read (| sign |) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        (*
            fn classify(self) -> FpCategory {
                self.classify()
            }
        *)
        Definition classify (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self := M.alloc (| Ty.path "f64", self |) in
              M.call_closure (|
                Ty.path "core::num::FpCategory",
                M.get_associated_function (| Ty.path "f64", "classify", [], [] |),
                [ M.read (| self |) ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::num::dec2flt::float::RawFloat"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            Self
            (* Instance *)
            [
              ("value_INFINITY", InstanceField.Method value_INFINITY);
              ("value_NEG_INFINITY", InstanceField.Method value_NEG_INFINITY);
              ("value_NAN", InstanceField.Method value_NAN);
              ("value_NEG_NAN", InstanceField.Method value_NEG_NAN);
              ("value_MANTISSA_EXPLICIT_BITS", InstanceField.Method value_MANTISSA_EXPLICIT_BITS);
              ("value_MIN_EXPONENT_ROUND_TO_EVEN",
                InstanceField.Method value_MIN_EXPONENT_ROUND_TO_EVEN);
              ("value_MAX_EXPONENT_ROUND_TO_EVEN",
                InstanceField.Method value_MAX_EXPONENT_ROUND_TO_EVEN);
              ("value_MIN_EXPONENT_FAST_PATH", InstanceField.Method value_MIN_EXPONENT_FAST_PATH);
              ("value_MAX_EXPONENT_FAST_PATH", InstanceField.Method value_MAX_EXPONENT_FAST_PATH);
              ("value_MAX_EXPONENT_DISGUISED_FAST_PATH",
                InstanceField.Method value_MAX_EXPONENT_DISGUISED_FAST_PATH);
              ("value_MINIMUM_EXPONENT", InstanceField.Method value_MINIMUM_EXPONENT);
              ("value_INFINITE_POWER", InstanceField.Method value_INFINITE_POWER);
              ("value_SIGN_INDEX", InstanceField.Method value_SIGN_INDEX);
              ("value_SMALLEST_POWER_OF_TEN", InstanceField.Method value_SMALLEST_POWER_OF_TEN);
              ("value_LARGEST_POWER_OF_TEN", InstanceField.Method value_LARGEST_POWER_OF_TEN);
              ("from_u64", InstanceField.Method from_u64);
              ("from_u64_bits", InstanceField.Method from_u64_bits);
              ("pow10_fast_path", InstanceField.Method pow10_fast_path);
              ("integer_decode", InstanceField.Method integer_decode);
              ("classify", InstanceField.Method classify)
            ].
      End Impl_core_num_dec2flt_float_RawFloat_for_f64.
    End float.
  End dec2flt.
End num.
