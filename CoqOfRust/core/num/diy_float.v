(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module diy_float.
    (* StructRecord
      {
        name := "Fp";
        const_params := [];
        ty_params := [];
        fields := [ ("f", Ty.path "u64"); ("e", Ty.path "i16") ];
      } *)
    
    Module Impl_core_marker_Copy_for_core_num_diy_float_Fp.
      Definition Self : Ty.t := Ty.path "core::num::diy_float::Fp".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_core_num_diy_float_Fp.
    
    Module Impl_core_clone_Clone_for_core_num_diy_float_Fp.
      Definition Self : Ty.t := Ty.path "core::num::diy_float::Fp".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "core::num::diy_float::Fp" ],
                self
              |) in
            M.read (|
              M.match_operator (|
                Ty.path "core::num::diy_float::Fp",
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.path "core::num::diy_float::Fp",
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_core_num_diy_float_Fp.
    
    Module Impl_core_fmt_Debug_for_core_num_diy_float_Fp.
      Definition Self : Ty.t := Ty.path "core::num::diy_float::Fp".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "core::num::diy_float::Fp" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Fp" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "f" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "core::num::diy_float::Fp",
                          "f"
                        |)
                      |)
                    |)
                  |));
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "e" |) |) |);
                (* Unsize *)
                M.pointer_coercion
                  (M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "&") [] [ Ty.path "i16" ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::diy_float::Fp",
                              "e"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_core_num_diy_float_Fp.
    
    Module Impl_core_num_diy_float_Fp.
      Definition Self : Ty.t := Ty.path "core::num::diy_float::Fp".
      
      (*
          pub fn mul(&self, other: &Fp) -> Fp {
              const MASK: u64 = 0xffffffff;
              let a = self.f >> 32;
              let b = self.f & MASK;
              let c = other.f >> 32;
              let d = other.f & MASK;
              let ac = a * c;
              let bc = b * c;
              let ad = a * d;
              let bd = b * d;
              let tmp = (bd >> 32) + (ad & MASK) + (bc & MASK) + (1 << 31) /* round */;
              let f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);
              let e = self.e + other.e + 64;
              Fp { f, e }
          }
      *)
      Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "core::num::diy_float::Fp" ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "core::num::diy_float::Fp" ],
                other
              |) in
            M.read (|
              let~ a : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.shr,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::num::diy_float::Fp",
                        "f"
                      |)
                    |);
                    Value.Integer IntegerKind.I32 32
                  ]
                |) in
              let~ b : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::num::diy_float::Fp",
                        "f"
                      |)
                    |);
                    M.read (| get_constant (| "core::num::diy_float::mul::MASK", Ty.path "u64" |) |)
                  ]
                |) in
              let~ c : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.shr,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "core::num::diy_float::Fp",
                        "f"
                      |)
                    |);
                    Value.Integer IntegerKind.I32 32
                  ]
                |) in
              let~ d : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.bit_and,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "core::num::diy_float::Fp",
                        "f"
                      |)
                    |);
                    M.read (| get_constant (| "core::num::diy_float::mul::MASK", Ty.path "u64" |) |)
                  ]
                |) in
              let~ ac : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.mul,
                  [ M.read (| a |); M.read (| c |) ]
                |) in
              let~ bc : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.mul,
                  [ M.read (| b |); M.read (| c |) ]
                |) in
              let~ ad : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.mul,
                  [ M.read (| a |); M.read (| d |) ]
                |) in
              let~ bd : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.mul,
                  [ M.read (| b |); M.read (| d |) ]
                |) in
              let~ tmp : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.add,
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.add,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.add,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.shr,
                              [ M.read (| bd |); Value.Integer IntegerKind.I32 32 ]
                            |);
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.bit_and,
                              [
                                M.read (| ad |);
                                M.read (|
                                  get_constant (|
                                    "core::num::diy_float::mul::MASK",
                                    Ty.path "u64"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.bit_and,
                          [
                            M.read (| bc |);
                            M.read (|
                              get_constant (| "core::num::diy_float::mul::MASK", Ty.path "u64" |)
                            |)
                          ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.shl,
                      [ Value.Integer IntegerKind.U64 1; Value.Integer IntegerKind.I32 31 ]
                    |)
                  ]
                |) in
              let~ f : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.add,
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.add,
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.add,
                          [
                            M.read (| ac |);
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.shr,
                              [ M.read (| ad |); Value.Integer IntegerKind.I32 32 ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.shr,
                          [ M.read (| bc |); Value.Integer IntegerKind.I32 32 ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.shr,
                      [ M.read (| tmp |); Value.Integer IntegerKind.I32 32 ]
                    |)
                  ]
                |) in
              let~ e : Ty.path "i16" :=
                M.call_closure (|
                  Ty.path "i16",
                  BinOp.Wrap.add,
                  [
                    M.call_closure (|
                      Ty.path "i16",
                      BinOp.Wrap.add,
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "core::num::diy_float::Fp",
                            "e"
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "core::num::diy_float::Fp",
                            "e"
                          |)
                        |)
                      ]
                    |);
                    Value.Integer IntegerKind.I16 64
                  ]
                |) in
              M.alloc (|
                Ty.path "core::num::diy_float::Fp",
                Value.StructRecord
                  "core::num::diy_float::Fp"
                  []
                  []
                  [ ("f", M.read (| f |)); ("e", M.read (| e |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_mul : M.IsAssociatedFunction.C Self "mul" mul.
      Admitted.
      Global Typeclasses Opaque mul.
      
      (*
          pub fn normalize(&self) -> Fp {
              let mut f = self.f;
              let mut e = self.e;
              if f >> (64 - 32) == 0 {
                  f <<= 32;
                  e -= 32;
              }
              if f >> (64 - 16) == 0 {
                  f <<= 16;
                  e -= 16;
              }
              if f >> (64 - 8) == 0 {
                  f <<= 8;
                  e -= 8;
              }
              if f >> (64 - 4) == 0 {
                  f <<= 4;
                  e -= 4;
              }
              if f >> (64 - 2) == 0 {
                  f <<= 2;
                  e -= 2;
              }
              if f >> (64 - 1) == 0 {
                  f <<= 1;
                  e -= 1;
              }
              debug_assert!(f >= (1 << 63));
              Fp { f, e }
          }
      *)
      Definition normalize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "core::num::diy_float::Fp" ],
                self
              |) in
            M.read (|
              let~ f : Ty.path "u64" :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::diy_float::Fp",
                    "f"
                  |)
                |) in
              let~ e : Ty.path "i16" :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "core::num::diy_float::Fp",
                    "e"
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.shr,
                                      [
                                        M.read (| f |);
                                        M.call_closure (|
                                          Ty.path "i32",
                                          BinOp.Wrap.sub,
                                          [
                                            Value.Integer IntegerKind.I32 64;
                                            Value.Integer IntegerKind.I32 32
                                          ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.U64 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            let β := f in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shl,
                                [ M.read (| β |); Value.Integer IntegerKind.I32 32 ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            let β := e in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "i16",
                                BinOp.Wrap.sub,
                                [ M.read (| β |); Value.Integer IntegerKind.I16 32 ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.shr,
                                      [
                                        M.read (| f |);
                                        M.call_closure (|
                                          Ty.path "i32",
                                          BinOp.Wrap.sub,
                                          [
                                            Value.Integer IntegerKind.I32 64;
                                            Value.Integer IntegerKind.I32 16
                                          ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.U64 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            let β := f in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shl,
                                [ M.read (| β |); Value.Integer IntegerKind.I32 16 ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            let β := e in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "i16",
                                BinOp.Wrap.sub,
                                [ M.read (| β |); Value.Integer IntegerKind.I16 16 ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.shr,
                                      [
                                        M.read (| f |);
                                        M.call_closure (|
                                          Ty.path "i32",
                                          BinOp.Wrap.sub,
                                          [
                                            Value.Integer IntegerKind.I32 64;
                                            Value.Integer IntegerKind.I32 8
                                          ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.U64 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            let β := f in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shl,
                                [ M.read (| β |); Value.Integer IntegerKind.I32 8 ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            let β := e in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "i16",
                                BinOp.Wrap.sub,
                                [ M.read (| β |); Value.Integer IntegerKind.I16 8 ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.shr,
                                      [
                                        M.read (| f |);
                                        M.call_closure (|
                                          Ty.path "i32",
                                          BinOp.Wrap.sub,
                                          [
                                            Value.Integer IntegerKind.I32 64;
                                            Value.Integer IntegerKind.I32 4
                                          ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.U64 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            let β := f in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shl,
                                [ M.read (| β |); Value.Integer IntegerKind.I32 4 ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            let β := e in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "i16",
                                BinOp.Wrap.sub,
                                [ M.read (| β |); Value.Integer IntegerKind.I16 4 ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.shr,
                                      [
                                        M.read (| f |);
                                        M.call_closure (|
                                          Ty.path "i32",
                                          BinOp.Wrap.sub,
                                          [
                                            Value.Integer IntegerKind.I32 64;
                                            Value.Integer IntegerKind.I32 2
                                          ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.U64 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            let β := f in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shl,
                                [ M.read (| β |); Value.Integer IntegerKind.I32 2 ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            let β := e in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "i16",
                                BinOp.Wrap.sub,
                                [ M.read (| β |); Value.Integer IntegerKind.I16 2 ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.eq,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.shr,
                                      [
                                        M.read (| f |);
                                        M.call_closure (|
                                          Ty.path "i32",
                                          BinOp.Wrap.sub,
                                          [
                                            Value.Integer IntegerKind.I32 64;
                                            Value.Integer IntegerKind.I32 1
                                          ]
                                        |)
                                      ]
                                    |);
                                    Value.Integer IntegerKind.U64 0
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            let β := f in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shl,
                                [ M.read (| β |); Value.Integer IntegerKind.I32 1 ]
                              |)
                            |) in
                          let~ _ : Ty.tuple [] :=
                            let β := e in
                            M.write (|
                              β,
                              M.call_closure (|
                                Ty.path "i16",
                                BinOp.Wrap.sub,
                                [ M.read (| β |); Value.Integer IntegerKind.I16 1 ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.tuple [] :=
                            M.read (|
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            Ty.path "bool",
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.ge,
                                                [
                                                  M.read (| f |);
                                                  M.call_closure (|
                                                    Ty.path "u64",
                                                    BinOp.Wrap.shl,
                                                    [
                                                      Value.Integer IntegerKind.U64 1;
                                                      Value.Integer IntegerKind.I32 63
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        Ty.tuple [],
                                        M.never_to_any (|
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (| "core::panicking::panic", [], [] |),
                                            [ mk_str (| "assertion failed: f >= (1 << 63)" |) ]
                                          |)
                                        |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Ty.path "core::num::diy_float::Fp",
                Value.StructRecord
                  "core::num::diy_float::Fp"
                  []
                  []
                  [ ("f", M.read (| f |)); ("e", M.read (| e |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_normalize :
        M.IsAssociatedFunction.C Self "normalize" normalize.
      Admitted.
      Global Typeclasses Opaque normalize.
      
      (*
          pub fn normalize_to(&self, e: i16) -> Fp {
              let edelta = self.e - e;
              assert!(edelta >= 0);
              let edelta = edelta as usize;
              assert_eq!(self.f << edelta >> edelta, self.f);
              Fp { f: self.f << edelta, e }
          }
      *)
      Definition normalize_to (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; e ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "core::num::diy_float::Fp" ],
                self
              |) in
            let e := M.alloc (| Ty.path "i16", e |) in
            M.read (|
              let~ edelta : Ty.path "i16" :=
                M.call_closure (|
                  Ty.path "i16",
                  BinOp.Wrap.sub,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "core::num::diy_float::Fp",
                        "e"
                      |)
                    |);
                    M.read (| e |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [ M.read (| edelta |); Value.Integer IntegerKind.I16 0 ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            Ty.tuple [],
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic", [], [] |),
                                [ mk_str (| "assertion failed: edelta >= 0" |) ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                    ]
                  |)
                |) in
              let~ edelta : Ty.path "usize" := M.cast (Ty.path "usize") (M.read (| edelta |)) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "u64" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "u64" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "u64",
                              M.call_closure (|
                                Ty.path "u64",
                                BinOp.Wrap.shr,
                                [
                                  M.call_closure (|
                                    Ty.path "u64",
                                    BinOp.Wrap.shl,
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "core::num::diy_float::Fp",
                                          "f"
                                        |)
                                      |);
                                      M.read (| edelta |)
                                    ]
                                  |);
                                  M.read (| edelta |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::diy_float::Fp",
                              "f"
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    Ty.tuple [],
                                    M.never_to_any (|
                                      M.read (|
                                        let~ kind : Ty.path "core::panicking::AssertKind" :=
                                          Value.StructTuple
                                            "core::panicking::AssertKind::Eq"
                                            []
                                            []
                                            [] in
                                        M.alloc (|
                                          Ty.path "never",
                                          M.call_closure (|
                                            Ty.path "never",
                                            M.get_function (|
                                              "core::panicking::assert_failed",
                                              [],
                                              [ Ty.path "u64"; Ty.path "u64" ]
                                            |),
                                            [
                                              M.read (| kind |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| left_val |) |)
                                                  |)
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| right_val |) |)
                                                  |)
                                                |)
                                              |);
                                              Value.StructTuple
                                                "core::option::Option::None"
                                                []
                                                [ Ty.path "core::fmt::Arguments" ]
                                                []
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            ]
                          |)))
                    ]
                  |)
                |) in
              M.alloc (|
                Ty.path "core::num::diy_float::Fp",
                Value.StructRecord
                  "core::num::diy_float::Fp"
                  []
                  []
                  [
                    ("f",
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.shl,
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "core::num::diy_float::Fp",
                              "f"
                            |)
                          |);
                          M.read (| edelta |)
                        ]
                      |));
                    ("e", M.read (| e |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_normalize_to :
        M.IsAssociatedFunction.C Self "normalize_to" normalize_to.
      Admitted.
      Global Typeclasses Opaque normalize_to.
    End Impl_core_num_diy_float_Fp.
  End diy_float.
End num.
