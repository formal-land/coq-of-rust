(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module f64.
  Definition value_RADIX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "RADIX", Ty.path "u32" |))).
  
  Global Instance Instance_IsConstant_value_RADIX : M.IsFunction.C "core::f64::RADIX" value_RADIX.
  Admitted.
  Global Typeclasses Opaque value_RADIX.
  
  Definition value_MANTISSA_DIGITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (get_associated_constant (| Ty.path "f64", "MANTISSA_DIGITS", Ty.path "u32" |))).
  
  Global Instance Instance_IsConstant_value_MANTISSA_DIGITS :
    M.IsFunction.C "core::f64::MANTISSA_DIGITS" value_MANTISSA_DIGITS.
  Admitted.
  Global Typeclasses Opaque value_MANTISSA_DIGITS.
  
  Definition value_DIGITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "DIGITS", Ty.path "u32" |))).
  
  Global Instance Instance_IsConstant_value_DIGITS :
    M.IsFunction.C "core::f64::DIGITS" value_DIGITS.
  Admitted.
  Global Typeclasses Opaque value_DIGITS.
  
  Definition value_EPSILON (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "EPSILON", Ty.path "f64" |))).
  
  Global Instance Instance_IsConstant_value_EPSILON :
    M.IsFunction.C "core::f64::EPSILON" value_EPSILON.
  Admitted.
  Global Typeclasses Opaque value_EPSILON.
  
  Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "MIN", Ty.path "f64" |))).
  
  Global Instance Instance_IsConstant_value_MIN : M.IsFunction.C "core::f64::MIN" value_MIN.
  Admitted.
  Global Typeclasses Opaque value_MIN.
  
  Definition value_MIN_POSITIVE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "MIN_POSITIVE", Ty.path "f64" |))).
  
  Global Instance Instance_IsConstant_value_MIN_POSITIVE :
    M.IsFunction.C "core::f64::MIN_POSITIVE" value_MIN_POSITIVE.
  Admitted.
  Global Typeclasses Opaque value_MIN_POSITIVE.
  
  Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "MAX", Ty.path "f64" |))).
  
  Global Instance Instance_IsConstant_value_MAX : M.IsFunction.C "core::f64::MAX" value_MAX.
  Admitted.
  Global Typeclasses Opaque value_MAX.
  
  Definition value_MIN_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "MIN_EXP", Ty.path "i32" |))).
  
  Global Instance Instance_IsConstant_value_MIN_EXP :
    M.IsFunction.C "core::f64::MIN_EXP" value_MIN_EXP.
  Admitted.
  Global Typeclasses Opaque value_MIN_EXP.
  
  Definition value_MAX_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "MAX_EXP", Ty.path "i32" |))).
  
  Global Instance Instance_IsConstant_value_MAX_EXP :
    M.IsFunction.C "core::f64::MAX_EXP" value_MAX_EXP.
  Admitted.
  Global Typeclasses Opaque value_MAX_EXP.
  
  Definition value_MIN_10_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "MIN_10_EXP", Ty.path "i32" |))).
  
  Global Instance Instance_IsConstant_value_MIN_10_EXP :
    M.IsFunction.C "core::f64::MIN_10_EXP" value_MIN_10_EXP.
  Admitted.
  Global Typeclasses Opaque value_MIN_10_EXP.
  
  Definition value_MAX_10_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "MAX_10_EXP", Ty.path "i32" |))).
  
  Global Instance Instance_IsConstant_value_MAX_10_EXP :
    M.IsFunction.C "core::f64::MAX_10_EXP" value_MAX_10_EXP.
  Admitted.
  Global Typeclasses Opaque value_MAX_10_EXP.
  
  Definition value_NAN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "NAN", Ty.path "f64" |))).
  
  Global Instance Instance_IsConstant_value_NAN : M.IsFunction.C "core::f64::NAN" value_NAN.
  Admitted.
  Global Typeclasses Opaque value_NAN.
  
  Definition value_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "INFINITY", Ty.path "f64" |))).
  
  Global Instance Instance_IsConstant_value_INFINITY :
    M.IsFunction.C "core::f64::INFINITY" value_INFINITY.
  Admitted.
  Global Typeclasses Opaque value_INFINITY.
  
  Definition value_NEG_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (get_associated_constant (| Ty.path "f64", "NEG_INFINITY", Ty.path "f64" |))).
  
  Global Instance Instance_IsConstant_value_NEG_INFINITY :
    M.IsFunction.C "core::f64::NEG_INFINITY" value_NEG_INFINITY.
  Admitted.
  Global Typeclasses Opaque value_NEG_INFINITY.
  
  Module consts.
    Definition value_PI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_PI : M.IsFunction.C "core::f64::consts::PI" value_PI.
    Admitted.
    Global Typeclasses Opaque value_PI.
    
    Definition value_TAU (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_TAU :
      M.IsFunction.C "core::f64::consts::TAU" value_TAU.
    Admitted.
    Global Typeclasses Opaque value_TAU.
    
    Definition value_PHI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_PHI :
      M.IsFunction.C "core::f64::consts::PHI" value_PHI.
    Admitted.
    Global Typeclasses Opaque value_PHI.
    
    Definition value_EGAMMA (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_EGAMMA :
      M.IsFunction.C "core::f64::consts::EGAMMA" value_EGAMMA.
    Admitted.
    Global Typeclasses Opaque value_EGAMMA.
    
    Definition value_FRAC_PI_2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_PI_2 :
      M.IsFunction.C "core::f64::consts::FRAC_PI_2" value_FRAC_PI_2.
    Admitted.
    Global Typeclasses Opaque value_FRAC_PI_2.
    
    Definition value_FRAC_PI_3 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_PI_3 :
      M.IsFunction.C "core::f64::consts::FRAC_PI_3" value_FRAC_PI_3.
    Admitted.
    Global Typeclasses Opaque value_FRAC_PI_3.
    
    Definition value_FRAC_PI_4 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_PI_4 :
      M.IsFunction.C "core::f64::consts::FRAC_PI_4" value_FRAC_PI_4.
    Admitted.
    Global Typeclasses Opaque value_FRAC_PI_4.
    
    Definition value_FRAC_PI_6 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_PI_6 :
      M.IsFunction.C "core::f64::consts::FRAC_PI_6" value_FRAC_PI_6.
    Admitted.
    Global Typeclasses Opaque value_FRAC_PI_6.
    
    Definition value_FRAC_PI_8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_PI_8 :
      M.IsFunction.C "core::f64::consts::FRAC_PI_8" value_FRAC_PI_8.
    Admitted.
    Global Typeclasses Opaque value_FRAC_PI_8.
    
    Definition value_FRAC_1_PI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_1_PI :
      M.IsFunction.C "core::f64::consts::FRAC_1_PI" value_FRAC_1_PI.
    Admitted.
    Global Typeclasses Opaque value_FRAC_1_PI.
    
    Definition value_FRAC_1_SQRT_PI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_1_SQRT_PI :
      M.IsFunction.C "core::f64::consts::FRAC_1_SQRT_PI" value_FRAC_1_SQRT_PI.
    Admitted.
    Global Typeclasses Opaque value_FRAC_1_SQRT_PI.
    
    Definition value_FRAC_1_SQRT_2PI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_1_SQRT_2PI :
      M.IsFunction.C "core::f64::consts::FRAC_1_SQRT_2PI" value_FRAC_1_SQRT_2PI.
    Admitted.
    Global Typeclasses Opaque value_FRAC_1_SQRT_2PI.
    
    Definition value_FRAC_2_PI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_2_PI :
      M.IsFunction.C "core::f64::consts::FRAC_2_PI" value_FRAC_2_PI.
    Admitted.
    Global Typeclasses Opaque value_FRAC_2_PI.
    
    Definition value_FRAC_2_SQRT_PI (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_2_SQRT_PI :
      M.IsFunction.C "core::f64::consts::FRAC_2_SQRT_PI" value_FRAC_2_SQRT_PI.
    Admitted.
    Global Typeclasses Opaque value_FRAC_2_SQRT_PI.
    
    Definition value_SQRT_2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_SQRT_2 :
      M.IsFunction.C "core::f64::consts::SQRT_2" value_SQRT_2.
    Admitted.
    Global Typeclasses Opaque value_SQRT_2.
    
    Definition value_FRAC_1_SQRT_2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_1_SQRT_2 :
      M.IsFunction.C "core::f64::consts::FRAC_1_SQRT_2" value_FRAC_1_SQRT_2.
    Admitted.
    Global Typeclasses Opaque value_FRAC_1_SQRT_2.
    
    Definition value_SQRT_3 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_SQRT_3 :
      M.IsFunction.C "core::f64::consts::SQRT_3" value_SQRT_3.
    Admitted.
    Global Typeclasses Opaque value_SQRT_3.
    
    Definition value_FRAC_1_SQRT_3 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_FRAC_1_SQRT_3 :
      M.IsFunction.C "core::f64::consts::FRAC_1_SQRT_3" value_FRAC_1_SQRT_3.
    Admitted.
    Global Typeclasses Opaque value_FRAC_1_SQRT_3.
    
    Definition value_E (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_E : M.IsFunction.C "core::f64::consts::E" value_E.
    Admitted.
    Global Typeclasses Opaque value_E.
    
    Definition value_LOG2_10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_LOG2_10 :
      M.IsFunction.C "core::f64::consts::LOG2_10" value_LOG2_10.
    Admitted.
    Global Typeclasses Opaque value_LOG2_10.
    
    Definition value_LOG2_E (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_LOG2_E :
      M.IsFunction.C "core::f64::consts::LOG2_E" value_LOG2_E.
    Admitted.
    Global Typeclasses Opaque value_LOG2_E.
    
    Definition value_LOG10_2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_LOG10_2 :
      M.IsFunction.C "core::f64::consts::LOG10_2" value_LOG10_2.
    Admitted.
    Global Typeclasses Opaque value_LOG10_2.
    
    Definition value_LOG10_E (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_LOG10_E :
      M.IsFunction.C "core::f64::consts::LOG10_E" value_LOG10_E.
    Admitted.
    Global Typeclasses Opaque value_LOG10_E.
    
    Definition value_LN_2 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_LN_2 :
      M.IsFunction.C "core::f64::consts::LN_2" value_LN_2.
    Admitted.
    Global Typeclasses Opaque value_LN_2.
    
    Definition value_LN_10 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_LN_10 :
      M.IsFunction.C "core::f64::consts::LN_10" value_LN_10.
    Admitted.
    Global Typeclasses Opaque value_LN_10.
  End consts.
  
  Module Impl_f64.
    Definition Self : Ty.t := Ty.path "f64".
    
    (*     pub const RADIX: u32 = 2; *)
    (* Ty.path "u32" *)
    Definition value_RADIX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "u32", Value.Integer IntegerKind.U32 2 |))).
    
    Global Instance AssociatedConstant_value_RADIX :
      M.IsAssociatedFunction.C Self "RADIX" value_RADIX.
    Admitted.
    Global Typeclasses Opaque value_RADIX.
    
    (*     pub const MANTISSA_DIGITS: u32 = 53; *)
    (* Ty.path "u32" *)
    Definition value_MANTISSA_DIGITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "u32", Value.Integer IntegerKind.U32 53 |))).
    
    Global Instance AssociatedConstant_value_MANTISSA_DIGITS :
      M.IsAssociatedFunction.C Self "MANTISSA_DIGITS" value_MANTISSA_DIGITS.
    Admitted.
    Global Typeclasses Opaque value_MANTISSA_DIGITS.
    
    (*     pub const DIGITS: u32 = 15; *)
    (* Ty.path "u32" *)
    Definition value_DIGITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "u32", Value.Integer IntegerKind.U32 15 |))).
    
    Global Instance AssociatedConstant_value_DIGITS :
      M.IsAssociatedFunction.C Self "DIGITS" value_DIGITS.
    Admitted.
    Global Typeclasses Opaque value_DIGITS.
    
    (*     pub const EPSILON: f64 = 2.2204460492503131e-16_f64; *)
    (* Ty.path "f64" *)
    Definition value_EPSILON (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance AssociatedConstant_value_EPSILON :
      M.IsAssociatedFunction.C Self "EPSILON" value_EPSILON.
    Admitted.
    Global Typeclasses Opaque value_EPSILON.
    
    (*     pub const MIN: f64 = -1.7976931348623157e+308_f64; *)
    (* Ty.path "f64" *)
    Definition value_MIN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance AssociatedConstant_value_MIN : M.IsAssociatedFunction.C Self "MIN" value_MIN.
    Admitted.
    Global Typeclasses Opaque value_MIN.
    
    (*     pub const MIN_POSITIVE: f64 = 2.2250738585072014e-308_f64; *)
    (* Ty.path "f64" *)
    Definition value_MIN_POSITIVE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance AssociatedConstant_value_MIN_POSITIVE :
      M.IsAssociatedFunction.C Self "MIN_POSITIVE" value_MIN_POSITIVE.
    Admitted.
    Global Typeclasses Opaque value_MIN_POSITIVE.
    
    (*     pub const MAX: f64 = 1.7976931348623157e+308_f64; *)
    (* Ty.path "f64" *)
    Definition value_MAX (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance AssociatedConstant_value_MAX : M.IsAssociatedFunction.C Self "MAX" value_MAX.
    Admitted.
    Global Typeclasses Opaque value_MAX.
    
    (*     pub const MIN_EXP: i32 = -1021; *)
    (* Ty.path "i32" *)
    Definition value_MIN_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-1021) |))).
    
    Global Instance AssociatedConstant_value_MIN_EXP :
      M.IsAssociatedFunction.C Self "MIN_EXP" value_MIN_EXP.
    Admitted.
    Global Typeclasses Opaque value_MIN_EXP.
    
    (*     pub const MAX_EXP: i32 = 1024; *)
    (* Ty.path "i32" *)
    Definition value_MAX_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 1024 |))).
    
    Global Instance AssociatedConstant_value_MAX_EXP :
      M.IsAssociatedFunction.C Self "MAX_EXP" value_MAX_EXP.
    Admitted.
    Global Typeclasses Opaque value_MAX_EXP.
    
    (*     pub const MIN_10_EXP: i32 = -307; *)
    (* Ty.path "i32" *)
    Definition value_MIN_10_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 (-307) |))).
    
    Global Instance AssociatedConstant_value_MIN_10_EXP :
      M.IsAssociatedFunction.C Self "MIN_10_EXP" value_MIN_10_EXP.
    Admitted.
    Global Typeclasses Opaque value_MIN_10_EXP.
    
    (*     pub const MAX_10_EXP: i32 = 308; *)
    (* Ty.path "i32" *)
    Definition value_MAX_10_EXP (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "i32", Value.Integer IntegerKind.I32 308 |))).
    
    Global Instance AssociatedConstant_value_MAX_10_EXP :
      M.IsAssociatedFunction.C Self "MAX_10_EXP" value_MAX_10_EXP.
    Admitted.
    Global Typeclasses Opaque value_MAX_10_EXP.
    
    (*     pub const NAN: f64 = 0.0_f64 / 0.0_f64; *)
    (* Ty.path "f64" *)
    Definition value_NAN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "f64",
          M.call_closure (|
            Ty.path "f64",
            BinOp.Wrap.div,
            [ M.read (| UnsupportedLiteral |); M.read (| UnsupportedLiteral |) ]
          |)
        |))).
    
    Global Instance AssociatedConstant_value_NAN : M.IsAssociatedFunction.C Self "NAN" value_NAN.
    Admitted.
    Global Typeclasses Opaque value_NAN.
    
    (*     pub const INFINITY: f64 = 1.0_f64 / 0.0_f64; *)
    (* Ty.path "f64" *)
    Definition value_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "f64",
          M.call_closure (|
            Ty.path "f64",
            BinOp.Wrap.div,
            [ M.read (| UnsupportedLiteral |); M.read (| UnsupportedLiteral |) ]
          |)
        |))).
    
    Global Instance AssociatedConstant_value_INFINITY :
      M.IsAssociatedFunction.C Self "INFINITY" value_INFINITY.
    Admitted.
    Global Typeclasses Opaque value_INFINITY.
    
    (*     pub const NEG_INFINITY: f64 = -1.0_f64 / 0.0_f64; *)
    (* Ty.path "f64" *)
    Definition value_NEG_INFINITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "f64",
          M.call_closure (|
            Ty.path "f64",
            BinOp.Wrap.div,
            [ M.read (| UnsupportedLiteral |); M.read (| UnsupportedLiteral |) ]
          |)
        |))).
    
    Global Instance AssociatedConstant_value_NEG_INFINITY :
      M.IsAssociatedFunction.C Self "NEG_INFINITY" value_NEG_INFINITY.
    Admitted.
    Global Typeclasses Opaque value_NEG_INFINITY.
    
    (*     const SIGN_MASK: u64 = 0x8000_0000_0000_0000; *)
    (* Ty.path "u64" *)
    Definition value_SIGN_MASK (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 9223372036854775808 |))).
    
    Global Instance AssociatedConstant_value_SIGN_MASK :
      M.IsAssociatedFunction.C Self "SIGN_MASK" value_SIGN_MASK.
    Admitted.
    Global Typeclasses Opaque value_SIGN_MASK.
    
    (*     const EXP_MASK: u64 = 0x7ff0_0000_0000_0000; *)
    (* Ty.path "u64" *)
    Definition value_EXP_MASK (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 9218868437227405312 |))).
    
    Global Instance AssociatedConstant_value_EXP_MASK :
      M.IsAssociatedFunction.C Self "EXP_MASK" value_EXP_MASK.
    Admitted.
    Global Typeclasses Opaque value_EXP_MASK.
    
    (*     const MAN_MASK: u64 = 0x000f_ffff_ffff_ffff; *)
    (* Ty.path "u64" *)
    Definition value_MAN_MASK (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 4503599627370495 |))).
    
    Global Instance AssociatedConstant_value_MAN_MASK :
      M.IsAssociatedFunction.C Self "MAN_MASK" value_MAN_MASK.
    Admitted.
    Global Typeclasses Opaque value_MAN_MASK.
    
    (*     const TINY_BITS: u64 = 0x1; *)
    (* Ty.path "u64" *)
    Definition value_TINY_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 1 |))).
    
    Global Instance AssociatedConstant_value_TINY_BITS :
      M.IsAssociatedFunction.C Self "TINY_BITS" value_TINY_BITS.
    Admitted.
    Global Typeclasses Opaque value_TINY_BITS.
    
    (*     const NEG_TINY_BITS: u64 = Self::TINY_BITS | Self::SIGN_MASK; *)
    (* Ty.path "u64" *)
    Definition value_NEG_TINY_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "u64",
          M.call_closure (|
            Ty.path "u64",
            BinOp.Wrap.bit_or,
            [
              M.read (| get_associated_constant (| Ty.path "f64", "TINY_BITS", Ty.path "u64" |) |);
              M.read (| get_associated_constant (| Ty.path "f64", "SIGN_MASK", Ty.path "u64" |) |)
            ]
          |)
        |))).
    
    Global Instance AssociatedConstant_value_NEG_TINY_BITS :
      M.IsAssociatedFunction.C Self "NEG_TINY_BITS" value_NEG_TINY_BITS.
    Admitted.
    Global Typeclasses Opaque value_NEG_TINY_BITS.
    
    (*
        pub const fn is_nan(self) -> bool {
            self != self
        }
    *)
    Definition is_nan (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (| Ty.path "bool", BinOp.ne, [ M.read (| self |); M.read (| self |) ] |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_nan : M.IsAssociatedFunction.C Self "is_nan" is_nan.
    Admitted.
    Global Typeclasses Opaque is_nan.
    
    (*
        pub const fn is_infinite(self) -> bool {
            // Getting clever with transmutation can result in incorrect answers on some FPUs
            // FIXME: alter the Rust <-> Rust calling convention to prevent this problem.
            // See https://github.com/rust-lang/rust/issues/72327
            (self == f64::INFINITY) | (self == f64::NEG_INFINITY)
        }
    *)
    Definition is_infinite (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.Wrap.bit_or,
            [
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (| self |);
                  M.read (|
                    get_associated_constant (| Ty.path "f64", "INFINITY", Ty.path "f64" |)
                  |)
                ]
              |);
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (| self |);
                  M.read (|
                    get_associated_constant (| Ty.path "f64", "NEG_INFINITY", Ty.path "f64" |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_infinite :
      M.IsAssociatedFunction.C Self "is_infinite" is_infinite.
    Admitted.
    Global Typeclasses Opaque is_infinite.
    
    (*
        pub const fn is_finite(self) -> bool {
            // There's no need to handle NaN separately: if self is NaN,
            // the comparison is not true, exactly as desired.
            self.abs() < Self::INFINITY
        }
    *)
    Definition is_finite (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.lt,
            [
              M.call_closure (|
                Ty.path "f64",
                M.get_associated_function (| Ty.path "f64", "abs", [], [] |),
                [ M.read (| self |) ]
              |);
              M.read (| get_associated_constant (| Ty.path "f64", "INFINITY", Ty.path "f64" |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_finite :
      M.IsAssociatedFunction.C Self "is_finite" is_finite.
    Admitted.
    Global Typeclasses Opaque is_finite.
    
    (*
        pub const fn is_subnormal(self) -> bool {
            matches!(self.classify(), FpCategory::Subnormal)
        }
    *)
    Definition is_subnormal (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.read (|
            M.match_operator (|
              Ty.path "bool",
              M.alloc (|
                Ty.path "core::num::FpCategory",
                M.call_closure (|
                  Ty.path "core::num::FpCategory",
                  M.get_associated_function (| Ty.path "f64", "classify", [], [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::num::FpCategory::Subnormal" |) in
                    M.alloc (| Ty.path "bool", Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Ty.path "bool", Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_subnormal :
      M.IsAssociatedFunction.C Self "is_subnormal" is_subnormal.
    Admitted.
    Global Typeclasses Opaque is_subnormal.
    
    (*
        pub const fn is_normal(self) -> bool {
            matches!(self.classify(), FpCategory::Normal)
        }
    *)
    Definition is_normal (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.read (|
            M.match_operator (|
              Ty.path "bool",
              M.alloc (|
                Ty.path "core::num::FpCategory",
                M.call_closure (|
                  Ty.path "core::num::FpCategory",
                  M.get_associated_function (| Ty.path "f64", "classify", [], [] |),
                  [ M.read (| self |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::num::FpCategory::Normal" |) in
                    M.alloc (| Ty.path "bool", Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Ty.path "bool", Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_normal :
      M.IsAssociatedFunction.C Self "is_normal" is_normal.
    Admitted.
    Global Typeclasses Opaque is_normal.
    
    (*
        pub const fn classify(self) -> FpCategory {
            // We used to have complicated logic here that avoids the simple bit-based tests to work
            // around buggy codegen for x87 targets (see
            // https://github.com/rust-lang/rust/issues/114479). However, some LLVM versions later, none
            // of our tests is able to find any difference between the complicated and the naive
            // version, so now we are back to the naive version.
            let b = self.to_bits();
            match (b & Self::MAN_MASK, b & Self::EXP_MASK) {
                (0, Self::EXP_MASK) => FpCategory::Infinite,
                (_, Self::EXP_MASK) => FpCategory::Nan,
                (0, 0) => FpCategory::Zero,
                (_, 0) => FpCategory::Subnormal,
                _ => FpCategory::Normal,
            }
        }
    *)
    Definition classify (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.read (|
            let~ b : Ty.path "u64" :=
              M.call_closure (|
                Ty.path "u64",
                M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                [ M.read (| self |) ]
              |) in
            M.match_operator (|
              Ty.path "core::num::FpCategory",
              M.alloc (|
                Ty.tuple [ Ty.path "u64"; Ty.path "u64" ],
                Value.Tuple
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [
                        M.read (| b |);
                        M.read (|
                          get_associated_constant (| Ty.path "f64", "MAN_MASK", Ty.path "u64" |)
                        |)
                      ]
                    |);
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.bit_and,
                      [
                        M.read (| b |);
                        M.read (|
                          get_associated_constant (| Ty.path "f64", "EXP_MASK", Ty.path "u64" |)
                        |)
                      ]
                    |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ0_0 |),
                        Value.Integer IntegerKind.U64 0
                      |) in
                    let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ0_1 |),
                        Value.Integer IntegerKind.U64 9218868437227405312
                      |) in
                    M.alloc (|
                      Ty.path "core::num::FpCategory",
                      Value.StructTuple "core::num::FpCategory::Infinite" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ0_1 |),
                        Value.Integer IntegerKind.U64 9218868437227405312
                      |) in
                    M.alloc (|
                      Ty.path "core::num::FpCategory",
                      Value.StructTuple "core::num::FpCategory::Nan" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ0_0 |),
                        Value.Integer IntegerKind.U64 0
                      |) in
                    let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ0_1 |),
                        Value.Integer IntegerKind.U64 0
                      |) in
                    M.alloc (|
                      Ty.path "core::num::FpCategory",
                      Value.StructTuple "core::num::FpCategory::Zero" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ0_1 |),
                        Value.Integer IntegerKind.U64 0
                      |) in
                    M.alloc (|
                      Ty.path "core::num::FpCategory",
                      Value.StructTuple "core::num::FpCategory::Subnormal" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.path "core::num::FpCategory",
                      Value.StructTuple "core::num::FpCategory::Normal" [] [] []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_classify : M.IsAssociatedFunction.C Self "classify" classify.
    Admitted.
    Global Typeclasses Opaque classify.
    
    (*
        pub const fn is_sign_positive(self) -> bool {
            !self.is_sign_negative()
        }
    *)
    Definition is_sign_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          UnOp.not (|
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (| Ty.path "f64", "is_sign_negative", [], [] |),
              [ M.read (| self |) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_sign_positive :
      M.IsAssociatedFunction.C Self "is_sign_positive" is_sign_positive.
    Admitted.
    Global Typeclasses Opaque is_sign_positive.
    
    (*
        pub fn is_positive(self) -> bool {
            self.is_sign_positive()
        }
    *)
    Definition is_positive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (| Ty.path "f64", "is_sign_positive", [], [] |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_positive :
      M.IsAssociatedFunction.C Self "is_positive" is_positive.
    Admitted.
    Global Typeclasses Opaque is_positive.
    
    (*
        pub const fn is_sign_negative(self) -> bool {
            // IEEE754 says: isSignMinus(x) is true if and only if x has negative sign. isSignMinus
            // applies to zeros and NaNs as well.
            // SAFETY: This is just transmuting to get the sign bit, it's fine.
            unsafe { mem::transmute::<f64, u64>(self) & Self::SIGN_MASK != 0 }
        }
    *)
    Definition is_sign_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.ne,
            [
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.bit_and,
                [
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_function (|
                      "core::intrinsics::transmute",
                      [],
                      [ Ty.path "f64"; Ty.path "u64" ]
                    |),
                    [ M.read (| self |) ]
                  |);
                  M.read (|
                    get_associated_constant (| Ty.path "f64", "SIGN_MASK", Ty.path "u64" |)
                  |)
                ]
              |);
              Value.Integer IntegerKind.U64 0
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_sign_negative :
      M.IsAssociatedFunction.C Self "is_sign_negative" is_sign_negative.
    Admitted.
    Global Typeclasses Opaque is_sign_negative.
    
    (*
        pub fn is_negative(self) -> bool {
            self.is_sign_negative()
        }
    *)
    Definition is_negative (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (| Ty.path "f64", "is_sign_negative", [], [] |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_negative :
      M.IsAssociatedFunction.C Self "is_negative" is_negative.
    Admitted.
    Global Typeclasses Opaque is_negative.
    
    (*
        pub const fn next_up(self) -> Self {
            // Some targets violate Rust's assumption of IEEE semantics, e.g. by flushing
            // denormals to zero. This is in general unsound and unsupported, but here
            // we do our best to still produce the correct result on such targets.
            let bits = self.to_bits();
            if self.is_nan() || bits == Self::INFINITY.to_bits() {
                return self;
            }
    
            let abs = bits & !Self::SIGN_MASK;
            let next_bits = if abs == 0 {
                Self::TINY_BITS
            } else if bits == abs {
                bits + 1
            } else {
                bits - 1
            };
            Self::from_bits(next_bits)
        }
    *)
    Definition next_up (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.read (|
            M.catch_return (Ty.path "f64") (|
              ltac:(M.monadic
                (M.alloc (|
                  Ty.path "f64",
                  M.read (|
                    let~ bits : Ty.path "u64" :=
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                        [ M.read (| self |) ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.read (|
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      LogicalOp.or (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.path "f64",
                                            "is_nan",
                                            [],
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |),
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| bits |);
                                              M.call_closure (|
                                                Ty.path "u64",
                                                M.get_associated_function (|
                                                  Ty.path "f64",
                                                  "to_bits",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    get_associated_constant (|
                                                      Ty.path "f64",
                                                      "INFINITY",
                                                      Ty.path "f64"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)))
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  Ty.tuple [],
                                  M.never_to_any (|
                                    M.read (| M.return_ (| M.read (| self |) |) |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)
                      |) in
                    let~ abs : Ty.path "u64" :=
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.bit_and,
                        [
                          M.read (| bits |);
                          UnOp.not (|
                            M.read (|
                              get_associated_constant (|
                                Ty.path "f64",
                                "SIGN_MASK",
                                Ty.path "u64"
                              |)
                            |)
                          |)
                        ]
                      |) in
                    let~ next_bits : Ty.path "u64" :=
                      M.read (|
                        M.match_operator (|
                          Ty.path "u64",
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [ M.read (| abs |); Value.Integer IntegerKind.U64 0 ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                get_associated_constant (|
                                  Ty.path "f64",
                                  "TINY_BITS",
                                  Ty.path "u64"
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.path "u64",
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              Ty.path "bool",
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.eq,
                                                [ M.read (| bits |); M.read (| abs |) ]
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          Ty.path "u64",
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.add,
                                            [ M.read (| bits |); Value.Integer IntegerKind.U64 1 ]
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          Ty.path "u64",
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.sub,
                                            [ M.read (| bits |); Value.Integer IntegerKind.U64 1 ]
                                          |)
                                        |)))
                                  ]
                                |)))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Ty.path "f64",
                      M.call_closure (|
                        Ty.path "f64",
                        M.get_associated_function (| Ty.path "f64", "from_bits", [], [] |),
                        [ M.read (| next_bits |) ]
                      |)
                    |)
                  |)
                |)))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_next_up : M.IsAssociatedFunction.C Self "next_up" next_up.
    Admitted.
    Global Typeclasses Opaque next_up.
    
    (*
        pub const fn next_down(self) -> Self {
            // Some targets violate Rust's assumption of IEEE semantics, e.g. by flushing
            // denormals to zero. This is in general unsound and unsupported, but here
            // we do our best to still produce the correct result on such targets.
            let bits = self.to_bits();
            if self.is_nan() || bits == Self::NEG_INFINITY.to_bits() {
                return self;
            }
    
            let abs = bits & !Self::SIGN_MASK;
            let next_bits = if abs == 0 {
                Self::NEG_TINY_BITS
            } else if bits == abs {
                bits - 1
            } else {
                bits + 1
            };
            Self::from_bits(next_bits)
        }
    *)
    Definition next_down (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.read (|
            M.catch_return (Ty.path "f64") (|
              ltac:(M.monadic
                (M.alloc (|
                  Ty.path "f64",
                  M.read (|
                    let~ bits : Ty.path "u64" :=
                      M.call_closure (|
                        Ty.path "u64",
                        M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                        [ M.read (| self |) ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.read (|
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      LogicalOp.or (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.path "f64",
                                            "is_nan",
                                            [],
                                            []
                                          |),
                                          [ M.read (| self |) ]
                                        |),
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| bits |);
                                              M.call_closure (|
                                                Ty.path "u64",
                                                M.get_associated_function (|
                                                  Ty.path "f64",
                                                  "to_bits",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (|
                                                    get_associated_constant (|
                                                      Ty.path "f64",
                                                      "NEG_INFINITY",
                                                      Ty.path "f64"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)))
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.alloc (|
                                  Ty.tuple [],
                                  M.never_to_any (|
                                    M.read (| M.return_ (| M.read (| self |) |) |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                          ]
                        |)
                      |) in
                    let~ abs : Ty.path "u64" :=
                      M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.bit_and,
                        [
                          M.read (| bits |);
                          UnOp.not (|
                            M.read (|
                              get_associated_constant (|
                                Ty.path "f64",
                                "SIGN_MASK",
                                Ty.path "u64"
                              |)
                            |)
                          |)
                        ]
                      |) in
                    let~ next_bits : Ty.path "u64" :=
                      M.read (|
                        M.match_operator (|
                          Ty.path "u64",
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [ M.read (| abs |); Value.Integer IntegerKind.U64 0 ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                get_associated_constant (|
                                  Ty.path "f64",
                                  "NEG_TINY_BITS",
                                  Ty.path "u64"
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.path "u64",
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              Ty.path "bool",
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.eq,
                                                [ M.read (| bits |); M.read (| abs |) ]
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          Ty.path "u64",
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.sub,
                                            [ M.read (| bits |); Value.Integer IntegerKind.U64 1 ]
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.alloc (|
                                          Ty.path "u64",
                                          M.call_closure (|
                                            Ty.path "u64",
                                            BinOp.Wrap.add,
                                            [ M.read (| bits |); Value.Integer IntegerKind.U64 1 ]
                                          |)
                                        |)))
                                  ]
                                |)))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Ty.path "f64",
                      M.call_closure (|
                        Ty.path "f64",
                        M.get_associated_function (| Ty.path "f64", "from_bits", [], [] |),
                        [ M.read (| next_bits |) ]
                      |)
                    |)
                  |)
                |)))
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_next_down :
      M.IsAssociatedFunction.C Self "next_down" next_down.
    Admitted.
    Global Typeclasses Opaque next_down.
    
    (*
        pub const fn recip(self) -> f64 {
            1.0 / self
        }
    *)
    Definition recip (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "f64",
            BinOp.Wrap.div,
            [ M.read (| UnsupportedLiteral |); M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_recip : M.IsAssociatedFunction.C Self "recip" recip.
    Admitted.
    Global Typeclasses Opaque recip.
    
    (*
        pub const fn to_degrees(self) -> f64 {
            // The division here is correctly rounded with respect to the true
            // value of 180/π. (This differs from f32, where a constant must be
            // used to ensure a correctly rounded result.)
            self * (180.0f64 / consts::PI)
        }
    *)
    Definition to_degrees (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "f64",
            BinOp.Wrap.mul,
            [
              M.read (| self |);
              M.call_closure (|
                Ty.path "f64",
                BinOp.Wrap.div,
                [
                  M.read (| UnsupportedLiteral |);
                  M.read (| get_constant (| "core::f64::consts::PI", Ty.path "f64" |) |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_degrees :
      M.IsAssociatedFunction.C Self "to_degrees" to_degrees.
    Admitted.
    Global Typeclasses Opaque to_degrees.
    
    (*
        pub const fn to_radians(self) -> f64 {
            const RADS_PER_DEG: f64 = consts::PI / 180.0;
            self * RADS_PER_DEG
        }
    *)
    Definition to_radians (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "f64",
            BinOp.Wrap.mul,
            [
              M.read (| self |);
              M.read (| get_constant (| "core::f64::to_radians::RADS_PER_DEG", Ty.path "f64" |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_radians :
      M.IsAssociatedFunction.C Self "to_radians" to_radians.
    Admitted.
    Global Typeclasses Opaque to_radians.
    
    (*
        pub const fn max(self, other: f64) -> f64 {
            intrinsics::maxnumf64(self, other)
        }
    *)
    Definition max (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          let other := M.alloc (| Ty.path "f64", other |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_function (| "core::intrinsics::maxnumf64", [], [] |),
            [ M.read (| self |); M.read (| other |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_max : M.IsAssociatedFunction.C Self "max" max.
    Admitted.
    Global Typeclasses Opaque max.
    
    (*
        pub const fn min(self, other: f64) -> f64 {
            intrinsics::minnumf64(self, other)
        }
    *)
    Definition min (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          let other := M.alloc (| Ty.path "f64", other |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_function (| "core::intrinsics::minnumf64", [], [] |),
            [ M.read (| self |); M.read (| other |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_min : M.IsAssociatedFunction.C Self "min" min.
    Admitted.
    Global Typeclasses Opaque min.
    
    (*
        pub const fn maximum(self, other: f64) -> f64 {
            if self > other {
                self
            } else if other > self {
                other
            } else if self == other {
                if self.is_sign_positive() && other.is_sign_negative() { self } else { other }
            } else {
                self + other
            }
        }
    *)
    Definition maximum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          let other := M.alloc (| Ty.path "f64", other |) in
          M.read (|
            M.match_operator (|
              Ty.path "f64",
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [ M.read (| self |); M.read (| other |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.path "f64",
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.gt,
                                    [ M.read (| other |); M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            other));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.path "f64",
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          Ty.path "bool",
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [ M.read (| self |); M.read (| other |) ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.match_operator (|
                                      Ty.path "f64",
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  LogicalOp.and (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_associated_function (|
                                                        Ty.path "f64",
                                                        "is_sign_positive",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| self |) ]
                                                    |),
                                                    ltac:(M.monadic
                                                      (M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_associated_function (|
                                                          Ty.path "f64",
                                                          "is_sign_negative",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.read (| other |) ]
                                                      |)))
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            self));
                                        fun γ => ltac:(M.monadic other)
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      Ty.path "f64",
                                      M.call_closure (|
                                        Ty.path "f64",
                                        BinOp.Wrap.add,
                                        [ M.read (| self |); M.read (| other |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_maximum : M.IsAssociatedFunction.C Self "maximum" maximum.
    Admitted.
    Global Typeclasses Opaque maximum.
    
    (*
        pub const fn minimum(self, other: f64) -> f64 {
            if self < other {
                self
            } else if other < self {
                other
            } else if self == other {
                if self.is_sign_negative() && other.is_sign_positive() { self } else { other }
            } else {
                // At least one input is NaN. Use `+` to perform NaN propagation and quieting.
                self + other
            }
        }
    *)
    Definition minimum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          let other := M.alloc (| Ty.path "f64", other |) in
          M.read (|
            M.match_operator (|
              Ty.path "f64",
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.lt,
                            [ M.read (| self |); M.read (| other |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    self));
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.path "f64",
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [ M.read (| other |); M.read (| self |) ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            other));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.path "f64",
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          Ty.path "bool",
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [ M.read (| self |); M.read (| other |) ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.match_operator (|
                                      Ty.path "f64",
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  LogicalOp.and (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_associated_function (|
                                                        Ty.path "f64",
                                                        "is_sign_negative",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| self |) ]
                                                    |),
                                                    ltac:(M.monadic
                                                      (M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_associated_function (|
                                                          Ty.path "f64",
                                                          "is_sign_positive",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.read (| other |) ]
                                                      |)))
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            self));
                                        fun γ => ltac:(M.monadic other)
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      Ty.path "f64",
                                      M.call_closure (|
                                        Ty.path "f64",
                                        BinOp.Wrap.add,
                                        [ M.read (| self |); M.read (| other |) ]
                                      |)
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_minimum : M.IsAssociatedFunction.C Self "minimum" minimum.
    Admitted.
    Global Typeclasses Opaque minimum.
    
    (*
        pub const fn midpoint(self, other: f64) -> f64 {
            const LO: f64 = f64::MIN_POSITIVE * 2.;
            const HI: f64 = f64::MAX / 2.;
    
            let (a, b) = (self, other);
            let abs_a = a.abs();
            let abs_b = b.abs();
    
            if abs_a <= HI && abs_b <= HI {
                // Overflow is impossible
                (a + b) / 2.
            } else if abs_a < LO {
                // Not safe to halve `a` (would underflow)
                a + (b / 2.)
            } else if abs_b < LO {
                // Not safe to halve `b` (would underflow)
                (a / 2.) + b
            } else {
                // Safe to halve `a` and `b`
                (a / 2.) + (b / 2.)
            }
        }
    *)
    Definition midpoint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          let other := M.alloc (| Ty.path "f64", other |) in
          M.read (|
            M.match_operator (|
              Ty.path "f64",
              M.alloc (|
                Ty.tuple [ Ty.path "f64"; Ty.path "f64" ],
                Value.Tuple [ M.read (| self |); M.read (| other |) ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let a := M.copy (| Ty.path "f64", γ0_0 |) in
                    let b := M.copy (| Ty.path "f64", γ0_1 |) in
                    let~ abs_a : Ty.path "f64" :=
                      M.call_closure (|
                        Ty.path "f64",
                        M.get_associated_function (| Ty.path "f64", "abs", [], [] |),
                        [ M.read (| a |) ]
                      |) in
                    let~ abs_b : Ty.path "f64" :=
                      M.call_closure (|
                        Ty.path "f64",
                        M.get_associated_function (| Ty.path "f64", "abs", [], [] |),
                        [ M.read (| b |) ]
                      |) in
                    M.match_operator (|
                      Ty.path "f64",
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [
                                        M.read (| abs_a |);
                                        M.read (|
                                          get_constant (|
                                            "core::f64::midpoint::HI",
                                            Ty.path "f64"
                                          |)
                                        |)
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.le,
                                        [
                                          M.read (| abs_b |);
                                          M.read (|
                                            get_constant (|
                                              "core::f64::midpoint::HI",
                                              Ty.path "f64"
                                            |)
                                          |)
                                        ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              Ty.path "f64",
                              M.call_closure (|
                                Ty.path "f64",
                                BinOp.Wrap.div,
                                [
                                  M.call_closure (|
                                    Ty.path "f64",
                                    BinOp.Wrap.add,
                                    [ M.read (| a |); M.read (| b |) ]
                                  |);
                                  M.read (| UnsupportedLiteral |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.path "f64",
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          Ty.path "bool",
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.lt,
                                            [
                                              M.read (| abs_a |);
                                              M.read (|
                                                get_constant (|
                                                  "core::f64::midpoint::LO",
                                                  Ty.path "f64"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      Ty.path "f64",
                                      M.call_closure (|
                                        Ty.path "f64",
                                        BinOp.Wrap.add,
                                        [
                                          M.read (| a |);
                                          M.call_closure (|
                                            Ty.path "f64",
                                            BinOp.Wrap.div,
                                            [ M.read (| b |); M.read (| UnsupportedLiteral |) ]
                                          |)
                                        ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.path "f64",
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.lt,
                                                    [
                                                      M.read (| abs_b |);
                                                      M.read (|
                                                        get_constant (|
                                                          "core::f64::midpoint::LO",
                                                          Ty.path "f64"
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.alloc (|
                                              Ty.path "f64",
                                              M.call_closure (|
                                                Ty.path "f64",
                                                BinOp.Wrap.add,
                                                [
                                                  M.call_closure (|
                                                    Ty.path "f64",
                                                    BinOp.Wrap.div,
                                                    [
                                                      M.read (| a |);
                                                      M.read (| UnsupportedLiteral |)
                                                    ]
                                                  |);
                                                  M.read (| b |)
                                                ]
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              Ty.path "f64",
                                              M.call_closure (|
                                                Ty.path "f64",
                                                BinOp.Wrap.add,
                                                [
                                                  M.call_closure (|
                                                    Ty.path "f64",
                                                    BinOp.Wrap.div,
                                                    [
                                                      M.read (| a |);
                                                      M.read (| UnsupportedLiteral |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "f64",
                                                    BinOp.Wrap.div,
                                                    [
                                                      M.read (| b |);
                                                      M.read (| UnsupportedLiteral |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_midpoint : M.IsAssociatedFunction.C Self "midpoint" midpoint.
    Admitted.
    Global Typeclasses Opaque midpoint.
    
    (*
        pub unsafe fn to_int_unchecked<Int>(self) -> Int
        where
            Self: FloatToInt<Int>,
        {
            // SAFETY: the caller must uphold the safety contract for
            // `FloatToInt::to_int_unchecked`.
            unsafe { FloatToInt::<Int>::to_int_unchecked(self) }
        }
    *)
    Definition to_int_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ Int ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Int,
            M.get_trait_method (|
              "core::convert::num::FloatToInt",
              Ty.path "f64",
              [],
              [ Int ],
              "to_int_unchecked",
              [],
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_int_unchecked :
      M.IsAssociatedFunction.C Self "to_int_unchecked" to_int_unchecked.
    Admitted.
    Global Typeclasses Opaque to_int_unchecked.
    
    (*
        pub const fn to_bits(self) -> u64 {
            // SAFETY: `u64` is a plain old datatype so we can always transmute to it.
            unsafe { mem::transmute(self) }
        }
    *)
    Definition to_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "u64",
            M.get_function (|
              "core::intrinsics::transmute",
              [],
              [ Ty.path "f64"; Ty.path "u64" ]
            |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_bits : M.IsAssociatedFunction.C Self "to_bits" to_bits.
    Admitted.
    Global Typeclasses Opaque to_bits.
    
    (*
        pub const fn from_bits(v: u64) -> Self {
            // It turns out the safety issues with sNaN were overblown! Hooray!
            // SAFETY: `u64` is a plain old datatype so we can always transmute from it.
            unsafe { mem::transmute(v) }
        }
    *)
    Definition from_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| Ty.path "u64", v |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_function (|
              "core::intrinsics::transmute",
              [],
              [ Ty.path "u64"; Ty.path "f64" ]
            |),
            [ M.read (| v |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_bits :
      M.IsAssociatedFunction.C Self "from_bits" from_bits.
    Admitted.
    Global Typeclasses Opaque from_bits.
    
    (*
        pub const fn to_be_bytes(self) -> [u8; 8] {
            self.to_bits().to_be_bytes()
        }
    *)
    Definition to_be_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
            M.get_associated_function (| Ty.path "u64", "to_be_bytes", [], [] |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_be_bytes :
      M.IsAssociatedFunction.C Self "to_be_bytes" to_be_bytes.
    Admitted.
    Global Typeclasses Opaque to_be_bytes.
    
    (*
        pub const fn to_le_bytes(self) -> [u8; 8] {
            self.to_bits().to_le_bytes()
        }
    *)
    Definition to_le_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
            M.get_associated_function (| Ty.path "u64", "to_le_bytes", [], [] |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_le_bytes :
      M.IsAssociatedFunction.C Self "to_le_bytes" to_le_bytes.
    Admitted.
    Global Typeclasses Opaque to_le_bytes.
    
    (*
        pub const fn to_ne_bytes(self) -> [u8; 8] {
            self.to_bits().to_ne_bytes()
        }
    *)
    Definition to_ne_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
            M.get_associated_function (| Ty.path "u64", "to_ne_bytes", [], [] |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_ne_bytes :
      M.IsAssociatedFunction.C Self "to_ne_bytes" to_ne_bytes.
    Admitted.
    Global Typeclasses Opaque to_ne_bytes.
    
    (*
        pub const fn from_be_bytes(bytes: [u8; 8]) -> Self {
            Self::from_bits(u64::from_be_bytes(bytes))
        }
    *)
    Definition from_be_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes :=
            M.alloc (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
              bytes
            |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_associated_function (| Ty.path "f64", "from_bits", [], [] |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_associated_function (| Ty.path "u64", "from_be_bytes", [], [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_be_bytes :
      M.IsAssociatedFunction.C Self "from_be_bytes" from_be_bytes.
    Admitted.
    Global Typeclasses Opaque from_be_bytes.
    
    (*
        pub const fn from_le_bytes(bytes: [u8; 8]) -> Self {
            Self::from_bits(u64::from_le_bytes(bytes))
        }
    *)
    Definition from_le_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes :=
            M.alloc (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
              bytes
            |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_associated_function (| Ty.path "f64", "from_bits", [], [] |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_associated_function (| Ty.path "u64", "from_le_bytes", [], [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction.C Self "from_le_bytes" from_le_bytes.
    Admitted.
    Global Typeclasses Opaque from_le_bytes.
    
    (*
        pub const fn from_ne_bytes(bytes: [u8; 8]) -> Self {
            Self::from_bits(u64::from_ne_bytes(bytes))
        }
    *)
    Definition from_ne_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes :=
            M.alloc (|
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 8 ] [ Ty.path "u8" ],
              bytes
            |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_associated_function (| Ty.path "f64", "from_bits", [], [] |),
            [
              M.call_closure (|
                Ty.path "u64",
                M.get_associated_function (| Ty.path "u64", "from_ne_bytes", [], [] |),
                [ M.read (| bytes |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_ne_bytes :
      M.IsAssociatedFunction.C Self "from_ne_bytes" from_ne_bytes.
    Admitted.
    Global Typeclasses Opaque from_ne_bytes.
    
    (*
        pub fn total_cmp(&self, other: &Self) -> crate::cmp::Ordering {
            let mut left = self.to_bits() as i64;
            let mut right = other.to_bits() as i64;
    
            // In case of negatives, flip all the bits except the sign
            // to achieve a similar layout as two's complement integers
            //
            // Why does this work? IEEE 754 floats consist of three fields:
            // Sign bit, exponent and mantissa. The set of exponent and mantissa
            // fields as a whole have the property that their bitwise order is
            // equal to the numeric magnitude where the magnitude is defined.
            // The magnitude is not normally defined on NaN values, but
            // IEEE 754 totalOrder defines the NaN values also to follow the
            // bitwise order. This leads to order explained in the doc comment.
            // However, the representation of magnitude is the same for negative
            // and positive numbers – only the sign bit is different.
            // To easily compare the floats as signed integers, we need to
            // flip the exponent and mantissa bits in case of negative numbers.
            // We effectively convert the numbers to "two's complement" form.
            //
            // To do the flipping, we construct a mask and XOR against it.
            // We branchlessly calculate an "all-ones except for the sign bit"
            // mask from negative-signed values: right shifting sign-extends
            // the integer, so we "fill" the mask with sign bits, and then
            // convert to unsigned to push one more zero bit.
            // On positive values, the mask is all zeros, so it's a no-op.
            left ^= (((left >> 63) as u64) >> 1) as i64;
            right ^= (((right >> 63) as u64) >> 1) as i64;
    
            left.cmp(&right)
        }
    *)
    Definition total_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "f64" ], self |) in
          let other := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "f64" ], other |) in
          M.read (|
            let~ left : Ty.path "i64" :=
              M.cast
                (Ty.path "i64")
                (M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                  [ M.read (| M.deref (| M.read (| self |) |) |) ]
                |)) in
            let~ right : Ty.path "i64" :=
              M.cast
                (Ty.path "i64")
                (M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "f64", "to_bits", [], [] |),
                  [ M.read (| M.deref (| M.read (| other |) |) |) ]
                |)) in
            let~ _ : Ty.tuple [] :=
              let β := left in
              M.write (|
                β,
                M.call_closure (|
                  Ty.path "i64",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (| β |);
                    M.cast
                      (Ty.path "i64")
                      (M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.shr,
                        [
                          M.cast
                            (Ty.path "u64")
                            (M.call_closure (|
                              Ty.path "i64",
                              BinOp.Wrap.shr,
                              [ M.read (| left |); Value.Integer IntegerKind.I32 63 ]
                            |));
                          Value.Integer IntegerKind.I32 1
                        ]
                      |))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              let β := right in
              M.write (|
                β,
                M.call_closure (|
                  Ty.path "i64",
                  BinOp.Wrap.bit_xor,
                  [
                    M.read (| β |);
                    M.cast
                      (Ty.path "i64")
                      (M.call_closure (|
                        Ty.path "u64",
                        BinOp.Wrap.shr,
                        [
                          M.cast
                            (Ty.path "u64")
                            (M.call_closure (|
                              Ty.path "i64",
                              BinOp.Wrap.shr,
                              [ M.read (| right |); Value.Integer IntegerKind.I32 63 ]
                            |));
                          Value.Integer IntegerKind.I32 1
                        ]
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              Ty.path "core::cmp::Ordering",
              M.call_closure (|
                Ty.path "core::cmp::Ordering",
                M.get_trait_method (| "core::cmp::Ord", Ty.path "i64", [], [], "cmp", [], [] |),
                [
                  M.borrow (| Pointer.Kind.Ref, left |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, right |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_total_cmp :
      M.IsAssociatedFunction.C Self "total_cmp" total_cmp.
    Admitted.
    Global Typeclasses Opaque total_cmp.
    
    (*
        pub const fn clamp(mut self, min: f64, max: f64) -> f64 {
            const_assert!(
                min <= max,
                "min > max, or either was NaN",
                "min > max, or either was NaN. min = {min:?}, max = {max:?}",
                min: f64,
                max: f64,
            );
    
            if self < min {
                self = min;
            }
            if self > max {
                self = max;
            }
            self
        }
    *)
    Definition clamp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; min; max ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          let min := M.alloc (| Ty.path "f64", min |) in
          let max := M.alloc (| Ty.path "f64", max |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_function (| "core::intrinsics::likely", [], [] |),
                                  [
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.le,
                                      [ M.read (| min |); M.read (| max |) ]
                                    |)
                                  ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          Ty.tuple [],
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_associated_function (| Self, "do_panic.clamp", [], [] |),
                              [ M.read (| min |); M.read (| max |) ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| self |); M.read (| min |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] := M.write (| self, M.read (| min |) |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.gt,
                                [ M.read (| self |); M.read (| max |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] := M.write (| self, M.read (| max |) |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                  ]
                |)
              |) in
            self
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_clamp : M.IsAssociatedFunction.C Self "clamp" clamp.
    Admitted.
    Global Typeclasses Opaque clamp.
    
    (*
        pub const fn abs(self) -> f64 {
            // SAFETY: this is actually a safe intrinsic
            unsafe { intrinsics::fabsf64(self) }
        }
    *)
    Definition abs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_function (| "core::intrinsics::fabsf64", [], [] |),
            [ M.read (| self |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_abs : M.IsAssociatedFunction.C Self "abs" abs.
    Admitted.
    Global Typeclasses Opaque abs.
    
    (*
        pub const fn signum(self) -> f64 {
            if self.is_nan() { Self::NAN } else { 1.0_f64.copysign(self) }
        }
    *)
    Definition signum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          M.read (|
            M.match_operator (|
              Ty.path "f64",
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (| Ty.path "f64", "is_nan", [], [] |),
                            [ M.read (| self |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    get_associated_constant (| Ty.path "f64", "NAN", Ty.path "f64" |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Ty.path "f64",
                      M.call_closure (|
                        Ty.path "f64",
                        M.get_associated_function (| Ty.path "f64", "copysign", [], [] |),
                        [ M.read (| UnsupportedLiteral |); M.read (| self |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_signum : M.IsAssociatedFunction.C Self "signum" signum.
    Admitted.
    Global Typeclasses Opaque signum.
    
    (*
        pub const fn copysign(self, sign: f64) -> f64 {
            // SAFETY: this is actually a safe intrinsic
            unsafe { intrinsics::copysignf64(self, sign) }
        }
    *)
    Definition copysign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; sign ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.path "f64", self |) in
          let sign := M.alloc (| Ty.path "f64", sign |) in
          M.call_closure (|
            Ty.path "f64",
            M.get_function (| "core::intrinsics::copysignf64", [], [] |),
            [ M.read (| self |); M.read (| sign |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_copysign : M.IsAssociatedFunction.C Self "copysign" copysign.
    Admitted.
    Global Typeclasses Opaque copysign.
  End Impl_f64.
End f64.
