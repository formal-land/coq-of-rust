(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module num.
  Module flt2dec.
    Module estimator.
      (*
      pub fn estimate_scaling_factor(mant: u64, exp: i16) -> i16 {
          // 2^(nbits-1) < mant <= 2^nbits if mant > 0
          let nbits = 64 - (mant - 1).leading_zeros() as i64;
          // 1292913986 = floor(2^32 * log_10 2)
          // therefore this always underestimates (or is exact), but not much.
          (((nbits + exp as i64) * 1292913986) >> 32) as i16
      }
      *)
      Definition estimate_scaling_factor (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [], [ mant; exp ] =>
          ltac:(M.monadic
            (let mant := M.alloc (| mant |) in
            let exp := M.alloc (| exp |) in
            M.read (|
              let nbits :=
                M.alloc (|
                  BinOp.Panic.sub (|
                    Integer.I64,
                    Value.Integer 64,
                    M.rust_cast
                      (M.call_closure (|
                        M.get_associated_function (| Ty.path "u64", "leading_zeros", [] |),
                        [ BinOp.Panic.sub (| Integer.U64, M.read (| mant |), Value.Integer 1 |) ]
                      |))
                  |)
                |) in
              M.alloc (|
                M.rust_cast
                  (BinOp.Panic.shr (|
                    BinOp.Panic.mul (|
                      Integer.I64,
                      BinOp.Panic.add (|
                        Integer.I64,
                        M.read (| nbits |),
                        M.rust_cast (M.read (| exp |))
                      |),
                      Value.Integer 1292913986
                    |),
                    Value.Integer 32
                  |))
              |)
            |)))
        | _, _ => M.impossible
        end.
    End estimator.
  End flt2dec.
End num.
